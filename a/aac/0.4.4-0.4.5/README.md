# Comparing `tmp/aac-0.4.4-py3-none-any.whl.zip` & `tmp/aac-0.4.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,86 +1,86 @@
-Zip file size: 93224 bytes, number of entries: 84
--rw-r--r--  2.0 unx      681 b- defN 24-Apr-30 19:38 aac/__init__.py
--rw-r--r--  2.0 unx      184 b- defN 24-Apr-30 19:38 aac/__main__.py
--rw-r--r--  2.0 unx    39404 b- defN 24-Apr-30 19:38 aac/aac.aac
--rw-r--r--  2.0 unx       93 b- defN 24-Apr-30 19:38 aac/context/__init__.py
--rw-r--r--  2.0 unx     3340 b- defN 24-Apr-30 19:38 aac/context/constants.py
--rw-r--r--  2.0 unx     3555 b- defN 24-Apr-30 19:38 aac/context/definition.py
--rw-r--r--  2.0 unx    36891 b- defN 24-Apr-30 19:38 aac/context/definition_parser.py
--rw-r--r--  2.0 unx    11942 b- defN 24-Apr-30 19:38 aac/context/language_context.py
--rw-r--r--  2.0 unx      416 b- defN 24-Apr-30 19:38 aac/context/language_error.py
--rw-r--r--  2.0 unx     1179 b- defN 24-Apr-30 19:38 aac/context/lexeme.py
--rw-r--r--  2.0 unx     1193 b- defN 24-Apr-30 19:38 aac/context/source_location.py
--rw-r--r--  2.0 unx     2025 b- defN 24-Apr-30 19:38 aac/context/util.py
--rw-r--r--  2.0 unx      613 b- defN 24-Apr-30 19:38 aac/execute/__init__.py
--rw-r--r--  2.0 unx     4123 b- defN 24-Apr-30 19:38 aac/execute/aac_execution_result.py
--rw-r--r--  2.0 unx     6357 b- defN 24-Apr-30 19:38 aac/execute/command_line.py
--rw-r--r--  2.0 unx      280 b- defN 24-Apr-30 19:38 aac/execute/hookspecs.py
--rw-r--r--  2.0 unx     1351 b- defN 24-Apr-30 19:38 aac/execute/plugin_manager.py
--rw-r--r--  2.0 unx     3728 b- defN 24-Apr-30 19:38 aac/execute/plugin_runner.py
--rw-r--r--  2.0 unx       66 b- defN 24-Apr-30 19:38 aac/in_out/__init__.py
--rw-r--r--  2.0 unx      253 b- defN 24-Apr-30 19:38 aac/in_out/constants.py
--rw-r--r--  2.0 unx     2507 b- defN 24-Apr-30 19:38 aac/in_out/paths.py
--rw-r--r--  2.0 unx     2274 b- defN 24-Apr-30 19:38 aac/in_out/writer.py
--rw-r--r--  2.0 unx       63 b- defN 24-Apr-30 19:38 aac/in_out/files/__init__.py
--rw-r--r--  2.0 unx      925 b- defN 24-Apr-30 19:38 aac/in_out/files/aac_file.py
--rw-r--r--  2.0 unx     1640 b- defN 24-Apr-30 19:38 aac/in_out/files/find.py
--rw-r--r--  2.0 unx      443 b- defN 24-Apr-30 19:38 aac/in_out/parser/__init__.py
--rw-r--r--  2.0 unx     4901 b- defN 24-Apr-30 19:38 aac/in_out/parser/_cache.py
--rw-r--r--  2.0 unx      538 b- defN 24-Apr-30 19:38 aac/in_out/parser/_cache_manager.py
--rw-r--r--  2.0 unx     9476 b- defN 24-Apr-30 19:38 aac/in_out/parser/_parse_source.py
--rw-r--r--  2.0 unx      601 b- defN 24-Apr-30 19:38 aac/in_out/parser/_parser_error.py
--rw-r--r--  2.0 unx     4682 b- defN 24-Apr-30 19:38 aac/in_out/parser/_yaml.py
--rw-r--r--  2.0 unx       74 b- defN 24-Apr-30 19:38 aac/plugins/__init__.py
--rw-r--r--  2.0 unx     5817 b- defN 24-Apr-30 19:38 aac/plugins/aac_primitives/__init__.py
--rw-r--r--  2.0 unx     1171 b- defN 24-Apr-30 19:38 aac/plugins/aac_primitives/aac_primitive_constraints.aac
--rw-r--r--  2.0 unx    13451 b- defN 24-Apr-30 19:38 aac/plugins/aac_primitives/aac_primitive_constraints_impl.py
--rw-r--r--  2.0 unx     1875 b- defN 24-Apr-30 19:38 aac/plugins/check/__init__.py
--rw-r--r--  2.0 unx      723 b- defN 24-Apr-30 19:38 aac/plugins/check/check_aac.aac
--rw-r--r--  2.0 unx    10760 b- defN 24-Apr-30 19:38 aac/plugins/check/check_aac_impl.py
--rw-r--r--  2.0 unx     2417 b- defN 24-Apr-30 19:38 aac/plugins/constraint_assignment_arguments/__init__.py
--rw-r--r--  2.0 unx      529 b- defN 24-Apr-30 19:38 aac/plugins/constraint_assignment_arguments/constraint_assignment_arguments.aac
--rw-r--r--  2.0 unx     7514 b- defN 24-Apr-30 19:38 aac/plugins/constraint_assignment_arguments/constraint_assignment_arguments_impl.py
--rw-r--r--  2.0 unx     2085 b- defN 24-Apr-30 19:38 aac/plugins/exclusive_fields/__init__.py
--rw-r--r--  2.0 unx      594 b- defN 24-Apr-30 19:38 aac/plugins/exclusive_fields/exclusive_fields.aac
--rw-r--r--  2.0 unx     2350 b- defN 24-Apr-30 19:38 aac/plugins/exclusive_fields/exclusive_fields_impl.py
--rw-r--r--  2.0 unx     4565 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/__init__.py
--rw-r--r--  2.0 unx     2571 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/gen_plugin.aac
--rw-r--r--  2.0 unx     7281 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/gen_plugin_generator.aac
--rw-r--r--  2.0 unx     3251 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/gen_plugin_impl.py
--rw-r--r--  2.0 unx       35 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/empty.jinja2
--rw-r--r--  2.0 unx     1396 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/feature_file.jinja2
--rw-r--r--  2.0 unx     6704 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/plugin_impl.jinja2
--rw-r--r--  2.0 unx    10212 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/plugin_init.jinja2
--rw-r--r--  2.0 unx     3939 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/plugin_unit_test.jinja2
--rw-r--r--  2.0 unx      215 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/project_readme.jinja2
--rw-r--r--  2.0 unx     1069 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/project_setup.jinja2
--rw-r--r--  2.0 unx      862 b- defN 24-Apr-30 19:38 aac/plugins/gen_plugin/templates/project_tox.jinja2
--rw-r--r--  2.0 unx     2425 b- defN 24-Apr-30 19:38 aac/plugins/generate/__init__.py
--rw-r--r--  2.0 unx     2245 b- defN 24-Apr-30 19:38 aac/plugins/generate/generate.aac
--rw-r--r--  2.0 unx    14699 b- defN 24-Apr-30 19:38 aac/plugins/generate/generate_impl.py
--rw-r--r--  2.0 unx       62 b- defN 24-Apr-30 19:38 aac/plugins/generate/helpers/__init__.py
--rw-r--r--  2.0 unx     4757 b- defN 24-Apr-30 19:38 aac/plugins/generate/helpers/python_helpers.py
--rw-r--r--  2.0 unx     2153 b- defN 24-Apr-30 19:38 aac/plugins/if_true_then_empty/__init__.py
--rw-r--r--  2.0 unx      558 b- defN 24-Apr-30 19:38 aac/plugins/if_true_then_empty/if_true_then_empty.aac
--rw-r--r--  2.0 unx     2286 b- defN 24-Apr-30 19:38 aac/plugins/if_true_then_empty/if_true_then_empty_impl.py
--rw-r--r--  2.0 unx     1993 b- defN 24-Apr-30 19:38 aac/plugins/no_ext_for_final/__init__.py
--rw-r--r--  2.0 unx      360 b- defN 24-Apr-30 19:38 aac/plugins/no_ext_for_final/no_ext_for_final.aac
--rw-r--r--  2.0 unx     2425 b- defN 24-Apr-30 19:38 aac/plugins/no_ext_for_final/no_ext_for_final_impl.py
--rw-r--r--  2.0 unx     2016 b- defN 24-Apr-30 19:38 aac/plugins/print_defs/__init__.py
--rw-r--r--  2.0 unx      447 b- defN 24-Apr-30 19:38 aac/plugins/print_defs/print_aac_definitions.aac
--rw-r--r--  2.0 unx     1423 b- defN 24-Apr-30 19:38 aac/plugins/print_defs/print_aac_definitions_impl.py
--rw-r--r--  2.0 unx     2158 b- defN 24-Apr-30 19:38 aac/plugins/root_schema_must_have_name/__init__.py
--rw-r--r--  2.0 unx      370 b- defN 24-Apr-30 19:38 aac/plugins/root_schema_must_have_name/root_schema_must_have_name.aac
--rw-r--r--  2.0 unx     2751 b- defN 24-Apr-30 19:38 aac/plugins/root_schema_must_have_name/root_schema_must_have_name_impl.py
--rw-r--r--  2.0 unx     1872 b- defN 24-Apr-30 19:38 aac/plugins/unique_root_keys/__init__.py
--rw-r--r--  2.0 unx      357 b- defN 24-Apr-30 19:38 aac/plugins/unique_root_keys/unique_root_keys.aac
--rw-r--r--  2.0 unx     1457 b- defN 24-Apr-30 19:38 aac/plugins/unique_root_keys/unique_root_keys_impl.py
--rw-r--r--  2.0 unx     1773 b- defN 24-Apr-30 19:38 aac/plugins/version/__init__.py
--rw-r--r--  2.0 unx      226 b- defN 24-Apr-30 19:38 aac/plugins/version/version.aac
--rw-r--r--  2.0 unx      875 b- defN 24-Apr-30 19:38 aac/plugins/version/version_impl.py
--rw-r--r--  2.0 unx    13241 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       53 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        4 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     7889 b- defN 24-Apr-30 19:38 aac-0.4.4.dist-info/RECORD
-84 files, 308151 bytes uncompressed, 80442 bytes compressed:  73.9%
+Zip file size: 93775 bytes, number of entries: 84
+-rw-r--r--  2.0 unx      681 b- defN 24-May-20 15:42 aac/__init__.py
+-rw-r--r--  2.0 unx      184 b- defN 24-May-20 15:42 aac/__main__.py
+-rw-r--r--  2.0 unx    39404 b- defN 24-May-20 15:42 aac/aac.aac
+-rw-r--r--  2.0 unx       93 b- defN 24-May-20 15:42 aac/context/__init__.py
+-rw-r--r--  2.0 unx     3340 b- defN 24-May-20 15:42 aac/context/constants.py
+-rw-r--r--  2.0 unx     3555 b- defN 24-May-20 15:42 aac/context/definition.py
+-rw-r--r--  2.0 unx    37371 b- defN 24-May-20 15:42 aac/context/definition_parser.py
+-rw-r--r--  2.0 unx    11942 b- defN 24-May-20 15:42 aac/context/language_context.py
+-rw-r--r--  2.0 unx      416 b- defN 24-May-20 15:42 aac/context/language_error.py
+-rw-r--r--  2.0 unx     1179 b- defN 24-May-20 15:42 aac/context/lexeme.py
+-rw-r--r--  2.0 unx     1193 b- defN 24-May-20 15:42 aac/context/source_location.py
+-rw-r--r--  2.0 unx     2025 b- defN 24-May-20 15:42 aac/context/util.py
+-rw-r--r--  2.0 unx      613 b- defN 24-May-20 15:42 aac/execute/__init__.py
+-rw-r--r--  2.0 unx     4123 b- defN 24-May-20 15:42 aac/execute/aac_execution_result.py
+-rw-r--r--  2.0 unx     6357 b- defN 24-May-20 15:42 aac/execute/command_line.py
+-rw-r--r--  2.0 unx      280 b- defN 24-May-20 15:42 aac/execute/hookspecs.py
+-rw-r--r--  2.0 unx     1351 b- defN 24-May-20 15:42 aac/execute/plugin_manager.py
+-rw-r--r--  2.0 unx     3728 b- defN 24-May-20 15:42 aac/execute/plugin_runner.py
+-rw-r--r--  2.0 unx       66 b- defN 24-May-20 15:42 aac/in_out/__init__.py
+-rw-r--r--  2.0 unx      253 b- defN 24-May-20 15:42 aac/in_out/constants.py
+-rw-r--r--  2.0 unx     2507 b- defN 24-May-20 15:42 aac/in_out/paths.py
+-rw-r--r--  2.0 unx     2274 b- defN 24-May-20 15:42 aac/in_out/writer.py
+-rw-r--r--  2.0 unx       63 b- defN 24-May-20 15:42 aac/in_out/files/__init__.py
+-rw-r--r--  2.0 unx      925 b- defN 24-May-20 15:42 aac/in_out/files/aac_file.py
+-rw-r--r--  2.0 unx     1640 b- defN 24-May-20 15:42 aac/in_out/files/find.py
+-rw-r--r--  2.0 unx      443 b- defN 24-May-20 15:42 aac/in_out/parser/__init__.py
+-rw-r--r--  2.0 unx     4901 b- defN 24-May-20 15:42 aac/in_out/parser/_cache.py
+-rw-r--r--  2.0 unx      538 b- defN 24-May-20 15:42 aac/in_out/parser/_cache_manager.py
+-rw-r--r--  2.0 unx     9476 b- defN 24-May-20 15:42 aac/in_out/parser/_parse_source.py
+-rw-r--r--  2.0 unx      601 b- defN 24-May-20 15:42 aac/in_out/parser/_parser_error.py
+-rw-r--r--  2.0 unx     4682 b- defN 24-May-20 15:42 aac/in_out/parser/_yaml.py
+-rw-r--r--  2.0 unx       74 b- defN 24-May-20 15:42 aac/plugins/__init__.py
+-rw-r--r--  2.0 unx     5817 b- defN 24-May-20 15:42 aac/plugins/aac_primitives/__init__.py
+-rw-r--r--  2.0 unx     1171 b- defN 24-May-20 15:42 aac/plugins/aac_primitives/aac_primitive_constraints.aac
+-rw-r--r--  2.0 unx    13451 b- defN 24-May-20 15:42 aac/plugins/aac_primitives/aac_primitive_constraints_impl.py
+-rw-r--r--  2.0 unx     1875 b- defN 24-May-20 15:42 aac/plugins/check/__init__.py
+-rw-r--r--  2.0 unx      723 b- defN 24-May-20 15:42 aac/plugins/check/check_aac.aac
+-rw-r--r--  2.0 unx    10760 b- defN 24-May-20 15:42 aac/plugins/check/check_aac_impl.py
+-rw-r--r--  2.0 unx     2417 b- defN 24-May-20 15:42 aac/plugins/constraint_assignment_arguments/__init__.py
+-rw-r--r--  2.0 unx      529 b- defN 24-May-20 15:42 aac/plugins/constraint_assignment_arguments/constraint_assignment_arguments.aac
+-rw-r--r--  2.0 unx     7514 b- defN 24-May-20 15:42 aac/plugins/constraint_assignment_arguments/constraint_assignment_arguments_impl.py
+-rw-r--r--  2.0 unx     2085 b- defN 24-May-20 15:42 aac/plugins/exclusive_fields/__init__.py
+-rw-r--r--  2.0 unx      594 b- defN 24-May-20 15:42 aac/plugins/exclusive_fields/exclusive_fields.aac
+-rw-r--r--  2.0 unx     2350 b- defN 24-May-20 15:42 aac/plugins/exclusive_fields/exclusive_fields_impl.py
+-rw-r--r--  2.0 unx     4565 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/__init__.py
+-rw-r--r--  2.0 unx     2571 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/gen_plugin.aac
+-rw-r--r--  2.0 unx     7281 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/gen_plugin_generator.aac
+-rw-r--r--  2.0 unx     3251 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/gen_plugin_impl.py
+-rw-r--r--  2.0 unx       35 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/templates/empty.jinja2
+-rw-r--r--  2.0 unx     1396 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/templates/feature_file.jinja2
+-rw-r--r--  2.0 unx     6704 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/templates/plugin_impl.jinja2
+-rw-r--r--  2.0 unx    10212 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/templates/plugin_init.jinja2
+-rw-r--r--  2.0 unx     3939 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/templates/plugin_unit_test.jinja2
+-rw-r--r--  2.0 unx      215 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/templates/project_readme.jinja2
+-rw-r--r--  2.0 unx     1069 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/templates/project_setup.jinja2
+-rw-r--r--  2.0 unx      862 b- defN 24-May-20 15:42 aac/plugins/gen_plugin/templates/project_tox.jinja2
+-rw-r--r--  2.0 unx     2425 b- defN 24-May-20 15:42 aac/plugins/generate/__init__.py
+-rw-r--r--  2.0 unx     2245 b- defN 24-May-20 15:42 aac/plugins/generate/generate.aac
+-rw-r--r--  2.0 unx    14699 b- defN 24-May-20 15:42 aac/plugins/generate/generate_impl.py
+-rw-r--r--  2.0 unx       62 b- defN 24-May-20 15:42 aac/plugins/generate/helpers/__init__.py
+-rw-r--r--  2.0 unx     4757 b- defN 24-May-20 15:42 aac/plugins/generate/helpers/python_helpers.py
+-rw-r--r--  2.0 unx     2153 b- defN 24-May-20 15:42 aac/plugins/if_true_then_empty/__init__.py
+-rw-r--r--  2.0 unx      558 b- defN 24-May-20 15:42 aac/plugins/if_true_then_empty/if_true_then_empty.aac
+-rw-r--r--  2.0 unx     2286 b- defN 24-May-20 15:42 aac/plugins/if_true_then_empty/if_true_then_empty_impl.py
+-rw-r--r--  2.0 unx     1993 b- defN 24-May-20 15:42 aac/plugins/no_ext_for_final/__init__.py
+-rw-r--r--  2.0 unx      360 b- defN 24-May-20 15:42 aac/plugins/no_ext_for_final/no_ext_for_final.aac
+-rw-r--r--  2.0 unx     2425 b- defN 24-May-20 15:42 aac/plugins/no_ext_for_final/no_ext_for_final_impl.py
+-rw-r--r--  2.0 unx     2016 b- defN 24-May-20 15:42 aac/plugins/print_defs/__init__.py
+-rw-r--r--  2.0 unx      447 b- defN 24-May-20 15:42 aac/plugins/print_defs/print_aac_definitions.aac
+-rw-r--r--  2.0 unx     1423 b- defN 24-May-20 15:42 aac/plugins/print_defs/print_aac_definitions_impl.py
+-rw-r--r--  2.0 unx     2158 b- defN 24-May-20 15:42 aac/plugins/root_schema_must_have_name/__init__.py
+-rw-r--r--  2.0 unx      370 b- defN 24-May-20 15:42 aac/plugins/root_schema_must_have_name/root_schema_must_have_name.aac
+-rw-r--r--  2.0 unx     2751 b- defN 24-May-20 15:42 aac/plugins/root_schema_must_have_name/root_schema_must_have_name_impl.py
+-rw-r--r--  2.0 unx     1872 b- defN 24-May-20 15:42 aac/plugins/unique_root_keys/__init__.py
+-rw-r--r--  2.0 unx      357 b- defN 24-May-20 15:42 aac/plugins/unique_root_keys/unique_root_keys.aac
+-rw-r--r--  2.0 unx     1457 b- defN 24-May-20 15:42 aac/plugins/unique_root_keys/unique_root_keys_impl.py
+-rw-r--r--  2.0 unx     1773 b- defN 24-May-20 15:42 aac/plugins/version/__init__.py
+-rw-r--r--  2.0 unx      226 b- defN 24-May-20 15:42 aac/plugins/version/version.aac
+-rw-r--r--  2.0 unx      875 b- defN 24-May-20 15:42 aac/plugins/version/version_impl.py
+-rw-r--r--  2.0 unx    13241 b- defN 24-May-20 15:42 aac-0.4.5.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-20 15:42 aac-0.4.5.dist-info/WHEEL
+-rw-r--r--  2.0 unx       53 b- defN 24-May-20 15:42 aac-0.4.5.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        4 b- defN 24-May-20 15:42 aac-0.4.5.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7889 b- defN 24-May-20 15:42 aac-0.4.5.dist-info/RECORD
+84 files, 308631 bytes uncompressed, 80993 bytes compressed:  73.8%
```

## zipnote {}

```diff
@@ -231,23 +231,23 @@
 
 Filename: aac/plugins/version/version.aac
 Comment: 
 
 Filename: aac/plugins/version/version_impl.py
 Comment: 
 
-Filename: aac-0.4.4.dist-info/METADATA
+Filename: aac-0.4.5.dist-info/METADATA
 Comment: 
 
-Filename: aac-0.4.4.dist-info/WHEEL
+Filename: aac-0.4.5.dist-info/WHEEL
 Comment: 
 
-Filename: aac-0.4.4.dist-info/entry_points.txt
+Filename: aac-0.4.5.dist-info/entry_points.txt
 Comment: 
 
-Filename: aac-0.4.4.dist-info/top_level.txt
+Filename: aac-0.4.5.dist-info/top_level.txt
 Comment: 
 
-Filename: aac-0.4.4.dist-info/RECORD
+Filename: aac-0.4.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## aac/__init__.py

```diff
@@ -8,15 +8,15 @@
     major = sys.version_info.major
     print(f"Python version {major}.{minor} is too low; AaC requires at least Python version 3.9 or higher to run.")
     exit(1)
 
 import logging
 import os
 
-__version__ = "0.4.4"
+__version__ = "0.4.5"
 __log_file_name__ = os.path.join(os.path.dirname(__file__), "aac.log")
 
 logging.basicConfig(
     format="%(asctime)s::%(pathname)s:%(lineno)d::%(levelname)s::%(message)s",
     filename=__log_file_name__,
     encoding="utf-8",
     level=logging.DEBUG,
```

## aac/context/definition_parser.py

```diff
@@ -5,740 +5,829 @@
 from aac.context.definition import Definition
 from aac.context.lexeme import Lexeme
 from aac.context.util import get_python_module_name, get_python_class_name
 
 
 class DefinitionParser():
     """Definition Parser class, responsible for loading definition files."""
-    def load_definitions(  # noqa: C901
-        self, context, parsed_definitions: list[Definition]
-    ) -> list[Definition]:
+
+    def find_definitions_by_name(self, name: str) -> list[Definition]:
         """
-        Loads the given definitions into the context and populates the instance with a python object.
+        Method to find a definition by name.
 
         Args:
-            context (LanguageContext): An instance of the active LanguageContext.
-            parsed_definitions: (list[Definition]): The parsed contents of a definition file.
+            name (str): The name of the definition being searched for.
 
         Returns:
-            The parsed definitions to load into the LanguageContext.
+            The definition with the given name.
         """
-
-        # Maintainer note:  Yes, this function is a bit of a monster...sorry about that.
-        # I wanted to keep all this stuff together because if it all works out this should be the
-        # only place where we have to deal with navigating the structure of the definitions and
-        # not using the python objects.  In order for this to work, any changes in here should
-        # avoid the use of he definition instance...other than actually creating it.
-
-        primitive_name_to_py_type = {
-            definition.name: definition.structure["primitive"]["python_type"]
-            for definition in parsed_definitions + context.get_definitions()
-            if definition.get_root_key() == "primitive"
-        }
-        fully_qualified_name_to_definition = {}
-
-        def find_definitions_by_name(name: str) -> list[Definition]:
-            """
-            Method to find a definition by name.
-
-            Args:
-                name (str): The name of the definition being searched for.
-
-            Returns:
-                The definition with the given name.
-            """
-            result = []
-            for definition in context.get_definitions():
+        result = []
+        for definition in self.context.get_definitions():
+            if definition.name == name:
+                result.append(definition)
+        # if we didn't find any definitions in the context, check the parsed definitions
+        if len(result) == 0:
+            for definition in self.parsed_definitions:
                 if definition.name == name:
                     result.append(definition)
-            # if we didn't find any definitions in the context, check the parsed definitions
-            if len(result) == 0:
-                for definition in parsed_definitions:
-                    if definition.name == name:
-                        result.append(definition)
-            return result
+        return result
 
-        def get_location_str(lexeme_value: str, lexemes: list[Lexeme]) -> str:
-            """
-            Method to find the file name and line number for a requested Lexeme value.
-
-            Args:
-                lexeme_value (str): The Lexeme to match.
-                lexemes (list[Lexeme]): A list of definition Lexemes.
-
-            Returns:
-                The file name and line number of the requested Lexeme value.
-            """
-            lexeme = [lexeme for lexeme in lexemes if lexeme.value == lexeme_value]
-            location_str = (
-                "Unable to identify source and location"  # this is the 'not found' case
-            )
-            if len(lexeme) == 1:  # this is the single match case
+    def get_location_str(self, lexeme_value: str, lexemes: list[Lexeme]) -> str:
+        """
+        Method to find the file name and line number for a requested Lexeme value.
+
+        Args:
+            lexeme_value (str): The Lexeme to match.
+            lexemes (list[Lexeme]): A list of definition Lexemes.
+
+        Returns:
+            The file name and line number of the requested Lexeme value.
+        """
+        lexeme = [lexeme for lexeme in lexemes if lexeme.value == lexeme_value]
+        location_str = (
+            "Unable to identify source and location"  # this is the 'not found' case
+        )
+        if len(lexeme) == 1:  # this is the single match case
+            source_str = lexeme[0].source
+            line_str = lexeme[0].location.line + 1
+            location_str = f"File: {source_str}  Line: {line_str}"
+        elif len(lexeme) > 1:  # this is the ambiguous match case
+            # check to see if location source is the same for all matches
+            if all(
+                [
+                    lexeme[0].source == lexeme[i].source
+                    for i in range(1, len(lexeme))
+                ]
+            ):
                 source_str = lexeme[0].source
-                line_str = lexeme[0].location.line + 1
-                location_str = f"File: {source_str}  Line: {line_str}"
-            elif len(lexeme) > 1:  # this is the ambiguous match case
-                # check to see if location source is the same for all matches
-                if all(
-                    [
-                        lexeme[0].source == lexeme[i].source
-                        for i in range(1, len(lexeme))
-                    ]
-                ):
-                    source_str = lexeme[0].source
-                    location_str = f"File: {source_str}  Possible Lines: {', '.join([str(lex.location.line+1) for lex in lexeme])}"
-                else:  # if not, just list each possible location
-                    location_str = "Unable to identify unique location - "
-                    for lex in lexeme:
-                        location_str += (
-                            f"File: {lex.source}  Line: {lex.location.line+1}  "
-                        )
-            return location_str
+                location_str = f"File: {source_str}  Possible Lines: {', '.join([str(lex.location.line+1) for lex in lexeme])}"
+            else:  # if not, just list each possible location
+                location_str = "Unable to identify unique location - "
+                for lex in lexeme:
+                    location_str += (
+                        f"File: {lex.source}  Line: {lex.location.line+1}  "
+                    )
+        return location_str
 
-        def get_inheritance_parents(definition: Definition) -> list[Type]:
-            """
-            Looks up the inheritance parent classes for the given definition and returns them as a list of Python classes.
-
-            Args:
-                definition (Definition): The definition whose parent class(es) is being searched for.
-
-            Returns:
-                The parent class(es) as a list of Python classes.
-            """
-            inheritance_parents = []
-
-            if "extends" in definition.structure[definition.get_root_key()]:
-                for parent in definition.structure[definition.get_root_key()][
-                    "extends"
-                ]:
-                    # I need to find the definition referenced by the extends
-                    parent_package = parent["package"]
-                    parent_name = parent["name"]
-                    parent_fully_qualified_name = ""
-                    try:
-                        parent_fully_qualified_name = f"{get_python_module_name(parent_package)}.{get_python_class_name(parent_name)}"
-                    except LanguageError as e:
-                        raise LanguageError(
-                            f"Failed to establish parent fully qualified name from parent_package {parent_package} and parent_name {parent_name}: {e.message}", get_location_str(parent_name, definition.lexemes)
-                        )
+    def get_inheritance_parents(self, definition: Definition) -> list[Type]:
+        """
+        Looks up the inheritance parent classes for the given definition and returns them as a list of Python classes.
+
+        Args:
+            definition (Definition): The definition whose parent class(es) is being searched for.
+
+        Returns:
+            The parent class(es) as a list of Python classes.
+        """
+        inheritance_parents = []
+
+        if "extends" in definition.structure[definition.get_root_key()]:
+            for parent in definition.structure[definition.get_root_key()][
+                "extends"
+            ]:
+                # I need to find the definition referenced by the extends
+                parent_package = parent["package"]
+                parent_name = parent["name"]
+                parent_fully_qualified_name = ""
+                try:
+                    parent_fully_qualified_name = f"{get_python_module_name(parent_package)}.{get_python_class_name(parent_name)}"
+                except LanguageError as e:
+                    raise LanguageError(
+                        f"Failed to establish parent fully qualified name from parent_package {parent_package} and parent_name {parent_name}: {e.message}", self.get_location_str(parent_name, definition.lexemes)
+                    )
 
+                if (
+                    parent_fully_qualified_name
+                    in self.context.context_instance.fully_qualified_name_to_class
+                ):
+                    inheritance_parents.append(
+                        self.context.context_instance.fully_qualified_name_to_class[
+                            parent_fully_qualified_name
+                        ]
+                    )
+                else:
+                    # there is a chance that processing order just means we haven't gotten to the parent yet
+                    parent_definition = None
                     if (
                         parent_fully_qualified_name
-                        in context.context_instance.fully_qualified_name_to_class
+                        in self.fully_qualified_name_to_definition
                     ):
+                        parent_definition = self.fully_qualified_name_to_definition[
+                            parent_fully_qualified_name
+                        ]
+
+                    if not parent_definition:
+                        raise LanguageError(
+                            f"Cannot find parent definition {parent_fully_qualified_name} for {definition.name}",
+                            self.get_location_str(parent_name, definition.lexemes),
+                        )
+
+                    if parent_definition.get_root_key() == "schema":
                         inheritance_parents.append(
-                            context.context_instance.fully_qualified_name_to_class[
-                                parent_fully_qualified_name
-                            ]
+                            self.create_schema_class(parent_definition)
                         )
                     else:
-                        # there is a chance that processing order just means we haven't gotten to the parent yet
-                        parent_definition = None
-                        if (
-                            parent_fully_qualified_name
-                            in fully_qualified_name_to_definition
-                        ):
-                            parent_definition = fully_qualified_name_to_definition[
-                                parent_fully_qualified_name
-                            ]
-
-                        if not parent_definition:
-                            raise LanguageError(
-                                f"Cannot find parent definition {parent_fully_qualified_name} for {definition.name}",
-                                get_location_str(parent_name, definition.lexemes),
-                            )
-
-                        if parent_definition.get_root_key() == "schema":
-                            inheritance_parents.append(
-                                create_schema_class(parent_definition)
-                            )
-                        else:
-                            # AaC only supports schema inheritance
-                            raise LanguageError(
-                                f"AaC extension is only supported for schema.  Unable to create parent class with AaC root: {parent_definition.get_root_key()}",
-                                get_location_str(parent_name, definition.lexemes),
-                            )
-
-            return inheritance_parents
-
-        def create_enum_class(enum_definition: Definition) -> Type:
-            """
-            Creates an enum class from a given enum definition.
-
-            Args:
-                enum_definition (Definition): An enum definition to convert to a class.
-
-            Returns:
-                The created class.
-            """
-            if not enum_definition.get_root_key() == "enum":
-                raise LanguageError(
-                    f"Definition {enum_definition.name} is not an enum",
-                    get_location_str(
-                        enum_definition.get_root_key(), enum_definition.lexemes
-                    ),
+                        # AaC only supports schema inheritance
+                        raise LanguageError(
+                            f"AaC extension is only supported for schema.  Unable to create parent class with AaC root: {parent_definition.get_root_key()}",
+                            self.get_location_str(parent_name, definition.lexemes),
+                        )
+
+        return inheritance_parents
+
+    def create_enum_class(self, enum_definition: Definition) -> Enum:
+        """
+        Creates an enum class from a given enum definition.
+
+        Args:
+            enum_definition (Definition): An enum definition to convert to a class.
+
+        Returns:
+            The created class.
+        """
+        if enum_definition.get_root_key() != "enum":
+            raise LanguageError(
+                f"Definition {enum_definition.name} is not an enum",
+                self.get_location_str(
+                    enum_definition.get_root_key(), enum_definition.lexemes
                 )
+            )
 
-            fully_qualified_name = enum_definition.get_fully_qualified_name()
-            if (
+        fully_qualified_name = enum_definition.get_fully_qualified_name()
+        if (
+            fully_qualified_name
+            in self.context.context_instance.fully_qualified_name_to_class
+        ):
+            # we've already created the class, so nothing to do here
+            return self.context.context_instance.fully_qualified_name_to_class[
                 fully_qualified_name
-                in context.context_instance.fully_qualified_name_to_class
-            ):
-                # we've already created the class, so nothing to do here
-                return context.context_instance.fully_qualified_name_to_class[
-                    fully_qualified_name
-                ]
+            ]
 
-            # Note:  trying to allow extension with Enums fails, so I just removed it
-            #        but we can revisit and try to find a solution in the future if needed
+        # Note:  trying to allow extension with Enums fails, so I just removed it
+        #        but we can revisit and try to find a solution in the future if needed
 
-            values = {}
-            if "values" in enum_definition.structure["enum"]:
-                for value in enum_definition.structure["enum"]["values"]:
-                    values[value] = auto()
-            # create the enum class
-            instance_class = None
-            try:
-                instance_class = Enum(
-                    enum_definition.get_python_class_name(),
-                    values,
-                    module=enum_definition.get_python_module_name(),
-                )
-            except LanguageError as e:
+        values = {}
+        if "values" in enum_definition.structure["enum"]:
+            for value in enum_definition.structure["enum"]["values"]:
+                values[value] = auto()
+        # create the enum class
+        instance_class = None
+        try:
+            instance_class = Enum(
+                enum_definition.get_python_class_name(),
+                values,
+                module=enum_definition.get_python_module_name(),
+            )
+        except LanguageError as e:
+            raise LanguageError(
+                f"Failed to create Enum instance_class for {enum_definition.name}: {e.message}",
+                self.get_location_str(enum_definition.name, enum_definition.lexemes),
+            )
+        self.context.context_instance.fully_qualified_name_to_class[
+            fully_qualified_name
+        ] = instance_class
+        return instance_class
+
+    def add_field_to_class(self, field: dict, instance_class: Type, schema_definition: Definition) -> Type:
+        """
+        Creates an attribute within the instance class and adds the field name and type to it.
+
+        Args:
+            field (dict): The field being loaded into the instance class.
+            instance_class (Type): The instance class being loaded with field definitions.
+            schema_definition (Definition): The schema definition containing the fields being iterated through and loaded.
+
+        Returns:
+            the instance class after being loaded with field definitions.
+        """
+        field_name = field["name"]
+        field_type = field["type"]
+        is_list = False
+
+        clean_field_type = field_type
+        if field_type.endswith("[]"):
+            is_list = True
+            clean_field_type = field_type[:-2]
+        if "(" in clean_field_type:
+            clean_field_type = clean_field_type[: clean_field_type.find("(")]
+
+        # let's make sure the type of the field is known, or create it if it's not
+        potential_definitions = self.find_definitions_by_name(clean_field_type)
+        if len(potential_definitions) != 1:
+            if len(potential_definitions) == 0:
                 raise LanguageError(
-                    f"Failed to create Enum instance_class for {enum_definition.name}: {e.message}",
-                    get_location_str(enum_definition.name, enum_definition.lexemes),
+                    f"Could not find AaC definition for type {clean_field_type} while loading {schema_definition.name}",
+                    self.get_location_str(field_type, schema_definition.lexemes),
                 )
-            context.context_instance.fully_qualified_name_to_class[
-                fully_qualified_name
-            ] = instance_class
-            return instance_class
-
-        def create_schema_class(schema_definition: Definition) -> Type:
-            """
-            Creates a schema class from a given schema definition.
-
-            Args:
-                schema_definition (Definition): A schema definition to convert to a class.
-
-            Returns:
-                The created class.
-            """
-            instance_class = None
-
-            fully_qualified_name = schema_definition.get_fully_qualified_name()
-            if schema_definition.get_root_key() == "primitive":
-                # this is a primitive, so there's no structure to create...just return the python type
-                return eval(primitive_name_to_py_type[schema_definition.name])
-            elif schema_definition.get_root_key() == "enum":
-                # this is an enum, so create the enum class
-                return create_enum_class(schema_definition)
-            elif schema_definition.get_root_key() != "schema":
+            else:
                 raise LanguageError(
-                    f"Definition {schema_definition.name} is not a schema",
-                    get_location_str(
-                        schema_definition.get_root_key(), schema_definition.lexemes
-                    ),
+                    f"Discovered multiple AaC definitions for type {clean_field_type} while loading {schema_definition.name}.  You may need to add a package name to differentiate.",
+                    self.get_location_str(field_type, schema_definition.lexemes),
                 )
 
-            if (
-                fully_qualified_name
-                in context.context_instance.fully_qualified_name_to_class
-            ):
-                # we've already created the class, so nothing to do here
-                return context.context_instance.fully_qualified_name_to_class[
-                    fully_qualified_name
-                ]
+        parsed_definition = potential_definitions[0]
 
-            instance_class = None
-            inheritance_parents = get_inheritance_parents(schema_definition)
-            if len(inheritance_parents) == 0:
-                try:
-                    instance_class = type(
-                        schema_definition.get_python_class_name(),
-                        tuple([object]),
-                        {"__module__": schema_definition.get_python_module_name()},
-                    )
-                except LanguageError as e:
-                    raise LanguageError(
-                        f"Failed to create instance_class for {schema_definition.name}: {e.message}",
-                        get_location_str(
-                            schema_definition.name, schema_definition.lexemes
-                        ),
-                    )
-            else:
-                parent_classes = inheritance_parents  # the following causes a method resolution order (MRO) error when creating the type: [object] + inheritance_parents
-                try:
-                    instance_class = type(
-                        definition.get_python_class_name(),
-                        tuple(parent_classes),
-                        {"__module__": schema_definition.get_python_module_name()},
-                    )
-                except LanguageError as e:
-                    raise LanguageError(
-                        f"Failed to create instance_class for {schema_definition.name}: {e.message}",
-                        get_location_str(
-                            schema_definition.name, schema_definition.lexemes
-                        ),
-                    )
+        self.create_schema_class(parsed_definition)
 
-            # now add the fields to the class
-            for field in schema_definition.structure["schema"]["fields"]:
-                field_name = field["name"]
-                field_type = field["type"]
-                is_list = False
-
-                clean_field_type = field_type
-                if field_type.endswith("[]"):
-                    is_list = True
-                    clean_field_type = field_type[:-2]
-                if "(" in clean_field_type:
-                    clean_field_type = clean_field_type[: clean_field_type.find("(")]
-
-                # let's make sure the type of the field is known, or create it if it's not
-                potential_definitions = find_definitions_by_name(clean_field_type)
-                if len(potential_definitions) != 1:
-                    if len(potential_definitions) == 0:
-                        raise LanguageError(
-                            f"Could not find AaC definition for type {clean_field_type} while loading {schema_definition.name}",
-                            get_location_str(field_type, schema_definition.lexemes),
-                        )
-                    else:
-                        raise LanguageError(
-                            f"Discovered multiple AaC definitions for type {clean_field_type} while loading {schema_definition.name}.  You may need to add a package name to differentiate.",
-                            get_location_str(field_type, schema_definition.lexemes),
-                        )
+        # since python is dynamically typed, we really don't have to worry about setting a type when we create the field
+        # we just need to make sure a reasonable default value is used, so for us that means an empty list or None
+        # Question:  is there ever a case where we may need a dict value?
+        if is_list:
+            setattr(instance_class, field_name, [])
+        else:
+            setattr(instance_class, field_name, None)
+        return instance_class
 
-                parsed_definition = potential_definitions[0]
+    def create_instance_class(self, inheritance_parents: list, schema_definition: Definition) -> Type:
+        """
+        Method to create an instance class type for the given definition.
 
-                create_schema_class(parsed_definition)
+        Args:
+            inheritance_parents (list[Type]): Types that this definition inherits from.
+            schema_definition (Definition): The definition being converted to an instance class.
 
-                # since python is dynamically typed, we really don't have to worry about setting a type when we create the field
-                # we just need to make sure a reasonable default value is used, so for us that means an empty list or None
-                # Question:  is there ever a case where we may need a dict value?
-                if is_list:
-                    setattr(instance_class, field_name, [])
-                else:
-                    setattr(instance_class, field_name, None)
+        Returns:
+            The created instance class.
+        """
+        if len(inheritance_parents) == 0:
+            base_content = [object]
+        else:
+            base_content = inheritance_parents
+
+        try:
+            instance_class = type(
+                schema_definition.get_python_class_name(),
+                tuple(base_content),
+                {"__module__": schema_definition.get_python_module_name()}
+            )
+        except LanguageError as e:
+            raise LanguageError(
+                f"Failed to create instance_class for {schema_definition.name}: {e.message}",
+                self.get_location_str(
+                    schema_definition.name, schema_definition.lexemes
+                )
+            )
+        return instance_class
+
+    def create_schema_class(self, schema_definition: Definition) -> Type:
+        """
+        Creates a schema class from a given schema definition.
 
-            # finally store the class in the context
-            context.context_instance.fully_qualified_name_to_class[
+        Args:
+            schema_definition (Definition): A schema definition to convert to a class.
+
+        Returns:
+            The created class.
+        """
+
+        fully_qualified_name = schema_definition.get_fully_qualified_name()
+        if schema_definition.get_root_key() == "primitive":
+            # this is a primitive, so there's no structure to create, just return the python type
+            return eval(self.primitive_name_to_py_type[schema_definition.name])
+        elif schema_definition.get_root_key() == "enum":
+            # this is an enum, so create the enum class
+            return self.create_enum_class(schema_definition)
+        elif schema_definition.get_root_key() != "schema":
+            raise LanguageError(
+                f"Definition {schema_definition.name} is not a schema",
+                self.get_location_str(
+                    schema_definition.get_root_key(), schema_definition.lexemes
+                )
+            )
+
+        if (
+            fully_qualified_name
+            in self.context.context_instance.fully_qualified_name_to_class
+        ):
+            # we've already created the class, so nothing to do here
+            return self.context.context_instance.fully_qualified_name_to_class[
                 fully_qualified_name
-            ] = instance_class
-            return instance_class
+            ]
 
-        def create_object_instance(type_class: Type, fields: dict) -> Any:
-            """
-            Creates an instance object from the given fields.
-
-            Args:
-                type_class (Type): The class created from the field type.
-                fields (dict): Given fields to create instances from.
-
-            Returns:
-                The created instance object.
-            """
-            result = type_class()
-            for field_name, field_value in fields.items():
-                setattr(result, field_name, field_value)
-            return result
+        inheritance_parents = self.get_inheritance_parents(schema_definition)
+        instance_class = self.create_instance_class(inheritance_parents, schema_definition)
 
-        def get_defined_fields(package: str, name: str) -> list[str]:
-            """
-            Returns a list of defined fields for the given definition.
-
-            Args:
-                package (str): The definition package.
-                name (str): The definition name.
+        # now add the fields to the class
+        for field in schema_definition.structure["schema"]["fields"]:
+            instance_class = self.add_field_to_class(field, instance_class, schema_definition)
+
+        # finally store the class in the context
+        self.context.context_instance.fully_qualified_name_to_class[
+            fully_qualified_name
+        ] = instance_class
+        return instance_class
 
-            Returns: A list of definition fields.
-            """
-            result = []
-            defining_definition = None
-            for definition in context.get_definitions() + parsed_definitions:
-                if definition.name == name and definition.package == package:
-                    defining_definition = definition
-                    break
-            if (
-                "extends"
-                in defining_definition.structure[defining_definition.get_root_key()]
-            ):
-                for parent in defining_definition.structure[
-                    defining_definition.get_root_key()
-                ]["extends"]:
-                    result.extend(get_defined_fields(parent["package"], parent["name"]))
-            if "fields" in defining_definition.structure[definition.get_root_key()]:
-                result.extend(
-                    [
-                        field["name"]
-                        for field in definition.structure[definition.get_root_key()][
-                            "fields"
-                        ]
+    def create_object_instance(self, type_class: Type, fields: dict) -> Any:
+        """
+        Creates an instance object from the given fields.
+
+        Args:
+            type_class (Type): The class created from the field type.
+            fields (dict): Given fields to create instances from.
+
+        Returns:
+            The created instance object.
+        """
+        result = type_class()
+        for field_name, field_value in fields.items():
+            setattr(result, field_name, field_value)
+        return result
+
+    def get_defined_fields(self, package: str, name: str) -> list[str]:
+        """
+        Returns a list of defined fields for the given definition.
+
+        Args:
+            package (str): The definition package.
+            name (str): The definition name.
+
+        Returns:
+            A list of definition fields.
+        """
+        result = []
+        defining_definition = None
+        for definition in self.context.get_definitions() + self.parsed_definitions:
+            if definition.name == name and definition.package == package:
+                defining_definition = definition
+                break
+        if (
+            "extends"
+            in defining_definition.structure[defining_definition.get_root_key()]
+        ):
+            for parent in defining_definition.structure[
+                defining_definition.get_root_key()
+            ]["extends"]:
+                result.extend(self.get_defined_fields(parent["package"], parent["name"]))
+        if "fields" in defining_definition.structure[definition.get_root_key()]:
+            result.extend(
+                [
+                    field["name"]
+                    for field in definition.structure[definition.get_root_key()][
+                        "fields"
                     ]
-                )
-            return result
+                ]
+            )
+        return result
+
+    def populate_sub_fields(self, subfields: dict, defining_definition: Definition, item: dict, lexemes: list[Lexeme]) -> dict:
+        """
+        Method used to populate sub-fields in an instance class field.
+
+        Args:
+            subfields (dict): dictionary containing relevant sub-fields.
+            defining_definition (Definition): The overall definition containing the field.
+            item (dict): The current field definition which contains sub-fields.
+            lexemes (List[Lexeme]): A list of definition Lexemes.
+
+        Returns:
+            The populated dictionary of sub-fields.
+        """
+        for subfield in defining_definition.structure["schema"][
+            "fields"
+        ]:
+            subfield_name = subfield["name"]
+            subfield_type = subfield["type"]
+            subfield_is_required = False
+            if "is_required" in subfield:
+                subfield_is_required = subfield["is_required"]
+            subfield_value = None
+            if subfield_name in item:
+                subfield_value = item[subfield_name]
+            else:
+                if "default" in subfield:
+                    # let's see if we need to cast the value
+                    subfield_default_str = subfield["default"]
+                    if isinstance(subfield_default_str, str):
+                        type_map = {
+                            "int": int,
+                            "number": float,
+                            "bool": lambda x: x.lower()
+                            in ("yes", "true", "t", "1"),
+                            "string": str,
+                        }
+                        if subfield_type in type_map:
+                            subfield_value = type_map[
+                                subfield_type
+                            ](subfield_default_str)
+                    else:
+                        subfield_value = subfield_default_str
+            # we need to eliminate previously covered lexemes, so go through the list until we find subfield_name then add it and everything else
+            found = False
+            sub_lexemes = []
+            for lex in lexemes:
+                if lex.value == subfield_name:
+                    found = True
+                    sub_lexemes.append(lex)
+                if found:
+                    sub_lexemes.append(lex)
+            subfields[subfield_name] = self.create_field_instance(
+                subfield_name,
+                subfield_type,
+                subfield_is_required,
+                subfield_value,
+                sub_lexemes,
+            )
+        return subfields
+
+    def field_instance_creator_list(self, lexemes: list, field_value: Any, field_name: str, defining_definition: Definition, instance: list, instance_class: Type) -> list:
+        """
+        Method to create instance fields from list type fields.
 
-        def create_field_instance(
-            field_name: str,
-            field_type: str,
-            is_required: bool,
-            field_value: Any,
-            lexemes: list[Lexeme],
-        ) -> Any:
-            """
-            Adds an entry to the instance attribute of a definition for the given field.
-
-            Args:
-                field_name (str): Name of the field.
-                field_type (str): Type of the field.
-                is_required (bool): Contents of the is_required field for the specified field.
-                field_value (Any): The value for the specified field.
-                lexemes (list[Lexeme]): A list of definition Lexemes.
-
-            Returns:
-                The instance field value.
-            """
-            is_list = False
-            clean_field_type = field_type
-            if field_type.endswith("[]"):
-                is_list = True
-                clean_field_type = field_type[:-2]
-            if "(" in clean_field_type:
-                clean_field_type = clean_field_type[: clean_field_type.find("(")]
-
-            # now get the defining definition from the clean_field_type
-            defining_definitions = find_definitions_by_name(clean_field_type)
-            if not defining_definitions or len(defining_definitions) == 0:
+        Args:
+            lexemes (List[Lexeme]): A list of definition Lexemes.
+            field_value (Any): Value stored in the field.
+            field_name (str): The name of the field.
+            defining_definition (Definition): Definition containing the field being checked.
+            instance (list[Any]: The instance that will contain the created field)
+            instance_class (Type): The instance type class
+
+        Returns:
+            The updated instance containing the created field.
+        """
+        for item in field_value:
+            if not isinstance(item, dict):
                 raise LanguageError(
-                    f"Could not find definition for '{clean_field_type}'.",
-                    get_location_str(field_type, lexemes),
+                    f"Invalid parsed value for field '{field_name}'.  Expected type 'dict', but found '{type(item)}'. Value = {item}",
+                    self.get_location_str(field_name, lexemes),
                 )
-            elif len(defining_definitions) > 1:
+            # go through the fields and create instances for each
+            subfields = {}
+            if "fields" not in defining_definition.structure["schema"]:
                 raise LanguageError(
-                    f"Found multiple definitions for '{clean_field_type}'.",
-                    get_location_str(field_type, lexemes),
+                    f"Schema '{defining_definition.name}' does not contain any fields.",
+                    self.get_location_str(field_name, lexemes),
                 )
-            defining_definition = defining_definitions[0]
 
-            if defining_definition.get_root_key() == "primitive":
-                # this is a primitive, so ensure the parsed value aligns with the type and return it
-                python_type = defining_definition.structure["primitive"]["python_type"]
-                if is_list:
-                    if not field_value:
-                        if is_required:
-                            raise LanguageError(message=f"Missing required field {field_name}.", location=None)
-                        field_value = []
-                    else:
-                        for item in field_value:
-                            if not isinstance(item, eval(python_type)):
-                                raise LanguageError(
-                                    message=f"Invalid value for field '{field_name}'.  Expected type '{python_type}', but found '{type(item)}'",
-                                    location=get_location_str(field_value, lexemes),
-                                )
-                else:
-                    if not field_value:
-                        if is_required:
-                            raise LanguageError(f"Missing required field {field_name}.")
-                    else:
-                        if "Any" != python_type:
-                            if not isinstance(field_value, eval(python_type)):
-                                raise LanguageError(
-                                    f"Invalid value for field '{field_name}'.  Expected type '{python_type}', but found '{type(field_value)}'",
-                                    get_location_str(field_value, lexemes),
-                                )
-                return field_value
-            elif defining_definition.get_root_key() == "enum":
-                # this is an enum, so ensure the parsed value aligns with the type and return it
-                enum_class = context.context_instance.fully_qualified_name_to_class[
-                    defining_definition.get_fully_qualified_name()
-                ]
-                if not enum_class:
-                    enum_class = create_enum_class(defining_definition)
-                if is_list:
-                    result = []
-                    for item in field_value:
-                        if not isinstance(item, str):
-                            raise LanguageError(
-                                f"Invalid value for field '{field_name}'.  Expected type 'str', but found '{type(item)}'",
-                                get_location_str(field_name, lexemes),
-                            )
-                        try:
-                            result.append(getattr(enum_class, item))
-                        except ValueError:
-                            raise LanguageError(
-                                f"{item} is not a valid value for enum {defining_definition.name}",
-                                get_location_str(item, lexemes),
-                            )
-                    return result
-                else:
-                    if not field_value:
-                        return None
-                    try:
-                        return context.create_aac_enum(
-                            defining_definition.get_fully_qualified_name(), field_value
-                        )
-                    except ValueError:
-                        raise LanguageError(
-                            f"{field_value} is not a valid value for enum {defining_definition.name}",
-                            get_location_str(field_value, lexemes),
-                        )
-            else:  # this isn't a primitive and isn't an enum, so it must be a schema
-                field_fully_qualified_name = (
-                    defining_definition.get_fully_qualified_name()
+            # make sure there are no undefined fields
+            defined_field_names = self.get_defined_fields(
+                defining_definition.package, defining_definition.name
+            )
+            item_field_names = [field for field in item.keys()]
+            for item_field_name in item_field_names:
+                if item_field_name not in defined_field_names:
+                    raise LanguageError(
+                        f"Found undefined field name '{item_field_name}' when expecting {defined_field_names} as defined in {defining_definition.name}",
+                        self.get_location_str(item_field_name, lexemes),
+                    )
+            subfields = self.populate_sub_fields(subfields, defining_definition, item, lexemes)
+
+            instance.append(
+                self.create_object_instance(instance_class, subfields)
+            )
+        return instance
+
+    def field_instance_creator_not_list(self, lexemes: list, field_value: Any, field_name: str, defining_definition: Definition, instance: list, instance_class: Type) -> list:
+        """
+        Method to create instance fields from non-list type fields.
+
+        Args:
+            lexemes (List[Lexeme]): A list of definition Lexemes.
+            field_value (Any): Value stored in the field.
+            field_name (str): The name of the field.
+            defining_definition (Definition): Definition containing the field being checked.
+            instance (list[Any]: The instance that will contain the created field)
+            instance_class (Type): The instance type class
+
+        Returns:
+            The updated instance containing the created field
+        """
+        defined_field_names = self.get_defined_fields(
+            defining_definition.package, defining_definition.name
+        )
+        item_field_names = [field for field in field_value.keys()]
+        for item_field_name in item_field_names:
+            if item_field_name not in defined_field_names:
+                raise LanguageError(
+                    f"Found undefined field name '{item_field_name}' when expecting {defined_field_names} as defined in {defining_definition.name}",
+                    self.get_location_str(item_field_name, lexemes),
                 )
 
-                instance_class = context.context_instance.fully_qualified_name_to_class[
-                    field_fully_qualified_name
-                ]
-                if not instance_class:
-                    if defining_definition.get_root_key() == "schema":
-                        instance_class = create_schema_class(defining_definition)
-                    else:
-                        raise LanguageError(
-                            f"Unable to process AaC definition of type {field_fully_qualified_name} with root {defining_definition.get_root_key()}",
-                            get_location_str(field_name, lexemes),
-                        )
-                instance = None
-                if is_list:
-                    instance = []
-                    if not field_value:
-                        if is_required:
-                            raise LanguageError(f"Missing required field {field_name}")
-                    else:
-                        if not isinstance(field_value, list):
-                            if is_required:
-                                raise LanguageError(
-                                    f"Invalid parsed value for field '{field_name}'.  Expected type 'list', but found '{type(field_value)}'.  Value = {field_value}",
-                                    get_location_str(field_name, lexemes),
-                                )
-                            else:
-                                return instance
-                        for item in field_value:
-                            if not isinstance(item, dict):
-                                raise LanguageError(
-                                    f"Invalid parsed value for field '{field_name}'.  Expected type 'dict', but found '{type(item)}'. Value = {item}",
-                                    get_location_str(field_name, lexemes),
-                                )
-                            # go through the fields and create instances for each
-                            subfields = {}
-                            if "fields" not in defining_definition.structure["schema"]:
-                                raise LanguageError(
-                                    f"Schema '{defining_definition.name}' does not contain any fields.",
-                                    get_location_str(field_name, lexemes),
-                                )
-
-                            # make sure there are no undefined fields
-                            defined_field_names = get_defined_fields(
-                                defining_definition.package, defining_definition.name
-                            )
-                            item_field_names = [field for field in item.keys()]
-                            for item_field_name in item_field_names:
-                                if item_field_name not in defined_field_names:
-                                    raise LanguageError(
-                                        f"Found undefined field name '{item_field_name}' when expecting {defined_field_names} as defined in {defining_definition.name}",
-                                        get_location_str(item_field_name, lexemes),
-                                    )
-
-                            for subfield in defining_definition.structure["schema"][
-                                "fields"
-                            ]:
-                                subfield_name = subfield["name"]
-                                subfield_type = subfield["type"]
-                                subfield_is_required = False
-                                if "is_required" in subfield:
-                                    subfield_is_required = subfield["is_required"]
-                                subfield_value = None
-                                if subfield_name in item:
-                                    subfield_value = item[subfield_name]
-                                else:
-                                    if "default" in subfield:
-                                        # let's see if we need to cast the value
-                                        subfield_default_str = subfield["default"]
-                                        if isinstance(subfield_default_str, str):
-                                            type_map = {
-                                                "int": int,
-                                                "number": float,
-                                                "bool": lambda x: x.lower()
-                                                in ("yes", "true", "t", "1"),
-                                                "string": str,
-                                            }
-                                            if subfield_type in type_map:
-                                                subfield_value = type_map[
-                                                    subfield_type
-                                                ](subfield_default_str)
-                                        else:
-                                            subfield_value = subfield_default_str
-                                # we need to eliminate previously covered lexemes, so go through the list until we find subfield_name then add it and everything else
-                                found = False
-                                sub_lexemes = []
-                                for lex in lexemes:
-                                    if lex.value == subfield_name:
-                                        found = True
-                                        sub_lexemes.append(lex)
-                                    if found:
-                                        sub_lexemes.append(lex)
-                                subfields[subfield_name] = create_field_instance(
-                                    subfield_name,
-                                    subfield_type,
-                                    subfield_is_required,
-                                    subfield_value,
-                                    sub_lexemes,
-                                )
-                            instance.append(
-                                create_object_instance(instance_class, subfields)
-                            )
-                else:
-                    instance = None
-                    if not field_value:
-                        if is_required:
-                            raise LanguageError(
-                                f"Missing required field {field_name}",
-                                get_location_str(field_name, lexemes),
-                            )
-                        else:
-                            return instance
-                    if not isinstance(field_value, dict):
-                        # this is a complex type defined by a schema, with a field value so it should be a dict
-                        raise LanguageError(
-                            f"Invalid parsed value for field '{field_name}'.  Expected type 'dict', but found '{type(field_value)}'.  Value = {field_value}",
-                            get_location_str(field_name, lexemes),
-                        )
+        subfields = {}
+        if "fields" not in defining_definition.structure["schema"]:
+            raise LanguageError(
+                f"Schema '{defining_definition.name}' does not contain any fields.",
+                self.get_location_str(field_name, lexemes),
+            )
+        subfields = self.populate_sub_fields(subfields, defining_definition, field_value, lexemes)
+        instance = self.create_object_instance(instance_class, subfields)
+        return instance
 
-                    # make sure there are no undefined fields
-                    defined_field_names = get_defined_fields(
-                        defining_definition.package, defining_definition.name
-                    )
-                    item_field_names = [field for field in field_value.keys()]
-                    for item_field_name in item_field_names:
-                        if item_field_name not in defined_field_names:
-                            raise LanguageError(
-                                f"Found undefined field name '{item_field_name}' when expecting {defined_field_names} as defined in {defining_definition.name}",
-                                get_location_str(item_field_name, lexemes),
-                            )
+    def field_instance_check(self, is_list: bool, field_value: Any, field_name: str, is_required: bool, lexemes: list[Lexeme], defining_definition: Definition, instance_class: Type) -> list:
+        """
+        Method used to check if a field is a list, and to call the corresponding field instance creator method.
 
-                    subfields = {}
-                    if "fields" not in defining_definition.structure["schema"]:
+        Args:
+            is_list (bool): Boolean value determining if the field type is a list.
+            field_value (Any): Value stored in the field.
+            field_name (str): The name of the field.
+            lexemes (List[Lexeme]): A list of definition Lexemes.
+            defining_definition (Definition): Definition containing the field being checked.
+            instance_class (Type): The class type of the instance being created.
+
+        Returns:
+            The created instance list.
+        """
+        if is_list:
+            instance = []
+            if not field_value:
+                if is_required:
+                    raise LanguageError(f"Missing required field {field_name}")
+            else:
+                if not isinstance(field_value, list):
+                    if is_required:
                         raise LanguageError(
-                            f"Schema '{defining_definition.name}' does not contain any fields.",
-                            get_location_str(field_name, lexemes),
-                        )
-                    for subfield in defining_definition.structure["schema"]["fields"]:
-                        subfield_name = subfield["name"]
-                        subfield_type = subfield["type"]
-                        subfield_is_required = False
-                        if "is_required" in subfield:
-                            subfield_is_required = subfield["is_required"]
-                        subfield_value = None
-                        if subfield_name in field_value:
-                            subfield_value = field_value[subfield_name]
-                        else:
-                            if "default" in subfield:
-                                # let's see if we need to cast the value
-                                subfield_default_str = subfield["default"]
-                                if isinstance(subfield_default_str, str):
-                                    type_map = {
-                                        "int": int,
-                                        "number": float,
-                                        "bool": lambda x: x.lower()
-                                        in ("yes", "true", "t", "1"),
-                                        "string": str,
-                                    }
-                                    if subfield_type in type_map:
-                                        subfield_value = type_map[subfield_type](
-                                            subfield_default_str
-                                        )
-                                else:
-                                    subfield_value = subfield_default_str
-                        # we need to eliminate previously covered lexemes, so go through the list until we find subfield_name then add it and everything else
-                        found = False
-                        sub_lexemes = []
-                        for lex in lexemes:
-                            if lex.value == subfield_name:
-                                found = True
-                                sub_lexemes.append(lex)
-                            if found:
-                                sub_lexemes.append(lex)
-                        subfields[subfield_name] = create_field_instance(
-                            subfield_name,
-                            subfield_type,
-                            subfield_is_required,
-                            subfield_value,
-                            sub_lexemes,
+                            f"Invalid parsed value for field '{field_name}'.  Expected type 'list', but found '{type(field_value)}'.  Value = {field_value}",
+                            self.get_location_str(field_name, lexemes),
                         )
+                    else:
+                        return instance
+                instance = self.field_instance_creator_list(lexemes, field_value, field_name, defining_definition, instance, instance_class)
+        else:
+            instance = None
+            if not field_value:
+                if is_required:
+                    raise LanguageError(
+                        f"Missing required field {field_name}",
+                        self.get_location_str(field_name, lexemes),
+                    )
+                else:
+                    return instance
+            if not isinstance(field_value, dict):
+                # this is a complex type defined by a schema, with a field value so it should be a dict
+                raise LanguageError(
+                    f"Invalid parsed value for field '{field_name}'.  Expected type 'dict', but found '{type(field_value)}'.  Value = {field_value}",
+                    self.get_location_str(field_name, lexemes),
+                )
 
-                    instance = create_object_instance(instance_class, subfields)
+            # make sure there are no undefined fields
+            instance = self.field_instance_creator_not_list(lexemes, field_value, field_name, defining_definition, instance, instance_class)
+        return instance
 
-                return instance
+    def primitive_field_value_check(self, is_list: bool, field_value: Any, field_name: str, is_required: bool, lexemes: list, defining_definition: Definition) -> Any:
+        """
+        Method used to ensure primitive type field definitions have valid values.
 
-        def create_definition_instance(definition: Definition) -> Any:
-            """
-            Populates the instance field of a given definition.
+        Args:
+            is_list (bool): Boolean value determining if the field type is a list.
+            field_value (Any): Value stored in the field.
+            field_name (str): The name of the field.
+            is_required (bool): Boolean value determining if the field is required.
+            lexemes (List[Lexeme]): A list of definition Lexemes.
+            defining_definition (Definition): Definition containing the field being checked.
 
-            Args:
-                definition (Definition): The given definition being populated.
+        Returns:
+            The content of the primitive type field value.
+        """
+        python_type = defining_definition.structure["primitive"]["python_type"]
+        if not field_value:
+            if is_required:
+                raise LanguageError(message=f"Missing required field {field_name}.", location=None)
+            if is_list:
+                field_value = []
+        elif is_list:
+            for item in field_value:
+                if not isinstance(item, eval(python_type)):
+                    raise LanguageError(
+                        message=f"Invalid value for field '{field_name}'.  Expected type '{python_type}', but found '{type(item)}'",
+                        location=self.get_location_str(field_value, lexemes),
+                    )
+        else:
+            if "Any" != python_type:
+                if not isinstance(field_value, eval(python_type)):
+                    raise LanguageError(
+                        f"Invalid value for field '{field_name}'.  Expected type '{python_type}', but found '{type(field_value)}'",
+                        self.get_location_str(field_value, lexemes),
+                    )
+        return field_value
 
-            Returns:
-                The populated instance for the given definition.
-            """
-            instance = None
+    def enum_field_value_check(self, is_list: bool, field_value: Any, field_name: str, lexemes: list, defining_definition: Definition) -> list:
+        """
+        Method used to ensure enum type field definitions have valid values.
 
-            defining_definition = None
-            for item in context.get_definitions() + parsed_definitions:
-                if item.get_root_key() == "schema":
-                    if "root" in item.structure["schema"]:
-                        if (
-                            definition.get_root_key()
-                            == item.structure["schema"]["root"]
-                        ):
-                            defining_definition = item
+        Args:
+            is_list (bool): Boolean value determining if the field type is a list.
+            field_value (Any): Value stored in the field.
+            field_name (str): The name of the field.
+            lexemes (List[Lexeme]): A list of definition Lexemes.
+            defining_definition (Definition): Definition containing the field being checked.
 
-            if not defining_definition:
+        Returns:
+            The list of valid enum field values.
+        """
+        enum_class = self.context.context_instance.fully_qualified_name_to_class[
+            defining_definition.get_fully_qualified_name()
+        ]
+        if not enum_class:
+            enum_class = self.create_enum_class(defining_definition)
+        if is_list:
+            result = []
+            for item in field_value:
+                if not isinstance(item, str):
+                    raise LanguageError(
+                        f"Invalid value for field '{field_name}'.  Expected type 'str', but found '{type(item)}'",
+                        self.get_location_str(field_name, lexemes),
+                    )
+                try:
+                    result.append(getattr(enum_class, item))
+                except ValueError:
+                    raise LanguageError(
+                        f"{item} is not a valid value for enum {defining_definition.name}",
+                        self.get_location_str(item, lexemes),
+                    )
+            return result
+        else:
+            if not field_value:
+                return [None]
+            try:
+                return self.context.create_aac_enum(
+                    defining_definition.get_fully_qualified_name(), field_value
+                )
+            except ValueError:
                 raise LanguageError(
-                    f"Could not find definition for {definition.name} with root {definition.get_root_key()}",
-                    get_location_str(definition.get_root_key(), definition.lexemes),
+                    f"{field_value} is not a valid value for enum {defining_definition.name}",
+                    self.get_location_str(field_value, lexemes),
                 )
 
+    def schema_field_value_check(self, is_list, field_value, field_name: str, is_required, lexemes, defining_definition) -> list:
+        """
+        Method used to ensure schema type field definitions have valid values.
+
+        Args:
+            is_list (bool): Boolean value determining if the field type is a list.
+            field_value (Any): Value stored in the field.
+            field_name (str): The name of the field.
+            lexemes (List[Lexeme]): A list of definition Lexemes.
+            defining_definition (Definition): Definition containing the field being checked.
+
+        Returns:
+            The List of valid schema defined field values.
+        """
+        field_fully_qualified_name = (
+            defining_definition.get_fully_qualified_name()
+        )
+        instance_class = self.context.context_instance.fully_qualified_name_to_class[
+            field_fully_qualified_name
+        ]
+        if not instance_class:
             if defining_definition.get_root_key() == "schema":
-                # since schemas are how we define "all the things" the root key of the defining definition should be 'schema'
-                create_schema_class(defining_definition)
+                instance_class = self.create_schema_class(defining_definition)
             else:
                 raise LanguageError(
-                    f"Definition for root key '{defining_definition.get_root_key()}' is not a Schema.",
-                    get_location_str(definition.get_root_key(), definition.lexemes),
+                    f"Unable to process AaC definition of type {field_fully_qualified_name} with root {defining_definition.get_root_key()}",
+                    self.get_location_str(field_name, lexemes),
                 )
+        instance = self.field_instance_check(is_list, field_value, field_name, is_required, lexemes, defining_definition, instance_class)
+
+        return instance
+
+    def create_field_instance(
+        self,
+        field_name: str,
+        field_type: str,
+        is_required: bool,
+        field_value: Any,
+        lexemes: list[Lexeme],
+    ) -> Any:
+        """
+        Adds an entry to the instance attribute of a definition for the given field.
+
+        Args:
+            field_name (str): Name of the field.
+            field_type (str): Type of the field.
+            is_required (bool): Contents of the is_required field for the specified field.
+            field_value (Any): The value for the specified field.
+            lexemes (list[Lexeme]): A list of definition Lexemes.
 
-            instance = create_field_instance(
-                "root",
-                defining_definition.name,
-                True,
-                definition.structure[definition.get_root_key()],
-                definition.lexemes,
+        Returns:
+            The instance field value.
+        """
+        is_list = False
+        clean_field_type = field_type
+        if field_type.endswith("[]"):
+            is_list = True
+            clean_field_type = field_type[:-2]
+        if "(" in clean_field_type:
+            clean_field_type = clean_field_type[: clean_field_type.find("(")]
+
+        # now get the defining definition from the clean_field_type
+        defining_definitions = self.find_definitions_by_name(clean_field_type)
+        if not defining_definitions or len(defining_definitions) == 0:
+            raise LanguageError(
+                f"Could not find definition for '{clean_field_type}'.",
+                self.get_location_str(field_type, lexemes),
             )
+        elif len(defining_definitions) > 1:
+            raise LanguageError(
+                f"Found multiple definitions for '{clean_field_type}'.",
+                self.get_location_str(field_type, lexemes),
+            )
+        defining_definition = defining_definitions[0]
+
+        if defining_definition.get_root_key() == "primitive":
+            # this is a primitive, so ensure the parsed value aligns with the type and return it
+            return self.primitive_field_value_check(is_list, field_value, field_name, is_required, lexemes, defining_definition)
 
-            definition.instance = instance
-            return instance
+        elif defining_definition.get_root_key() == "enum":
+            # this is an enum, so ensure the parsed value aligns with the type and return it
+            return self.enum_field_value_check(is_list, field_value, field_name, lexemes, defining_definition)
 
-        # Start the load_definition function code here
+        else:  # this isn't a primitive and isn't an enum, so it must be a schema
+            return self.schema_field_value_check(is_list, field_value, field_name, is_required, lexemes, defining_definition)
+
+    def create_definition_instance(self, definition: Definition) -> Any:
+        """
+        Populates the instance field of a given definition.
+
+        Args:
+            definition (Definition): The given definition being populated.
 
-        fully_qualified_name_to_definition = {
+        Returns:
+            The populated instance for the given definition.
+        """
+        instance = None
+
+        defining_definition = None
+        for item in self.context.get_definitions() + self.parsed_definitions:
+            if item.get_root_key() == "schema":
+                if "root" in item.structure["schema"]:
+                    if (
+                        definition.get_root_key()
+                        == item.structure["schema"]["root"]
+                    ):
+                        defining_definition = item
+
+        if not defining_definition:
+            raise LanguageError(
+                f"Could not find definition for {definition.name} with root {definition.get_root_key()}",
+                self.get_location_str(definition.get_root_key(), definition.lexemes),
+            )
+
+        if defining_definition.get_root_key() == "schema":
+            # since schemas are how we define "all the things" the root key of the defining definition should be 'schema'
+            self.create_schema_class(defining_definition)
+        else:
+            raise LanguageError(
+                f"Definition for root key '{defining_definition.get_root_key()}' is not a Schema.",
+                self.get_location_str(definition.get_root_key(), definition.lexemes),
+            )
+
+        instance = self.create_field_instance(
+            "root",
+            defining_definition.name,
+            True,
+            definition.structure[definition.get_root_key()],
+            definition.lexemes,
+        )
+
+        definition.instance = instance
+        return instance
+
+    # Start the load_definition function code here
+    def load_definitions(
+        self, context, parsed_definitions: list[Definition]
+    ) -> list[Definition]:
+        """
+        Loads the given definitions into the context and populates the instance with a python object.
+
+        Args:
+            context (LanguageContext): An instance of the active LanguageContext.
+            parsed_definitions: (list[Definition]): The parsed contents of a definition file.
+
+        Returns:
+            The parsed definitions to load into the LanguageContext.
+        """
+
+        # Maintainer note:  Yes, this function is a bit of a monster...sorry about that.
+        # I wanted to keep all this stuff together because if it all works out this should be the
+        # only place where we have to deal with navigating the structure of the definitions and
+        # not using the python objects.  In order for this to work, any changes in here should
+        # avoid the use of he definition instance...other than actually creating it.
+        result = []
+        schema_defs_by_root = {}
+        self.context = context
+        self.parsed_definitions = parsed_definitions
+        self.primitive_name_to_py_type = {
+            definition.name: definition.structure["primitive"]["python_type"]
+            for definition in self.parsed_definitions + self.context.get_definitions()
+            if definition.get_root_key() == "primitive"
+        }
+        self.fully_qualified_name_to_definition = {
             definition.get_fully_qualified_name(): definition
-            for definition in parsed_definitions + context.get_definitions()
+            for definition in self.parsed_definitions + self.context.get_definitions()
             if "package" in definition.structure[definition.get_root_key()]
         }
 
-        schema_defs_by_root = {}
-        for definition in context.get_definitions():
+        for definition in self.context.get_definitions():
             if definition.get_root_key() == "schema":
                 if definition.instance.root:
                     schema_defs_by_root[definition.instance.root] = definition
 
-        result: list[Definition] = []
-        for definition in parsed_definitions:
+        for definition in self.parsed_definitions:
             # create and register the instance
-            create_definition_instance(definition)
+            self.create_definition_instance(definition)
             result.append(definition)
-            context.context_instance.definitions.add(definition)
-            context.context_instance.fully_qualified_name_to_definition[
+            self.context.context_instance.definitions.add(definition)
+            self.context.context_instance.fully_qualified_name_to_definition[
                 f"{definition.package}.{definition.name}"
             ] = definition
 
         return result
```

## Comparing `aac-0.4.4.dist-info/METADATA` & `aac-0.4.5.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: aac
-Version: 0.4.4
+Version: 0.4.5
 Summary: A distinctly different take on Model-Based System Engineering (MBSE) that allows a system modeller to define a system in simple yaml. 
 Keywords: MBSE
 Classifier: Programming Language :: Python :: 3.9
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Topic :: Scientific/Engineering
 Description-Content-Type: text/markdown
```

## Comparing `aac-0.4.4.dist-info/RECORD` & `aac-0.4.5.dist-info/RECORD`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,14 @@
-aac/__init__.py,sha256=66NMSYQXSPkhG_dxd2Rdjwy4Ukgt3BnKY1Bv34-RH0A,681
+aac/__init__.py,sha256=VTBuOPEbzllrbBTyG9tkAuiZ1j3lzlrgTnc91GdmLy8,681
 aac/__main__.py,sha256=y4F8Ij8KtQ2ngIu2RhbNY50Scc58waKLhKUu4irkoVc,184
 aac/aac.aac,sha256=hW3mC_wcEOJNJNGgvgkVXU3Z8QZXAGfGG-iAQQ4sAhM,39404
 aac/context/__init__.py,sha256=KzlQOyArJrbh9jsb0BxEvT4DH6KGu-HLkXz0qvAhEGQ,93
 aac/context/constants.py,sha256=yZNSkbpfvEPPvMXHLt3xF8BuGN990FpP6SyRsM399L4,3340
 aac/context/definition.py,sha256=slApbPJFdBRUb91g0vbYv4Mq93NAFJ2Ub9ggMNVmoJk,3555
-aac/context/definition_parser.py,sha256=ulSUVlnGdvpWf5tDUzP8h3peyYW9K9NrRik3jhoOrhI,36891
+aac/context/definition_parser.py,sha256=BuHstQThj81W1GufJkj09GLDjp9B7Y2Gq5Ky5GylgYA,37371
 aac/context/language_context.py,sha256=yWOQAEuthzZ1lUsQ7giYy6JxO8mfZqL6pV4XVBUQqaE,11942
 aac/context/language_error.py,sha256=mvwlIp4T3qqjxxhz9POZOVvm0xB-OgaS6BBaA36XTYo,416
 aac/context/lexeme.py,sha256=RPzYXOyNSb83bUNFnagayzrU5jUqfdxYzlTBF8SRPwU,1179
 aac/context/source_location.py,sha256=fZj9jj9rp7iFj7J5B_6CMCYlvReyxL1bpOuWNJsYMtQ,1193
 aac/context/util.py,sha256=qkzFKNk8L2yj7gJvZq6IBfSof5Hj01Ir9ES1aq3h778,2025
 aac/execute/__init__.py,sha256=l7xXXpX4FOMESojBmvsPxNv95g4vZxl93CIgslo3h5I,613
 aac/execute/aac_execution_result.py,sha256=O7bU3Ot3bpfK5XXOd6djSFKhiphtVnaXoK60z5R8PFw,4123
@@ -73,12 +73,12 @@
 aac/plugins/root_schema_must_have_name/root_schema_must_have_name_impl.py,sha256=ecrzKVXFriH-pe7eq-hOnqrB3w4m-NvUpBk_r1otmrE,2751
 aac/plugins/unique_root_keys/__init__.py,sha256=lMp9qz4unAg_pj8A5Su7WycX8QWy5QqiIsXCq9pyZN0,1872
 aac/plugins/unique_root_keys/unique_root_keys.aac,sha256=rFo9iXlXiqC-i5cHhFFOiOYx813umZw568Z7bhz0b24,357
 aac/plugins/unique_root_keys/unique_root_keys_impl.py,sha256=BALEPQkTaWEQCV6ay1sN195tbO9year3znfMKlskhfg,1457
 aac/plugins/version/__init__.py,sha256=w-hFRq-1A3Ka1l_kziZ6Xr1SyXF8aC5Oo-Ud8SmjR24,1773
 aac/plugins/version/version.aac,sha256=_KsTx9u4KmwhorKgw7NkQoEr-9HnqZ40xKqqnZIom0E,226
 aac/plugins/version/version_impl.py,sha256=lFeo8cuDT6r8qVBuAHsEjE9nMDDhmW4_C2W-YI0zMzc,875
-aac-0.4.4.dist-info/METADATA,sha256=Y_1vdtHwx0edHfH22hVtCobwYKxAPmS3BAA_Uq653Ys,13241
-aac-0.4.4.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-aac-0.4.4.dist-info/entry_points.txt,sha256=VlLg669v9njSJeVU9sRCXBWO7zp4pE_GkcH1Qm2RbeA,53
-aac-0.4.4.dist-info/top_level.txt,sha256=xOCuEGfR7nNuBR15J9eDu3CwMr8Rb2GEVL9HEilW1c4,4
-aac-0.4.4.dist-info/RECORD,,
+aac-0.4.5.dist-info/METADATA,sha256=8VZISiLpCdxTH-4MDF_gqE-S5OWSIlbTh1RbKapyMfA,13241
+aac-0.4.5.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
+aac-0.4.5.dist-info/entry_points.txt,sha256=VlLg669v9njSJeVU9sRCXBWO7zp4pE_GkcH1Qm2RbeA,53
+aac-0.4.5.dist-info/top_level.txt,sha256=xOCuEGfR7nNuBR15J9eDu3CwMr8Rb2GEVL9HEilW1c4,4
+aac-0.4.5.dist-info/RECORD,,
```

