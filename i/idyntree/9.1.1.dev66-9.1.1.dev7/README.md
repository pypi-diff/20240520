# Comparing `tmp/idyntree-9.1.1.dev66.tar.gz` & `tmp/idyntree-9.1.1.dev7.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "idyntree-9.1.1.dev66.tar", last modified: Mon Oct 16 15:30:08 2023, max compression
+gzip compressed data, was "idyntree-9.1.1.dev7.tar", last modified: Fri Sep  1 07:53:04 2023, max compression
```

## Comparing `idyntree-9.1.1.dev66.tar` & `idyntree-9.1.1.dev7.tar`

### file list

```diff
@@ -1,1286 +1,1195 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.322977 idyntree-9.1.1.dev66/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.070976 idyntree-9.1.1.dev66/.github/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.094976 idyntree-9.1.1.dev66/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (127)    11900 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/.github/workflows/ci.yml
--rw-r--r--   0 runner    (1001) docker     (127)     2076 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/.github/workflows/gh-pages.yml
--rw-r--r--   0 runner    (1001) docker     (127)     4557 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/.github/workflows/matlab.yml
--rw-r--r--   0 runner    (1001) docker     (127)     3508 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/.github/workflows/python.yml
--rw-r--r--   0 runner    (1001) docker     (127)     3010 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/.github/workflows/regenerate-matlab-bindings.yml
--rw-r--r--   0 runner    (1001) docker     (127)       65 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/.gitignore
--rw-r--r--   0 runner    (1001) docker     (127)    46728 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/CHANGELOG.md
--rw-r--r--   0 runner    (1001) docker     (127)     3468 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     2636 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/CONTRIBUTING.md
--rw-r--r--   0 runner    (1001) docker     (127)     1529 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/LICENSE
--rw-r--r--   0 runner    (1001) docker     (127)    14341 2023-10-16 15:30:08.322977 idyntree-9.1.1.dev66/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)    12875 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/README.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.098976 idyntree-9.1.1.dev66/bindings/
--rw-r--r--   0 runner    (1001) docker     (127)     7748 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)    10084 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/iDynTree.i
--rw-r--r--   0 runner    (1001) docker     (127)     2615 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/ignore.i
--rw-r--r--   0 runner    (1001) docker     (127)     1370 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/joints.i
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.098976 idyntree-9.1.1.dev66/bindings/lua/
--rw-r--r--   0 runner    (1001) docker     (127)      649 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/lua/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.098976 idyntree-9.1.1.dev66/bindings/matlab/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.106976 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/
--rw-r--r--   0 runner    (1001) docker     (127)     4082 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/README.md
--rw-r--r--   0 runner    (1001) docker     (127)     1452 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/generalizedBiasForces.m
--rw-r--r--   0 runner    (1001) docker     (127)     1493 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/generalizedGravityForces.m
--rw-r--r--   0 runner    (1001) docker     (127)      942 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getBaseTwist.m
--rw-r--r--   0 runner    (1001) docker     (127)     1239 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getCenterOfMassJacobian.m
--rw-r--r--   0 runner    (1001) docker     (127)      954 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getCenterOfMassPosition.m
--rw-r--r--   0 runner    (1001) docker     (127)      956 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getCenterOfMassVelocity.m
--rw-r--r--   0 runner    (1001) docker     (127)     1231 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getCentroidalTotalMomentum.m
--rw-r--r--   0 runner    (1001) docker     (127)      912 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFloatingBase.m
--rw-r--r--   0 runner    (1001) docker     (127)     1153 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameBiasAcc.m
--rw-r--r--   0 runner    (1001) docker     (127)     1527 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameFreeFloatingJacobian.m
--rw-r--r--   0 runner    (1001) docker     (127)      954 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameIndex.m
--rw-r--r--   0 runner    (1001) docker     (127)      947 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameName.m
--rw-r--r--   0 runner    (1001) docker     (127)     1704 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameVelocityRepresentation.m
--rw-r--r--   0 runner    (1001) docker     (127)     1947 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFreeFloatingMassMatrix.m
--rw-r--r--   0 runner    (1001) docker     (127)     1228 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getJointPos.m
--rw-r--r--   0 runner    (1001) docker     (127)     1220 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getJointVel.m
--rw-r--r--   0 runner    (1001) docker     (127)     5393 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getMeshes.m
--rw-r--r--   0 runner    (1001) docker     (127)     1276 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getModelVel.m
--rw-r--r--   0 runner    (1001) docker     (127)     1203 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getNrOfDegreesOfFreedom.m
--rw-r--r--   0 runner    (1001) docker     (127)     1747 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getRelativeJacobian.m
--rw-r--r--   0 runner    (1001) docker     (127)     3914 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getRelativeTransform.m
--rw-r--r--   0 runner    (1001) docker     (127)     3231 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getRobotState.m
--rw-r--r--   0 runner    (1001) docker     (127)     2643 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getWorldBaseTransform.m
--rw-r--r--   0 runner    (1001) docker     (127)     2493 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getWorldTransform.m
--rw-r--r--   0 runner    (1001) docker     (127)     2447 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getWorldTransformsAsHomogeneous.m
--rw-r--r--   0 runner    (1001) docker     (127)     1569 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/initializeVisualizer.m
--rw-r--r--   0 runner    (1001) docker     (127)     2817 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/loadReducedModel.m
--rw-r--r--   0 runner    (1001) docker     (127)     4772 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/modifyLinkVisual.m
--rw-r--r--   0 runner    (1001) docker     (127)     2635 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/modifyLinksVisualization.m
--rw-r--r--   0 runner    (1001) docker     (127)     1455 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/plotFrame.m
--rw-r--r--   0 runner    (1001) docker     (127)     3753 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/plotMeshInWorld.m
--rw-r--r--   0 runner    (1001) docker     (127)     8137 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/prepareVisualization.m
--rw-r--r--   0 runner    (1001) docker     (127)     1075 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/setFloatingBase.m
--rw-r--r--   0 runner    (1001) docker     (127)     1890 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/setFrameVelocityRepresentation.m
--rw-r--r--   0 runner    (1001) docker     (127)     1677 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/setJointPos.m
--rw-r--r--   0 runner    (1001) docker     (127)     8712 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/setRobotState.m
--rw-r--r--   0 runner    (1001) docker     (127)      937 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/updateFrame.m
--rw-r--r--   0 runner    (1001) docker     (127)     1187 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/updateVisualization.m
--rw-r--r--   0 runner    (1001) docker     (127)     4617 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/updateVisualizer.m
--rw-r--r--   0 runner    (1001) docker     (127)     2183 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/visualizerSetup.m
--rw-r--r--   0 runner    (1001) docker     (127)     7501 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.114976 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.158976 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)      151 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ACCELEROMETER.m
--rw-r--r--   0 runner    (1001) docker     (127)      159 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ACCELEROMETER_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)     2327 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AccelerometerSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)      119 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyAlgorithm.m
--rw-r--r--   0 runner    (1001) docker     (127)     3310 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyAlgorithmInternalBuffers.m
--rw-r--r--   0 runner    (1001) docker     (127)     2287 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyInertia.m
--rw-r--r--   0 runner    (1001) docker     (127)     1459 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeEstimatorState.m
--rw-r--r--   0 runner    (1001) docker     (127)     3167 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeMahonyFilter.m
--rw-r--r--   0 runner    (1001) docker     (127)     2029 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeMahonyFilterParameters.m
--rw-r--r--   0 runner    (1001) docker     (127)     3668 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeQuaternionEKF.m
--rw-r--r--   0 runner    (1001) docker     (127)     3498 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeQuaternionEKFParameters.m
--rw-r--r--   0 runner    (1001) docker     (127)     2738 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Axis.m
--rw-r--r--   0 runner    (1001) docker     (127)      158 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BERDY_FLOATING_BASE.m
--rw-r--r--   0 runner    (1001) docker     (127)      186 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES.m
--rw-r--r--   0 runner    (1001) docker     (127)      164 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BODY_FIXED_REPRESENTATION.m
--rw-r--r--   0 runner    (1001) docker     (127)     1659 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdyDynamicVariable.m
--rw-r--r--   0 runner    (1001) docker     (127)     3466 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdyDynamicVariables.m
--rw-r--r--   0 runner    (1001) docker     (127)     5032 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdyHelper.m
--rw-r--r--   0 runner    (1001) docker     (127)     3048 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdyOptions.m
--rw-r--r--   0 runner    (1001) docker     (127)     1641 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdySensor.m
--rw-r--r--   0 runner    (1001) docker     (127)     3448 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdySensors.m
--rw-r--r--   0 runner    (1001) docker     (127)     2714 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdySparseMAPSolver.m
--rw-r--r--   0 runner    (1001) docker     (127)     1440 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Box.m
--rw-r--r--   0 runner    (1001) docker     (127)     1091 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ClassicalAcc.m
--rw-r--r--   0 runner    (1001) docker     (127)     1644 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ColorViz.m
--rw-r--r--   0 runner    (1001) docker     (127)      149 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ColumnMajor.m
--rw-r--r--   0 runner    (1001) docker     (127)      122 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/CompositeRigidBodyAlgorithm.m
--rw-r--r--   0 runner    (1001) docker     (127)      126 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ComputeLinearAndAngularMomentum.m
--rw-r--r--   0 runner    (1001) docker     (127)      140 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ComputeLinearAndAngularMomentumDerivativeBias.m
--rw-r--r--   0 runner    (1001) docker     (127)     1014 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ContactWrench.m
--rw-r--r--   0 runner    (1001) docker     (127)     4113 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ConvexHullProjectionConstraint.m
--rw-r--r--   0 runner    (1001) docker     (127)      117 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/CreateModelFromDHChain.m
--rw-r--r--   0 runner    (1001) docker     (127)     1226 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Cylinder.m
--rw-r--r--   0 runner    (1001) docker     (127)     1995 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DHChain.m
--rw-r--r--   0 runner    (1001) docker     (127)     2167 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DHLink.m
--rw-r--r--   0 runner    (1001) docker     (127)      156 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DIRECTIONAL_LIGHT.m
--rw-r--r--   0 runner    (1001) docker     (127)     1017 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOFSpatialForceArray.m
--rw-r--r--   0 runner    (1001) docker     (127)     1019 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOFSpatialMotionArray.m
--rw-r--r--   0 runner    (1001) docker     (127)      155 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOF_ACCELERATION.m
--rw-r--r--   0 runner    (1001) docker     (127)      162 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOF_ACCELERATION_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)      209 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOF_INVALID_INDEX.m
--rw-r--r--   0 runner    (1001) docker     (127)      208 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOF_INVALID_NAME.m
--rw-r--r--   0 runner    (1001) docker     (127)      149 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOF_TORQUE.m
--rw-r--r--   0 runner    (1001) docker     (127)      156 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOF_TORQUE_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)     1459 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Direction.m
--rw-r--r--   0 runner    (1001) docker     (127)     3144 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DiscreteExtendedKalmanFilterHelper.m
--rw-r--r--   0 runner    (1001) docker     (127)      608 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Dummy.m
--rw-r--r--   0 runner    (1001) docker     (127)     1247 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DynamicMatrixView.m
--rw-r--r--   0 runner    (1001) docker     (127)     3004 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DynamicSpan.m
--rw-r--r--   0 runner    (1001) docker     (127)     2691 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ExtWrenchesAndJointTorquesEstimator.m
--rw-r--r--   0 runner    (1001) docker     (127)     1650 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ExternalMesh.m
--rw-r--r--   0 runner    (1001) docker     (127)      118 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ExtractDHChainFromModel.m
--rw-r--r--   0 runner    (1001) docker     (127)      211 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FRAME_INVALID_INDEX.m
--rw-r--r--   0 runner    (1001) docker     (127)      210 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FRAME_INVALID_NAME.m
--rw-r--r--   0 runner    (1001) docker     (127)      150 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FULL_WRENCH.m
--rw-r--r--   0 runner    (1001) docker     (127)     5219 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FixedJoint.m
--rw-r--r--   0 runner    (1001) docker     (127)      115 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ForwardAccKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      119 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ForwardBiasAccKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      121 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ForwardPosVelAccKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      118 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ForwardPosVelKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      120 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ForwardPositionKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      118 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ForwardVelAccKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      889 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FrameFreeFloatingJacobian.m
--rw-r--r--   0 runner    (1001) docker     (127)     1134 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingAcc.m
--rw-r--r--   0 runner    (1001) docker     (127)     1171 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingGeneralizedTorques.m
--rw-r--r--   0 runner    (1001) docker     (127)      753 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingMassMatrix.m
--rw-r--r--   0 runner    (1001) docker     (127)     1144 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingPos.m
--rw-r--r--   0 runner    (1001) docker     (127)     1134 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingVel.m
--rw-r--r--   0 runner    (1001) docker     (127)      147 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/GYROSCOPE.m
--rw-r--r--   0 runner    (1001) docker     (127)      155 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/GYROSCOPE_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)     1702 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/GeomVector3.m
--rw-r--r--   0 runner    (1001) docker     (127)     2319 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/GyroscopeSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)     2009 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IAttitudeEstimator.m
--rw-r--r--   0 runner    (1001) docker     (127)     1316 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ICamera.m
--rw-r--r--   0 runner    (1001) docker     (127)     1485 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ICameraAnimator.m
--rw-r--r--   0 runner    (1001) docker     (127)     1738 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IEnvironment.m
--rw-r--r--   0 runner    (1001) docker     (127)     1353 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IFrameVisualization.m
--rw-r--r--   0 runner    (1001) docker     (127)     1495 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IJetsVisualization.m
--rw-r--r--   0 runner    (1001) docker     (127)     5964 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IJoint.m
--rw-r--r--   0 runner    (1001) docker     (127)     1681 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ILabel.m
--rw-r--r--   0 runner    (1001) docker     (127)     2240 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ILight.m
--rw-r--r--   0 runner    (1001) docker     (127)     2811 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IModelVisualization.m
--rw-r--r--   0 runner    (1001) docker     (127)      167 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/INERTIAL_FIXED_REPRESENTATION.m
--rw-r--r--   0 runner    (1001) docker     (127)     1573 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ITexture.m
--rw-r--r--   0 runner    (1001) docker     (127)      809 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ITexturesHandler.m
--rw-r--r--   0 runner    (1001) docker     (127)     1892 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IVectorsVisualization.m
--rw-r--r--   0 runner    (1001) docker     (127)     1377 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IndexRange.m
--rw-r--r--   0 runner    (1001) docker     (127)     3446 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IndexVector.m
--rw-r--r--   0 runner    (1001) docker     (127)     3417 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IntVector.m
--rw-r--r--   0 runner    (1001) docker     (127)      137 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseDynamicsInertialParametersRegressor.m
--rw-r--r--   0 runner    (1001) docker     (127)     8512 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      189 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsRotationParametrizationQuaternion.m
--rw-r--r--   0 runner    (1001) docker     (127)      191 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsRotationParametrizationRollPitchYaw.m
--rw-r--r--   0 runner    (1001) docker     (127)      183 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintFull.m
--rw-r--r--   0 runner    (1001) docker     (127)      183 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintNone.m
--rw-r--r--   0 runner    (1001) docker     (127)      191 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintPositionOnly.m
--rw-r--r--   0 runner    (1001) docker     (127)      191 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintRotationOnly.m
--rw-r--r--   0 runner    (1001) docker     (127)      211 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JOINT_INVALID_INDEX.m
--rw-r--r--   0 runner    (1001) docker     (127)      210 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JOINT_INVALID_NAME.m
--rw-r--r--   0 runner    (1001) docker     (127)      151 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JOINT_WRENCH.m
--rw-r--r--   0 runner    (1001) docker     (127)      158 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JOINT_WRENCH_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)      879 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JointDOFsDoubleArray.m
--rw-r--r--   0 runner    (1001) docker     (127)      877 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JointPosDoubleArray.m
--rw-r--r--   0 runner    (1001) docker     (127)     1196 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JointSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)     8171 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/KinDynComputations.m
--rw-r--r--   0 runner    (1001) docker     (127)      168 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LINK_BODY_PROPER_ACCELERATION.m
--rw-r--r--   0 runner    (1001) docker     (127)      178 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LINK_BODY_PROPER_CLASSICAL_ACCELERATION.m
--rw-r--r--   0 runner    (1001) docker     (127)      210 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LINK_INVALID_INDEX.m
--rw-r--r--   0 runner    (1001) docker     (127)      209 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LINK_INVALID_NAME.m
--rw-r--r--   0 runner    (1001) docker     (127)     1234 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Link.m
--rw-r--r--   0 runner    (1001) docker     (127)     1250 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkAccArray.m
--rw-r--r--   0 runner    (1001) docker     (127)     1026 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkArticulatedBodyInertias.m
--rw-r--r--   0 runner    (1001) docker     (127)     1565 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkContactWrenches.m
--rw-r--r--   0 runner    (1001) docker     (127)      996 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkInertias.m
--rw-r--r--   0 runner    (1001) docker     (127)     1252 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkPositions.m
--rw-r--r--   0 runner    (1001) docker     (127)     1470 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)     1864 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkUnknownWrenchContacts.m
--rw-r--r--   0 runner    (1001) docker     (127)     1250 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkVelArray.m
--rw-r--r--   0 runner    (1001) docker     (127)     1371 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkWrenches.m
--rw-r--r--   0 runner    (1001) docker     (127)     3493 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinksSolidShapesVector.m
--rw-r--r--   0 runner    (1001) docker     (127)      159 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MIXED_REPRESENTATION.m
--rw-r--r--   0 runner    (1001) docker     (127)     1494 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Material.m
--rw-r--r--   0 runner    (1001) docker     (127)     2382 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MatlabSwigIterator.m
--rw-r--r--   0 runner    (1001) docker     (127)     2243 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix10x16.m
--rw-r--r--   0 runner    (1001) docker     (127)     2239 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix1x6.m
--rw-r--r--   0 runner    (1001) docker     (127)     2239 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix2x3.m
--rw-r--r--   0 runner    (1001) docker     (127)     2239 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix3x3.m
--rw-r--r--   0 runner    (1001) docker     (127)     2239 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix4x4.m
--rw-r--r--   0 runner    (1001) docker     (127)     3605 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix4x4Vector.m
--rw-r--r--   0 runner    (1001) docker     (127)     2241 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix6x10.m
--rw-r--r--   0 runner    (1001) docker     (127)     2239 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix6x6.m
--rw-r--r--   0 runner    (1001) docker     (127)     2749 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MatrixDynSize.m
--rw-r--r--   0 runner    (1001) docker     (127)     3437 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MatrixDynSizeVector.m
--rw-r--r--   0 runner    (1001) docker     (127)     6324 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Model.m
--rw-r--r--   0 runner    (1001) docker     (127)     1597 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelCalibrationHelper.m
--rw-r--r--   0 runner    (1001) docker     (127)     1664 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelExporter.m
--rw-r--r--   0 runner    (1001) docker     (127)     1745 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelExporterOptions.m
--rw-r--r--   0 runner    (1001) docker     (127)     1967 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelLoader.m
--rw-r--r--   0 runner    (1001) docker     (127)     1197 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelParserOptions.m
--rw-r--r--   0 runner    (1001) docker     (127)     1145 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelSolidShapes.m
--rw-r--r--   0 runner    (1001) docker     (127)      895 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MomentumFreeFloatingJacobian.m
--rw-r--r--   0 runner    (1001) docker     (127)     1580 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl1.m
--rw-r--r--   0 runner    (1001) docker     (127)     1580 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl2.m
--rw-r--r--   0 runner    (1001) docker     (127)     1580 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl3.m
--rw-r--r--   0 runner    (1001) docker     (127)     1580 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl4.m
--rw-r--r--   0 runner    (1001) docker     (127)     1580 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl5.m
--rw-r--r--   0 runner    (1001) docker     (127)     1580 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl6.m
--rw-r--r--   0 runner    (1001) docker     (127)      153 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/NET_EXT_WRENCH.m
--rw-r--r--   0 runner    (1001) docker     (127)      160 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/NET_EXT_WRENCH_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)      184 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV.m
--rw-r--r--   0 runner    (1001) docker     (127)      150 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/NO_UNKNOWNS.m
--rw-r--r--   0 runner    (1001) docker     (127)       63 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/NR_OF_SENSOR_TYPES.m
--rw-r--r--   0 runner    (1001) docker     (127)     1153 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Neighbor.m
--rw-r--r--   0 runner    (1001) docker     (127)      153 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/NoJointDynamics.m
--rw-r--r--   0 runner    (1001) docker     (127)      164 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ORIGINAL_BERDY_FIXED_BASE.m
--rw-r--r--   0 runner    (1001) docker     (127)      150 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/POINT_LIGHT.m
--rw-r--r--   0 runner    (1001) docker     (127)      149 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/PURE_FORCE.m
--rw-r--r--   0 runner    (1001) docker     (127)      170 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/PURE_FORCE_WITH_KNOWN_DIRECTION.m
--rw-r--r--   0 runner    (1001) docker     (127)     1114 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/PixelViz.m
--rw-r--r--   0 runner    (1001) docker     (127)     1654 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Polygon.m
--rw-r--r--   0 runner    (1001) docker     (127)     1398 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Polygon2D.m
--rw-r--r--   0 runner    (1001) docker     (127)     2185 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Position.m
--rw-r--r--   0 runner    (1001) docker     (127)     4487 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/PrismaticJoint.m
--rw-r--r--   0 runner    (1001) docker     (127)      149 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RCM_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)      111 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RNEADynamicPhase.m
--rw-r--r--   0 runner    (1001) docker     (127)     4458 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RevoluteJoint.m
--rw-r--r--   0 runner    (1001) docker     (127)     2867 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RigidBodyInertiaNonLinearParametrization.m
--rw-r--r--   0 runner    (1001) docker     (127)     4624 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Rotation.m
--rw-r--r--   0 runner    (1001) docker     (127)      718 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RotationalInertia.m
--rw-r--r--   0 runner    (1001) docker     (127)      146 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RowMajor.m
--rw-r--r--   0 runner    (1001) docker     (127)      159 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SIX_AXIS_FORCE_TORQUE.m
--rw-r--r--   0 runner    (1001) docker     (127)      167 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SIX_AXIS_FORCE_TORQUE_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)     1437 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Sensor.m
--rw-r--r--   0 runner    (1001) docker     (127)     2688 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SensorsList.m
--rw-r--r--   0 runner    (1001) docker     (127)     1565 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SensorsMeasurements.m
--rw-r--r--   0 runner    (1001) docker     (127)     1695 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SimpleLeggedOdometry.m
--rw-r--r--   0 runner    (1001) docker     (127)     4284 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SixAxisForceTorqueSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)     2736 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SolidShape.m
--rw-r--r--   0 runner    (1001) docker     (127)     3483 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SolidShapesVector.m
--rw-r--r--   0 runner    (1001) docker     (127)     2664 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SparseMatrixColMajor.m
--rw-r--r--   0 runner    (1001) docker     (127)     2664 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SparseMatrixRowMajor.m
--rw-r--r--   0 runner    (1001) docker     (127)      981 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialAcc.m
--rw-r--r--   0 runner    (1001) docker     (127)      760 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialForceVector.m
--rw-r--r--   0 runner    (1001) docker     (127)     3480 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialForceVectorBase.m
--rw-r--r--   0 runner    (1001) docker     (127)     3480 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialInertia.m
--rw-r--r--   0 runner    (1001) docker     (127)      989 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialMomentum.m
--rw-r--r--   0 runner    (1001) docker     (127)     1286 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialMotionVector.m
--rw-r--r--   0 runner    (1001) docker     (127)     3482 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialMotionVectorBase.m
--rw-r--r--   0 runner    (1001) docker     (127)      968 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Sphere.m
--rw-r--r--   0 runner    (1001) docker     (127)     3423 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/StringVector.m
--rw-r--r--   0 runner    (1001) docker     (127)     1580 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SubModelDecomposition.m
--rw-r--r--   0 runner    (1001) docker     (127)      170 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_ANGULAR_ACCELEROMETER.m
--rw-r--r--   0 runner    (1001) docker     (127)      178 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)      169 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_FORCE_TORQUE_CONTACT.m
--rw-r--r--   0 runner    (1001) docker     (127)      177 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR.m
--rw-r--r--   0 runner    (1001) docker     (127)      215 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/TRAVERSAL_INVALID_INDEX.m
--rw-r--r--   0 runner    (1001) docker     (127)     2359 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ThreeAxisAngularAccelerometerSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)     2829 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ThreeAxisForceTorqueContactSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)     2638 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Transform.m
--rw-r--r--   0 runner    (1001) docker     (127)     2127 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/TransformDerivative.m
--rw-r--r--   0 runner    (1001) docker     (127)      110 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/TransformFromDH.m
--rw-r--r--   0 runner    (1001) docker     (127)      119 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/TransformFromDHCraig1989.m
--rw-r--r--   0 runner    (1001) docker     (127)     2656 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Traversal.m
--rw-r--r--   0 runner    (1001) docker     (127)     1094 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Twist.m
--rw-r--r--   0 runner    (1001) docker     (127)      155 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/URDFJointDynamics.m
--rw-r--r--   0 runner    (1001) docker     (127)     1977 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/UnknownWrenchContact.m
--rw-r--r--   0 runner    (1001) docker     (127)     2581 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector10.m
--rw-r--r--   0 runner    (1001) docker     (127)     2581 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector16.m
--rw-r--r--   0 runner    (1001) docker     (127)     2579 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector3.m
--rw-r--r--   0 runner    (1001) docker     (127)     2579 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector4.m
--rw-r--r--   0 runner    (1001) docker     (127)     2579 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector6.m
--rw-r--r--   0 runner    (1001) docker     (127)     3093 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/VectorDynSize.m
--rw-r--r--   0 runner    (1001) docker     (127)     3458 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/VectorDynSizeVector.m
--rw-r--r--   0 runner    (1001) docker     (127)     3425 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Visualizer.m
--rw-r--r--   0 runner    (1001) docker     (127)     1706 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/VisualizerOptions.m
--rw-r--r--   0 runner    (1001) docker     (127)      971 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Wrench.m
--rw-r--r--   0 runner    (1001) docker     (127)      126 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/addRandomAdditionalFrameToModel.m
--rw-r--r--   0 runner    (1001) docker     (127)      115 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/addRandomLinkToModel.m
--rw-r--r--   0 runner    (1001) docker     (127)      114 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/checkDoublesAreEqual.m
--rw-r--r--   0 runner    (1001) docker     (127)      122 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/computeBoundingBoxFromShape.m
--rw-r--r--   0 runner    (1001) docker     (127)      113 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/computeBoxVertices.m
--rw-r--r--   0 runner    (1001) docker     (127)      131 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/computeLinkNetWrenchesWithoutGravity.m
--rw-r--r--   0 runner    (1001) docker     (127)      125 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/computeTransformToSubModelBase.m
--rw-r--r--   0 runner    (1001) docker     (127)      126 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/computeTransformToTraversalBase.m
--rw-r--r--   0 runner    (1001) docker     (127)      134 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/createModelWithNormalizedJointNumbering.m
--rw-r--r--   0 runner    (1001) docker     (127)      113 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/createReducedModel.m
--rw-r--r--   0 runner    (1001) docker     (127)      111 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/dofsListFromURDF.m
--rw-r--r--   0 runner    (1001) docker     (127)      117 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/dofsListFromURDFString.m
--rw-r--r--   0 runner    (1001) docker     (127)       58 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/dynamic_extent.m
--rw-r--r--   0 runner    (1001) docker     (127)      136 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/dynamicsEstimationForwardVelAccKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      133 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/dynamicsEstimationForwardVelKinematics.m
--rw-r--r--   0 runner    (1001) docker     (127)      119 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/estimateExternalWrenches.m
--rw-r--r--   0 runner    (1001) docker     (127)     2500 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/estimateExternalWrenchesBuffers.m
--rw-r--r--   0 runner    (1001) docker     (127)      136 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/estimateExternalWrenchesWithoutInternalFT.m
--rw-r--r--   0 runner    (1001) docker     (127)      154 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/estimateInertialParametersFromLinkBoundingBoxesAndTotalMass.m
--rw-r--r--   0 runner    (1001) docker     (127)      149 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/estimateLinkContactWrenchesFromLinkNetExternalWrenches.m
--rw-r--r--   0 runner    (1001) docker     (127)      110 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/extractSubModel.m
--rw-r--r--   0 runner    (1001) docker     (127)      109 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/getRandomChain.m
--rw-r--r--   0 runner    (1001) docker     (127)      125 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/getRandomInverseDynamicsInputs.m
--rw-r--r--   0 runner    (1001) docker     (127)      118 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/getRandomJointPositions.m
--rw-r--r--   0 runner    (1001) docker     (127)      108 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/getRandomLink.m
--rw-r--r--   0 runner    (1001) docker     (127)      120 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/getRandomLinkIndexOfModel.m
--rw-r--r--   0 runner    (1001) docker     (127)      115 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/getRandomLinkOfModel.m
--rw-r--r--   0 runner    (1001) docker     (127)      109 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/getRandomModel.m
--rw-r--r--   0 runner    (1001) docker     (127)      112 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/getSensorTypeSize.m
--rw-r--r--   0 runner    (1001) docker     (127)       61 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/input_dimensions.m
--rw-r--r--   0 runner    (1001) docker     (127)      105 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/int2string.m
--rw-r--r--   0 runner    (1001) docker     (127)      120 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/isDOFBerdyDynamicVariable.m
--rw-r--r--   0 runner    (1001) docker     (127)      122 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/isJointBerdyDynamicVariable.m
--rw-r--r--   0 runner    (1001) docker     (127)      108 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/isJointSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)      121 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/isLinkBerdyDynamicVariable.m
--rw-r--r--   0 runner    (1001) docker     (127)      107 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/isLinkSensor.m
--rw-r--r--   0 runner    (1001) docker     (127)       80 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/output_dimensions_with_magnetometer.m
--rw-r--r--   0 runner    (1001) docker     (127)       83 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/output_dimensions_without_magnetometer.m
--rw-r--r--   0 runner    (1001) docker     (127)      121 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/predictSensorsMeasurements.m
--rw-r--r--   0 runner    (1001) docker     (127)      135 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/predictSensorsMeasurementsFromRawBuffers.m
--rw-r--r--   0 runner    (1001) docker     (127)      110 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/removeFakeLinks.m
--rw-r--r--   0 runner    (1001) docker     (127)      105 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/reportDebug.m
--rw-r--r--   0 runner    (1001) docker     (127)      104 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/reportInfo.m
--rw-r--r--   0 runner    (1001) docker     (127)      124 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/sizeOfRotationParametrization.m
--rw-r--r--   0 runner    (1001) docker     (127)  5052045 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/iDynTreeMATLAB_wrap.cxx
--rw-r--r--   0 runner    (1001) docker     (127)       53 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/iDynTreeSwigGet.m
--rw-r--r--   0 runner    (1001) docker     (127)      353 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/iDynTreeSwigMem.m
--rw-r--r--   0 runner    (1001) docker     (127)     1908 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/autogenerated/iDynTreeSwigRef.m
--rwxr-xr-x   0 runner    (1001) docker     (127)     1334 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/fix_generic_names_in_autogenerated_files.sh
--rw-r--r--   0 runner    (1001) docker     (127)       41 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/iDynTreesetup.m
--rw-r--r--   0 runner    (1001) docker     (127)       66 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/matlab.i
--rw-r--r--   0 runner    (1001) docker     (127)     1147 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/matlab_mat4x4vec.i
--rw-r--r--   0 runner    (1001) docker     (127)    14801 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/matlab_matvec.i
--rw-r--r--   0 runner    (1001) docker     (127)      984 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/matlab_spatialvec.i
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.158976 idyntree-9.1.1.dev66/bindings/matlab/tests/
--rw-r--r--   0 runner    (1001) docker     (127)     1616 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     1127 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/EKFTest.m
--rw-r--r--   0 runner    (1001) docker     (127)     2427 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/InertiaUnitTest.m
--rw-r--r--   0 runner    (1001) docker     (127)      356 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/JointUnitTest.m
--rw-r--r--   0 runner    (1001) docker     (127)      492 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/MatrixUnitTest.m
--rw-r--r--   0 runner    (1001) docker     (127)      725 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/PositionUnitTest.m
--rw-r--r--   0 runner    (1001) docker     (127)     2364 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/TransformUnitTest.m
--rw-r--r--   0 runner    (1001) docker     (127)     5828 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/highLevelWrappersSmokeTest.m
--rw-r--r--   0 runner    (1001) docker     (127)      383 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/iDynTreeAssertEqual.m
--rw-r--r--   0 runner    (1001) docker     (127)      136 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/iDynTreeLoad.m
--rw-r--r--   0 runner    (1001) docker     (127)    52742 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/matlab/tests/model.urdf
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.158976 idyntree-9.1.1.dev66/bindings/pybind11/
--rw-r--r--   0 runner    (1001) docker     (127)     1361 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)      306 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/error_utilities.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      356 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/error_utilities.h
--rw-r--r--   0 runner    (1001) docker     (127)      591 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    11686 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_core.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      306 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_core.h
--rw-r--r--   0 runner    (1001) docker     (127)     2860 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_high_level.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      330 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_high_level.h
--rw-r--r--   0 runner    (1001) docker     (127)    11266 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_model.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      311 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_model.h
--rw-r--r--   0 runner    (1001) docker     (127)     2673 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_modelio_urdf.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      338 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_modelio_urdf.h
--rw-r--r--   0 runner    (1001) docker     (127)     2495 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_sensors.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      318 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/idyntree_sensors.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.162976 idyntree-9.1.1.dev66/bindings/pybind11/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      178 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)    15919 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_core.py
--rw-r--r--   0 runner    (1001) docker     (127)     6871 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_high_level.py
--rw-r--r--   0 runner    (1001) docker     (127)    13719 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_model.py
--rw-r--r--   0 runner    (1001) docker     (127)     4634 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_modelio_urdf.py
--rw-r--r--   0 runner    (1001) docker     (127)     2595 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_sensors.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.162976 idyntree-9.1.1.dev66/bindings/python/
--rw-r--r--   0 runner    (1001) docker     (127)     1962 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)   109459 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/numpy.i
--rw-r--r--   0 runner    (1001) docker     (127)    12831 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/python.i
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.162976 idyntree-9.1.1.dev66/bindings/python/scripts/
--rw-r--r--   0 runner    (1001) docker     (127)      202 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/scripts/CMakeLists.txt
--rwxr-xr-x   0 runner    (1001) docker     (127)      849 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/scripts/idyntree-model-view-meshcat.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.162976 idyntree-9.1.1.dev66/bindings/python/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      701 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     5390 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/tests/ExtWrenchesAndJointTorquesEstimatorUnitTest.py
--rw-r--r--   0 runner    (1001) docker     (127)     3053 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/tests/dyncomp.py
--rw-r--r--   0 runner    (1001) docker     (127)     4834 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/tests/geometry.py
--rw-r--r--   0 runner    (1001) docker     (127)    10310 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/tests/helpers.py
--rw-r--r--   0 runner    (1001) docker     (127)      900 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/tests/joints.py
--rw-r--r--   0 runner    (1001) docker     (127)    52742 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/tests/model.urdf
--rw-r--r--   0 runner    (1001) docker     (127)      645 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/tests/modelloader.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.166976 idyntree-9.1.1.dev66/bindings/python/visualize/
--rw-r--r--   0 runner    (1001) docker     (127)       50 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/visualize/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    19465 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/python/visualize/meshcat_visualizer.py
--rw-r--r--   0 runner    (1001) docker     (127)     1743 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/bindings/sensors.i
--rw-r--r--   0 runner    (1001) docker     (127)      305 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/ci_env.yml
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.166976 idyntree-9.1.1.dev66/cmake/
--rw-r--r--   0 runner    (1001) docker     (127)     6871 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/AddInstallRPATHSupport.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     3781 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/AddUninstallTarget.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     5135 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/ECMEnableSanitizers.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     2958 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/ExtractVersion.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     9162 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/FindIPOPT.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     2197 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/FindIrrlicht.cmake
--rw-r--r--   0 runner    (1001) docker     (127)    65539 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/FindMatlab.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     6759 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/FindOctave.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     1613 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/FindTinyXML.cmake
--rw-r--r--   0 runner    (1001) docker     (127)      861 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/FindValgrind.cmake
--rw-r--r--   0 runner    (1001) docker     (127)      728 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/FindWORHP.cmake
--rw-r--r--   0 runner    (1001) docker     (127)    29066 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/InstallBasicPackageFiles.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     1438 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/OrocosKDLFindLogic.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     8535 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/StandardFindModule.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     5440 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/iDynTreeDependencies.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     5234 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/iDynTreeOptions.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     6032 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/cmake/valgrind-macos.supp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.170976 idyntree-9.1.1.dev66/doc/
--rw-r--r--   0 runner    (1001) docker     (127)     2164 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)    76913 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/Doxyfile.in
--rw-r--r--   0 runner    (1001) docker     (127)     7985 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/build-from-source.md
--rw-r--r--   0 runner    (1001) docker     (127)     3828 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/dcTutorialCpp.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.170976 idyntree-9.1.1.dev66/doc/dev/
--rw-r--r--   0 runner    (1001) docker     (127)     5950 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/dev/faqs.md
--rw-r--r--   0 runner    (1001) docker     (127)     5591 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/generating-idyntree-matlab-bindings.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.170976 idyntree-9.1.1.dev66/doc/images/
--rw-r--r--   0 runner    (1001) docker     (127)    49125 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/images/position.svg
--rw-r--r--   0 runner    (1001) docker     (127)    74554 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/images/transform.svg
--rw-r--r--   0 runner    (1001) docker     (127)     5220 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/main.dox
--rw-r--r--   0 runner    (1001) docker     (127)     6991 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/matlab_visualization.md
--rw-r--r--   0 runner    (1001) docker     (127)     4213 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/model_loading.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.170976 idyntree-9.1.1.dev66/doc/symbolic/
--rw-r--r--   0 runner    (1001) docker     (127)     1495 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/doc/symbolic/RPYExpressionReference.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.170976 idyntree-9.1.1.dev66/docs/
--rw-r--r--   0 runner    (1001) docker     (127)      358 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/docs/Doxyfile-mcss.in
--rw-r--r--   0 runner    (1001) docker     (127)   112872 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/docs/Doxyfile.in
--rw-r--r--   0 runner    (1001) docker     (127)     1193 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/docs/conf.py.in
--rw-r--r--   0 runner    (1001) docker     (127)       78 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/docs/config.toml
--rw-r--r--   0 runner    (1001) docker     (127)     4087 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/docs/generate_documentation_files.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2174 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/docs/generate_website.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.170976 idyntree-9.1.1.dev66/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      209 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.170976 idyntree-9.1.1.dev66/examples/cxx/
--rw-r--r--   0 runner    (1001) docker     (127)      270 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/cxx/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/examples/cxx/InverseKinematics/
--rw-r--r--   0 runner    (1001) docker     (127)     1278 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/cxx/InverseKinematics/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     1304 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/cxx/InverseKinematics/README.md
--rw-r--r--   0 runner    (1001) docker     (127)     8454 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/cxx/InverseKinematics/iDynTreeExampleInverseKinematics.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/examples/cxx/KinDynComputationsWithEigen/
--rw-r--r--   0 runner    (1001) docker     (127)      724 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/cxx/KinDynComputationsWithEigen/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     6966 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/cxx/KinDynComputationsWithEigen/main.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/examples/matlab/
--rw-r--r--   0 runner    (1001) docker     (127)     3936 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/matlab/GetJointAxesInWorldFrame.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/examples/matlab/SensorsListParsing/
--rw-r--r--   0 runner    (1001) docker     (127)     2137 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/matlab/SensorsListParsing/SensorsListParsing.m
--rw-r--r--   0 runner    (1001) docker     (127)    52742 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/matlab/SensorsListParsing/icub.urdf
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/examples/matlab/SixAxisFTOffsetEstimation/
--rw-r--r--   0 runner    (1001) docker     (127)     7368 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m
--rw-r--r--   0 runner    (1001) docker     (127)    66355 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/matlab/SixAxisFTOffsetEstimation/iCubGenova02.urdf
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/examples/matlab/iDynTreeWrappers/
--rw-r--r--   0 runner    (1001) docker     (127)     4723 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/matlab/iDynTreeWrappers/visualizeRobot.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/examples/models/
--rw-r--r--   0 runner    (1001) docker     (127)    66355 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/models/iCubGenova02.urdf
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/examples/python/
--rw-r--r--   0 runner    (1001) docker     (127)     1995 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/python/KinDynComputationsTutorial.py
--rw-r--r--   0 runner    (1001) docker     (127)     6784 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/examples/python/MeshcatVisualizerExample.ipynb
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/extern/
--rw-r--r--   0 runner    (1001) docker     (127)     1832 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/extern/MOxUnit/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.074976 idyntree-9.1.1.dev66/extern/MOxUnit/.github/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.174976 idyntree-9.1.1.dev66/extern/MOxUnit/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (127)     1373 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/.github/workflows/CI.yml
--rw-r--r--   0 runner    (1001) docker     (127)      133 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/.gitignore
--rw-r--r--   0 runner    (1001) docker     (127)     3016 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/.travis.yml
--rw-r--r--   0 runner    (1001) docker     (127)     1103 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/COPYING
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.178976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.178976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/
--rw-r--r--   0 runner    (1001) docker     (127)      662 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/MOxUnitErroredTestOutcome.m
--rw-r--r--   0 runner    (1001) docker     (127)      499 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/getOutcomeStr.m
--rw-r--r--   0 runner    (1001) docker     (127)      385 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/getSummaryContent.m
--rw-r--r--   0 runner    (1001) docker     (127)      337 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/isNonFailure.m
--rw-r--r--   0 runner    (1001) docker     (127)      332 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/isSuccess.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.178976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/
--rw-r--r--   0 runner    (1001) docker     (127)      657 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/MOxUnitFailedTestOutcome.m
--rw-r--r--   0 runner    (1001) docker     (127)      503 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/getOutcomeStr.m
--rw-r--r--   0 runner    (1001) docker     (127)      383 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/getSummaryContent.m
--rw-r--r--   0 runner    (1001) docker     (127)      334 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/isNonFailure.m
--rw-r--r--   0 runner    (1001) docker     (127)      329 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/isSuccess.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.178976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/
--rw-r--r--   0 runner    (1001) docker     (127)      801 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/MOxUnitFunctionHandleTestCase.m
--rw-r--r--   0 runner    (1001) docker     (127)      183 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/disp.m
--rw-r--r--   0 runner    (1001) docker     (127)     2698 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/run.m
--rw-r--r--   0 runner    (1001) docker     (127)      364 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/str.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.178976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/
--rw-r--r--   0 runner    (1001) docker     (127)      858 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/MOxUnitMatlabUnitWrapperTestCase.m
--rw-r--r--   0 runner    (1001) docker     (127)     1965 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/run.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.182976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/
--rw-r--r--   0 runner    (1001) docker     (127)      630 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/MOxUnitPassedTestOutcome.m
--rw-r--r--   0 runner    (1001) docker     (127)      501 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/getOutcomeStr.m
--rw-r--r--   0 runner    (1001) docker     (127)      296 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/getSummaryContent.m
--rw-r--r--   0 runner    (1001) docker     (127)      335 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/isNonFailure.m
--rw-r--r--   0 runner    (1001) docker     (127)      328 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/isSuccess.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.182976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/
--rw-r--r--   0 runner    (1001) docker     (127)      648 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/MOxUnitSkippedTestOutcome.m
--rw-r--r--   0 runner    (1001) docker     (127)      503 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/getOutcomeStr.m
--rw-r--r--   0 runner    (1001) docker     (127)      351 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/getSummaryContent.m
--rw-r--r--   0 runner    (1001) docker     (127)      336 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/isNonFailure.m
--rw-r--r--   0 runner    (1001) docker     (127)      330 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/isSuccess.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.182976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/
--rw-r--r--   0 runner    (1001) docker     (127)      534 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/MOxUnitTestCase.m
--rw-r--r--   0 runner    (1001) docker     (127)       40 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/countTestCases.m
--rw-r--r--   0 runner    (1001) docker     (127)      183 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/disp.m
--rw-r--r--   0 runner    (1001) docker     (127)      216 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/getLocation.m
--rw-r--r--   0 runner    (1001) docker     (127)      135 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/run.m
--rw-r--r--   0 runner    (1001) docker     (127)      289 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/str.m
--rw-r--r--   0 runner    (1001) docker     (127)      642 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/subsref.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.182976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/
--rw-r--r--   0 runner    (1001) docker     (127)      492 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/MOxUnitTestNode.m
--rw-r--r--   0 runner    (1001) docker     (127)      190 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/disp.m
--rw-r--r--   0 runner    (1001) docker     (127)      202 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/getName.m
--rw-r--r--   0 runner    (1001) docker     (127)      284 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/str.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.182976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/
--rw-r--r--   0 runner    (1001) docker     (127)      147 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/MOxUnitTestOutcome.m
--rw-r--r--   0 runner    (1001) docker     (127)      268 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getDuration.m
--rw-r--r--   0 runner    (1001) docker     (127)      719 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getProgressStr.m
--rw-r--r--   0 runner    (1001) docker     (127)     2408 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getSummaryStr.m
--rw-r--r--   0 runner    (1001) docker     (127)      112 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getTest.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.186977 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/
--rw-r--r--   0 runner    (1001) docker     (127)     1021 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/MOxUnitTestReport.m
--rw-r--r--   0 runner    (1001) docker     (127)      413 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/addTestOutcome.m
--rw-r--r--   0 runner    (1001) docker     (127)      500 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/countTestOutcomes.m
--rw-r--r--   0 runner    (1001) docker     (127)      361 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/disp.m
--rw-r--r--   0 runner    (1001) docker     (127)      498 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getDuration.m
--rw-r--r--   0 runner    (1001) docker     (127)       45 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getName.m
--rw-r--r--   0 runner    (1001) docker     (127)     1226 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getStatisticsStr.m
--rw-r--r--   0 runner    (1001) docker     (127)      316 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getStream.m
--rw-r--r--   0 runner    (1001) docker     (127)     3808 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getSummaryStr.m
--rw-r--r--   0 runner    (1001) docker     (127)       83 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getTestOutcome.m
--rw-r--r--   0 runner    (1001) docker     (127)      974 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getTestOutputStatistics.m
--rw-r--r--   0 runner    (1001) docker     (127)      334 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getVerbosity.m
--rw-r--r--   0 runner    (1001) docker     (127)     1039 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/reportTestOutcome.m
--rw-r--r--   0 runner    (1001) docker     (127)      579 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/wasSuccessful.m
--rw-r--r--   0 runner    (1001) docker     (127)      602 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/writeXML.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.186977 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/
--rw-r--r--   0 runner    (1001) docker     (127)      535 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/MOxUnitTestSuite.m
--rw-r--r--   0 runner    (1001) docker     (127)     1207 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromDirectory.m
--rw-r--r--   0 runner    (1001) docker     (127)     1276 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromFile.m
--rw-r--r--   0 runner    (1001) docker     (127)      569 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromSuite.m
--rw-r--r--   0 runner    (1001) docker     (127)      908 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addTest.m
--rw-r--r--   0 runner    (1001) docker     (127)      334 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/countTestCases.m
--rw-r--r--   0 runner    (1001) docker     (127)      244 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/countTestNodes.m
--rw-r--r--   0 runner    (1001) docker     (127)      156 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/disp.m
--rw-r--r--   0 runner    (1001) docker     (127)      383 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/getTestNode.m
--rw-r--r--   0 runner    (1001) docker     (127)     2386 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/run.m
--rw-r--r--   0 runner    (1001) docker     (127)      836 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/setTestNode.m
--rw-r--r--   0 runner    (1001) docker     (127)      329 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/str.m
--rw-r--r--   0 runner    (1001) docker     (127)     2420 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertElementsAlmostEqual.m
--rw-r--r--   0 runner    (1001) docker     (127)     2516 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertEqual.m
--rw-r--r--   0 runner    (1001) docker     (127)       70 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertError.m
--rw-r--r--   0 runner    (1001) docker     (127)     6104 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertExceptionThrown.m
--rw-r--r--   0 runner    (1001) docker     (127)     1538 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertFalse.m
--rw-r--r--   0 runner    (1001) docker     (127)     1834 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertGreaterThan.m
--rw-r--r--   0 runner    (1001) docker     (127)     1782 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertLessThan.m
--rw-r--r--   0 runner    (1001) docker     (127)     1983 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertNotEqual.m
--rw-r--r--   0 runner    (1001) docker     (127)     1530 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertTrue.m
--rw-r--r--   0 runner    (1001) docker     (127)     2927 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertVectorsAlmostEqual.m
--rw-r--r--   0 runner    (1001) docker     (127)     6911 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertWarning.m
--rw-r--r--   0 runner    (1001) docker     (127)     5854 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/initTestSuite.m
--rw-r--r--   0 runner    (1001) docker     (127)    13051 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/moxunit_runtests.m
--rw-r--r--   0 runner    (1001) docker     (127)     1561 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/moxunit_set_path.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.190976 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/
--rw-r--r--   0 runner    (1001) docker     (127)     1093 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_isa_test_skipped_exception.m
--rw-r--r--   0 runner    (1001) docker     (127)      671 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_throw_test_skipped_exception.m
--rw-r--r--   0 runner    (1001) docker     (127)     5006 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_elem2str.m
--rw-r--r--   0 runner    (1001) docker     (127)      995 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_escape_xml.m
--rw-r--r--   0 runner    (1001) docker     (127)     1958 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_find_files.m
--rw-r--r--   0 runner    (1001) docker     (127)     6081 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_floats_almost_equal.m
--rw-r--r--   0 runner    (1001) docker     (127)      384 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_get_test_name_regexp.m
--rw-r--r--   0 runner    (1001) docker     (127)     1454 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_input2str.m
--rw-r--r--   0 runner    (1001) docker     (127)     1623 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_is_message_identifier.m
--rw-r--r--   0 runner    (1001) docker     (127)      484 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_is_test_function_name.m
--rw-r--r--   0 runner    (1001) docker     (127)      978 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_isfolder.m
--rw-r--r--   0 runner    (1001) docker     (127)     3250 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_mfile_subfunctions.m
--rw-r--r--   0 runner    (1001) docker     (127)      502 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_is_octave.m
--rw-r--r--   0 runner    (1001) docker     (127)     1585 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_supports.m
--rw-r--r--   0 runner    (1001) docker     (127)      526 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_version.m
--rw-r--r--   0 runner    (1001) docker     (127)      629 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_regexp_matches.m
--rw-r--r--   0 runner    (1001) docker     (127)     2137 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_remove_matlab_anchor_tag.m
--rw-r--r--   0 runner    (1001) docker     (127)     1197 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_stack2str.m
--rw-r--r--   0 runner    (1001) docker     (127)     2555 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_strjoin.m
--rw-r--r--   0 runner    (1001) docker     (127)     5023 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/Makefile
--rw-r--r--   0 runner    (1001) docker     (127)    13738 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/README.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.198976 idyntree-9.1.1.dev66/extern/MOxUnit/tests/
--rw-r--r--   0 runner    (1001) docker     (127)     2848 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_elements_almost_equal.m
--rw-r--r--   0 runner    (1001) docker     (127)     1064 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_equal.m
--rw-r--r--   0 runner    (1001) docker     (127)     5031 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_exception_thrown.m
--rw-r--r--   0 runner    (1001) docker     (127)      839 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_false.m
--rw-r--r--   0 runner    (1001) docker     (127)     1917 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_greater_than.m
--rw-r--r--   0 runner    (1001) docker     (127)     1809 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_less_than.m
--rw-r--r--   0 runner    (1001) docker     (127)      818 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_not_equal.m
--rw-r--r--   0 runner    (1001) docker     (127)      830 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_true.m
--rw-r--r--   0 runner    (1001) docker     (127)     3197 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_vectors_almost_equal.m
--rw-r--r--   0 runner    (1001) docker     (127)     4782 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_warning.m
--rw-r--r--   0 runner    (1001) docker     (127)     2397 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_function_handle_test_case.m
--rw-r--r--   0 runner    (1001) docker     (127)     3337 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_matlab_unittest_test_wrapper_suite.m
--rw-r--r--   0 runner    (1001) docker     (127)      730 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_isa_test_skipped_exception.m
--rw-r--r--   0 runner    (1001) docker     (127)     9856 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_runtests.m
--rw-r--r--   0 runner    (1001) docker     (127)     1295 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_set_path.m
--rw-r--r--   0 runner    (1001) docker     (127)     5085 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_elem2str.m
--rw-r--r--   0 runner    (1001) docker     (127)      702 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_escape_xml.m
--rw-r--r--   0 runner    (1001) docker     (127)     3613 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_find_files.m
--rw-r--r--   0 runner    (1001) docker     (127)      987 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_get_test_name_regexp.m
--rw-r--r--   0 runner    (1001) docker     (127)      828 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_input2str.m
--rw-r--r--   0 runner    (1001) docker     (127)     2402 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_is_message_identifier.m
--rw-r--r--   0 runner    (1001) docker     (127)      714 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_isfolder.m
--rw-r--r--   0 runner    (1001) docker     (127)     6454 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_mfile_subfunctions.m
--rw-r--r--   0 runner    (1001) docker     (127)     1434 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_platform_supports.m
--rw-r--r--   0 runner    (1001) docker     (127)      850 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_platform_version.m
--rw-r--r--   0 runner    (1001) docker     (127)     1999 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_regexp_matches.m
--rw-r--r--   0 runner    (1001) docker     (127)     1655 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_remove_matlab_anchor_tag.m
--rw-r--r--   0 runner    (1001) docker     (127)     2613 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_stack2str.m
--rw-r--r--   0 runner    (1001) docker     (127)     1071 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_strjoin.m
--rw-r--r--   0 runner    (1001) docker     (127)      691 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_case.m
--rw-r--r--   0 runner    (1001) docker     (127)      472 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_node.m
--rw-r--r--   0 runner    (1001) docker     (127)     3556 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_outcome.m
--rw-r--r--   0 runner    (1001) docker     (127)     8285 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_report.m
--rw-r--r--   0 runner    (1001) docker     (127)     4394 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_suite.m
--rw-r--r--   0 runner    (1001) docker     (127)      973 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_testcase_class.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.198976 idyntree-9.1.1.dev66/extern/MOxUnit/tools/
--rw-r--r--   0 runner    (1001) docker     (127)     7233 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tools/fix_mfile_test_init.py
--rw-r--r--   0 runner    (1001) docker     (127)     5432 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/MOxUnit/tools/matlab_tokenizer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.198976 idyntree-9.1.1.dev66/extern/fpconv/
--rw-r--r--   0 runner    (1001) docker     (127)     8263 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/fpconv/fpconv.c
--rw-r--r--   0 runner    (1001) docker     (127)     2002 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/fpconv/fpconv.h
--rw-r--r--   0 runner    (1001) docker     (127)     4980 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/fpconv/powers.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.198976 idyntree-9.1.1.dev66/extern/mesh2tri/
--rw-r--r--   0 runner    (1001) docker     (127)     1313 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/mesh2tri/license.txt
--rw-r--r--   0 runner    (1001) docker     (127)     3736 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/extern/mesh2tri/mesh2tri.m
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.198976 idyntree-9.1.1.dev66/idyntree.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)    14341 2023-10-16 15:30:07.000000 idyntree-9.1.1.dev66/idyntree.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)    56723 2023-10-16 15:30:08.000000 idyntree-9.1.1.dev66/idyntree.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2023-10-16 15:30:07.000000 idyntree-9.1.1.dev66/idyntree.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)       67 2023-10-16 15:30:07.000000 idyntree-9.1.1.dev66/idyntree.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2023-10-16 15:30:07.000000 idyntree-9.1.1.dev66/idyntree.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (127)        6 2023-10-16 15:30:07.000000 idyntree-9.1.1.dev66/idyntree.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)       16 2023-10-16 15:30:07.000000 idyntree-9.1.1.dev66/idyntree.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (127)      281 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (127)     1456 2023-10-16 15:30:08.322977 idyntree-9.1.1.dev66/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (127)     1293 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.202977 idyntree-9.1.1.dev66/src/
--rw-r--r--   0 runner    (1001) docker     (127)      874 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.202977 idyntree-9.1.1.dev66/src/core/
--rw-r--r--   0 runner    (1001) docker     (127)     7538 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.082976 idyntree-9.1.1.dev66/src/core/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.210976 idyntree-9.1.1.dev66/src/core/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)     4580 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/ArticulatedBodyInertia.h
--rw-r--r--   0 runner    (1001) docker     (127)     4374 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Axis.h
--rw-r--r--   0 runner    (1001) docker     (127)     2294 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/ClassicalAcc.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.218977 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/
--rw-r--r--   0 runner    (1001) docker     (127)      458 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/ArticulatedBodyInertia.h
--rw-r--r--   0 runner    (1001) docker     (127)      364 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Axis.h
--rw-r--r--   0 runner    (1001) docker     (127)      406 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/ClassicalAcc.h
--rw-r--r--   0 runner    (1001) docker     (127)      402 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/CubicSpline.h
--rw-r--r--   0 runner    (1001) docker     (127)      389 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Direction.h
--rw-r--r--   0 runner    (1001) docker     (127)      406 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/EigenHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)      428 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/EigenMathHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)      438 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/EigenSparseHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)      402 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/GeomVector3.h
--rw-r--r--   0 runner    (1001) docker     (127)      505 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/InertiaNonLinearParametrization.h
--rw-r--r--   0 runner    (1001) docker     (127)      413 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/MatrixDynSize.h
--rw-r--r--   0 runner    (1001) docker     (127)      414 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/MatrixFixSize.h
--rw-r--r--   0 runner    (1001) docker     (127)      396 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/MatrixView.h
--rw-r--r--   0 runner    (1001) docker     (127)      384 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Position.h
--rw-r--r--   0 runner    (1001) docker     (127)      395 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/PositionRaw.h
--rw-r--r--   0 runner    (1001) docker     (127)      467 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/PrivatePreProcessorUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)      406 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/PrivateUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)      384 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Rotation.h
--rw-r--r--   0 runner    (1001) docker     (127)      395 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/RotationRaw.h
--rw-r--r--   0 runner    (1001) docker     (127)      441 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/RotationalInertiaRaw.h
--rw-r--r--   0 runner    (1001) docker     (127)      385 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SO3Utils.h
--rw-r--r--   0 runner    (1001) docker     (127)      246 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Span.h
--rw-r--r--   0 runner    (1001) docker     (127)      406 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SparseMatrix.h
--rw-r--r--   0 runner    (1001) docker     (127)      396 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SpatialAcc.h
--rw-r--r--   0 runner    (1001) docker     (127)      432 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SpatialForceVector.h
--rw-r--r--   0 runner    (1001) docker     (127)      416 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SpatialInertia.h
--rw-r--r--   0 runner    (1001) docker     (127)      428 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SpatialInertiaRaw.h
--rw-r--r--   0 runner    (1001) docker     (127)      419 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SpatialMomentum.h
--rw-r--r--   0 runner    (1001) docker     (127)      437 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SpatialMotionVector.h
--rw-r--r--   0 runner    (1001) docker     (127)      411 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/SpatialVector.h
--rw-r--r--   0 runner    (1001) docker     (127)      391 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/TestUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)      389 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Transform.h
--rw-r--r--   0 runner    (1001) docker     (127)      441 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/TransformDerivative.h
--rw-r--r--   0 runner    (1001) docker     (127)      384 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Triplets.h
--rw-r--r--   0 runner    (1001) docker     (127)      369 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Twist.h
--rw-r--r--   0 runner    (1001) docker     (127)      369 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Utils.h
--rw-r--r--   0 runner    (1001) docker     (127)      421 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/VectorDynSize.h
--rw-r--r--   0 runner    (1001) docker     (127)      413 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/VectorFixSize.h
--rw-r--r--   0 runner    (1001) docker     (127)      374 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Core/Wrench.h
--rw-r--r--   0 runner    (1001) docker     (127)     1275 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/CubicSpline.h
--rw-r--r--   0 runner    (1001) docker     (127)     2971 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Direction.h
--rw-r--r--   0 runner    (1001) docker     (127)    14809 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/EigenHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)     2504 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/EigenMathHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)     3504 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/EigenSparseHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)     1583 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/GeomVector3.h
--rw-r--r--   0 runner    (1001) docker     (127)     2309 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/InertiaNonLinearParametrization.h
--rw-r--r--   0 runner    (1001) docker     (127)     7405 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/MatrixDynSize.h
--rw-r--r--   0 runner    (1001) docker     (127)    11594 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/MatrixFixSize.h
--rw-r--r--   0 runner    (1001) docker     (127)    11352 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/MatrixView.h
--rw-r--r--   0 runner    (1001) docker     (127)     3591 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Position.h
--rw-r--r--   0 runner    (1001) docker     (127)      379 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/PositionRaw.h
--rw-r--r--   0 runner    (1001) docker     (127)      403 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/PrivatePreProcessorUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)     3667 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/PrivateUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)    20482 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Rotation.h
--rw-r--r--   0 runner    (1001) docker     (127)      379 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/RotationRaw.h
--rw-r--r--   0 runner    (1001) docker     (127)     1748 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/RotationalInertia.h
--rw-r--r--   0 runner    (1001) docker     (127)      426 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/RotationalInertiaRaw.h
--rw-r--r--   0 runner    (1001) docker     (127)     3716 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SO3Utils.h
--rw-r--r--   0 runner    (1001) docker     (127)    26097 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Span.h
--rw-r--r--   0 runner    (1001) docker     (127)    12392 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SparseMatrix.h
--rw-r--r--   0 runner    (1001) docker     (127)     1279 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialAcc.h
--rw-r--r--   0 runner    (1001) docker     (127)     2171 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialForceVector.h
--rw-r--r--   0 runner    (1001) docker     (127)    11405 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialInertia.h
--rw-r--r--   0 runner    (1001) docker     (127)      414 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialInertiaRaw.h
--rw-r--r--   0 runner    (1001) docker     (127)     1225 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialMomentum.h
--rw-r--r--   0 runner    (1001) docker     (127)     4518 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialMotionVector.h
--rw-r--r--   0 runner    (1001) docker     (127)    12425 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialVector.h
--rw-r--r--   0 runner    (1001) docker     (127)    13603 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/TestUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)    19177 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Transform.h
--rw-r--r--   0 runner    (1001) docker     (127)     9466 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/TransformDerivative.h
--rw-r--r--   0 runner    (1001) docker     (127)     5673 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Triplets.h
--rw-r--r--   0 runner    (1001) docker     (127)     1093 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Twist.h
--rw-r--r--   0 runner    (1001) docker     (127)     3831 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Utils.h
--rw-r--r--   0 runner    (1001) docker     (127)     8272 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/VectorDynSize.h
--rw-r--r--   0 runner    (1001) docker     (127)    11292 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/VectorFixSize.h
--rw-r--r--   0 runner    (1001) docker     (127)      874 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/include/iDynTree/Wrench.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.222977 idyntree-9.1.1.dev66/src/core/src/
--rw-r--r--   0 runner    (1001) docker     (127)     8616 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/ArticulatedBodyInertia.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     8069 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Axis.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3063 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/ClassicalAcc.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     7740 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/CubicSpline.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3183 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Direction.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3304 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/GeomVector3.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9148 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/InertiaNonLinearParametrization.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9090 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/MatrixDynSize.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     6869 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Position.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      797 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/PrivateUtils.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    23325 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Rotation.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1113 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/RotationalInertia.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     6014 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/SO3Utils.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    30812 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/SparseMatrix.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1112 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/SpatialAcc.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1196 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/SpatialForceVector.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    13968 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/SpatialInertia.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1230 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/SpatialMomentum.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3362 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/SpatialMotionVector.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4109 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/TestUtils.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    15280 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Transform.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     8174 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/TransformDerivative.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4997 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Triplets.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1374 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Twist.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2652 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Utils.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     6204 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/VectorDynSize.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      981 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/src/Wrench.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.226976 idyntree-9.1.1.dev66/src/core/tests/
--rw-r--r--   0 runner    (1001) docker     (127)     5104 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/ArticulatedBodyInertiaUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5468 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/AxisUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2110 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     2856 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/CubicSplineUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      885 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/DirectionUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2422 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/EigenHelpersUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2641 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/EigenSparseHelpersUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1253 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/ExpLogUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2310 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/MatrixDynSizeUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1729 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/MatrixViewUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      845 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/PrivateUtilsUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     8978 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/RotationUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4563 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/SO3UtilsUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    37842 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/SpanUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9206 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/SparseMatrixUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1129 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/SpatialAccUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    17909 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/SpatialInertiaUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      627 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/SpatialToEigenCompilationErrorTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1232 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/TransformFromMatrix4x4UnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1001 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/TwistUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1289 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/VectorDynSizeUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1603 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/core/tests/WrenchUnitTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.226976 idyntree-9.1.1.dev66/src/estimation/
--rw-r--r--   0 runner    (1001) docker     (127)     4343 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.082976 idyntree-9.1.1.dev66/src/estimation/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.230977 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)    11370 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/AttitudeEstimator.h
--rw-r--r--   0 runner    (1001) docker     (127)     5447 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/AttitudeEstimatorUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)     8487 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/AttitudeMahonyFilter.h
--rw-r--r--   0 runner    (1001) docker     (127)    20016 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/AttitudeQuaternionEKF.h
--rw-r--r--   0 runner    (1001) docker     (127)    30890 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/BerdyHelper.h
--rw-r--r--   0 runner    (1001) docker     (127)     3459 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/BerdySparseMAPSolver.h
--rw-r--r--   0 runner    (1001) docker     (127)     5805 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/BipedFootContactClassifier.h
--rw-r--r--   0 runner    (1001) docker     (127)     4020 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/ContactStateMachine.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.234977 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/
--rw-r--r--   0 runner    (1001) docker     (127)      447 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/AttitudeEstimator.h
--rw-r--r--   0 runner    (1001) docker     (127)      477 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/AttitudeEstimatorUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)      466 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/AttitudeMahonyFilter.h
--rw-r--r--   0 runner    (1001) docker     (127)      471 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/AttitudeQuaternionEKF.h
--rw-r--r--   0 runner    (1001) docker     (127)      419 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/BerdyHelper.h
--rw-r--r--   0 runner    (1001) docker     (127)      526 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/BerdySparseMAPSolver.h
--rw-r--r--   0 runner    (1001) docker     (127)      496 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/BipedFootContactClassifier.h
--rw-r--r--   0 runner    (1001) docker     (127)      457 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/ContactStateMachine.h
--rw-r--r--   0 runner    (1001) docker     (127)      557 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h
--rw-r--r--   0 runner    (1001) docker     (127)      466 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/ExtendedKalmanFilter.h
--rw-r--r--   0 runner    (1001) docker     (127)      510 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/ExternalWrenchesEstimation.h
--rw-r--r--   0 runner    (1001) docker     (127)      497 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/GravityCompensationHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)      424 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/KalmanFilter.h
--rw-r--r--   0 runner    (1001) docker     (127)      433 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/SchmittTrigger.h
--rw-r--r--   0 runner    (1001) docker     (127)      466 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/Estimation/SimpleLeggedOdometry.h
--rw-r--r--   0 runner    (1001) docker     (127)    19666 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/ExtWrenchesAndJointTorquesEstimator.h
--rw-r--r--   0 runner    (1001) docker     (127)    18409 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/ExtendedKalmanFilter.h
--rw-r--r--   0 runner    (1001) docker     (127)    17891 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/ExternalWrenchesEstimation.h
--rw-r--r--   0 runner    (1001) docker     (127)     5253 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/GravityCompensationHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)    11150 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/KalmanFilter.h
--rw-r--r--   0 runner    (1001) docker     (127)     6222 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/SchmittTrigger.h
--rw-r--r--   0 runner    (1001) docker     (127)     9362 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/include/iDynTree/SimpleLeggedOdometry.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.238977 idyntree-9.1.1.dev66/src/estimation/src/
--rw-r--r--   0 runner    (1001) docker     (127)      216 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/AttitudeEstimator.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5098 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/AttitudeEstimatorUtils.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    11701 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/AttitudeMahonyFilter.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    23608 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/AttitudeQuaternionEKF.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    97716 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/BerdyHelper.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    18145 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/BerdySparseMAPSolver.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4735 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/BipedFootContactClassifier.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1792 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/ContactStateMachine.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    27422 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/ExtWrenchesAndJointTorquesEstimator.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9333 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/ExtendedKalmanFilter.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    38287 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/ExternalWrenchesEstimation.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     7106 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/GravityCompensationHelpers.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9135 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/KalmanFilter.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3149 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/SchmittTrigger.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    11059 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/src/SimpleLeggedOdometry.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.238977 idyntree-9.1.1.dev66/src/estimation/tests/
--rw-r--r--   0 runner    (1001) docker     (127)     4734 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/tests/AttitudeEstimatorUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    16636 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/tests/BerdyHelperUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      568 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/tests/BerdyMAPSolverUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      955 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     9840 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/tests/ExtWrenchesAndJointTorquesEstimatorUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    13490 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/tests/ExternalWrenchesEstimationUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3999 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/tests/KalmanFilterUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3624 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/estimation/tests/SimpleLeggedOdometryUnitTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.238977 idyntree-9.1.1.dev66/src/high-level/
--rw-r--r--   0 runner    (1001) docker     (127)     1657 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/high-level/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.082976 idyntree-9.1.1.dev66/src/high-level/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.238977 idyntree-9.1.1.dev66/src/high-level/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)    61803 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/high-level/include/iDynTree/KinDynComputations.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.242977 idyntree-9.1.1.dev66/src/high-level/src/
--rw-r--r--   0 runner    (1001) docker     (127)   116883 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/high-level/src/KinDynComputations.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.242977 idyntree-9.1.1.dev66/src/high-level/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      722 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/high-level/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)    19483 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/high-level/tests/KinDynComputationsMatrixViewAndSpanUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    36100 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/high-level/tests/KinDynComputationsUnitTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.242977 idyntree-9.1.1.dev66/src/icub/
--rw-r--r--   0 runner    (1001) docker     (127)     1425 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/icub/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.082976 idyntree-9.1.1.dev66/src/icub/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.242977 idyntree-9.1.1.dev66/src/icub/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)     2131 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/icub/include/iDynTree/iKinConversions.h
--rw-r--r--   0 runner    (1001) docker     (127)     3763 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/icub/include/iDynTree/iKinConversionsImplementation.h
--rw-r--r--   0 runner    (1001) docker     (127)     6831 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/icub/include/iDynTree/skinDynLibConversions.h
--rw-r--r--   0 runner    (1001) docker     (127)    15576 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/icub/include/iDynTree/skinDynLibConversionsImplementation.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.242977 idyntree-9.1.1.dev66/src/inverse-kinematics/
--rw-r--r--   0 runner    (1001) docker     (127)     2801 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.082976 idyntree-9.1.1.dev66/src/inverse-kinematics/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.242977 idyntree-9.1.1.dev66/src/inverse-kinematics/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)     4753 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/include/iDynTree/BoundingBoxHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)     7991 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/include/iDynTree/ConvexHullHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)    50798 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/include/iDynTree/InverseKinematics.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.242977 idyntree-9.1.1.dev66/src/inverse-kinematics/include/private/
--rw-r--r--   0 runner    (1001) docker     (127)    11909 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/include/private/InverseKinematicsData.h
--rw-r--r--   0 runner    (1001) docker     (127)    18755 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/include/private/InverseKinematicsNLP.h
--rw-r--r--   0 runner    (1001) docker     (127)     8991 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/include/private/TransformConstraint.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.246977 idyntree-9.1.1.dev66/src/inverse-kinematics/src/
--rw-r--r--   0 runner    (1001) docker     (127)     6333 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/src/BoundingBoxHelpers.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    12535 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/src/ConvexHullHelpers.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    53546 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/src/InverseKinematics.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    24032 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/src/InverseKinematicsData.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    87744 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/src/InverseKinematicsNLP.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5034 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/src/TransformConstraint.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.246977 idyntree-9.1.1.dev66/src/inverse-kinematics/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      638 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     6036 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/tests/ConvexHullHelpersUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    28275 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/tests/InverseKinematicsMatrixViewAndSpanUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    27382 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/tests/InverseKinematicsUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     6890 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/inverse-kinematics/tests/iKinVersusLegacyTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.246977 idyntree-9.1.1.dev66/src/model/
--rw-r--r--   0 runner    (1001) docker     (127)     7778 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.086976 idyntree-9.1.1.dev66/src/model/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.254977 idyntree-9.1.1.dev66/src/model/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)     2999 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/AccelerometerSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)      440 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/AllSensorsTypes.h
--rw-r--r--   0 runner    (1001) docker     (127)      512 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Centroidal.h
--rw-r--r--   0 runner    (1001) docker     (127)     4634 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/ContactWrench.h
--rw-r--r--   0 runner    (1001) docker     (127)     5692 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/DenavitHartenberg.h
--rw-r--r--   0 runner    (1001) docker     (127)    10313 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Dynamics.h
--rw-r--r--   0 runner    (1001) docker     (127)     3301 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/DynamicsLinearization.h
--rw-r--r--   0 runner    (1001) docker     (127)     2141 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/DynamicsLinearizationHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)      649 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/DynamicsUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)     7653 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/FixedJoint.h
--rw-r--r--   0 runner    (1001) docker     (127)     7227 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/ForwardKinematics.h
--rw-r--r--   0 runner    (1001) docker     (127)     2480 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/FreeFloatingMatrices.h
--rw-r--r--   0 runner    (1001) docker     (127)     6307 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/FreeFloatingState.h
--rw-r--r--   0 runner    (1001) docker     (127)     2869 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/GyroscopeSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)    19438 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/IJoint.h
--rw-r--r--   0 runner    (1001) docker     (127)     1226 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Indices.h
--rw-r--r--   0 runner    (1001) docker     (127)     1809 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Jacobians.h
--rw-r--r--   0 runner    (1001) docker     (127)     3168 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/JointState.h
--rw-r--r--   0 runner    (1001) docker     (127)     1786 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Link.h
--rw-r--r--   0 runner    (1001) docker     (127)     7044 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/LinkState.h
--rw-r--r--   0 runner    (1001) docker     (127)     1927 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/LinkTraversalsCache.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.258977 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/
--rw-r--r--   0 runner    (1001) docker     (127)      398 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/Centroidal.h
--rw-r--r--   0 runner    (1001) docker     (127)      414 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/ContactWrench.h
--rw-r--r--   0 runner    (1001) docker     (127)      402 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/DenavitHartenberg.h
--rw-r--r--   0 runner    (1001) docker     (127)      388 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/Dynamics.h
--rw-r--r--   0 runner    (1001) docker     (127)      444 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/DynamicsLinearization.h
--rw-r--r--   0 runner    (1001) docker     (127)      473 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/DynamicsLinearizationHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)      414 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/DynamicsUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)      400 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/FixedJoint.h
--rw-r--r--   0 runner    (1001) docker     (127)      427 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/ForwardKinematics.h
--rw-r--r--   0 runner    (1001) docker     (127)      452 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/FreeFloatingMatrices.h
--rw-r--r--   0 runner    (1001) docker     (127)      437 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/FreeFloatingState.h
--rw-r--r--   0 runner    (1001) docker     (127)      377 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/IJoint.h
--rw-r--r--   0 runner    (1001) docker     (127)      382 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/Indices.h
--rw-r--r--   0 runner    (1001) docker     (127)      393 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/Jacobians.h
--rw-r--r--   0 runner    (1001) docker     (127)      400 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/JointState.h
--rw-r--r--   0 runner    (1001) docker     (127)      368 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/Link.h
--rw-r--r--   0 runner    (1001) docker     (127)      395 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/LinkState.h
--rw-r--r--   0 runner    (1001) docker     (127)      447 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/LinkTraversalsCache.h
--rw-r--r--   0 runner    (1001) docker     (127)      372 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/Model.h
--rw-r--r--   0 runner    (1001) docker     (127)      421 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/ModelTestUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)      432 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/ModelTransformers.h
--rw-r--r--   0 runner    (1001) docker     (127)      431 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/MovableJointImpl.h
--rw-r--r--   0 runner    (1001) docker     (127)      419 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/PrismaticJoint.h
--rw-r--r--   0 runner    (1001) docker     (127)      414 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/RevoluteJoint.h
--rw-r--r--   0 runner    (1001) docker     (127)      404 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/SolidShapes.h
--rw-r--r--   0 runner    (1001) docker     (127)      387 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/SubModel.h
--rw-r--r--   0 runner    (1001) docker     (127)      392 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model/Traversal.h
--rw-r--r--   0 runner    (1001) docker     (127)    23807 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Model.h
--rw-r--r--   0 runner    (1001) docker     (127)     2068 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/ModelSensorsTransformers.h
--rw-r--r--   0 runner    (1001) docker     (127)     6468 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/ModelTestUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)     4449 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/ModelTransformers.h
--rw-r--r--   0 runner    (1001) docker     (127)     5783 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/MovableJointImpl.h
--rw-r--r--   0 runner    (1001) docker     (127)     9841 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/PredictSensorsMeasurements.h
--rw-r--r--   0 runner    (1001) docker     (127)     9180 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/PrismaticJoint.h
--rw-r--r--   0 runner    (1001) docker     (127)     9609 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/RevoluteJoint.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.262977 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/
--rw-r--r--   0 runner    (1001) docker     (127)      450 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/AccelerometerSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)      432 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/AllSensorsTypes.h
--rw-r--r--   0 runner    (1001) docker     (127)      430 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/GyroscopeSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)      477 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/ModelSensorsTransformers.h
--rw-r--r--   0 runner    (1001) docker     (127)      487 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/PredictSensorsMeasurements.h
--rw-r--r--   0 runner    (1001) docker     (127)      388 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/Sensors.h
--rw-r--r--   0 runner    (1001) docker     (127)      447 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/SixAxisForceTorqueSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)      478 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)      472 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)    19011 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors.h
--rw-r--r--   0 runner    (1001) docker     (127)     8821 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/SixAxisForceTorqueSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)     7439 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/SolidShapes.h
--rw-r--r--   0 runner    (1001) docker     (127)     4888 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/SubModel.h
--rw-r--r--   0 runner    (1001) docker     (127)     3195 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/ThreeAxisAngularAccelerometerSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)     4645 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/ThreeAxisForceTorqueContactSensor.h
--rw-r--r--   0 runner    (1001) docker     (127)     8063 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/include/iDynTree/Traversal.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.270977 idyntree-9.1.1.dev66/src/model/src/
--rw-r--r--   0 runner    (1001) docker     (127)     3862 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/AccelerometerSensor.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4051 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/ContactWrench.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    30846 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/DenavitHartenberg.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    25012 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/Dynamics.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    38160 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/DynamicsLinearization.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1208 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/DynamicsLinearizationHelpers.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     8318 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/FixedJoint.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    11863 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/ForwardKinematics.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2046 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/FreeFloatingMatrices.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3739 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/FreeFloatingState.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3512 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/GyroscopeSensor.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      518 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/Indices.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2001 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/Jacobians.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3736 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/JointState.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      653 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/Link.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     7226 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/LinkState.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1285 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/LinkTraversalsCache.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    30256 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/Model.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      500 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/ModelInterfaceDestructors.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      977 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/ModelSensorsTransformers.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    37686 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/ModelTransformers.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     7982 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/PredictSensorsMeasurements.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    13393 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/PrismaticJoint.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    13781 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/RevoluteJoint.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    34513 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/Sensors.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    13403 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/SixAxisForceTorqueSensor.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    10751 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/SolidShapes.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9522 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/SubModel.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3977 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/ThreeAxisAngularAccelerometerSensor.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     6222 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/ThreeAxisForceTorqueContactSensor.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5418 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/src/Traversal.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.270977 idyntree-9.1.1.dev66/src/model/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      758 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     5733 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/tests/JointUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1015 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/tests/LinkUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    14974 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/tests/ModelUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     7056 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/tests/SensorsListUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2308 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model/tests/ThreeAxisForceTorqueContactSensorUnitTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.270977 idyntree-9.1.1.dev66/src/model_io/
--rw-r--r--   0 runner    (1001) docker     (127)      328 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.270977 idyntree-9.1.1.dev66/src/model_io/codecs/
--rw-r--r--   0 runner    (1001) docker     (127)     4467 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.086976 idyntree-9.1.1.dev66/src/model_io/codecs/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.270977 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)     3463 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelCalibrationHelper.h
--rw-r--r--   0 runner    (1001) docker     (127)     6890 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelExporter.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.270977 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelIO/
--rw-r--r--   0 runner    (1001) docker     (127)      473 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelIO/ModelCalibrationHelper.h
--rw-r--r--   0 runner    (1001) docker     (127)      426 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelIO/ModelExporter.h
--rw-r--r--   0 runner    (1001) docker     (127)      416 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelIO/ModelLoader.h
--rw-r--r--   0 runner    (1001) docker     (127)      433 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelIO/URDFDofsImport.h
--rw-r--r--   0 runner    (1001) docker     (127)     8798 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelLoader.h
--rw-r--r--   0 runner    (1001) docker     (127)      779 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/URDFDofsImport.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.274977 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/
--rw-r--r--   0 runner    (1001) docker     (127)     1341 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/ForceTorqueSensorElement.h
--rw-r--r--   0 runner    (1001) docker     (127)      887 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/GeometryElement.h
--rw-r--r--   0 runner    (1001) docker     (127)      904 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/InertialElement.h
--rw-r--r--   0 runner    (1001) docker     (127)     2117 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/JointElement.h
--rw-r--r--   0 runner    (1001) docker     (127)     1417 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/LinkElement.h
--rw-r--r--   0 runner    (1001) docker     (127)     1221 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/MaterialElement.h
--rw-r--r--   0 runner    (1001) docker     (127)      810 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/OriginElement.h
--rw-r--r--   0 runner    (1001) docker     (127)     2080 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/RobotElement.h
--rw-r--r--   0 runner    (1001) docker     (127)     2822 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/SensorElement.h
--rw-r--r--   0 runner    (1001) docker     (127)     1935 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/URDFDocument.h
--rw-r--r--   0 runner    (1001) docker     (127)     1767 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/URDFModelExport.h
--rw-r--r--   0 runner    (1001) docker     (127)     4704 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/URDFParsingUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)     1532 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/include/private/VisualElement.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.278977 idyntree-9.1.1.dev66/src/model_io/codecs/src/
--rw-r--r--   0 runner    (1001) docker     (127)     5732 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/ForceTorqueSensorElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5853 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/GeometryElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4583 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/InertialElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9214 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/JointElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2848 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/LinkElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2546 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/MaterialElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3778 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/ModelCalibrationHelper.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2898 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/ModelExporter.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     6458 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/ModelLoader.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1357 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/OriginElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4011 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/RobotElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5582 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/SensorElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    17222 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/URDFDocument.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1452 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/URDFDofsImport.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    25181 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/URDFModelExport.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1959 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/src/VisualElement.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.278977 idyntree-9.1.1.dev66/src/model_io/codecs/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      942 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     1898 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/tests/ModelCalibrationHelperUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9750 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/tests/ModelExporterUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5493 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/tests/PredictSensorsMeasurementUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2165 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/tests/URDFGenericSensorImportUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9067 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/tests/URDFModelImportUnitTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2613 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/codecs/tests/icubSensorURDFUnitTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.086976 idyntree-9.1.1.dev66/src/model_io/tests/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.086976 idyntree-9.1.1.dev66/src/model_io/tests/format_examples/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.282977 idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/
--rw-r--r--   0 runner    (1001) docker     (127)     1181 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/double_root.xml
--rw-r--r--   0 runner    (1001) docker     (127)      628 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/invalid_schema.xml
--rw-r--r--   0 runner    (1001) docker     (127)      601 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/invalid_xml.xml
--rw-r--r--   0 runner    (1001) docker     (127)     1155 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/schema.xsd
--rw-r--r--   0 runner    (1001) docker     (127)      614 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/valid.xml
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.282977 idyntree-9.1.1.dev66/src/model_io/xml/
--rw-r--r--   0 runner    (1001) docker     (127)     2469 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.086976 idyntree-9.1.1.dev66/src/model_io/xml/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.282977 idyntree-9.1.1.dev66/src/model_io/xml/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)     1039 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/include/iDynTree/XMLAttribute.h
--rw-r--r--   0 runner    (1001) docker     (127)     1374 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/include/iDynTree/XMLDocument.h
--rw-r--r--   0 runner    (1001) docker     (127)     4618 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/include/iDynTree/XMLElement.h
--rw-r--r--   0 runner    (1001) docker     (127)     6767 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/include/iDynTree/XMLParser.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.282977 idyntree-9.1.1.dev66/src/model_io/xml/src/
--rw-r--r--   0 runner    (1001) docker     (127)     1375 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/src/XMLAttribute.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1513 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/src/XMLDocument.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5003 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/src/XMLElement.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    18883 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/src/XMLParser.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.282977 idyntree-9.1.1.dev66/src/model_io/xml/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      678 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     2378 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/model_io/xml/tests/XMLParserUnitTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.282977 idyntree-9.1.1.dev66/src/optimalcontrol/
--rw-r--r--   0 runner    (1001) docker     (127)     5757 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.090976 idyntree-9.1.1.dev66/src/optimalcontrol/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.286977 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)    15702 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Constraint.h
--rw-r--r--   0 runner    (1001) docker     (127)    18490 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/ConstraintsGroup.h
--rw-r--r--   0 runner    (1001) docker     (127)     3054 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/ControlledDynamicalSystem.h
--rw-r--r--   0 runner    (1001) docker     (127)     2273 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Controller.h
--rw-r--r--   0 runner    (1001) docker     (127)     9607 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Cost.h
--rw-r--r--   0 runner    (1001) docker     (127)    13075 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/DynamicalSystem.h
--rw-r--r--   0 runner    (1001) docker     (127)    13049 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrator.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.290977 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/
--rw-r--r--   0 runner    (1001) docker     (127)     1470 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/FixedStepIntegrator.h
--rw-r--r--   0 runner    (1001) docker     (127)     4688 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/ForwardEuler.h
--rw-r--r--   0 runner    (1001) docker     (127)     4808 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/ImplicitTrapezoidal.h
--rw-r--r--   0 runner    (1001) docker     (127)     1592 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/RK4.h
--rw-r--r--   0 runner    (1001) docker     (127)     5146 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/L2NormCost.h
--rw-r--r--   0 runner    (1001) docker     (127)     5173 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/LinearConstraint.h
--rw-r--r--   0 runner    (1001) docker     (127)     1714 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/LinearCost.h
--rw-r--r--   0 runner    (1001) docker     (127)      816 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/LinearMPC.h
--rw-r--r--   0 runner    (1001) docker     (127)     4615 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/LinearSystem.h
--rw-r--r--   0 runner    (1001) docker     (127)     1045 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/MPC.h
--rw-r--r--   0 runner    (1001) docker     (127)     1026 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/MultiBodySystem.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.290977 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OCSolvers/
--rw-r--r--   0 runner    (1001) docker     (127)     3046 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OCSolvers/MultipleShootingSolver.h
--rw-r--r--   0 runner    (1001) docker     (127)      813 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OptimalControl.h
--rw-r--r--   0 runner    (1001) docker     (127)    13528 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OptimalControlProblem.h
--rw-r--r--   0 runner    (1001) docker     (127)     1206 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OptimalControlSolver.h
--rw-r--r--   0 runner    (1001) docker     (127)     4231 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OptimizationProblem.h
--rw-r--r--   0 runner    (1001) docker     (127)     1969 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizer.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.290977 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/
--rw-r--r--   0 runner    (1001) docker     (127)     2730 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/AlglibInterface.h
--rw-r--r--   0 runner    (1001) docker     (127)     2520 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/IpoptInterface.h
--rw-r--r--   0 runner    (1001) docker     (127)     3272 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/OsqpInterface.h
--rw-r--r--   0 runner    (1001) docker     (127)     2528 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/WorhpInterface.h
--rw-r--r--   0 runner    (1001) docker     (127)     2329 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/QuadraticCost.h
--rw-r--r--   0 runner    (1001) docker     (127)     4804 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/QuadraticLikeCost.h
--rw-r--r--   0 runner    (1001) docker     (127)     1963 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/SparsityStructure.h
--rw-r--r--   0 runner    (1001) docker     (127)      841 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/SystemLineariser.h
--rw-r--r--   0 runner    (1001) docker     (127)     1579 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/TimeRange.h
--rw-r--r--   0 runner    (1001) docker     (127)     2939 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/TimeVaryingObject.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.298977 idyntree-9.1.1.dev66/src/optimalcontrol/src/
--rw-r--r--   0 runner    (1001) docker     (127)    19262 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/AlglibInterface.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3673 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/AlglibInterfaceNotImplemented.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5890 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/Constraint.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    44066 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/ConstraintsGroup.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    11200 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/ControlledDynamicalSystem.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      796 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/Controller.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3416 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/Cost.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4635 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/DynamicalSystem.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3902 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/FixedStepIntegrator.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    19114 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/ForwardEuler.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    22294 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/ImplicitTrapezoidal.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9159 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/Integrator.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    34174 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/IpoptInterface.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4439 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/IpoptInterfaceNotImplemented.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    24831 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/L2NormCost.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    12991 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/LinearConstraint.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3133 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/LinearCost.cpp
--rw-r--r--   0 runner    (1001) docker     (127)        0 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/LinearMPC.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    11871 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/LinearSystem.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      389 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/MPC.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      401 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/MultiBodySystem.cpp
--rw-r--r--   0 runner    (1001) docker     (127)   129811 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/MultipleShootingSolver.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    75509 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/OptimalControlProblem.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2010 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/OptimalControlSolver.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5745 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/OptimizationProblem.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2010 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/Optimizer.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    39839 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/OsqpInterface.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2910 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/OsqpInterfaceNotImplemented.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5942 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/QuadraticCost.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    18940 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/QuadraticLikeCost.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4643 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/RK4.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4768 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/SparsityStructure.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      402 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/SystemLineariser.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3816 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/TimeRange.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1560 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/TimeVaryingObject.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    34524 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/WorhpInterface.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4442 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/src/WorhpInterfaceNotImplemented.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.302977 idyntree-9.1.1.dev66/src/optimalcontrol/tests/
--rw-r--r--   0 runner    (1001) docker     (127)     6916 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/AlglibInterfaceTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1070 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     3348 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/ConstraintsGroupTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     8909 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/IntegratorsTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     7281 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/IpoptInterfaceTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2716 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/L2NormTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5397 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/LinearOCOsqpTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    21220 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/MultipleShootingTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    17708 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/OCProblemTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    12241 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/OptimalControlIpoptTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1149 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/OptimalControlTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     7351 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/optimalcontrol/tests/WorhpInterfaceTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.302977 idyntree-9.1.1.dev66/src/solid-shapes/
--rw-r--r--   0 runner    (1001) docker     (127)     2448 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/solid-shapes/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.090976 idyntree-9.1.1.dev66/src/solid-shapes/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.302977 idyntree-9.1.1.dev66/src/solid-shapes/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)     2424 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/solid-shapes/include/iDynTree/InertialParametersSolidShapesHelpers.h
--rw-r--r--   0 runner    (1001) docker     (127)     1582 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/solid-shapes/include/iDynTree/ModelTransformersSolidShapes.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.302977 idyntree-9.1.1.dev66/src/solid-shapes/src/
--rw-r--r--   0 runner    (1001) docker     (127)    13305 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/solid-shapes/src/InertialParametersSolidShapesHelpers.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2306 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/solid-shapes/src/ModelTransformersSolidShapes.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.302977 idyntree-9.1.1.dev66/src/solid-shapes/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      730 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/solid-shapes/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     3619 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/solid-shapes/tests/InertialParametersSolidShapesHelpersIntegrationTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2376 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/solid-shapes/tests/ModelTransformersSolidShapesIntegrationTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.302977 idyntree-9.1.1.dev66/src/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      932 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.302977 idyntree-9.1.1.dev66/src/tests/benchmark/
--rw-r--r--   0 runner    (1001) docker     (127)      537 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/benchmark/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     6452 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/benchmark/DynamicsBenchmark.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.310977 idyntree-9.1.1.dev66/src/tests/data/
--rw-r--r--   0 runner    (1001) docker     (127)     1434 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)    48061 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/bigman.urdf
--rw-r--r--   0 runner    (1001) docker     (127)     2759 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/cube.stl
--rw-r--r--   0 runner    (1001) docker     (127)     1321 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/frame.urdf
--rw-r--r--   0 runner    (1001) docker     (127)    66355 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/iCubDarmstadt01.urdf
--rw-r--r--   0 runner    (1001) docker     (127)    66496 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/iCubGenova02.urdf
--rw-r--r--   0 runner    (1001) docker     (127)     8301 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/icalibrate.urdf
--rw-r--r--   0 runner    (1001) docker     (127)    47566 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/icub.urdf
--rw-r--r--   0 runner    (1001) docker     (127)    63947 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/icub2BB5Sea.urdf
--rw-r--r--   0 runner    (1001) docker     (127)     4077 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/icubTwoLinks.urdf
--rw-r--r--   0 runner    (1001) docker     (127)    52742 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/icub_model.urdf
--rw-r--r--   0 runner    (1001) docker     (127)    60226 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/icub_sensorised.urdf
--rw-r--r--   0 runner    (1001) docker     (127)    54040 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/icub_skin_frames.urdf
--rw-r--r--   0 runner    (1001) docker     (127)     2035 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/oneLink.urdf
--rw-r--r--   0 runner    (1001) docker     (127)      901 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/robotModelTestTwoLinks.urdf
--rw-r--r--   0 runner    (1001) docker     (127)      494 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/simple_model.urdf
--rw-r--r--   0 runner    (1001) docker     (127)     1557 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/testModels.h.in
--rw-r--r--   0 runner    (1001) docker     (127)     2673 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/threeLinks.urdf
--rw-r--r--   0 runner    (1001) docker     (127)     1351 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/twoLinks.urdf
--rw-r--r--   0 runner    (1001) docker     (127)     1213 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/twoLinksFixed.urdf
--rw-r--r--   0 runner    (1001) docker     (127)      888 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/twoLinksRotationOnZAxis.urdf
--rw-r--r--   0 runner    (1001) docker     (127)     1191 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/data/twoLinksWithoutBaseSensors.urdf
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.310977 idyntree-9.1.1.dev66/src/tests/icub_consistency/
--rw-r--r--   0 runner    (1001) docker     (127)      936 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/icub_consistency/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)    22083 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/icub_consistency/iCubExternalWrenchesEstimationConsistencyTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     4986 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/icub_consistency/iKinConsistencyTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.310977 idyntree-9.1.1.dev66/src/tests/integration/
--rw-r--r--   0 runner    (1001) docker     (127)     2618 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/integration/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     7326 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/integration/DenavitHartenbergIntegrationTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     6982 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/integration/DynamicsIntegrationTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    23378 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/integration/DynamicsLinearizationIntegrationTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2364 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/integration/InertialParametersSolidShapesHelpersIntegrationTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     9518 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/integration/ReducedModelWithFTIntegrationTest.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    19027 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/integration/iCubTorqueEstimationIntegrationTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.310977 idyntree-9.1.1.dev66/src/tests/yarp_benchmark/
--rw-r--r--   0 runner    (1001) docker     (127)      499 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/yarp_benchmark/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     3965 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tests/yarp_benchmark/PseudoInverseBenchmark.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.310977 idyntree-9.1.1.dev66/src/tools/
--rw-r--r--   0 runner    (1001) docker     (127)     1180 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tools/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)    18829 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tools/cmdline.h
--rw-r--r--   0 runner    (1001) docker     (127)     5205 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tools/idyntree-model-info.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2357 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tools/idyntree-model-simplify-shapes.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1795 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tools/idyntree-model-view.cpp
--rwxr-xr-x   0 runner    (1001) docker     (127)     5510 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/tools/idyntree-normalize-collada-meshes.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.314977 idyntree-9.1.1.dev66/src/visualization/
--rw-r--r--   0 runner    (1001) docker     (127)     5446 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.090976 idyntree-9.1.1.dev66/src/visualization/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.314977 idyntree-9.1.1.dev66/src/visualization/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)     6342 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/include/iDynTree/MeshcatVisualizer.h
--rw-r--r--   0 runner    (1001) docker     (127)    26759 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/include/iDynTree/Visualizer.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.318977 idyntree-9.1.1.dev66/src/visualization/src/
--rw-r--r--   0 runner    (1001) docker     (127)     3166 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Camera.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1050 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Camera.h
--rw-r--r--   0 runner    (1001) docker     (127)    10121 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/CameraAnimator.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3071 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/CameraAnimator.h
--rw-r--r--   0 runner    (1001) docker     (127)     7931 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/DummyImplementations.h
--rw-r--r--   0 runner    (1001) docker     (127)     5132 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Environment.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1436 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Environment.h
--rw-r--r--   0 runner    (1001) docker     (127)     1886 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/FloorGridSceneNode.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      921 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/FloorGridSceneNode.h
--rw-r--r--   0 runner    (1001) docker     (127)     3206 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/FrameVisualization.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1509 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/FrameVisualization.h
--rw-r--r--   0 runner    (1001) docker     (127)    16337 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/IrrlichtUtils.h
--rw-r--r--   0 runner    (1001) docker     (127)     5035 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/JetsVisualization.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1689 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/JetsVisualization.h
--rw-r--r--   0 runner    (1001) docker     (127)     3464 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Label.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1414 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Label.h
--rw-r--r--   0 runner    (1001) docker     (127)     5100 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Light.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1207 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Light.h
--rw-r--r--   0 runner    (1001) docker     (127)    18523 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/MeshcatVisualizer.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    19129 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/ModelVisualization.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2044 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/ModelVisualization.h
--rw-r--r--   0 runner    (1001) docker     (127)     6980 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Texture.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1382 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Texture.h
--rw-r--r--   0 runner    (1001) docker     (127)     4111 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/TexturesHandler.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1509 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/TexturesHandler.h
--rw-r--r--   0 runner    (1001) docker     (127)     7835 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/VectorsVisualization.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2714 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/VectorsVisualization.h
--rw-r--r--   0 runner    (1001) docker     (127)    28933 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/src/Visualizer.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.318977 idyntree-9.1.1.dev66/src/visualization/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      691 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     8406 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/visualization/tests/VisualizerUnitTest.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.318977 idyntree-9.1.1.dev66/src/yarp/
--rw-r--r--   0 runner    (1001) docker     (127)     1553 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.090976 idyntree-9.1.1.dev66/src/yarp/include/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.322977 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/
--rw-r--r--   0 runner    (1001) docker     (127)      806 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPConfigurationsLoader.h
--rw-r--r--   0 runner    (1001) docker     (127)     1215 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPConfigurationsLoaderImplementation.h
--rw-r--r--   0 runner    (1001) docker     (127)     7298 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPConversions.h
--rw-r--r--   0 runner    (1001) docker     (127)     3682 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPConversionsImplementation.h
--rw-r--r--   0 runner    (1001) docker     (127)     2196 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPEigenConversions.h
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2023-10-16 15:30:08.322977 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/yarp/
--rw-r--r--   0 runner    (1001) docker     (127)      467 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/yarp/YARPConfigurationsLoader.h
--rw-r--r--   0 runner    (1001) docker     (127)      540 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/yarp/YARPConfigurationsLoaderImplementation.h
--rw-r--r--   0 runner    (1001) docker     (127)      420 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/yarp/YARPConversions.h
--rw-r--r--   0 runner    (1001) docker     (127)      493 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/yarp/YARPConversionsImplementation.h
--rw-r--r--   0 runner    (1001) docker     (127)      448 2023-10-16 15:29:22.000000 idyntree-9.1.1.dev66/src/yarp/include/iDynTree/yarp/YARPEigenConversions.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.232256 idyntree-9.1.1.dev7/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.056254 idyntree-9.1.1.dev7/.github/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.072254 idyntree-9.1.1.dev7/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (999)    11929 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/.github/workflows/ci.yml
+-rw-r--r--   0 runner    (1001) docker     (999)     2076 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/.github/workflows/gh-pages.yml
+-rw-r--r--   0 runner    (1001) docker     (999)     4937 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/.github/workflows/matlab.yml
+-rw-r--r--   0 runner    (1001) docker     (999)     3483 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/.github/workflows/python.yml
+-rw-r--r--   0 runner    (1001) docker     (999)     3078 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/.github/workflows/regenerate-matlab-bindings.yml
+-rw-r--r--   0 runner    (1001) docker     (999)       65 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (999)    44093 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/CHANGELOG.md
+-rw-r--r--   0 runner    (1001) docker     (999)     3663 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     2636 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/CONTRIBUTING.md
+-rw-r--r--   0 runner    (1001) docker     (999)    26526 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/LICENSE.LGPL2
+-rw-r--r--   0 runner    (1001) docker     (999)     7651 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/LICENSE.LGPL3
+-rw-r--r--   0 runner    (1001) docker     (999)    14663 2023-09-01 07:53:04.232256 idyntree-9.1.1.dev7/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (999)    13149 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/README.md
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.072254 idyntree-9.1.1.dev7/bindings/
+-rw-r--r--   0 runner    (1001) docker     (999)     7748 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)    10618 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/iDynTree.i
+-rw-r--r--   0 runner    (1001) docker     (999)     2615 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/ignore.i
+-rw-r--r--   0 runner    (1001) docker     (999)     1370 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/joints.i
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.072254 idyntree-9.1.1.dev7/bindings/lua/
+-rw-r--r--   0 runner    (1001) docker     (999)      649 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/lua/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.076254 idyntree-9.1.1.dev7/bindings/matlab/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.080254 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/
+-rw-r--r--   0 runner    (1001) docker     (999)     4082 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/README.md
+-rw-r--r--   0 runner    (1001) docker     (999)     1560 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/generalizedBiasForces.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1601 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/generalizedGravityForces.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1050 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getBaseTwist.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1347 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getCenterOfMassJacobian.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1062 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getCenterOfMassPosition.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1064 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getCenterOfMassVelocity.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1339 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getCentroidalTotalMomentum.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1020 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFloatingBase.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1261 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameBiasAcc.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1635 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameFreeFloatingJacobian.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1062 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameIndex.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1055 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameName.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1812 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameVelocityRepresentation.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2055 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFreeFloatingMassMatrix.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1336 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getJointPos.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1328 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getJointVel.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5493 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getMeshes.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1384 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getModelVel.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1311 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getNrOfDegreesOfFreedom.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1855 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getRelativeJacobian.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4022 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getRelativeTransform.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3339 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getRobotState.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2751 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getWorldBaseTransform.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2601 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getWorldTransform.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2547 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getWorldTransformsAsHomogeneous.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1677 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/initializeVisualizer.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2925 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/loadReducedModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4872 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/modifyLinkVisual.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2735 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/modifyLinksVisualization.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1455 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/plotFrame.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3853 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/plotMeshInWorld.m
+-rw-r--r--   0 runner    (1001) docker     (999)     8237 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/prepareVisualization.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1183 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/setFloatingBase.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1998 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/setFrameVelocityRepresentation.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1785 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/setJointPos.m
+-rw-r--r--   0 runner    (1001) docker     (999)     8820 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/setRobotState.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1037 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/updateFrame.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1287 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/updateVisualization.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4725 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/updateVisualizer.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2291 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/visualizerSetup.m
+-rw-r--r--   0 runner    (1001) docker     (999)     7501 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.088254 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.124255 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/
+-rw-r--r--   0 runner    (1001) docker     (999)      151 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ACCELEROMETER.m
+-rw-r--r--   0 runner    (1001) docker     (999)      159 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ACCELEROMETER_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2327 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AccelerometerSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)      119 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyAlgorithm.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3310 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyAlgorithmInternalBuffers.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2287 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyInertia.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1459 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeEstimatorState.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3167 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeMahonyFilter.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2029 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeMahonyFilterParameters.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3668 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeQuaternionEKF.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3498 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeQuaternionEKFParameters.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2738 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Axis.m
+-rw-r--r--   0 runner    (1001) docker     (999)      158 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BERDY_FLOATING_BASE.m
+-rw-r--r--   0 runner    (1001) docker     (999)      186 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES.m
+-rw-r--r--   0 runner    (1001) docker     (999)      163 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BODY_FIXED_REPRESENTATION.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1659 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdyDynamicVariable.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3462 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdyDynamicVariables.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5032 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdyHelper.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3048 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdyOptions.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1641 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdySensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3423 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdySensors.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2714 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdySparseMAPSolver.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1440 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Box.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1091 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ClassicalAcc.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1644 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ColorViz.m
+-rw-r--r--   0 runner    (1001) docker     (999)      149 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ColumnMajor.m
+-rw-r--r--   0 runner    (1001) docker     (999)      122 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/CompositeRigidBodyAlgorithm.m
+-rw-r--r--   0 runner    (1001) docker     (999)      126 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ComputeLinearAndAngularMomentum.m
+-rw-r--r--   0 runner    (1001) docker     (999)      140 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ComputeLinearAndAngularMomentumDerivativeBias.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1014 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ContactWrench.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4113 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ConvexHullProjectionConstraint.m
+-rw-r--r--   0 runner    (1001) docker     (999)      117 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/CreateModelFromDHChain.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1226 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Cylinder.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1995 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DHChain.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2167 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DHLink.m
+-rw-r--r--   0 runner    (1001) docker     (999)      156 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DIRECTIONAL_LIGHT.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1017 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOFSpatialForceArray.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1019 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOFSpatialMotionArray.m
+-rw-r--r--   0 runner    (1001) docker     (999)      155 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOF_ACCELERATION.m
+-rw-r--r--   0 runner    (1001) docker     (999)      162 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOF_ACCELERATION_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)      209 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOF_INVALID_INDEX.m
+-rw-r--r--   0 runner    (1001) docker     (999)      208 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOF_INVALID_NAME.m
+-rw-r--r--   0 runner    (1001) docker     (999)      149 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOF_TORQUE.m
+-rw-r--r--   0 runner    (1001) docker     (999)      156 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOF_TORQUE_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1459 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Direction.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3144 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DiscreteExtendedKalmanFilterHelper.m
+-rw-r--r--   0 runner    (1001) docker     (999)      608 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Dummy.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1247 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DynamicMatrixView.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3004 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DynamicSpan.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2388 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ExtWrenchesAndJointTorquesEstimator.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1386 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ExternalMesh.m
+-rw-r--r--   0 runner    (1001) docker     (999)      118 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ExtractDHChainFromModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      211 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FRAME_INVALID_INDEX.m
+-rw-r--r--   0 runner    (1001) docker     (999)      210 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FRAME_INVALID_NAME.m
+-rw-r--r--   0 runner    (1001) docker     (999)      150 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FULL_WRENCH.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4423 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FixedJoint.m
+-rw-r--r--   0 runner    (1001) docker     (999)      115 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ForwardAccKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      119 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ForwardBiasAccKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      121 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ForwardPosVelAccKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      118 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ForwardPosVelKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      120 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ForwardPositionKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      118 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ForwardVelAccKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      889 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FrameFreeFloatingJacobian.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1134 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingAcc.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1171 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingGeneralizedTorques.m
+-rw-r--r--   0 runner    (1001) docker     (999)      753 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingMassMatrix.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1144 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingPos.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1134 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingVel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      147 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/GYROSCOPE.m
+-rw-r--r--   0 runner    (1001) docker     (999)      155 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/GYROSCOPE_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1702 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/GeomVector3.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2319 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/GyroscopeSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2009 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IAttitudeEstimator.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1316 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ICamera.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1485 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ICameraAnimator.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1738 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IEnvironment.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1353 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IFrameVisualization.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1495 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IJetsVisualization.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5168 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IJoint.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1681 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ILabel.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2240 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ILight.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2811 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IModelVisualization.m
+-rw-r--r--   0 runner    (1001) docker     (999)      167 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/INERTIAL_FIXED_REPRESENTATION.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1573 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ITexture.m
+-rw-r--r--   0 runner    (1001) docker     (999)      809 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ITexturesHandler.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1892 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IVectorsVisualization.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1377 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IndexRange.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3417 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IntVector.m
+-rw-r--r--   0 runner    (1001) docker     (999)      137 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseDynamicsInertialParametersRegressor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     8512 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      189 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsRotationParametrizationQuaternion.m
+-rw-r--r--   0 runner    (1001) docker     (999)      191 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsRotationParametrizationRollPitchYaw.m
+-rw-r--r--   0 runner    (1001) docker     (999)      183 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintFull.m
+-rw-r--r--   0 runner    (1001) docker     (999)      183 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintNone.m
+-rw-r--r--   0 runner    (1001) docker     (999)      191 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintPositionOnly.m
+-rw-r--r--   0 runner    (1001) docker     (999)      191 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintRotationOnly.m
+-rw-r--r--   0 runner    (1001) docker     (999)      211 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JOINT_INVALID_INDEX.m
+-rw-r--r--   0 runner    (1001) docker     (999)      210 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JOINT_INVALID_NAME.m
+-rw-r--r--   0 runner    (1001) docker     (999)      151 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JOINT_WRENCH.m
+-rw-r--r--   0 runner    (1001) docker     (999)      158 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JOINT_WRENCH_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)      879 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JointDOFsDoubleArray.m
+-rw-r--r--   0 runner    (1001) docker     (999)      877 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JointPosDoubleArray.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1196 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JointSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     8171 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/KinDynComputations.m
+-rw-r--r--   0 runner    (1001) docker     (999)      168 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LINK_BODY_PROPER_ACCELERATION.m
+-rw-r--r--   0 runner    (1001) docker     (999)      178 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LINK_BODY_PROPER_CLASSICAL_ACCELERATION.m
+-rw-r--r--   0 runner    (1001) docker     (999)      210 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LINK_INVALID_INDEX.m
+-rw-r--r--   0 runner    (1001) docker     (999)      209 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LINK_INVALID_NAME.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1234 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Link.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1250 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkAccArray.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1026 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkArticulatedBodyInertias.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1565 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkContactWrenches.m
+-rw-r--r--   0 runner    (1001) docker     (999)      996 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkInertias.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1252 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkPositions.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1470 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1864 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkUnknownWrenchContacts.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1250 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkVelArray.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1371 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkWrenches.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3493 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinksSolidShapesVector.m
+-rw-r--r--   0 runner    (1001) docker     (999)      158 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MIXED_REPRESENTATION.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1485 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Material.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2382 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MatlabSwigIterator.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2243 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix10x16.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2239 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix1x6.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2239 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix2x3.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2239 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix3x3.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2239 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix4x4.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3605 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix4x4Vector.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2241 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix6x10.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2239 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix6x6.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2749 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MatrixDynSize.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5810 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Model.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1597 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelCalibrationHelper.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1664 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelExporter.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1481 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelExporterOptions.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1967 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelLoader.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1197 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelParserOptions.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1145 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelSolidShapes.m
+-rw-r--r--   0 runner    (1001) docker     (999)      895 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MomentumFreeFloatingJacobian.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1580 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl1.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1580 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl2.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1580 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl3.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1580 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl4.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1580 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl5.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1580 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl6.m
+-rw-r--r--   0 runner    (1001) docker     (999)      153 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/NET_EXT_WRENCH.m
+-rw-r--r--   0 runner    (1001) docker     (999)      160 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/NET_EXT_WRENCH_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)      184 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV.m
+-rw-r--r--   0 runner    (1001) docker     (999)      150 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/NO_UNKNOWNS.m
+-rw-r--r--   0 runner    (1001) docker     (999)       63 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/NR_OF_SENSOR_TYPES.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1153 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Neighbor.m
+-rw-r--r--   0 runner    (1001) docker     (999)      164 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ORIGINAL_BERDY_FIXED_BASE.m
+-rw-r--r--   0 runner    (1001) docker     (999)      150 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/POINT_LIGHT.m
+-rw-r--r--   0 runner    (1001) docker     (999)      149 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/PURE_FORCE.m
+-rw-r--r--   0 runner    (1001) docker     (999)      170 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/PURE_FORCE_WITH_KNOWN_DIRECTION.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1114 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/PixelViz.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1654 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Polygon.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1398 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Polygon2D.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2193 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Position.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1455 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/PositionRaw.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3660 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/PrismaticJoint.m
+-rw-r--r--   0 runner    (1001) docker     (999)      149 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RCM_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)      111 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RNEADynamicPhase.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3658 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RevoluteJoint.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2867 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RigidBodyInertiaNonLinearParametrization.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4628 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Rotation.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2025 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RotationRaw.m
+-rw-r--r--   0 runner    (1001) docker     (999)      724 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RotationalInertiaRaw.m
+-rw-r--r--   0 runner    (1001) docker     (999)      146 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RowMajor.m
+-rw-r--r--   0 runner    (1001) docker     (999)      159 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SIX_AXIS_FORCE_TORQUE.m
+-rw-r--r--   0 runner    (1001) docker     (999)      167 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SIX_AXIS_FORCE_TORQUE_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1437 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Sensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2688 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SensorsList.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1565 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SensorsMeasurements.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1695 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SimpleLeggedOdometry.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4284 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SixAxisForceTorqueSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2724 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SolidShape.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3483 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SolidShapesVector.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2664 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SparseMatrixColMajor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2664 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SparseMatrixRowMajor.m
+-rw-r--r--   0 runner    (1001) docker     (999)      981 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialAcc.m
+-rw-r--r--   0 runner    (1001) docker     (999)      760 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialForceVector.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3480 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialForceVectorBase.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2515 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialInertia.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1702 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialInertiaRaw.m
+-rw-r--r--   0 runner    (1001) docker     (999)      989 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialMomentum.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1286 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialMotionVector.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3482 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialMotionVectorBase.m
+-rw-r--r--   0 runner    (1001) docker     (999)      968 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Sphere.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3423 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/StringVector.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1580 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SubModelDecomposition.m
+-rw-r--r--   0 runner    (1001) docker     (999)      170 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_ANGULAR_ACCELEROMETER.m
+-rw-r--r--   0 runner    (1001) docker     (999)      178 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)      169 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_FORCE_TORQUE_CONTACT.m
+-rw-r--r--   0 runner    (1001) docker     (999)      177 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR.m
+-rw-r--r--   0 runner    (1001) docker     (999)      215 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/TRAVERSAL_INVALID_INDEX.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2359 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ThreeAxisAngularAccelerometerSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2829 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ThreeAxisForceTorqueContactSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2638 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Transform.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2127 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/TransformDerivative.m
+-rw-r--r--   0 runner    (1001) docker     (999)      110 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/TransformFromDH.m
+-rw-r--r--   0 runner    (1001) docker     (999)      119 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/TransformFromDHCraig1989.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2639 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Traversal.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1094 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Twist.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1977 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/UnknownWrenchContact.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2581 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector10.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2581 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector16.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2579 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector3.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2579 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector4.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2579 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector6.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3093 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/VectorDynSize.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3425 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Visualizer.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1706 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/VisualizerOptions.m
+-rw-r--r--   0 runner    (1001) docker     (999)      971 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Wrench.m
+-rw-r--r--   0 runner    (1001) docker     (999)      126 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/addRandomAdditionalFrameToModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      115 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/addRandomLinkToModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      114 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/checkDoublesAreEqual.m
+-rw-r--r--   0 runner    (1001) docker     (999)      122 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/computeBoundingBoxFromShape.m
+-rw-r--r--   0 runner    (1001) docker     (999)      113 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/computeBoxVertices.m
+-rw-r--r--   0 runner    (1001) docker     (999)      131 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/computeLinkNetWrenchesWithoutGravity.m
+-rw-r--r--   0 runner    (1001) docker     (999)      125 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/computeTransformToSubModelBase.m
+-rw-r--r--   0 runner    (1001) docker     (999)      126 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/computeTransformToTraversalBase.m
+-rw-r--r--   0 runner    (1001) docker     (999)      134 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/createModelWithNormalizedJointNumbering.m
+-rw-r--r--   0 runner    (1001) docker     (999)      113 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/createReducedModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      111 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/dofsListFromURDF.m
+-rw-r--r--   0 runner    (1001) docker     (999)      117 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/dofsListFromURDFString.m
+-rw-r--r--   0 runner    (1001) docker     (999)       58 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/dynamic_extent.m
+-rw-r--r--   0 runner    (1001) docker     (999)      136 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/dynamicsEstimationForwardVelAccKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      133 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/dynamicsEstimationForwardVelKinematics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      119 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/estimateExternalWrenches.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2500 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/estimateExternalWrenchesBuffers.m
+-rw-r--r--   0 runner    (1001) docker     (999)      136 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/estimateExternalWrenchesWithoutInternalFT.m
+-rw-r--r--   0 runner    (1001) docker     (999)      154 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/estimateInertialParametersFromLinkBoundingBoxesAndTotalMass.m
+-rw-r--r--   0 runner    (1001) docker     (999)      149 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/estimateLinkContactWrenchesFromLinkNetExternalWrenches.m
+-rw-r--r--   0 runner    (1001) docker     (999)      110 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/extractSubModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      109 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/getRandomChain.m
+-rw-r--r--   0 runner    (1001) docker     (999)      125 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/getRandomInverseDynamicsInputs.m
+-rw-r--r--   0 runner    (1001) docker     (999)      118 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/getRandomJointPositions.m
+-rw-r--r--   0 runner    (1001) docker     (999)      108 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/getRandomLink.m
+-rw-r--r--   0 runner    (1001) docker     (999)      120 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/getRandomLinkIndexOfModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      115 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/getRandomLinkOfModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      109 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/getRandomModel.m
+-rw-r--r--   0 runner    (1001) docker     (999)      112 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/getSensorTypeSize.m
+-rw-r--r--   0 runner    (1001) docker     (999)       61 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/input_dimensions.m
+-rw-r--r--   0 runner    (1001) docker     (999)      105 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/int2string.m
+-rw-r--r--   0 runner    (1001) docker     (999)      120 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/isDOFBerdyDynamicVariable.m
+-rw-r--r--   0 runner    (1001) docker     (999)      122 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/isJointBerdyDynamicVariable.m
+-rw-r--r--   0 runner    (1001) docker     (999)      108 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/isJointSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)      121 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/isLinkBerdyDynamicVariable.m
+-rw-r--r--   0 runner    (1001) docker     (999)      107 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/isLinkSensor.m
+-rw-r--r--   0 runner    (1001) docker     (999)       80 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/output_dimensions_with_magnetometer.m
+-rw-r--r--   0 runner    (1001) docker     (999)       83 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/output_dimensions_without_magnetometer.m
+-rw-r--r--   0 runner    (1001) docker     (999)      121 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/predictSensorsMeasurements.m
+-rw-r--r--   0 runner    (1001) docker     (999)      135 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/predictSensorsMeasurementsFromRawBuffers.m
+-rw-r--r--   0 runner    (1001) docker     (999)      110 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/removeFakeLinks.m
+-rw-r--r--   0 runner    (1001) docker     (999)      105 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/reportDebug.m
+-rw-r--r--   0 runner    (1001) docker     (999)      104 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/reportInfo.m
+-rw-r--r--   0 runner    (1001) docker     (999)      124 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/sizeOfRotationParametrization.m
+-rw-r--r--   0 runner    (1001) docker     (999)  4838030 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/iDynTreeMATLAB_wrap.cxx
+-rw-r--r--   0 runner    (1001) docker     (999)       53 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/iDynTreeSwigGet.m
+-rw-r--r--   0 runner    (1001) docker     (999)      353 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/iDynTreeSwigMem.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1908 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/autogenerated/iDynTreeSwigRef.m
+-rwxr-xr-x   0 runner    (1001) docker     (999)     1334 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/fix_generic_names_in_autogenerated_files.sh
+-rw-r--r--   0 runner    (1001) docker     (999)       41 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/iDynTreesetup.m
+-rw-r--r--   0 runner    (1001) docker     (999)       66 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/matlab.i
+-rw-r--r--   0 runner    (1001) docker     (999)     1147 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/matlab_mat4x4vec.i
+-rw-r--r--   0 runner    (1001) docker     (999)    14801 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/matlab_matvec.i
+-rw-r--r--   0 runner    (1001) docker     (999)      984 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/matlab_spatialvec.i
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.124255 idyntree-9.1.1.dev7/bindings/matlab/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)     1616 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     1127 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/EKFTest.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2430 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/InertiaUnitTest.m
+-rw-r--r--   0 runner    (1001) docker     (999)      356 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/JointUnitTest.m
+-rw-r--r--   0 runner    (1001) docker     (999)      492 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/MatrixUnitTest.m
+-rw-r--r--   0 runner    (1001) docker     (999)      725 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/PositionUnitTest.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2364 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/TransformUnitTest.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5828 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/highLevelWrappersSmokeTest.m
+-rw-r--r--   0 runner    (1001) docker     (999)      383 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/iDynTreeAssertEqual.m
+-rw-r--r--   0 runner    (1001) docker     (999)      136 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/iDynTreeLoad.m
+-rw-r--r--   0 runner    (1001) docker     (999)    52742 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/matlab/tests/model.urdf
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.128255 idyntree-9.1.1.dev7/bindings/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (999)     1425 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)      306 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/error_utilities.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      356 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/error_utilities.h
+-rw-r--r--   0 runner    (1001) docker     (999)      591 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    12228 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_core.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      306 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_core.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2886 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_high_level.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      330 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_high_level.h
+-rw-r--r--   0 runner    (1001) docker     (999)    11326 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_model.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      311 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_model.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2703 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_modelio_urdf.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      338 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_modelio_urdf.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2519 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_sensors.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      318 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/idyntree_sensors.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.128255 idyntree-9.1.1.dev7/bindings/pybind11/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      178 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)    15919 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_core.py
+-rw-r--r--   0 runner    (1001) docker     (999)     6868 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_high_level.py
+-rw-r--r--   0 runner    (1001) docker     (999)    13719 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_model.py
+-rw-r--r--   0 runner    (1001) docker     (999)     4634 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_modelio_urdf.py
+-rw-r--r--   0 runner    (1001) docker     (999)     2596 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_sensors.py
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.128255 idyntree-9.1.1.dev7/bindings/python/
+-rw-r--r--   0 runner    (1001) docker     (999)     1962 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)   109459 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/numpy.i
+-rw-r--r--   0 runner    (1001) docker     (999)    12939 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/python.i
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.128255 idyntree-9.1.1.dev7/bindings/python/scripts/
+-rw-r--r--   0 runner    (1001) docker     (999)      202 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/scripts/CMakeLists.txt
+-rwxr-xr-x   0 runner    (1001) docker     (999)     1036 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/scripts/idyntree-model-view-meshcat.py
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.128255 idyntree-9.1.1.dev7/bindings/python/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      559 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     3053 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/tests/dyncomp.py
+-rw-r--r--   0 runner    (1001) docker     (999)     4834 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/tests/geometry.py
+-rw-r--r--   0 runner    (1001) docker     (999)    10310 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/tests/helpers.py
+-rw-r--r--   0 runner    (1001) docker     (999)      900 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/tests/joints.py
+-rw-r--r--   0 runner    (1001) docker     (999)    52742 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/tests/model.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)      645 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/tests/modelloader.py
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.128255 idyntree-9.1.1.dev7/bindings/python/visualize/
+-rw-r--r--   0 runner    (1001) docker     (999)       50 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/visualize/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (999)    19651 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/python/visualize/meshcat_visualizer.py
+-rw-r--r--   0 runner    (1001) docker     (999)     1743 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/bindings/sensors.i
+-rw-r--r--   0 runner    (1001) docker     (999)      305 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/ci_env.yml
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.132255 idyntree-9.1.1.dev7/cmake/
+-rw-r--r--   0 runner    (1001) docker     (999)     6871 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/AddInstallRPATHSupport.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     3781 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/AddUninstallTarget.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     5135 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/ECMEnableSanitizers.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     2958 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/ExtractVersion.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     9162 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/FindIPOPT.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     2197 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/FindIrrlicht.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)    65539 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/FindMatlab.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     6759 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/FindOctave.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     1613 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/FindTinyXML.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)      861 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/FindValgrind.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)      728 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/FindWORHP.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)    28993 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/InstallBasicPackageFiles.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     1438 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/OrocosKDLFindLogic.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     8535 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/StandardFindModule.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     5496 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/iDynTreeDependencies.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     5234 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/iDynTreeOptions.cmake
+-rw-r--r--   0 runner    (1001) docker     (999)     6032 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/cmake/valgrind-macos.supp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.132255 idyntree-9.1.1.dev7/doc/
+-rw-r--r--   0 runner    (1001) docker     (999)     2197 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)    76913 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/Doxyfile.in
+-rw-r--r--   0 runner    (1001) docker     (999)     7985 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/build-from-source.md
+-rw-r--r--   0 runner    (1001) docker     (999)     3836 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/dcTutorialCpp.md
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.132255 idyntree-9.1.1.dev7/doc/dev/
+-rw-r--r--   0 runner    (1001) docker     (999)     5984 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/dev/faqs.md
+-rw-r--r--   0 runner    (1001) docker     (999)     5624 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/generating-idyntree-matlab-bindings.md
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.132255 idyntree-9.1.1.dev7/doc/images/
+-rw-r--r--   0 runner    (1001) docker     (999)    49125 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/images/position.svg
+-rw-r--r--   0 runner    (1001) docker     (999)    74554 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/images/transform.svg
+-rw-r--r--   0 runner    (1001) docker     (999)     5293 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/main.dox
+-rw-r--r--   0 runner    (1001) docker     (999)     6991 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/matlab_visualization.md
+-rw-r--r--   0 runner    (1001) docker     (999)     4213 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/model_loading.md
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.132255 idyntree-9.1.1.dev7/doc/symbolic/
+-rw-r--r--   0 runner    (1001) docker     (999)     1495 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/doc/symbolic/RPYExpressionReference.py
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/docs/
+-rw-r--r--   0 runner    (1001) docker     (999)      358 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/docs/Doxyfile-mcss.in
+-rw-r--r--   0 runner    (1001) docker     (999)   112872 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/docs/Doxyfile.in
+-rw-r--r--   0 runner    (1001) docker     (999)     1221 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/docs/conf.py.in
+-rw-r--r--   0 runner    (1001) docker     (999)       78 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/docs/config.toml
+-rw-r--r--   0 runner    (1001) docker     (999)     4170 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/docs/generate_documentation_files.py
+-rwxr-xr-x   0 runner    (1001) docker     (999)     2257 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/docs/generate_website.py
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/
+-rw-r--r--   0 runner    (1001) docker     (999)      209 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/cxx/
+-rw-r--r--   0 runner    (1001) docker     (999)      270 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/cxx/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/cxx/InverseKinematics/
+-rw-r--r--   0 runner    (1001) docker     (999)     1278 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/cxx/InverseKinematics/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     1304 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/cxx/InverseKinematics/README.md
+-rw-r--r--   0 runner    (1001) docker     (999)     8435 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/cxx/InverseKinematics/iDynTreeExampleInverseKinematics.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/cxx/KinDynComputationsWithEigen/
+-rw-r--r--   0 runner    (1001) docker     (999)      762 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/cxx/KinDynComputationsWithEigen/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     6956 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/cxx/KinDynComputationsWithEigen/main.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/matlab/
+-rw-r--r--   0 runner    (1001) docker     (999)     3936 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/matlab/GetJointAxesInWorldFrame.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/matlab/SensorsListParsing/
+-rw-r--r--   0 runner    (1001) docker     (999)     2137 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/matlab/SensorsListParsing/SensorsListParsing.m
+-rw-r--r--   0 runner    (1001) docker     (999)    52742 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/matlab/SensorsListParsing/icub.urdf
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/matlab/SixAxisFTOffsetEstimation/
+-rw-r--r--   0 runner    (1001) docker     (999)     7368 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m
+-rw-r--r--   0 runner    (1001) docker     (999)    66355 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/matlab/SixAxisFTOffsetEstimation/iCubGenova02.urdf
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/matlab/iDynTreeWrappers/
+-rw-r--r--   0 runner    (1001) docker     (999)     4723 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/matlab/iDynTreeWrappers/visualizeRobot.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/models/
+-rw-r--r--   0 runner    (1001) docker     (999)    66355 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/models/iCubGenova02.urdf
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/examples/python/
+-rw-r--r--   0 runner    (1001) docker     (999)     1995 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/python/KinDynComputationsTutorial.py
+-rw-r--r--   0 runner    (1001) docker     (999)     6784 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/examples/python/MeshcatVisualizerExample.ipynb
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/extern/
+-rw-r--r--   0 runner    (1001) docker     (999)     1940 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.136255 idyntree-9.1.1.dev7/extern/MOxUnit/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.060253 idyntree-9.1.1.dev7/extern/MOxUnit/.github/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.140255 idyntree-9.1.1.dev7/extern/MOxUnit/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (999)     1373 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/.github/workflows/CI.yml
+-rw-r--r--   0 runner    (1001) docker     (999)      133 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (999)     3016 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/.travis.yml
+-rw-r--r--   0 runner    (1001) docker     (999)     1103 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/COPYING
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.140255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.140255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/
+-rw-r--r--   0 runner    (1001) docker     (999)      662 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/MOxUnitErroredTestOutcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)      499 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/getOutcomeStr.m
+-rw-r--r--   0 runner    (1001) docker     (999)      385 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/getSummaryContent.m
+-rw-r--r--   0 runner    (1001) docker     (999)      337 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/isNonFailure.m
+-rw-r--r--   0 runner    (1001) docker     (999)      332 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/isSuccess.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.140255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/
+-rw-r--r--   0 runner    (1001) docker     (999)      657 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/MOxUnitFailedTestOutcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)      503 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/getOutcomeStr.m
+-rw-r--r--   0 runner    (1001) docker     (999)      383 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/getSummaryContent.m
+-rw-r--r--   0 runner    (1001) docker     (999)      334 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/isNonFailure.m
+-rw-r--r--   0 runner    (1001) docker     (999)      329 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/isSuccess.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.144255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/
+-rw-r--r--   0 runner    (1001) docker     (999)      801 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/MOxUnitFunctionHandleTestCase.m
+-rw-r--r--   0 runner    (1001) docker     (999)      183 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/disp.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2698 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/run.m
+-rw-r--r--   0 runner    (1001) docker     (999)      364 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/str.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.144255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/
+-rw-r--r--   0 runner    (1001) docker     (999)      858 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/MOxUnitMatlabUnitWrapperTestCase.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1965 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/run.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.144255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/
+-rw-r--r--   0 runner    (1001) docker     (999)      630 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/MOxUnitPassedTestOutcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)      501 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/getOutcomeStr.m
+-rw-r--r--   0 runner    (1001) docker     (999)      296 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/getSummaryContent.m
+-rw-r--r--   0 runner    (1001) docker     (999)      335 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/isNonFailure.m
+-rw-r--r--   0 runner    (1001) docker     (999)      328 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/isSuccess.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.144255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/
+-rw-r--r--   0 runner    (1001) docker     (999)      648 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/MOxUnitSkippedTestOutcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)      503 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/getOutcomeStr.m
+-rw-r--r--   0 runner    (1001) docker     (999)      351 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/getSummaryContent.m
+-rw-r--r--   0 runner    (1001) docker     (999)      336 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/isNonFailure.m
+-rw-r--r--   0 runner    (1001) docker     (999)      330 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/isSuccess.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.144255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/
+-rw-r--r--   0 runner    (1001) docker     (999)      534 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/MOxUnitTestCase.m
+-rw-r--r--   0 runner    (1001) docker     (999)       40 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/countTestCases.m
+-rw-r--r--   0 runner    (1001) docker     (999)      183 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/disp.m
+-rw-r--r--   0 runner    (1001) docker     (999)      216 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/getLocation.m
+-rw-r--r--   0 runner    (1001) docker     (999)      135 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/run.m
+-rw-r--r--   0 runner    (1001) docker     (999)      289 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/str.m
+-rw-r--r--   0 runner    (1001) docker     (999)      642 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/subsref.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.144255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/
+-rw-r--r--   0 runner    (1001) docker     (999)      492 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/MOxUnitTestNode.m
+-rw-r--r--   0 runner    (1001) docker     (999)      190 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/disp.m
+-rw-r--r--   0 runner    (1001) docker     (999)      202 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/getName.m
+-rw-r--r--   0 runner    (1001) docker     (999)      284 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestNode/str.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.148255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/
+-rw-r--r--   0 runner    (1001) docker     (999)      147 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/MOxUnitTestOutcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)      268 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getDuration.m
+-rw-r--r--   0 runner    (1001) docker     (999)      719 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getProgressStr.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2408 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getSummaryStr.m
+-rw-r--r--   0 runner    (1001) docker     (999)      112 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getTest.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.148255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/
+-rw-r--r--   0 runner    (1001) docker     (999)     1021 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/MOxUnitTestReport.m
+-rw-r--r--   0 runner    (1001) docker     (999)      413 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/addTestOutcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)      500 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/countTestOutcomes.m
+-rw-r--r--   0 runner    (1001) docker     (999)      361 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/disp.m
+-rw-r--r--   0 runner    (1001) docker     (999)      498 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getDuration.m
+-rw-r--r--   0 runner    (1001) docker     (999)       45 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getName.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1226 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getStatisticsStr.m
+-rw-r--r--   0 runner    (1001) docker     (999)      316 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getStream.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3808 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getSummaryStr.m
+-rw-r--r--   0 runner    (1001) docker     (999)       83 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getTestOutcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)      974 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getTestOutputStatistics.m
+-rw-r--r--   0 runner    (1001) docker     (999)      334 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getVerbosity.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1039 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/reportTestOutcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)      579 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/wasSuccessful.m
+-rw-r--r--   0 runner    (1001) docker     (999)      602 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/writeXML.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.152255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/
+-rw-r--r--   0 runner    (1001) docker     (999)      535 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/MOxUnitTestSuite.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1207 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromDirectory.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1276 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromFile.m
+-rw-r--r--   0 runner    (1001) docker     (999)      569 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromSuite.m
+-rw-r--r--   0 runner    (1001) docker     (999)      908 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addTest.m
+-rw-r--r--   0 runner    (1001) docker     (999)      334 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/countTestCases.m
+-rw-r--r--   0 runner    (1001) docker     (999)      244 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/countTestNodes.m
+-rw-r--r--   0 runner    (1001) docker     (999)      156 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/disp.m
+-rw-r--r--   0 runner    (1001) docker     (999)      383 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/getTestNode.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2386 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/run.m
+-rw-r--r--   0 runner    (1001) docker     (999)      836 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/setTestNode.m
+-rw-r--r--   0 runner    (1001) docker     (999)      329 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/str.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2420 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertElementsAlmostEqual.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2516 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertEqual.m
+-rw-r--r--   0 runner    (1001) docker     (999)       70 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertError.m
+-rw-r--r--   0 runner    (1001) docker     (999)     6104 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertExceptionThrown.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1538 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertFalse.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1834 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertGreaterThan.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1782 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertLessThan.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1983 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertNotEqual.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1530 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertTrue.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2927 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertVectorsAlmostEqual.m
+-rw-r--r--   0 runner    (1001) docker     (999)     6911 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertWarning.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5854 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/initTestSuite.m
+-rw-r--r--   0 runner    (1001) docker     (999)    13051 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/moxunit_runtests.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1561 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/moxunit_set_path.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.152255 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/
+-rw-r--r--   0 runner    (1001) docker     (999)     1093 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_isa_test_skipped_exception.m
+-rw-r--r--   0 runner    (1001) docker     (999)      671 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_throw_test_skipped_exception.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5006 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_elem2str.m
+-rw-r--r--   0 runner    (1001) docker     (999)      995 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_escape_xml.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1958 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_find_files.m
+-rw-r--r--   0 runner    (1001) docker     (999)     6081 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_floats_almost_equal.m
+-rw-r--r--   0 runner    (1001) docker     (999)      384 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_get_test_name_regexp.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1454 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_input2str.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1623 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_is_message_identifier.m
+-rw-r--r--   0 runner    (1001) docker     (999)      484 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_is_test_function_name.m
+-rw-r--r--   0 runner    (1001) docker     (999)      978 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_isfolder.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3250 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_mfile_subfunctions.m
+-rw-r--r--   0 runner    (1001) docker     (999)      502 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_is_octave.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1585 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_supports.m
+-rw-r--r--   0 runner    (1001) docker     (999)      526 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_version.m
+-rw-r--r--   0 runner    (1001) docker     (999)      629 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_regexp_matches.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2137 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_remove_matlab_anchor_tag.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1197 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_stack2str.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2555 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_strjoin.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5023 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/Makefile
+-rw-r--r--   0 runner    (1001) docker     (999)    13738 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/README.md
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.160255 idyntree-9.1.1.dev7/extern/MOxUnit/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)     2848 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_elements_almost_equal.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1064 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_equal.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5031 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_exception_thrown.m
+-rw-r--r--   0 runner    (1001) docker     (999)      839 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_false.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1917 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_greater_than.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1809 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_less_than.m
+-rw-r--r--   0 runner    (1001) docker     (999)      818 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_not_equal.m
+-rw-r--r--   0 runner    (1001) docker     (999)      830 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_true.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3197 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_vectors_almost_equal.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4782 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_warning.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2397 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_function_handle_test_case.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3337 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_matlab_unittest_test_wrapper_suite.m
+-rw-r--r--   0 runner    (1001) docker     (999)      730 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_isa_test_skipped_exception.m
+-rw-r--r--   0 runner    (1001) docker     (999)     9856 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_runtests.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1295 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_set_path.m
+-rw-r--r--   0 runner    (1001) docker     (999)     5085 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_elem2str.m
+-rw-r--r--   0 runner    (1001) docker     (999)      702 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_escape_xml.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3613 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_find_files.m
+-rw-r--r--   0 runner    (1001) docker     (999)      987 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_get_test_name_regexp.m
+-rw-r--r--   0 runner    (1001) docker     (999)      828 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_input2str.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2402 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_is_message_identifier.m
+-rw-r--r--   0 runner    (1001) docker     (999)      714 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_isfolder.m
+-rw-r--r--   0 runner    (1001) docker     (999)     6454 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_mfile_subfunctions.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1434 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_platform_supports.m
+-rw-r--r--   0 runner    (1001) docker     (999)      850 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_platform_version.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1999 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_regexp_matches.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1655 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_remove_matlab_anchor_tag.m
+-rw-r--r--   0 runner    (1001) docker     (999)     2613 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_stack2str.m
+-rw-r--r--   0 runner    (1001) docker     (999)     1071 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_strjoin.m
+-rw-r--r--   0 runner    (1001) docker     (999)      691 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_case.m
+-rw-r--r--   0 runner    (1001) docker     (999)      472 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_node.m
+-rw-r--r--   0 runner    (1001) docker     (999)     3556 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_outcome.m
+-rw-r--r--   0 runner    (1001) docker     (999)     8285 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_report.m
+-rw-r--r--   0 runner    (1001) docker     (999)     4394 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_suite.m
+-rw-r--r--   0 runner    (1001) docker     (999)      973 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_testcase_class.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.160255 idyntree-9.1.1.dev7/extern/MOxUnit/tools/
+-rw-r--r--   0 runner    (1001) docker     (999)     7233 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tools/fix_mfile_test_init.py
+-rw-r--r--   0 runner    (1001) docker     (999)     5432 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/MOxUnit/tools/matlab_tokenizer.py
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.160255 idyntree-9.1.1.dev7/extern/fpconv/
+-rw-r--r--   0 runner    (1001) docker     (999)     8263 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/fpconv/fpconv.c
+-rw-r--r--   0 runner    (1001) docker     (999)     2002 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/fpconv/fpconv.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4980 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/fpconv/powers.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.160255 idyntree-9.1.1.dev7/extern/mesh2tri/
+-rw-r--r--   0 runner    (1001) docker     (999)     1313 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/mesh2tri/license.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     3736 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/extern/mesh2tri/mesh2tri.m
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.160255 idyntree-9.1.1.dev7/idyntree.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (999)    14663 2023-09-01 07:53:03.000000 idyntree-9.1.1.dev7/idyntree.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (999)    52160 2023-09-01 07:53:04.000000 idyntree-9.1.1.dev7/idyntree.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (999)        1 2023-09-01 07:53:03.000000 idyntree-9.1.1.dev7/idyntree.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (999)       67 2023-09-01 07:53:03.000000 idyntree-9.1.1.dev7/idyntree.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (999)        1 2023-09-01 07:53:03.000000 idyntree-9.1.1.dev7/idyntree.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (999)        6 2023-09-01 07:53:03.000000 idyntree-9.1.1.dev7/idyntree.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (999)       16 2023-09-01 07:53:03.000000 idyntree-9.1.1.dev7/idyntree.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (999)      281 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (999)     1492 2023-09-01 07:53:04.232256 idyntree-9.1.1.dev7/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (999)     1293 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.160255 idyntree-9.1.1.dev7/src/
+-rw-r--r--   0 runner    (1001) docker     (999)     1096 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.160255 idyntree-9.1.1.dev7/src/core/
+-rw-r--r--   0 runner    (1001) docker     (999)     7903 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/core/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/core/include/iDynTree/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.168255 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/
+-rw-r--r--   0 runner    (1001) docker     (999)     4788 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/ArticulatedBodyInertia.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4459 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Axis.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2508 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/ClassicalAcc.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1488 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/CubicSpline.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3031 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Direction.h
+-rw-r--r--   0 runner    (1001) docker     (999)    15057 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/EigenHelpers.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2707 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/EigenMathHelpers.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3712 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/EigenSparseHelpers.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1791 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/GeomVector3.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2527 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/InertiaNonLinearParametrization.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7613 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/MatrixDynSize.h
+-rw-r--r--   0 runner    (1001) docker     (999)    11807 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/MatrixFixSize.h
+-rw-r--r--   0 runner    (1001) docker     (999)    11058 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/MatrixView.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3552 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Position.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2368 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/PositionRaw.h
+-rw-r--r--   0 runner    (1001) docker     (999)      606 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/PrivatePreProcessorUtils.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3875 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/PrivateUtils.h
+-rw-r--r--   0 runner    (1001) docker     (999)    20434 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Rotation.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4404 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/RotationRaw.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1756 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/RotationalInertiaRaw.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3929 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SO3Utils.h
+-rw-r--r--   0 runner    (1001) docker     (999)    26300 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Span.h
+-rw-r--r--   0 runner    (1001) docker     (999)    12610 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SparseMatrix.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1431 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialAcc.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2389 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialForceVector.h
+-rw-r--r--   0 runner    (1001) docker     (999)    10206 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialInertia.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3770 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialInertiaRaw.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1367 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialMomentum.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4743 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialMotionVector.h
+-rw-r--r--   0 runner    (1001) docker     (999)    12288 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialVector.h
+-rw-r--r--   0 runner    (1001) docker     (999)    13816 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/TestUtils.h
+-rw-r--r--   0 runner    (1001) docker     (999)    19395 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Transform.h
+-rw-r--r--   0 runner    (1001) docker     (999)     9679 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/TransformDerivative.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5886 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Triplets.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1254 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Twist.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4034 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Utils.h
+-rw-r--r--   0 runner    (1001) docker     (999)     8480 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/VectorDynSize.h
+-rw-r--r--   0 runner    (1001) docker     (999)    11505 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/VectorFixSize.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1033 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Wrench.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.172255 idyntree-9.1.1.dev7/src/core/src/
+-rw-r--r--   0 runner    (1001) docker     (999)     8844 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/ArticulatedBodyInertia.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     8128 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Axis.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3292 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/ClassicalAcc.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7953 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/CubicSpline.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3173 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Direction.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3517 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/GeomVector3.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9372 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/InertiaNonLinearParametrization.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9303 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/MatrixDynSize.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5301 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Position.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4033 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/PositionRaw.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1005 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/PrivateUtils.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    20782 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Rotation.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     6252 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/RotationRaw.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1069 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/RotationalInertiaRaw.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     6232 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/SO3Utils.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    31015 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/SparseMatrix.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1139 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/SpatialAcc.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1414 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/SpatialForceVector.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9886 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/SpatialInertia.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5616 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/SpatialInertiaRaw.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1242 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/SpatialMomentum.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3600 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/SpatialMotionVector.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4355 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/TestUtils.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    15559 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Transform.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     8397 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/TransformDerivative.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5200 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Triplets.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1430 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Twist.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2860 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Utils.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     6417 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/VectorDynSize.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1020 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/src/Wrench.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.172255 idyntree-9.1.1.dev7/src/core/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)     5365 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/ArticulatedBodyInertiaUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5706 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/AxisUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1996 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     2936 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/CubicSplineUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1103 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/DirectionUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2635 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/EigenHelpersUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2859 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/EigenSparseHelpersUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1481 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/ExpLogUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2523 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/MatrixDynSizeUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1952 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/MatrixViewUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1073 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/PrivateUtilsUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9196 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/RotationUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4647 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/SO3UtilsUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    38055 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/SpanUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9424 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/SparseMatrixUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1367 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/SpatialAccUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    18170 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/SpatialInertiaUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      850 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/SpatialToEigenCompilationErrorTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1601 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/TransformFromMatrix4x4UnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1224 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/TwistUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1507 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/VectorDynSizeUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1831 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/core/tests/WrenchUnitTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.176255 idyntree-9.1.1.dev7/src/estimation/
+-rw-r--r--   0 runner    (1001) docker     (999)     4603 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/estimation/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.176255 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/
+-rw-r--r--   0 runner    (1001) docker     (999)    11588 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/AttitudeEstimator.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5666 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/AttitudeEstimatorUtils.h
+-rw-r--r--   0 runner    (1001) docker     (999)     8706 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/AttitudeMahonyFilter.h
+-rw-r--r--   0 runner    (1001) docker     (999)    20246 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/AttitudeQuaternionEKF.h
+-rw-r--r--   0 runner    (1001) docker     (999)    30601 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/BerdyHelper.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3678 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/BerdySparseMAPSolver.h
+-rw-r--r--   0 runner    (1001) docker     (999)     6418 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/BipedFootContactClassifier.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4633 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/ContactStateMachine.h
+-rw-r--r--   0 runner    (1001) docker     (999)    14296 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h
+-rw-r--r--   0 runner    (1001) docker     (999)    18627 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/ExtendedKalmanFilter.h
+-rw-r--r--   0 runner    (1001) docker     (999)    18131 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/ExternalWrenchesEstimation.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5506 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/GravityCompensationHelpers.h
+-rw-r--r--   0 runner    (1001) docker     (999)    11373 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/KalmanFilter.h
+-rw-r--r--   0 runner    (1001) docker     (999)     6835 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/SchmittTrigger.h
+-rw-r--r--   0 runner    (1001) docker     (999)     9600 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/SimpleLeggedOdometry.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.180256 idyntree-9.1.1.dev7/src/estimation/src/
+-rw-r--r--   0 runner    (1001) docker     (999)      431 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/AttitudeEstimator.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5312 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/AttitudeEstimatorUtils.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    11926 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/AttitudeMahonyFilter.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    23833 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/AttitudeQuaternionEKF.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    97647 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/BerdyHelper.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    18395 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/BerdySparseMAPSolver.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4628 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/BipedFootContactClassifier.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1685 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/ContactStateMachine.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    17737 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/ExtWrenchesAndJointTorquesEstimator.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9552 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/ExtendedKalmanFilter.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    38574 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/ExternalWrenchesEstimation.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7320 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/GravityCompensationHelpers.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9349 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/KalmanFilter.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3042 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/SchmittTrigger.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    11304 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/src/SimpleLeggedOdometry.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.180256 idyntree-9.1.1.dev7/src/estimation/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)     4974 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/tests/AttitudeEstimatorUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    16907 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/tests/BerdyHelperUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      808 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/tests/BerdyMAPSolverUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1145 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     8174 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/tests/ExtWrenchesAndJointTorquesEstimatorUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    13792 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/tests/ExternalWrenchesEstimationUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4218 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/tests/KalmanFilterUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3851 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/estimation/tests/SimpleLeggedOdometryUnitTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.180256 idyntree-9.1.1.dev7/src/high-level/
+-rw-r--r--   0 runner    (1001) docker     (999)     1864 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/high-level/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/high-level/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.180256 idyntree-9.1.1.dev7/src/high-level/include/iDynTree/
+-rw-r--r--   0 runner    (1001) docker     (999)    62049 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/high-level/include/iDynTree/KinDynComputations.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.180256 idyntree-9.1.1.dev7/src/high-level/src/
+-rw-r--r--   0 runner    (1001) docker     (999)   117206 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/high-level/src/KinDynComputations.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.180256 idyntree-9.1.1.dev7/src/high-level/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      722 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/high-level/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)    19752 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/high-level/tests/KinDynComputationsMatrixViewAndSpanUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    36387 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/high-level/tests/KinDynComputationsUnitTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.180256 idyntree-9.1.1.dev7/src/icub/
+-rw-r--r--   0 runner    (1001) docker     (999)     1611 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/icub/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/icub/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.184255 idyntree-9.1.1.dev7/src/icub/include/iDynTree/
+-rw-r--r--   0 runner    (1001) docker     (999)     2334 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/icub/include/iDynTree/iKinConversions.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3977 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/icub/include/iDynTree/iKinConversionsImplementation.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7051 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/icub/include/iDynTree/skinDynLibConversions.h
+-rw-r--r--   0 runner    (1001) docker     (999)    15812 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/icub/include/iDynTree/skinDynLibConversionsImplementation.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.184255 idyntree-9.1.1.dev7/src/inverse-kinematics/
+-rw-r--r--   0 runner    (1001) docker     (999)     2685 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/inverse-kinematics/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.184255 idyntree-9.1.1.dev7/src/inverse-kinematics/include/iDynTree/
+-rw-r--r--   0 runner    (1001) docker     (999)     4885 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/include/iDynTree/BoundingBoxHelpers.h
+-rw-r--r--   0 runner    (1001) docker     (999)     8214 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/include/iDynTree/ConvexHullHelpers.h
+-rw-r--r--   0 runner    (1001) docker     (999)    51006 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/include/iDynTree/InverseKinematics.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.184255 idyntree-9.1.1.dev7/src/inverse-kinematics/include/private/
+-rw-r--r--   0 runner    (1001) docker     (999)    12138 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/include/private/InverseKinematicsData.h
+-rw-r--r--   0 runner    (1001) docker     (999)    18983 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/include/private/InverseKinematicsNLP.h
+-rw-r--r--   0 runner    (1001) docker     (999)     9199 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/include/private/TransformConstraint.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.184255 idyntree-9.1.1.dev7/src/inverse-kinematics/src/
+-rw-r--r--   0 runner    (1001) docker     (999)     6453 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/src/BoundingBoxHelpers.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    12748 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/src/ConvexHullHelpers.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    53777 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/src/InverseKinematics.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    24268 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/src/InverseKinematicsData.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    87952 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/src/InverseKinematicsNLP.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5242 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/src/TransformConstraint.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.184255 idyntree-9.1.1.dev7/src/inverse-kinematics/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      638 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     6249 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/tests/ConvexHullHelpersUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    28513 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/tests/InverseKinematicsMatrixViewAndSpanUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    27615 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/tests/InverseKinematicsUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7103 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/inverse-kinematics/tests/iKinVersusLegacyTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.184255 idyntree-9.1.1.dev7/src/model/
+-rw-r--r--   0 runner    (1001) docker     (999)     5834 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/model/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.064254 idyntree-9.1.1.dev7/src/model/include/iDynTree/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.188256 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/
+-rw-r--r--   0 runner    (1001) docker     (999)      721 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Centroidal.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4859 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/ContactWrench.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5912 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/DenavitHartenberg.h
+-rw-r--r--   0 runner    (1001) docker     (999)    10539 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Dynamics.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3526 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/DynamicsLinearization.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2355 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/DynamicsLinearizationHelpers.h
+-rw-r--r--   0 runner    (1001) docker     (999)      867 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/DynamicsUtils.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7873 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/FixedJoint.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7436 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/ForwardKinematics.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2688 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/FreeFloatingMatrices.h
+-rw-r--r--   0 runner    (1001) docker     (999)     6543 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/FreeFloatingState.h
+-rw-r--r--   0 runner    (1001) docker     (999)    19647 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/IJoint.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1429 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Indices.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2018 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Jacobians.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3229 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/JointState.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2000 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Link.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7278 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/LinkState.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2136 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/LinkTraversalsCache.h
+-rw-r--r--   0 runner    (1001) docker     (999)    23325 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Model.h
+-rw-r--r--   0 runner    (1001) docker     (999)     6715 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/ModelTestUtils.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4374 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/ModelTransformers.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5992 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/MovableJointImpl.h
+-rw-r--r--   0 runner    (1001) docker     (999)     9410 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/PrismaticJoint.h
+-rw-r--r--   0 runner    (1001) docker     (999)     9839 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/RevoluteJoint.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7653 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/SolidShapes.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5119 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/SubModel.h
+-rw-r--r--   0 runner    (1001) docker     (999)     8272 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Traversal.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.192256 idyntree-9.1.1.dev7/src/model/src/
+-rw-r--r--   0 runner    (1001) docker     (999)     4266 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/ContactWrench.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    31099 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/DenavitHartenberg.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    25277 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/Dynamics.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    38397 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/DynamicsLinearization.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1422 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/DynamicsLinearizationHelpers.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     8548 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/FixedJoint.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    12096 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/ForwardKinematics.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2261 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/FreeFloatingMatrices.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3954 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/FreeFloatingState.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      727 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/Indices.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2233 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/Jacobians.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3504 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/JointState.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      862 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/Link.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7446 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/LinkState.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1506 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/LinkTraversalsCache.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    30070 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/Model.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      709 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/ModelInterfaceDestructors.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    27375 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/ModelTransformers.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    13633 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/PrismaticJoint.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    14021 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/RevoluteJoint.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    10966 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/SolidShapes.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9761 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/SubModel.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5633 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/src/Traversal.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.192256 idyntree-9.1.1.dev7/src/model/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      872 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)      547 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/tests/ForwardKinematicsUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5984 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/tests/JointUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1237 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/tests/LinkUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    15254 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model/tests/ModelUnitTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.192256 idyntree-9.1.1.dev7/src/model_io/
+-rw-r--r--   0 runner    (1001) docker     (999)      518 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.196256 idyntree-9.1.1.dev7/src/model_io/codecs/
+-rw-r--r--   0 runner    (1001) docker     (999)     4584 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/model_io/codecs/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.196256 idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/
+-rw-r--r--   0 runner    (1001) docker     (999)     3582 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/ModelCalibrationHelper.h
+-rw-r--r--   0 runner    (1001) docker     (999)     6567 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/ModelExporter.h
+-rw-r--r--   0 runner    (1001) docker     (999)     8920 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/ModelLoader.h
+-rw-r--r--   0 runner    (1001) docker     (999)      982 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/URDFDofsImport.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.196256 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/
+-rw-r--r--   0 runner    (1001) docker     (999)     1588 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/ForceTorqueSensorElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1134 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/GeometryElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1165 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/InertialElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2380 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/JointElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1670 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/LinkElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1473 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/MaterialElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1057 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/OriginElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2327 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/RobotElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3082 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/SensorElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2241 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/URDFDocument.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1839 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/URDFModelExport.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4917 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/URDFParsingUtils.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1790 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/include/private/VisualElement.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.200256 idyntree-9.1.1.dev7/src/model_io/codecs/src/
+-rw-r--r--   0 runner    (1001) docker     (999)     5965 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/ForceTorqueSensorElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     6111 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/GeometryElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4833 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/InertialElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9479 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/JointElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3101 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/LinkElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2798 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/MaterialElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4149 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/ModelCalibrationHelper.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3099 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/ModelExporter.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7449 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/ModelLoader.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1609 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/OriginElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4272 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/RobotElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5830 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/SensorElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    17747 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/URDFDocument.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1677 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/URDFDofsImport.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    25303 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/URDFModelExport.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2211 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/src/VisualElement.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.200256 idyntree-9.1.1.dev7/src/model_io/codecs/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)     1132 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     2128 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/tests/ModelCalibrationHelperUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9850 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/tests/ModelExporterUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5902 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/tests/PredictSensorsMeasurementUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2389 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/tests/URDFGenericSensorImportUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9297 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/tests/URDFModelImportUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2867 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/codecs/tests/icubSensorURDFUnitTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/model_io/tests/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/model_io/tests/format_examples/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.200256 idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/
+-rw-r--r--   0 runner    (1001) docker     (999)     1181 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/double_root.xml
+-rw-r--r--   0 runner    (1001) docker     (999)      628 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/invalid_schema.xml
+-rw-r--r--   0 runner    (1001) docker     (999)      601 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/invalid_xml.xml
+-rw-r--r--   0 runner    (1001) docker     (999)     1155 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/schema.xsd
+-rw-r--r--   0 runner    (1001) docker     (999)      614 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/valid.xml
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.200256 idyntree-9.1.1.dev7/src/model_io/xml/
+-rw-r--r--   0 runner    (1001) docker     (999)     2659 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/model_io/xml/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.200256 idyntree-9.1.1.dev7/src/model_io/xml/include/iDynTree/
+-rw-r--r--   0 runner    (1001) docker     (999)     1286 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/include/iDynTree/XMLAttribute.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1621 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/include/iDynTree/XMLDocument.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4865 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/include/iDynTree/XMLElement.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7014 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/include/iDynTree/XMLParser.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.204256 idyntree-9.1.1.dev7/src/model_io/xml/src/
+-rw-r--r--   0 runner    (1001) docker     (999)     1622 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/src/XMLAttribute.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1760 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/src/XMLDocument.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5250 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/src/XMLElement.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    19135 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/src/XMLParser.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.204256 idyntree-9.1.1.dev7/src/model_io/xml/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      868 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     2383 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/model_io/xml/tests/XMLParserUnitTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.204256 idyntree-9.1.1.dev7/src/optimalcontrol/
+-rw-r--r--   0 runner    (1001) docker     (999)     5947 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/optimalcontrol/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.208256 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/
+-rw-r--r--   0 runner    (1001) docker     (999)    15911 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Constraint.h
+-rw-r--r--   0 runner    (1001) docker     (999)    18694 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/ConstraintsGroup.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3258 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/ControlledDynamicalSystem.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2477 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Controller.h
+-rw-r--r--   0 runner    (1001) docker     (999)     9811 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Cost.h
+-rw-r--r--   0 runner    (1001) docker     (999)    13284 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/DynamicalSystem.h
+-rw-r--r--   0 runner    (1001) docker     (999)    13263 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrator.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.208256 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/
+-rw-r--r--   0 runner    (1001) docker     (999)     1679 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/FixedStepIntegrator.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4877 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/ForwardEuler.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4997 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/ImplicitTrapezoidal.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1801 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/RK4.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5355 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/L2NormCost.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5382 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/LinearConstraint.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1918 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/LinearCost.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1020 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/LinearMPC.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4819 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/LinearSystem.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1249 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/MPC.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1230 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/MultiBodySystem.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.208256 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OCSolvers/
+-rw-r--r--   0 runner    (1001) docker     (999)     3250 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OCSolvers/MultipleShootingSolver.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1017 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OptimalControl.h
+-rw-r--r--   0 runner    (1001) docker     (999)    13737 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OptimalControlProblem.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1410 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OptimalControlSolver.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4435 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OptimizationProblem.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2173 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizer.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.208256 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/
+-rw-r--r--   0 runner    (1001) docker     (999)     2934 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/AlglibInterface.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2724 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/IpoptInterface.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3476 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/OsqpInterface.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2732 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/WorhpInterface.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2543 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/QuadraticCost.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5008 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/QuadraticLikeCost.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2172 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/SparsityStructure.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1045 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/SystemLineariser.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1783 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/TimeRange.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3158 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/TimeVaryingObject.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.212256 idyntree-9.1.1.dev7/src/optimalcontrol/src/
+-rw-r--r--   0 runner    (1001) docker     (999)    19486 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/AlglibInterface.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3882 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/AlglibInterfaceNotImplemented.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     6104 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/Constraint.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    44290 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/ConstraintsGroup.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    11409 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/ControlledDynamicalSystem.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1000 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/Controller.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3625 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/Cost.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4844 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/DynamicalSystem.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4116 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/FixedStepIntegrator.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    19333 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/ForwardEuler.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    22508 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/ImplicitTrapezoidal.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9373 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/Integrator.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    34398 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/IpoptInterface.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4648 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/IpoptInterfaceNotImplemented.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    25060 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/L2NormCost.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    13200 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/LinearConstraint.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3342 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/LinearCost.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)        0 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/LinearMPC.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    12095 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/LinearSystem.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      593 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/MPC.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      605 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/MultiBodySystem.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)   130030 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/MultipleShootingSolver.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    75733 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/OptimalControlProblem.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2219 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/OptimalControlSolver.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5954 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/OptimizationProblem.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2224 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/Optimizer.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    40063 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/OsqpInterface.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3119 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/OsqpInterfaceNotImplemented.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     6156 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/QuadraticCost.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    19154 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/QuadraticLikeCost.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4852 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/RK4.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4977 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/SparsityStructure.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)      606 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/SystemLineariser.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4025 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/TimeRange.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1764 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/TimeVaryingObject.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    34743 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/WorhpInterface.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4651 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/src/WorhpInterfaceNotImplemented.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.216256 idyntree-9.1.1.dev7/src/optimalcontrol/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)     7140 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/AlglibInterfaceTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1260 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     3562 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/ConstraintsGroupTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     9123 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/IntegratorsTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7505 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/IpoptInterfaceTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2790 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/L2NormTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5621 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/LinearOCOsqpTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    21449 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/MultipleShootingTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    17937 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/OCProblemTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    12465 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/OptimalControlIpoptTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1037 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/OptimalControlTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7575 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/optimalcontrol/tests/WorhpInterfaceTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.216256 idyntree-9.1.1.dev7/src/sensors/
+-rw-r--r--   0 runner    (1001) docker     (999)     2928 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/sensors/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.216256 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/
+-rw-r--r--   0 runner    (1001) docker     (999)     3215 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/AccelerometerSensor.h
+-rw-r--r--   0 runner    (1001) docker     (999)      683 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/AllSensorsTypes.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3085 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/GyroscopeSensor.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1049 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/ModelSensorsTransformers.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5465 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/PredictSensorsMeasurements.h
+-rw-r--r--   0 runner    (1001) docker     (999)    19205 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/Sensors.h
+-rw-r--r--   0 runner    (1001) docker     (999)     9038 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/SixAxisForceTorqueSensor.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3411 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4861 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.220256 idyntree-9.1.1.dev7/src/sensors/src/
+-rw-r--r--   0 runner    (1001) docker     (999)     4058 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/src/AccelerometerSensor.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3710 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/src/GyroscopeSensor.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    11442 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/src/ModelSensorsTransformers.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     6113 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/src/PredictSensorsMeasurements.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    34730 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/src/Sensors.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    13613 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/src/SixAxisForceTorqueSensor.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     4178 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/src/ThreeAxisAngularAccelerometerSensor.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     6424 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/src/ThreeAxisForceTorqueContactSensor.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.220256 idyntree-9.1.1.dev7/src/sensors/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      713 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     9572 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/tests/ReducedModelWithFTUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7293 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/tests/SensorsListUnitTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2524 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/sensors/tests/ThreeAxisForceTorqueContactSensorUnitTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.220256 idyntree-9.1.1.dev7/src/solid-shapes/
+-rw-r--r--   0 runner    (1001) docker     (999)     2332 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/solid-shapes/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/solid-shapes/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.220256 idyntree-9.1.1.dev7/src/solid-shapes/include/iDynTree/
+-rw-r--r--   0 runner    (1001) docker     (999)     2639 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/solid-shapes/include/iDynTree/InertialParametersSolidShapesHelpers.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1587 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/solid-shapes/include/iDynTree/ModelTransformersSolidShapes.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.220256 idyntree-9.1.1.dev7/src/solid-shapes/src/
+-rw-r--r--   0 runner    (1001) docker     (999)    13545 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/solid-shapes/src/InertialParametersSolidShapesHelpers.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2317 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/solid-shapes/src/ModelTransformersSolidShapes.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.220256 idyntree-9.1.1.dev7/src/solid-shapes/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      920 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/solid-shapes/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     3838 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/solid-shapes/tests/InertialParametersSolidShapesHelpersIntegrationTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2397 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/solid-shapes/tests/ModelTransformersSolidShapesIntegrationTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.220256 idyntree-9.1.1.dev7/src/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      932 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.220256 idyntree-9.1.1.dev7/src/tests/benchmark/
+-rw-r--r--   0 runner    (1001) docker     (999)      727 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/benchmark/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     6735 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/benchmark/DynamicsBenchmark.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.224256 idyntree-9.1.1.dev7/src/tests/data/
+-rw-r--r--   0 runner    (1001) docker     (999)     1624 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)    48061 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/bigman.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)     2759 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/cube.stl
+-rw-r--r--   0 runner    (1001) docker     (999)     1321 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/frame.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)    66355 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/iCubDarmstadt01.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)    66496 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/iCubGenova02.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)     8301 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/icalibrate.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)    47566 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/icub.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)    63947 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/icub2BB5Sea.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)     4077 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/icubTwoLinks.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)    52742 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/icub_model.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)    60226 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/icub_sensorised.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)    54040 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/icub_skin_frames.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)     2035 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/oneLink.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)      901 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/robotModelTestTwoLinks.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)      494 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/simple_model.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)     1557 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/testModels.h.in
+-rw-r--r--   0 runner    (1001) docker     (999)     2673 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/threeLinks.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)     1351 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/twoLinks.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)     1213 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/twoLinksFixed.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)      888 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/twoLinksRotationOnZAxis.urdf
+-rw-r--r--   0 runner    (1001) docker     (999)     1191 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/data/twoLinksWithoutBaseSensors.urdf
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.224256 idyntree-9.1.1.dev7/src/tests/icub_consistency/
+-rw-r--r--   0 runner    (1001) docker     (999)     1126 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/icub_consistency/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)    22401 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/icub_consistency/iCubExternalWrenchesEstimationConsistencyTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     5217 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/icub_consistency/iKinConsistencyTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.228256 idyntree-9.1.1.dev7/src/tests/integration/
+-rw-r--r--   0 runner    (1001) docker     (999)     2800 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/integration/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     7560 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/integration/DenavitHartenbergIntegrationTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     7251 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/integration/DynamicsIntegrationTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    23665 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/integration/DynamicsLinearizationIntegrationTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2583 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/integration/InertialParametersSolidShapesHelpersIntegrationTest.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    19314 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/integration/iCubTorqueEstimationIntegrationTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.228256 idyntree-9.1.1.dev7/src/tests/yarp_benchmark/
+-rw-r--r--   0 runner    (1001) docker     (999)      689 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/yarp_benchmark/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     4198 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tests/yarp_benchmark/PseudoInverseBenchmark.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.228256 idyntree-9.1.1.dev7/src/tools/
+-rw-r--r--   0 runner    (1001) docker     (999)     1370 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tools/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)    18829 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tools/cmdline.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5422 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tools/idyntree-model-info.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2390 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tools/idyntree-model-simplify-shapes.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2012 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tools/idyntree-model-view.cpp
+-rwxr-xr-x   0 runner    (1001) docker     (999)     5700 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/tools/idyntree-normalize-collada-meshes.py
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.228256 idyntree-9.1.1.dev7/src/visualization/
+-rw-r--r--   0 runner    (1001) docker     (999)     5502 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.068254 idyntree-9.1.1.dev7/src/visualization/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.228256 idyntree-9.1.1.dev7/src/visualization/include/iDynTree/
+-rw-r--r--   0 runner    (1001) docker     (999)     2808 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/include/iDynTree/MeshcatVisualizer.h
+-rw-r--r--   0 runner    (1001) docker     (999)    26984 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/include/iDynTree/Visualizer.h
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.232256 idyntree-9.1.1.dev7/src/visualization/src/
+-rw-r--r--   0 runner    (1001) docker     (999)     3369 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Camera.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1253 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Camera.h
+-rw-r--r--   0 runner    (1001) docker     (999)    10324 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/CameraAnimator.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     3274 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/CameraAnimator.h
+-rw-r--r--   0 runner    (1001) docker     (999)     8140 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/DummyImplementations.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5335 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Environment.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1639 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Environment.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2089 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/FloorGridSceneNode.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1124 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/FloorGridSceneNode.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3409 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/FrameVisualization.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1712 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/FrameVisualization.h
+-rw-r--r--   0 runner    (1001) docker     (999)    16551 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/IrrlichtUtils.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5244 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/JetsVisualization.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1892 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/JetsVisualization.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3667 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Label.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1617 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Label.h
+-rw-r--r--   0 runner    (1001) docker     (999)     5303 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Light.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1410 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Light.h
+-rw-r--r--   0 runner    (1001) docker     (999)    10180 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/MeshcatVisualizer.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)    19350 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/ModelVisualization.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2247 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/ModelVisualization.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7183 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Texture.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1585 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Texture.h
+-rw-r--r--   0 runner    (1001) docker     (999)     4314 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/TexturesHandler.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     1712 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/TexturesHandler.h
+-rw-r--r--   0 runner    (1001) docker     (999)     8038 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/VectorsVisualization.cpp
+-rw-r--r--   0 runner    (1001) docker     (999)     2917 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/VectorsVisualization.h
+-rw-r--r--   0 runner    (1001) docker     (999)    28315 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/src/Visualizer.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.232256 idyntree-9.1.1.dev7/src/visualization/tests/
+-rw-r--r--   0 runner    (1001) docker     (999)      898 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (999)     8622 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/visualization/tests/VisualizerUnitTest.cpp
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.232256 idyntree-9.1.1.dev7/src/yarp/
+-rw-r--r--   0 runner    (1001) docker     (999)     1641 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/yarp/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.072254 idyntree-9.1.1.dev7/src/yarp/include/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.072254 idyntree-9.1.1.dev7/src/yarp/include/iDynTree/
+drwxr-xr-x   0 runner    (1001) docker     (999)        0 2023-09-01 07:53:04.232256 idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/
+-rw-r--r--   0 runner    (1001) docker     (999)     1014 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPConfigurationsLoader.h
+-rw-r--r--   0 runner    (1001) docker     (999)     1418 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPConfigurationsLoaderImplementation.h
+-rw-r--r--   0 runner    (1001) docker     (999)     7506 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPConversions.h
+-rw-r--r--   0 runner    (1001) docker     (999)     3900 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPConversionsImplementation.h
+-rw-r--r--   0 runner    (1001) docker     (999)     2399 2023-09-01 07:52:24.000000 idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPEigenConversions.h
```

### Comparing `idyntree-9.1.1.dev66/.github/workflows/ci.yml` & `idyntree-9.1.1.dev7/.github/workflows/ci.yml`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-name: CI Workflow
+name: C++ CI Workflow
 
 on:
   push:
   pull_request:
   schedule:
   # * is a special character in YAML so you have to quote this string
   # Execute a "nightly" build at 2 AM UTC
@@ -162,14 +162,15 @@
       matrix:
         build_type: [Release]
         os:
           - ubuntu-latest
         docker_image:
           - "ubuntu:20.04"
           - "ubuntu:22.04"
+          - "debian:sid"
 
     container:
       image: ${{ matrix.docker_image }}
 
     steps:
     - uses: actions/checkout@v3
```

### Comparing `idyntree-9.1.1.dev66/.github/workflows/gh-pages.yml` & `idyntree-9.1.1.dev7/.github/workflows/gh-pages.yml`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/.github/workflows/matlab.yml` & `idyntree-9.1.1.dev7/.github/workflows/matlab.yml`

 * *Files 10% similar despite different names*

```diff
@@ -16,15 +16,31 @@
       run:
         shell: bash -l {0}
     strategy:
       fail-fast: false
       matrix:
         build_type: [Release]
         os: [ubuntu-20.04, windows-2019, macos-latest]
-        matlab_version: [R2022a, R2022b, R2023a]
+        matlab_version: [R2020a, R2020b, R2021a, latest]
+        exclude:
+          # R2020* is not supported on Windows on GitHub Actions
+          - os: windows-2019
+            matlab_version: R2020a
+            build_type: Release
+          - os: windows-2019
+            matlab_version: R2020b
+            build_type: Release
+          # R2020* is not working on macOS
+          # See https://github.com/robotology/idyntree/issues/1015
+          - os: macos-latest
+            matlab_version: R2020a
+            build_type: Release
+          - os: macos-latest
+            matlab_version: R2020b
+            build_type: Release
 
     steps:
     - uses: actions/checkout@v2
 
     - uses: conda-incubator/setup-miniconda@v2
       with:
         miniforge-variant: Mambaforge
@@ -57,20 +73,14 @@
     - name: Dependencies [Conda/Windows]
       if: contains(matrix.os, 'windows')
       run: |
         # Additional dependencies only useful on Windows
         # See https://github.com/robotology/robotology-superbuild/issues/477
         mamba install vs2019_win-64
 
-    # Workaround for https://github.com/robotology/idyntree/issues/1109
-    - name: Dependencies [Conda/macOS]
-      if: contains(matrix.os, 'macos')
-      run: |
-        mamba install libblas=*=*netlib
-
     # workaround for https://github.com/robotology/robotology-superbuild/issues/64
     # and https://github.com/robotology/idyntree/issues/995
     - name: Do not use MATLAB's stdc++ to avoid incompatibilities with other libraries
       if: contains(matrix.os, 'ubuntu')
       run:
           echo "LD_PRELOAD=${CONDA_PREFIX}/lib/libstdc++.so.6" >> $GITHUB_ENV
```

### Comparing `idyntree-9.1.1.dev66/.github/workflows/python.yml` & `idyntree-9.1.1.dev7/.github/workflows/python.yml`

 * *Files 2% similar despite different names*

```diff
@@ -91,15 +91,15 @@
       - name: Install cibuildwheel
         run: pip install cibuildwheel
 
       - name: Build wheels
         run: python -m cibuildwheel --output-dir wheelhouse
         env:
           CIBW_BUILD_VERBOSITY: 1
-          CIBW_BUILD: cp37-*manylinux*_x86_64 cp38-*manylinux*_x86_64 cp39-*manylinux*_x86_64 cp310-*manylinux*_x86_64 cp311-*manylinux*_x86_64 cp312-*manylinux*_x86_64
+          CIBW_BUILD: cp37-*manylinux*_x86_64 cp38-*manylinux*_x86_64 cp39-*manylinux*_x86_64 cp310-*manylinux*_x86_64 cp311-*manylinux*_x86_64
           CIBW_MANYLINUX_X86_64_IMAGE: manylinux_2_28
           CIBW_ENVIRONMENT_LINUX: AUDITWHEEL_PLAT=manylinux_2_28_x86_64
           CIBW_BEFORE_BUILD_LINUX: |
             dnf update -y &&\
             dnf install -y eigen3-devel libxml2-devel
           CIBW_TEST_COMMAND: "python -c 'import idyntree.bindings'"
```

### Comparing `idyntree-9.1.1.dev66/.github/workflows/regenerate-matlab-bindings.yml` & `idyntree-9.1.1.dev7/.github/workflows/regenerate-matlab-bindings.yml`

 * *Files 4% similar despite different names*

```diff
@@ -30,15 +30,16 @@
             swig --help
 
         - name: Configure and compile iDynTree
           run: |
             sudo apt-get update
             sudo apt-get install \
             git build-essential cmake libace-dev coinor-libipopt-dev libeigen3-dev \
-            libxml2-dev liboctave-dev python-dev python3-numpy valgrind libassimp-dev libirrlicht-dev libglfw3-dev
+            qtbase5-dev qtdeclarative5-dev qtmultimedia5-dev libqt5charts5-dev \
+            libxml2-dev liboctave-dev python-dev python3-numpy valgrind libassimp-dev libirrlicht-dev
             which swig 
             swig --help
             # Remove autogenerate files to ensure that removed files are actually removed
             git rm -r bindings/matlab/autogenerated
             mkdir -p build
             cd build
             cmake -DIDYNTREE_USES_ASSIMP:BOOL=ON -DIDYNTREE_USES_IPOPT:BOOL=ON -DIDYNTREE_USES_IRRLICHT:BOOL=ON -DIDYNTREE_USES_OCTAVE:BOOL=ON -DIDYNTREE_GENERATE_MATLAB:BOOL=ON ..
```

### Comparing `idyntree-9.1.1.dev66/CHANGELOG.md` & `idyntree-9.1.1.dev7/CHANGELOG.md`

 * *Files 2% similar despite different names*

```diff
@@ -4,37 +4,22 @@
 The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
 
 ## [Unreleased Major]
 
 ## [Unreleased]
 
-## [10.0.0] - 2023-10-16
-
 ### Added
 
 - Added the possibility of exporting additional XML elements that are added as child of the `<robot>` element in URDF ModelExporter (https://github.com/robotology/idyntree/pull/1088).
 - Added support for reading and wrting joint friction and damping values from URDF files (https://github.com/robotology/idyntree/pull/1094).
 
 ### Changed
 
-- Since iDynTree 10, all the changes of iDynTree will go directly to the `master` branch, the `devel` branch will be deleted. Users that want to work with a stable version of iDynTree should use a tagged version of iDynTree .
-- The license of the library is changed to `BSD-3-Clause` (https://github.com/robotology/idyntree/pull/1089).
 - The `iDynTree::ModelExporterOptions` class was changed to be defined as a struct (https://github.com/robotology/idyntree/pull/1088).
-- The header structure has been shortened, from `<iDynTree/@component@/@headername@.h>` to `<iDynTree/@headername@.h>` (https://github.com/robotology/idyntree/pull/1104).
-- `iDynTree::idyntree-sensors` library has been merged in `iDynTree::idyntree-model` (https://github.com/robotology/idyntree/pull/1104).
-- The `iDynTree::Model` class gained a `m_sensors` attribute and `sensors()` method to access to it to store sensors information as part of the `iDynTree::Model` itself (https://github.com/robotology/idyntree/pull/1106).
-
-### Deprecated
-
-- Linking `iDynTree::idyntree-sensors` is deprecated, you can just link `iDynTree::idyntree-model` instead, or just search and replace `iDynTree::idyntree-sensors` with an empty string if you are already linking `iDynTree::idyntree-model` (https://github.com/robotology/idyntree/pull/1104).
-- Including `<iDynTree/Core/@headername@.h>`, `<iDynTree/Model/@headername@.h>`, `<iDynTree/Sensors/@headername@.h>`, `<iDynTree/ModelIO/@headername@.h>`, `<iDynTree/Estimation/@headername@.h>`, `<iDynTree/yarp/@headername@.h>` is deprecated, just include `<iDynTree/@headername@.h>` . To perform this migration, just search and replace `<iDynTree/Core/` with `<iDynTree/`, `<iDynTree/Model/` with `<iDynTree/`, `<iDynTree/Sensors/` with `<iDynTree/`, `<iDynTree/ModelIO/` with `<iDynTree/`, `<iDynTree/Estimation/` with `<iDynTree/`, `<iDynTree/yarp/` with `<iDynTree/` (https://github.com/robotology/idyntree/pull/1104).
-- Several methods that take in input both a `iDynTree::Model` and a `iDynTree::SensorsList` have been deprecated, users are suggested to call the variant that takes in input only the `iDynTree::Model`, if necessary by populating correctly the sensors of the `iDynTree::Model` via the `iDynTree::Model::sensors` method (https://github.com/robotology/idyntree/pull/1106).
-- Several classes that ended in `Raw` are deprecated, and in their place their non-Raw counterpart should be used. In particular, the pair "deprecated"/"replacement"  is : `iDynTree::PositionRaw`/`iDynTree::Position`, `iDynTree::RotationRaw`/`iDynTree::Rotation`, `iDynTree::RotationalInertiaRaw`/`iDynTree::RotationalInertia` and   `iDynTree::SpatialInertiaRaw`/`iDynTree::SpatialInertia` (https://github.com/robotology/idyntree/pull/1114).
-
 
 ## [9.1.0] - 2023-05-25
 
 ### Added
 
 - Added optional dependency on [meshcat-cpp](https://github.com/ami-iit/meshcat-cpp) (https://github.com/robotology/idyntree/pull/1074).
 - Added `iDynTree::MeshcatVisualizer` C++ class (https://github.com/robotology/idyntree/pull/1074).
```

### Comparing `idyntree-9.1.1.dev66/CMakeLists.txt` & `idyntree-9.1.1.dev7/CMakeLists.txt`

 * *Files 7% similar despite different names*

```diff
@@ -1,13 +1,18 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+# Copyright (C) 2013-2018 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 cmake_minimum_required(VERSION 3.16)
 
-project(iDynTree VERSION 10.0.0
+project(iDynTree VERSION 9.1.0
                  LANGUAGES C CXX)
 
 # Disable in source build, unless Eclipse is used
 if( ("${PROJECT_SOURCE_DIR}" STREQUAL "${PROJECT_BINARY_DIR}") AND
     (NOT ("${CMAKE_EXTRA_GENERATOR}" STREQUAL "Eclipse CDT4")) )
    message(FATAL_ERROR "In-source builds of iDynTree are not allowed. "
                        "Please remove CMakeCache.txt and the CMakeFiles/ directory, then build out-of-source. "
```

### Comparing `idyntree-9.1.1.dev66/CONTRIBUTING.md` & `idyntree-9.1.1.dev7/CONTRIBUTING.md`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/LICENSE` & `idyntree-9.1.1.dev7/extern/mesh2tri/license.txt`

 * *Files 26% similar despite different names*

```diff
@@ -1,28 +1,24 @@
-BSD 3-Clause License
-
-Copyright (c) Fondazione Istituto Italiano di Tecnologia (IIT)
+Copyright (c) 2010, Kevin Moerman
+All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-1. Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
+modification, are permitted provided that the following conditions are
+met:
 
-3. Neither the name of the copyright holder nor the names of its
-   contributors may be used to endorse or promote products derived from
-   this software without specific prior written permission.
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the distribution
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `idyntree-9.1.1.dev66/PKG-INFO` & `idyntree-9.1.1.dev7/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 Metadata-Version: 2.1
 Name: idyntree
-Version: 9.1.1.dev66
+Version: 9.1.1.dev7
 Summary: Multibody Dynamics Library designed for Free Floating Robots.
 Home-page: https://github.com/robotology/idyntree
 Author: Diego Ferigo
 Author-email: dgferigo@gmail.com
-License: BSD-3-Clause
+License: LGPL
 Project-URL: Tracker, https://github.com/robotology/idyntree/issues
 Project-URL: Documentation, https://robotology.github.io/idyntree/master/
 Project-URL: Source, https://github.com/robotology/idyntree
 Keywords: robotics,dynamics,free-floating,floating-base,robot,robotic-library,multibody-dynamics
 Platform: any
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Operating System :: POSIX :: Linux
@@ -22,32 +22,32 @@
 Classifier: Programming Language :: C++
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: License :: OSI Approved :: BSD License
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: numpy
+License-File: LICENSE.LGPL2
+License-File: LICENSE.LGPL3
 
-iDynTree  [![License](https://img.shields.io/badge/License-BSD_3--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause) [![ZenHub](https://img.shields.io/badge/Shipping_faster_with-ZenHub-435198.svg)](https://zenhub.com)
+iDynTree [![License: LGPL v3](https://img.shields.io/badge/License-LGPL%20v3-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0) [![License: LGPL v2](https://img.shields.io/badge/License-LGPL%20v2-blue.svg)](https://www.gnu.org/licenses/lgpl-2.1)  [![ZenHub](https://img.shields.io/badge/Shipping_faster_with-ZenHub-435198.svg)](https://zenhub.com)
 ===========
 
 iDynTree is a library of robots dynamics algorithms for control, estimation and simulation. It is specifically designed for free-floating robots, but it is possible to use it also  with fixed-base robots.
 
 The **major characteristic features** of iDynTree are:
 * It is written in **C++**, with **Python** and **MATLAB** bindings.
 * It uses an  **undirected graph data structure** (`iDynTree::Model`) that is used to represent robots, to easily change the **base link** that you are using for your kinematics and dynamics computations without the need to reload your model or change your joint or link serializations. This is done as iDynTree was developed for floating-base robots such as humanoids, in which the most convenient choice of **base link** can change.
 * It contains support for **reading and writing URDF files** from a `iDynTree::Model`, making it useful to write tools that modify robot models and saves them back to file. This is done as iDynTree was meant to develop **tools for identification of kinematics and dynamics parameters**.
 * It defaults to use the **mixed representation** to represent link quantities (including the velocity and acceleration of the base link), but it can optionally use also **body (left-trivialized)** or **inertial (right-trivialized)** representation if requested. This is done because iDynTree was developed to satisfy the needs of **research in synthesis of floating-base whole-body controllers**. If you are not familiar with the different representation for 6D quantities, check  [Section 6 of "Multibody dynamics notation (version 2)"](
 https://pure.tue.nl/ws/portalfiles/portal/139293126/A_Multibody_Dynamics_Notation_Revision_2_.pdf).
-* It contains an implementation of the algorithm used in the iCub humanoid robot to **estimate the joint torques without the need of collocated joint torque sensors**, exploting the specific **undirected graph data structure** . This is done as this was one of the originally goal for the implementation of iDynTree. See the class [`iDynTree::ExtWrenchesAndJointTorquesEstimator`](https://github.com/robotology/idyntree/blob/master/src/estimation/include/iDynTree/ExtWrenchesAndJointTorquesEstimator.h) and [Chapter 6 of "Modelling, Estimation and Identification of Humanoid Robots Dynamics"](https://traversaro.github.io/traversaro-phd-thesis/traversaro-phd-thesis.pdf).
+* It contains an implementation of the algorithm used in the iCub humanoid robot to **estimate the joint torques without the need of collocated joint torque sensors**, exploting the specific **undirected graph data structure** . This is done as this was one of the originally goal for the implementation of iDynTree. See the class [`iDynTree::ExtWrenchesAndJointTorquesEstimator`](https://github.com/robotology/idyntree/blob/master/src/estimation/include/iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h) and [Chapter 6 of "Modelling, Estimation and Identification of Humanoid Robots Dynamics"](https://traversaro.github.io/traversaro-phd-thesis/traversaro-phd-thesis.pdf).
 
 To avoid confusion, it is also useful to clarify what **iDynTree is not**:
 * It is not the **fastest C++ library** for kinematics and dynamics multibody computations for robotics. It is not slow, but if have an application in which you need the absolute fastest library, check out [Pinocchio](https://github.com/stack-of-tasks/pinocchio).
 * It is not a **multibody simulator** library. It provides the building blocks that you could use to build a multibody simulator, but it is not a multibody simulator per se. If you need a simulator library in C++, check out [DART](https://dartsim.github.io/), [Simbody](https://github.com/simbody/simbody), [Drake](https://drake.mit.edu/), [MuJoCo](https://mujoco.org/) or the abstraction layer [`Gazebo Physics`](https://github.com/gazebosim/gz-physics). If you need a simulator implemented in MATLAB/Simulink (built on iDynTree), check [`matlab-whole-body-simulator`](https://github.com/ami-iit/matlab-whole-body-simulator).
 
 
 ##  Contents
@@ -74,15 +74,15 @@
 conda install -c conda-forge -c robotology idyntree-matlab-bindings
 ~~~
 
 If you are not familiar with conda or conda-forge, you can read an introduction document in [conda-forge overview](https://github.com/robotology/robotology-superbuild/blob/master/doc/conda-forge.md#conda-forge-overview).
 
 ### robotology-superbuild (advanced)
 
-If you are installing iDynTree for use as part of [iCub humanoid robot software installation](https://icub-tech-iit.github.io/documentation/sw_installation/), you may want to install iDynTree through the [robotology-superbuild](https://github.com/robotology/robotology-superbuild), an easy way to download, compile and install the robotology software on multiple operating systems, using the [CMake](https://www.cmake.org) build system and its extension [YCM](http://robotology.github.io/ycm). To get iDynTree when using the `robotology-superbuild`, please enable the `ROBOTOLOGY_ENABLE_DYNAMICS` CMake option of the superbuild. If you want to install also iDynTree Python or MATLAB bindings, remember to enable the `ROBOTOLOGY_USES_PYTHON` or `ROBOTOLOGY_USES_MATLAB` options. 
+If you are installing iDynTree for use as part of [iCub humanoid robot software installation](https://icub-tech-iit.github.io/documentation/sw_installation/), you may want to install iDynTree through the [robotology-superbuild](https://github.com/robotology/robotology-superbuild), an easy way to download, compile and install the robotology software on multiple operating systems, using the [CMake](www.cmake.org) build system and its extension [YCM](http://robotology.github.io/ycm). To get iDynTree when using the `robotology-superbuild`, please enable the `ROBOTOLOGY_ENABLE_DYNAMICS` CMake option of the superbuild. If you want to install also iDynTree Python or MATLAB bindings, remember to enable the `ROBOTOLOGY_USES_PYTHON` or `ROBOTOLOGY_USES_MATLAB` options. 
 
 ### Build from source (advanced)
 
 If you want to build iDynTree directly from source, you can check the documentation in [`doc/build-from-source.md`](doc/build-from-source.md).
 
 ## Library Usage
 
@@ -103,23 +103,24 @@
 
 If this is not working, make sure that you are launching `matlab` after having activated the conda environment (if you installed iDynTree via conda) or after having sourced por executed the correct setup script (if you installed iDynTree via the robotology-superbuild).
 
 ### Tutorials
 
 These tutorials describe how to use specific parts of iDynTree. Are you interested in a tutorial on a specific feature or algorithm that you can't find in this list? Just [request it on an enhancement issue](https://github.com/robotology/idyntree/issues/new).
 
+
 | Topic  | Location | Language  |
 |:------:|:--------:|:---------:|
-| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html) together with the [[Eigen](http://eigen.tuxfamily.org) C++ Matrix library to compute kinematics and dynamics quantities such as forward kinematics, inverse dynamics, mass matrix. | [examples/cxx/KinDynComputationsWithEigen/main.cpp](examples/cxx/KinDynComputationsWithEigen/main.cpp) | C++ |
-| How to use the [InverseKinematics class](https://robotology.github.io/idyntree/classiDynTree_1_1InverseKinematics.html) for the IK of an industrial fixed-base manipulator. | [examples/cxx/InverseKinematics/README.md](examples/cxx/InverseKinematics/README.md) | C++ |
-| Use of the [ExtWrenchesAndJointTorquesEstimator class](https://robotology.github.io/idyntree/classiDynTree_1_1ExtWrenchesAndJointTorquesEstimator.html) for computing offset for FT sensors |  [examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m](examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m) | MATLAB |
-| How to get the axis of a revolute joint expressed in a arbitary frame using the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html) | [examples/matlab/SensorsListParsing/SensorsListParsing.m](examples/matlab/SensorsListParsing/SensorsListParsing.m) | MATLAB |
+| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html) together with the [[Eigen](http://eigen.tuxfamily.org) C++ Matrix library to compute kinematics and dynamics quantities such as forward kinematics, inverse dynamics, mass matrix. | [examples/cxx/KinDynComputationsWithEigen/main.cpp](examples/cxx/KinDynComputationsWithEigen/main.cpp) | C++ |
+| How to use the [InverseKinematics class](https://robotology.github.io/docs/idyntree/master/classiDynTree_1_1InverseKinematics.html) for the IK of an industrial fixed-base manipulator. | [examples/cxx/InverseKinematics/README.md](examples/cxx/InverseKinematics/README.md) | C++ |
+| Use of the [ExtWrenchesAndJointTorquesEstimator class](https://robotology.github.io/idyntree/master/classiDynTree_1_1ExtWrenchesAndJointTorquesEstimator.html) for computing offset for FT sensors |  [examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m](examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m) | MATLAB |
+| How to get the axis of a revolute joint expressed in a arbitary frame using the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html) | [examples/matlab/SensorsListParsing/SensorsListParsing.m](examples/matlab/SensorsListParsing/SensorsListParsing.m) | MATLAB |
 | How to read the Six Axis Force Torque sensors information contained in a URDF model. | [examples/matlab/GetJointAxesInWorldFrame.m](examples/matlab/GetJointAxesInWorldFrame.m) | MATLAB |
 | Usage of the MATLAB-native visualizer using the [MATLAB high-level wrappers](bindings/matlab/+iDynTreeWrappers/README.md). | [examples/matlab/iDynTreeWrappers/visualizeRobot.m](examples/matlab/iDynTreeWrappers/visualizeRobot.m) | MATLAB |
-| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html). | [examples/python/KinDynComputationsTutorial.py](examples/python/KinDynComputationsTutorial.py) | Python |
+| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html). | [examples/python/KinDynComputationsTutorial.py](examples/python/KinDynComputationsTutorial.py) | Python |
 | Basic usage of the [MeshcatVisualizer class](bindings/python/visualize/meshcat_visualizer.py). | [examples/python/MeshcatVisualizerExample.ipynb](examples/python/MeshcatVisualizerExample.ipynb) | Python |
 
 ## Tools Usage 
 
 iDynTree also includes some command line tools to use some of the functionality of the library without writing any line of code. The available command line tools are listed in the following, and each tool also includes an online help that is tipically available by passing the `-h` flag.
 
 ### `idyntree-model-info`
@@ -181,14 +182,21 @@
   NUMBER={6},
   URL={http://www.frontiersin.org/humanoid_robotics/10.3389/frobt.2015.00006/abstract},
   DOI={10.3389/frobt.2015.00006},
   ISSN={2296-9144}}
 ~~~
 
 ## Acknowledgments
-The initial development of iDynTree was supported by the FP7 EU projects [CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics)](http://www.codyco.eu/)  and [Koroibot (No. 611909 ICT- 2013.2.1 Cognitive Systems and Robotics)](https://cordis.europa.eu/project/id/611909/).
+The initial development of iDynTree was supported by the FP7 EU projects [CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics)](http://www.codyco.eu/)  and [Koroibot (No. 611909 ICT- 2013.2.1 Cognitive Systems and Robotics)](http://koroibot.eu/).
 
 The development is now supported by the [Artificial Mechanical Intelligence research line](https://ami.iit.it/) at the [Italian Institute of Technology](https://www.iit.it/).
 
 ## License
+iDynTree is licensed under either the GNU Lesser General Public License v3.0 :
+
+https://www.gnu.org/licenses/lgpl-3.0.html
+
+or the GNU Lesser General Public License v2.1 :
+
+https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
 
-iDynTree is licensed under either the BSD-3-Clause license : https://spdx.org/licenses/BSD-3-Clause.html .
+at your option.
```

### Comparing `idyntree-9.1.1.dev66/README.md` & `idyntree-9.1.1.dev7/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-iDynTree  [![License](https://img.shields.io/badge/License-BSD_3--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause) [![ZenHub](https://img.shields.io/badge/Shipping_faster_with-ZenHub-435198.svg)](https://zenhub.com)
+iDynTree [![License: LGPL v3](https://img.shields.io/badge/License-LGPL%20v3-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0) [![License: LGPL v2](https://img.shields.io/badge/License-LGPL%20v2-blue.svg)](https://www.gnu.org/licenses/lgpl-2.1)  [![ZenHub](https://img.shields.io/badge/Shipping_faster_with-ZenHub-435198.svg)](https://zenhub.com)
 ===========
 
 iDynTree is a library of robots dynamics algorithms for control, estimation and simulation. It is specifically designed for free-floating robots, but it is possible to use it also  with fixed-base robots.
 
 The **major characteristic features** of iDynTree are:
 * It is written in **C++**, with **Python** and **MATLAB** bindings.
 * It uses an  **undirected graph data structure** (`iDynTree::Model`) that is used to represent robots, to easily change the **base link** that you are using for your kinematics and dynamics computations without the need to reload your model or change your joint or link serializations. This is done as iDynTree was developed for floating-base robots such as humanoids, in which the most convenient choice of **base link** can change.
 * It contains support for **reading and writing URDF files** from a `iDynTree::Model`, making it useful to write tools that modify robot models and saves them back to file. This is done as iDynTree was meant to develop **tools for identification of kinematics and dynamics parameters**.
 * It defaults to use the **mixed representation** to represent link quantities (including the velocity and acceleration of the base link), but it can optionally use also **body (left-trivialized)** or **inertial (right-trivialized)** representation if requested. This is done because iDynTree was developed to satisfy the needs of **research in synthesis of floating-base whole-body controllers**. If you are not familiar with the different representation for 6D quantities, check  [Section 6 of "Multibody dynamics notation (version 2)"](
 https://pure.tue.nl/ws/portalfiles/portal/139293126/A_Multibody_Dynamics_Notation_Revision_2_.pdf).
-* It contains an implementation of the algorithm used in the iCub humanoid robot to **estimate the joint torques without the need of collocated joint torque sensors**, exploting the specific **undirected graph data structure** . This is done as this was one of the originally goal for the implementation of iDynTree. See the class [`iDynTree::ExtWrenchesAndJointTorquesEstimator`](https://github.com/robotology/idyntree/blob/master/src/estimation/include/iDynTree/ExtWrenchesAndJointTorquesEstimator.h) and [Chapter 6 of "Modelling, Estimation and Identification of Humanoid Robots Dynamics"](https://traversaro.github.io/traversaro-phd-thesis/traversaro-phd-thesis.pdf).
+* It contains an implementation of the algorithm used in the iCub humanoid robot to **estimate the joint torques without the need of collocated joint torque sensors**, exploting the specific **undirected graph data structure** . This is done as this was one of the originally goal for the implementation of iDynTree. See the class [`iDynTree::ExtWrenchesAndJointTorquesEstimator`](https://github.com/robotology/idyntree/blob/master/src/estimation/include/iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h) and [Chapter 6 of "Modelling, Estimation and Identification of Humanoid Robots Dynamics"](https://traversaro.github.io/traversaro-phd-thesis/traversaro-phd-thesis.pdf).
 
 To avoid confusion, it is also useful to clarify what **iDynTree is not**:
 * It is not the **fastest C++ library** for kinematics and dynamics multibody computations for robotics. It is not slow, but if have an application in which you need the absolute fastest library, check out [Pinocchio](https://github.com/stack-of-tasks/pinocchio).
 * It is not a **multibody simulator** library. It provides the building blocks that you could use to build a multibody simulator, but it is not a multibody simulator per se. If you need a simulator library in C++, check out [DART](https://dartsim.github.io/), [Simbody](https://github.com/simbody/simbody), [Drake](https://drake.mit.edu/), [MuJoCo](https://mujoco.org/) or the abstraction layer [`Gazebo Physics`](https://github.com/gazebosim/gz-physics). If you need a simulator implemented in MATLAB/Simulink (built on iDynTree), check [`matlab-whole-body-simulator`](https://github.com/ami-iit/matlab-whole-body-simulator).
 
 
 ##  Contents
@@ -40,15 +40,15 @@
 conda install -c conda-forge -c robotology idyntree-matlab-bindings
 ~~~
 
 If you are not familiar with conda or conda-forge, you can read an introduction document in [conda-forge overview](https://github.com/robotology/robotology-superbuild/blob/master/doc/conda-forge.md#conda-forge-overview).
 
 ### robotology-superbuild (advanced)
 
-If you are installing iDynTree for use as part of [iCub humanoid robot software installation](https://icub-tech-iit.github.io/documentation/sw_installation/), you may want to install iDynTree through the [robotology-superbuild](https://github.com/robotology/robotology-superbuild), an easy way to download, compile and install the robotology software on multiple operating systems, using the [CMake](https://www.cmake.org) build system and its extension [YCM](http://robotology.github.io/ycm). To get iDynTree when using the `robotology-superbuild`, please enable the `ROBOTOLOGY_ENABLE_DYNAMICS` CMake option of the superbuild. If you want to install also iDynTree Python or MATLAB bindings, remember to enable the `ROBOTOLOGY_USES_PYTHON` or `ROBOTOLOGY_USES_MATLAB` options. 
+If you are installing iDynTree for use as part of [iCub humanoid robot software installation](https://icub-tech-iit.github.io/documentation/sw_installation/), you may want to install iDynTree through the [robotology-superbuild](https://github.com/robotology/robotology-superbuild), an easy way to download, compile and install the robotology software on multiple operating systems, using the [CMake](www.cmake.org) build system and its extension [YCM](http://robotology.github.io/ycm). To get iDynTree when using the `robotology-superbuild`, please enable the `ROBOTOLOGY_ENABLE_DYNAMICS` CMake option of the superbuild. If you want to install also iDynTree Python or MATLAB bindings, remember to enable the `ROBOTOLOGY_USES_PYTHON` or `ROBOTOLOGY_USES_MATLAB` options. 
 
 ### Build from source (advanced)
 
 If you want to build iDynTree directly from source, you can check the documentation in [`doc/build-from-source.md`](doc/build-from-source.md).
 
 ## Library Usage
 
@@ -69,23 +69,24 @@
 
 If this is not working, make sure that you are launching `matlab` after having activated the conda environment (if you installed iDynTree via conda) or after having sourced por executed the correct setup script (if you installed iDynTree via the robotology-superbuild).
 
 ### Tutorials
 
 These tutorials describe how to use specific parts of iDynTree. Are you interested in a tutorial on a specific feature or algorithm that you can't find in this list? Just [request it on an enhancement issue](https://github.com/robotology/idyntree/issues/new).
 
+
 | Topic  | Location | Language  |
 |:------:|:--------:|:---------:|
-| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html) together with the [[Eigen](http://eigen.tuxfamily.org) C++ Matrix library to compute kinematics and dynamics quantities such as forward kinematics, inverse dynamics, mass matrix. | [examples/cxx/KinDynComputationsWithEigen/main.cpp](examples/cxx/KinDynComputationsWithEigen/main.cpp) | C++ |
-| How to use the [InverseKinematics class](https://robotology.github.io/idyntree/classiDynTree_1_1InverseKinematics.html) for the IK of an industrial fixed-base manipulator. | [examples/cxx/InverseKinematics/README.md](examples/cxx/InverseKinematics/README.md) | C++ |
-| Use of the [ExtWrenchesAndJointTorquesEstimator class](https://robotology.github.io/idyntree/classiDynTree_1_1ExtWrenchesAndJointTorquesEstimator.html) for computing offset for FT sensors |  [examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m](examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m) | MATLAB |
-| How to get the axis of a revolute joint expressed in a arbitary frame using the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html) | [examples/matlab/SensorsListParsing/SensorsListParsing.m](examples/matlab/SensorsListParsing/SensorsListParsing.m) | MATLAB |
+| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html) together with the [[Eigen](http://eigen.tuxfamily.org) C++ Matrix library to compute kinematics and dynamics quantities such as forward kinematics, inverse dynamics, mass matrix. | [examples/cxx/KinDynComputationsWithEigen/main.cpp](examples/cxx/KinDynComputationsWithEigen/main.cpp) | C++ |
+| How to use the [InverseKinematics class](https://robotology.github.io/docs/idyntree/master/classiDynTree_1_1InverseKinematics.html) for the IK of an industrial fixed-base manipulator. | [examples/cxx/InverseKinematics/README.md](examples/cxx/InverseKinematics/README.md) | C++ |
+| Use of the [ExtWrenchesAndJointTorquesEstimator class](https://robotology.github.io/idyntree/master/classiDynTree_1_1ExtWrenchesAndJointTorquesEstimator.html) for computing offset for FT sensors |  [examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m](examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m) | MATLAB |
+| How to get the axis of a revolute joint expressed in a arbitary frame using the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html) | [examples/matlab/SensorsListParsing/SensorsListParsing.m](examples/matlab/SensorsListParsing/SensorsListParsing.m) | MATLAB |
 | How to read the Six Axis Force Torque sensors information contained in a URDF model. | [examples/matlab/GetJointAxesInWorldFrame.m](examples/matlab/GetJointAxesInWorldFrame.m) | MATLAB |
 | Usage of the MATLAB-native visualizer using the [MATLAB high-level wrappers](bindings/matlab/+iDynTreeWrappers/README.md). | [examples/matlab/iDynTreeWrappers/visualizeRobot.m](examples/matlab/iDynTreeWrappers/visualizeRobot.m) | MATLAB |
-| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html). | [examples/python/KinDynComputationsTutorial.py](examples/python/KinDynComputationsTutorial.py) | Python |
+| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html). | [examples/python/KinDynComputationsTutorial.py](examples/python/KinDynComputationsTutorial.py) | Python |
 | Basic usage of the [MeshcatVisualizer class](bindings/python/visualize/meshcat_visualizer.py). | [examples/python/MeshcatVisualizerExample.ipynb](examples/python/MeshcatVisualizerExample.ipynb) | Python |
 
 ## Tools Usage 
 
 iDynTree also includes some command line tools to use some of the functionality of the library without writing any line of code. The available command line tools are listed in the following, and each tool also includes an online help that is tipically available by passing the `-h` flag.
 
 ### `idyntree-model-info`
@@ -147,14 +148,21 @@
   NUMBER={6},
   URL={http://www.frontiersin.org/humanoid_robotics/10.3389/frobt.2015.00006/abstract},
   DOI={10.3389/frobt.2015.00006},
   ISSN={2296-9144}}
 ~~~
 
 ## Acknowledgments
-The initial development of iDynTree was supported by the FP7 EU projects [CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics)](http://www.codyco.eu/)  and [Koroibot (No. 611909 ICT- 2013.2.1 Cognitive Systems and Robotics)](https://cordis.europa.eu/project/id/611909/).
+The initial development of iDynTree was supported by the FP7 EU projects [CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics)](http://www.codyco.eu/)  and [Koroibot (No. 611909 ICT- 2013.2.1 Cognitive Systems and Robotics)](http://koroibot.eu/).
 
 The development is now supported by the [Artificial Mechanical Intelligence research line](https://ami.iit.it/) at the [Italian Institute of Technology](https://www.iit.it/).
 
 ## License
+iDynTree is licensed under either the GNU Lesser General Public License v3.0 :
+
+https://www.gnu.org/licenses/lgpl-3.0.html
+
+or the GNU Lesser General Public License v2.1 :
+
+https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
 
-iDynTree is licensed under either the BSD-3-Clause license : https://spdx.org/licenses/BSD-3-Clause.html .
+at your option.
```

### Comparing `idyntree-9.1.1.dev66/bindings/CMakeLists.txt` & `idyntree-9.1.1.dev7/bindings/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/iDynTree.i` & `idyntree-9.1.1.dev7/bindings/iDynTree.i`

 * *Files 12% similar despite different names*

```diff
@@ -32,101 +32,104 @@
 #ifdef SWIGMATLAB
 %include "./matlab/matlab.i"
 #endif
 
 %{
 /* Note : always include headers following the inheritance order */
 #include <cmath>
-#include <cstddef>
 
 //Utils
-#include "iDynTree/Utils.h"
+#include "iDynTree/Core/Utils.h"
 
 // Basic math classes
-#include "iDynTree/MatrixDynSize.h"
-#include "iDynTree/MatrixFixSize.h"
-#include "iDynTree/SparseMatrix.h"
+#include "iDynTree/Core/MatrixDynSize.h"
+#include "iDynTree/Core/MatrixFixSize.h"
+#include "iDynTree/Core/SparseMatrix.h"
 
-#include "iDynTree/VectorDynSize.h"
-#include "iDynTree/VectorFixSize.h"
+#include "iDynTree/Core/VectorDynSize.h"
+#include "iDynTree/Core/VectorFixSize.h"
 
 // Basic Vectors: Point Vectors and Spatial Vectors
-#include "iDynTree/Position.h"
-#include "iDynTree/SpatialForceVector.h"
-#include "iDynTree/SpatialMotionVector.h"
-#include "iDynTree/Twist.h"
-#include "iDynTree/Wrench.h"
-#include "iDynTree/SpatialMomentum.h"
-#include "iDynTree/SpatialAcc.h"
-#include "iDynTree/ClassicalAcc.h"
-#include "iDynTree/Direction.h"
-#include "iDynTree/Axis.h"
+#include "iDynTree/Core/PositionRaw.h"
+#include "iDynTree/Core/Position.h"
+#include "iDynTree/Core/SpatialForceVector.h"
+#include "iDynTree/Core/SpatialMotionVector.h"
+#include "iDynTree/Core/Twist.h"
+#include "iDynTree/Core/Wrench.h"
+#include "iDynTree/Core/SpatialMomentum.h"
+#include "iDynTree/Core/SpatialAcc.h"
+#include "iDynTree/Core/ClassicalAcc.h"
+#include "iDynTree/Core/Direction.h"
+#include "iDynTree/Core/Axis.h"
 
 // Inertias
-#include "iDynTree/RotationalInertia.h"
-#include "iDynTree/SpatialInertia.h"
-#include "iDynTree/SpatialInertia.h"
-#include "iDynTree/ArticulatedBodyInertia.h"
-#include "iDynTree/InertiaNonLinearParametrization.h"
+#include "iDynTree/Core/RotationalInertiaRaw.h"
+#include "iDynTree/Core/SpatialInertiaRaw.h"
+#include "iDynTree/Core/SpatialInertia.h"
+#include "iDynTree/Core/ArticulatedBodyInertia.h"
+#include "iDynTree/Core/InertiaNonLinearParametrization.h"
 
 // Transformations: Rotation and Transform
-#include "iDynTree/Rotation.h"
-#include "iDynTree/Transform.h"
-#include "iDynTree/TransformDerivative.h"
-#include "iDynTree/Span.h"
+#include "iDynTree/Core/RotationRaw.h"
+#include "iDynTree/Core/Rotation.h"
+#include "iDynTree/Core/Transform.h"
+#include "iDynTree/Core/TransformDerivative.h"
+#include "iDynTree/Core/Span.h"
 
 // Model related data structures
-#include "iDynTree/Indices.h"
-#include "iDynTree/LinkState.h"
-#include "iDynTree/Link.h"
-#include "iDynTree/IJoint.h"
-#include "iDynTree/FixedJoint.h"
-#include "iDynTree/MovableJointImpl.h"
-#include "iDynTree/RevoluteJoint.h"
-#include "iDynTree/PrismaticJoint.h"
-#include "iDynTree/Traversal.h"
-#include "iDynTree/SolidShapes.h"
-#include "iDynTree/Sensors.h"
-#include "iDynTree/Model.h"
-#include "iDynTree/JointState.h"
-#include "iDynTree/FreeFloatingMatrices.h"
-#include "iDynTree/FreeFloatingState.h"
-#include "iDynTree/ContactWrench.h"
-#include "iDynTree/ModelTestUtils.h"
-#include "iDynTree/ModelTransformers.h"
-#include "iDynTree/SubModel.h"
-#include "iDynTree/SixAxisForceTorqueSensor.h"
-#include "iDynTree/AccelerometerSensor.h"
-#include "iDynTree/GyroscopeSensor.h"
-#include "iDynTree/ThreeAxisAngularAccelerometerSensor.h"
-#include "iDynTree/ThreeAxisForceTorqueContactSensor.h"
-#include "iDynTree/PredictSensorsMeasurements.h"
+#include "iDynTree/Model/Indices.h"
+#include "iDynTree/Model/LinkState.h"
+#include "iDynTree/Model/Link.h"
+#include "iDynTree/Model/IJoint.h"
+#include "iDynTree/Model/FixedJoint.h"
+#include "iDynTree/Model/MovableJointImpl.h"
+#include "iDynTree/Model/RevoluteJoint.h"
+#include "iDynTree/Model/PrismaticJoint.h"
+#include "iDynTree/Model/Traversal.h"
+#include "iDynTree/Model/SolidShapes.h"
+#include "iDynTree/Model/Model.h"
+#include "iDynTree/Model/JointState.h"
+#include "iDynTree/Model/FreeFloatingMatrices.h"
+#include "iDynTree/Model/FreeFloatingState.h"
+#include "iDynTree/Model/ContactWrench.h"
+#include "iDynTree/Model/ModelTestUtils.h"
+#include "iDynTree/Model/ModelTransformers.h"
+#include "iDynTree/Model/SubModel.h"
 
 // Kinematics & Dynamics related functions
-#include "iDynTree/ForwardKinematics.h"
-#include "iDynTree/Dynamics.h"
-#include "iDynTree/DenavitHartenberg.h"
+#include "iDynTree/Model/ForwardKinematics.h"
+#include "iDynTree/Model/Dynamics.h"
+#include "iDynTree/Model/DenavitHartenberg.h"
+
+// Sensors related data structures
+#include "iDynTree/Sensors/Sensors.h"
+#include "iDynTree/Sensors/SixAxisForceTorqueSensor.h"
+#include "iDynTree/Sensors/AccelerometerSensor.h"
+#include "iDynTree/Sensors/GyroscopeSensor.h"
+#include "iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h"
+#include "iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h"
+#include "iDynTree/Sensors/PredictSensorsMeasurements.h"
 
 // Model loading from external formats
-#include "iDynTree/URDFDofsImport.h"
-#include "iDynTree/ModelLoader.h"
-#include "iDynTree/ModelExporter.h"
-#include "iDynTree/ModelCalibrationHelper.h"
+#include "iDynTree/ModelIO/URDFDofsImport.h"
+#include "iDynTree/ModelIO/ModelLoader.h"
+#include "iDynTree/ModelIO/ModelExporter.h"
+#include "iDynTree/ModelIO/ModelCalibrationHelper.h"
 
 
 // Estimation related classes
-#include "iDynTree/ExternalWrenchesEstimation.h"
-#include "iDynTree/ExtWrenchesAndJointTorquesEstimator.h"
-#include "iDynTree/SimpleLeggedOdometry.h"
-#include "iDynTree/BerdyHelper.h"
-#include "iDynTree/BerdySparseMAPSolver.h"
-#include "iDynTree/AttitudeEstimator.h"
-#include "iDynTree/AttitudeMahonyFilter.h"
-#include "iDynTree/ExtendedKalmanFilter.h"
-#include "iDynTree/AttitudeQuaternionEKF.h"
+#include "iDynTree/Estimation/ExternalWrenchesEstimation.h"
+#include "iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h"
+#include "iDynTree/Estimation/SimpleLeggedOdometry.h"
+#include "iDynTree/Estimation/BerdyHelper.h"
+#include "iDynTree/Estimation/BerdySparseMAPSolver.h"
+#include "iDynTree/Estimation/AttitudeEstimator.h"
+#include "iDynTree/Estimation/AttitudeMahonyFilter.h"
+#include "iDynTree/Estimation/ExtendedKalmanFilter.h"
+#include "iDynTree/Estimation/AttitudeQuaternionEKF.h"
 
 // SolidShapes related classes
 #include "iDynTree/InertialParametersSolidShapesHelpers.h"
 
 // High level interfaces
 #include "iDynTree/KinDynComputations.h"
 
@@ -135,53 +138,34 @@
 
 // Inverse Kinematics
 #include "iDynTree/ConvexHullHelpers.h"
 #include "iDynTree/InverseKinematics.h"
 
 %}
 
-// Wrap the std::vector<iDynTree::MatrixDynSize> params
-%template(MatrixDynSizeVector) std::vector<iDynTree::MatrixDynSize>;
-
-// Wrap the std::vector<iDynTree::VectorDynSize> params
-%template(VectorDynSizeVector) std::vector<iDynTree::VectorDynSize>;
-
-// Wrap the:
-// * std::vector<std::ptrdiff_t>,
-// * std::vector<iDynTree::LinkIndex>,
-// * std::vector<iDynTree::JointIndex>,
-// * std::vector<iDynTree::DOFIndex>,
-// * std::vector<iDynTree::FrameIndex>,
-// * std::vector<iDynTree::TraversalIndex>,
-// params
-namespace std {
-    typedef ::ptrdiff_t ptrdiff_t;
-}
-%template(IndexVector) std::vector<std::ptrdiff_t>;
-
 //Wrap std::vector<BerdySensors>
 namespace std {
     %template(BerdySensors) vector<iDynTree::BerdySensor>;
     %template(BerdyDynamicVariables) vector<iDynTree::BerdyDynamicVariable>;
 }
 
 //Utils
-%include "iDynTree/Utils.h"
+%include "iDynTree/Core/Utils.h"
 
 /* Note : always include headers following the inheritance order */
 // Basic math classes
-%include "iDynTree/MatrixDynSize.h"
-%include "iDynTree/MatrixFixSize.h"
-%include "iDynTree/SparseMatrix.h"
+%include "iDynTree/Core/MatrixDynSize.h"
+%include "iDynTree/Core/MatrixFixSize.h"
+%include "iDynTree/Core/SparseMatrix.h"
 %template(SparseMatrixRowMajor) iDynTree::SparseMatrix<iDynTree::RowMajor>;
 %template(SparseMatrixColMajor) iDynTree::SparseMatrix<iDynTree::ColumnMajor>;
 
 
-%include "iDynTree/VectorDynSize.h"
-%include "iDynTree/VectorFixSize.h"
+%include "iDynTree/Core/VectorDynSize.h"
+%include "iDynTree/Core/VectorFixSize.h"
 
 #ifdef SWIGMATLAB
 %include "./matlab/matlab_matvec.i"
 #endif
 
 #ifdef SWIGOCTAVE
 %include "./octave/octave_matvec.i"
@@ -198,19 +182,20 @@
 %template(Vector3) iDynTree::VectorFixSize<3>;
 %template(Vector4) iDynTree::VectorFixSize<4>;
 %template(Vector6) iDynTree::VectorFixSize<6>;
 %template(Vector10) iDynTree::VectorFixSize<10>;
 %template(Vector16) iDynTree::VectorFixSize<16>;
 
 // Basic Vectors: Point Vectors and Spatial Vectors
-%include "iDynTree/Position.h"
+%include "iDynTree/Core/PositionRaw.h"
+%include "iDynTree/Core/Position.h"
 
-%include "iDynTree/GeomVector3.h"
+%include "iDynTree/Core/GeomVector3.h"
 
-%include "iDynTree/SpatialVector.h"
+%include "iDynTree/Core/SpatialVector.h"
 
 %template() iDynTree::DualSpace<iDynTree::SpatialMotionVector>;
 %template() iDynTree::DualSpace<iDynTree::SpatialForceVector>;
 
 #ifdef SWIGMATLAB
 %include "./matlab/matlab_spatialvec.i"
 #endif
@@ -218,103 +203,108 @@
 #ifdef SWIGOCTAVE
 %include "./octave/octave_spatialvec.i"
 #endif
 
 %template(SpatialMotionVectorBase) iDynTree::SpatialVector<iDynTree::SpatialMotionVector>;
 %template(SpatialForceVectorBase) iDynTree::SpatialVector<iDynTree::SpatialForceVector>;
 
-%include "iDynTree/SpatialMotionVector.h"
-%include "iDynTree/SpatialForceVector.h"
-%include "iDynTree/Twist.h"
-%include "iDynTree/Wrench.h"
-%include "iDynTree/SpatialMomentum.h"
-%include "iDynTree/SpatialAcc.h"
-%include "iDynTree/ClassicalAcc.h"
-%include "iDynTree/Direction.h"
-%include "iDynTree/Axis.h"
+%include "iDynTree/Core/SpatialMotionVector.h"
+%include "iDynTree/Core/SpatialForceVector.h"
+%include "iDynTree/Core/Twist.h"
+%include "iDynTree/Core/Wrench.h"
+%include "iDynTree/Core/SpatialMomentum.h"
+%include "iDynTree/Core/SpatialAcc.h"
+%include "iDynTree/Core/ClassicalAcc.h"
+%include "iDynTree/Core/Direction.h"
+%include "iDynTree/Core/Axis.h"
 
 // Inertias
-%include "iDynTree/RotationalInertia.h"
-%include "iDynTree/SpatialInertia.h"
-%include "iDynTree/ArticulatedBodyInertia.h"
-%include "iDynTree/InertiaNonLinearParametrization.h"
+%include "iDynTree/Core/RotationalInertiaRaw.h"
+%include "iDynTree/Core/SpatialInertiaRaw.h"
+%include "iDynTree/Core/SpatialInertia.h"
+%include "iDynTree/Core/ArticulatedBodyInertia.h"
+%include "iDynTree/Core/InertiaNonLinearParametrization.h"
 
 // Transformations: Rotation and Transform
-%include "iDynTree/Rotation.h"
-%include "iDynTree/Transform.h"
-%include "iDynTree/TransformDerivative.h"
-%include "iDynTree/Span.h"
-%include "iDynTree/MatrixView.h"
+%include "iDynTree/Core/RotationRaw.h"
+%include "iDynTree/Core/Rotation.h"
+%include "iDynTree/Core/Transform.h"
+%include "iDynTree/Core/TransformDerivative.h"
+%include "iDynTree/Core/Span.h"
+%include "iDynTree/Core/MatrixView.h"
 
 %template(DynamicSpan) iDynTree::Span<double, iDynTree::dynamic_extent>;
 %template(DynamicMatrixView) iDynTree::MatrixView<double>;
 
 // Model related data structures
-%include "iDynTree/Indices.h"
-%include "iDynTree/LinkState.h"
-%include "iDynTree/Link.h"
-%include "iDynTree/IJoint.h"
-%include "iDynTree/FixedJoint.h"
-%include "iDynTree/MovableJointImpl.h"
+%include "iDynTree/Model/Indices.h"
+%include "iDynTree/Model/LinkState.h"
+%include "iDynTree/Model/Link.h"
+%include "iDynTree/Model/IJoint.h"
+%include "iDynTree/Model/FixedJoint.h"
+%include "iDynTree/Model/MovableJointImpl.h"
 
 %template(MovableJointImpl1) iDynTree::MovableJointImpl<1,1>;
 %template(MovableJointImpl2) iDynTree::MovableJointImpl<2,2>;
 %template(MovableJointImpl3) iDynTree::MovableJointImpl<3,3>;
 %template(MovableJointImpl4) iDynTree::MovableJointImpl<4,4>;
 %template(MovableJointImpl5) iDynTree::MovableJointImpl<5,5>;
 %template(MovableJointImpl6) iDynTree::MovableJointImpl<6,6>;
 
-%include "iDynTree/RevoluteJoint.h"
-%include "iDynTree/PrismaticJoint.h"
-%include "iDynTree/Traversal.h"
-%include "iDynTree/SolidShapes.h"
-%include "iDynTree/Sensors.h"
-%include "iDynTree/Model.h"
-%include "iDynTree/JointState.h"
-%include "iDynTree/FreeFloatingMatrices.h"
-%include "iDynTree/FreeFloatingState.h"
-%include "iDynTree/ContactWrench.h"
-%include "iDynTree/ModelTestUtils.h"
-%include "iDynTree/ModelTransformers.h"
-%include "iDynTree/SubModel.h"
-%include "iDynTree/SixAxisForceTorqueSensor.h"
-%include "iDynTree/AccelerometerSensor.h"
-%include "iDynTree/GyroscopeSensor.h"
-%include "iDynTree/ThreeAxisAngularAccelerometerSensor.h"
-%include "iDynTree/ThreeAxisForceTorqueContactSensor.h"
-%include "iDynTree/PredictSensorsMeasurements.h"
+%include "iDynTree/Model/RevoluteJoint.h"
+%include "iDynTree/Model/PrismaticJoint.h"
+%include "iDynTree/Model/Traversal.h"
+%include "iDynTree/Model/SolidShapes.h"
+%include "iDynTree/Model/Model.h"
+%include "iDynTree/Model/JointState.h"
+%include "iDynTree/Model/FreeFloatingMatrices.h"
+%include "iDynTree/Model/FreeFloatingState.h"
+%include "iDynTree/Model/ContactWrench.h"
+%include "iDynTree/Model/ModelTestUtils.h"
+%include "iDynTree/Model/ModelTransformers.h"
+%include "iDynTree/Model/SubModel.h"
 
-%include "sensors.i"
 %include "joints.i"
 
 %template(SolidShapesVector) std::vector<iDynTree::SolidShape*>;
 %template(LinksSolidShapesVector) std::vector< std::vector<iDynTree::SolidShape *>>;
 
 
 // Kinematics & Dynamics related functions
-%include "iDynTree/ForwardKinematics.h"
-%include "iDynTree/Dynamics.h"
-%include "iDynTree/DenavitHartenberg.h"
+%include "iDynTree/Model/ForwardKinematics.h"
+%include "iDynTree/Model/Dynamics.h"
+%include "iDynTree/Model/DenavitHartenberg.h"
+
+// Sensors related data structures
+%include "iDynTree/Sensors/Sensors.h"
+%include "iDynTree/Sensors/SixAxisForceTorqueSensor.h"
+%include "iDynTree/Sensors/AccelerometerSensor.h"
+%include "iDynTree/Sensors/GyroscopeSensor.h"
+%include "iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h"
+%include "iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h"
+%include "iDynTree/Sensors/PredictSensorsMeasurements.h"
+
+%include "sensors.i"
 
 // Model loading from external formats
-%include "iDynTree/URDFDofsImport.h"
-%include "iDynTree/ModelLoader.h"
-%include "iDynTree/ModelExporter.h"
-%include "iDynTree/ModelCalibrationHelper.h"
+%include "iDynTree/ModelIO/URDFDofsImport.h"
+%include "iDynTree/ModelIO/ModelLoader.h"
+%include "iDynTree/ModelIO/ModelExporter.h"
+%include "iDynTree/ModelIO/ModelCalibrationHelper.h"
 
 // Estimation related classes
-%include "iDynTree/ExternalWrenchesEstimation.h"
-%include "iDynTree/ExtWrenchesAndJointTorquesEstimator.h"
-%include "iDynTree/SimpleLeggedOdometry.h"
-%include "iDynTree/BerdyHelper.h"
-%include "iDynTree/BerdySparseMAPSolver.h"
-%include "iDynTree/AttitudeEstimator.h"
-%include "iDynTree/AttitudeMahonyFilter.h"
-%include "iDynTree/ExtendedKalmanFilter.h"
-%include "iDynTree/AttitudeQuaternionEKF.h"
+%include "iDynTree/Estimation/ExternalWrenchesEstimation.h"
+%include "iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h"
+%include "iDynTree/Estimation/SimpleLeggedOdometry.h"
+%include "iDynTree/Estimation/BerdyHelper.h"
+%include "iDynTree/Estimation/BerdySparseMAPSolver.h"
+%include "iDynTree/Estimation/AttitudeEstimator.h"
+%include "iDynTree/Estimation/AttitudeMahonyFilter.h"
+%include "iDynTree/Estimation/ExtendedKalmanFilter.h"
+%include "iDynTree/Estimation/AttitudeQuaternionEKF.h"
 
 // SolidShapes related classes
 %include "iDynTree/InertialParametersSolidShapesHelpers.h"
 
 // High level interfaces
 #ifdef SWIGPYTHON
 %shared_ptr(iDynTree::KinDynComputations)
```

### Comparing `idyntree-9.1.1.dev66/bindings/ignore.i` & `idyntree-9.1.1.dev7/bindings/ignore.i`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/joints.i` & `idyntree-9.1.1.dev7/bindings/joints.i`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/lua/CMakeLists.txt` & `idyntree-9.1.1.dev7/bindings/lua/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/README.md` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/README.md`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/generalizedBiasForces.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/generalizedBiasForces.m`

 * *Files 12% similar despite different names*

```diff
@@ -10,16 +10,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - h: [6+ndof x 1] generalized bias accelerations.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % create the vector that must be populated with the bias forces
     h_iDyntree = iDynTree.FreeFloatingGeneralizedTorques(KinDynModel.kinDynComp.model);
     
     % get the bias forces
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/generalizedGravityForces.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/generalizedGravityForces.m`

 * *Files 20% similar despite different names*

```diff
@@ -10,16 +10,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - g: [6+ndof x 1] generalized gravity forces.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % create the vector that must be populated with the gravity forces
     g_iDyntree = iDynTree.FreeFloatingGeneralizedTorques(KinDynModel.kinDynComp.model);
     
     % get the gravity forces
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getBaseTwist.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getModelVel.m`

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,36 @@
-function baseVel = getBaseTwist(KinDynModel)
+function stateVel = getModelVel(KinDynModel)
 
-    % GETBASETWIST retrieves the robot base velocity from the reduced model.
+    % GETMODELVEL gets the joints and floating base velocities from the 
+    %                  reduced model.
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT:  baseVel = getBaseTwist(KinDynModel)
+    % FORMAT:  stateVel = getModelVel(KinDynModel)
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
-    % OUTPUTS: - baseVel: [6 x 1] vector of base linear and angular velocity;
+    % OUTPUTS: - stateVel: [6+ndof x 1] vector of joints and base velocities.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
-
-    % get the base velocities
-    baseVel_iDyntree = KinDynModel.kinDynComp.getBaseTwist();
+    
+    % create the vector that must be populated with the stae velocities
+    stateVel_iDyntree = iDynTree.VectorDynSize(KinDynModel.NDOF);
+    
+    % get the joints velocities
+    ack = KinDynModel.kinDynComp.getModelVel(stateVel_iDyntree);
+    
+    % check for errors
+    if ~ack  
+        error('[getModelVel]: unable to retrieve the state velocities from the reduced model.')
+    end
     
     % convert to Matlab format
-    baseVel = baseVel_iDyntree.toMatlab;
+    stateVel = stateVel_iDyntree.toMatlab;
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getCenterOfMassJacobian.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getCenterOfMassJacobian.m`

 * *Files 11% similar despite different names*

```diff
@@ -9,16 +9,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - J_CoM: [3 x 6+ndof] CoM free floating Jacobian.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % create the matrix that must be populated with the jacobian map
     J_CoM_iDyntree = iDynTree.MatrixDynSize(3,KinDynModel.NDOF+6);
     
     % get the free floating jacobian
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getCenterOfMassPosition.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getCenterOfMassPosition.m`

 * *Files 27% similar despite different names*

```diff
@@ -9,16 +9,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - posCoM: [3 x 1] CoM position w.r.t. world frame.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % get the CoM position
     posCoM_iDyntree = KinDynModel.kinDynComp.getCenterOfMassPosition(); 
     
     % covert to matlab
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getCenterOfMassVelocity.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getCenterOfMassVelocity.m`

 * *Files 20% similar despite different names*

```diff
@@ -9,16 +9,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - velCoM: [3 x 1] CoM velocity w.r.t. world frame.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------  
     
     % get the CoM velocity
     velCoM_iDyntree = KinDynModel.kinDynComp.getCenterOfMassVelocity(); 
     
     % covert to matlab
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getCentroidalTotalMomentum.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getCentroidalTotalMomentum.m`

 * *Files 10% similar despite different names*

```diff
@@ -11,16 +11,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - totalMomentum: [6 x 1] vector of linear and angular momentum.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % get the momentum
     totalMomentum_iDyntree = KinDynModel.kinDynComp.getCentroidalTotalMomentum();
     
     % convert to Matlab format
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFloatingBase.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/setFloatingBase.m`

 * *Files 22% similar despite different names*

```diff
@@ -1,24 +1,29 @@
-function baseLinkName = getFloatingBase(KinDynModel)
+function [] = setFloatingBase(KinDynModel,floatBaseLinkName)
 
-    % GETFLOATINGBASE retrieves the floating base link name from the 
-    %                      reduced model.
+    % SETFLOATINGBASE sets the link that is used as floating base.
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT:  baseLinkName = getFloatingBase(KinDynModel)
+    % FORMAT: [] = setFloatingBase(KinDynModel,floatBaseLinkName)
     %
-    % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
-    %
-    % OUTPUTS: - baseLinkName: name of the base link.
+    % INPUTS: - floatBaseLinkName: a string with the name of the link to be
+    %                              used as floating base;
+    %         - KinDynModel: a structure containing the loaded model and additional info.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
-    % get the name of the floating base link
-    baseLinkName = KinDynModel.kinDynComp.getFloatingBase();  
+    % set the floating base link
+    ack = KinDynModel.kinDynComp.setFloatingBase(floatBaseLinkName);
+    
+    % check for errors
+    if ~ack  
+        error('[setFloatingBase]: unable to set the floating base link.')
+    end  
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameBiasAcc.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameFreeFloatingJacobian.m`

 * *Files 27% similar despite different names*

```diff
@@ -1,28 +1,38 @@
-function JDot_nu_frame = getFrameBiasAcc(KinDynModel,frameName)
+function J_frame = getFrameFreeFloatingJacobian(KinDynModel,frameName)
 
-    % GETFRAMEBIASACC gets the bias accelerations of a specified frame. 
+    % GETFRAMEFREEFLOATINGJACOBIAN gets the free floating jacobian of a 
+    %                                   specified frame. 
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT:  JDot_nu_frame = getFrameBiasAcc(KinDynModel,frameName)
+    % FORMAT:  J_frame = getFrameFreeFloatingJacobian(KinDynModel,frameName)
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %          - frameName: a string that specifies the frame w.r.t. compute the 
-    %                       bias accelerations, or the associated ID;     
+    %                       jacobian matrix, or the associated ID;     
     %
-    % OUTPUTS: - JDot_nu_frame: [6 x 6+ndof] frame bias accelerations.
+    % OUTPUTS: - J_frame: [6 x 6+ndof] frame free floating Jacobian.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
-    % get the bias acc
-    JDot_nu_frame_iDyntree = KinDynModel.kinDynComp.getFrameBiasAcc(frameName);
+    % create the matrix that must be populated with the jacobian map
+    J_frame_iDyntree = iDynTree.MatrixDynSize(6,KinDynModel.NDOF+6);
+    
+    % get the free floating jacobian
+    ack = KinDynModel.kinDynComp.getFrameFreeFloatingJacobian(frameName,J_frame_iDyntree);
+    
+    % check for errors
+    if ~ack   
+        error('[getFrameFreeFloatingJacobian]: unable to get the Jacobian from the reduced model.')
+    end
     
     % convert to Matlab format
-    JDot_nu_frame = JDot_nu_frame_iDyntree.toMatlab;
+    J_frame = J_frame_iDyntree.toMatlab;
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameFreeFloatingJacobian.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getJointVel.m`

 * *Files 24% similar despite different names*

```diff
@@ -1,37 +1,35 @@
-function J_frame = getFrameFreeFloatingJacobian(KinDynModel,frameName)
+function jointVel = getJointVel(KinDynModel)
 
-    % GETFRAMEFREEFLOATINGJACOBIAN gets the free floating jacobian of a 
-    %                                   specified frame. 
+    % GETJOINTVEL retrieves joint velocities from the reduced model.
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT:  J_frame = getFrameFreeFloatingJacobian(KinDynModel,frameName)
+    % FORMAT:  jointVel = getJointVel(KinDynModel)
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
-    %          - frameName: a string that specifies the frame w.r.t. compute the 
-    %                       jacobian matrix, or the associated ID;     
     %
-    % OUTPUTS: - J_frame: [6 x 6+ndof] frame free floating Jacobian.
+    % OUTPUTS: - jointVel: [ndof x 1] vector of joint velocities.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
+
+    % create the vector that must be populated with the joint velocities
+    jointVel_iDyntree = iDynTree.VectorDynSize(KinDynModel.NDOF);
     
-    % create the matrix that must be populated with the jacobian map
-    J_frame_iDyntree = iDynTree.MatrixDynSize(6,KinDynModel.NDOF+6);
-    
-    % get the free floating jacobian
-    ack = KinDynModel.kinDynComp.getFrameFreeFloatingJacobian(frameName,J_frame_iDyntree);
+    % get the joints velocities
+    ack = KinDynModel.kinDynComp.getJointVel(jointVel_iDyntree);
     
     % check for errors
     if ~ack   
-        error('[getFrameFreeFloatingJacobian]: unable to get the Jacobian from the reduced model.')
+        error('[getJointVel]: unable to retrieve the joint velocities from the reduced model.')
     end
     
     % convert to Matlab format
-    J_frame = J_frame_iDyntree.toMatlab;
+    jointVel = jointVel_iDyntree.toMatlab;
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameIndex.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameIndex.m`

 * *Files 26% similar despite different names*

```diff
@@ -10,15 +10,16 @@
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %          - frameName: a string specifying a valid frame name.
     %
     % OUTPUTS: - frameID: the ID associated to the given frame name.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % get the ID of the given frame
     frameID = KinDynModel.kinDynComp.getFrameIndex(frameName); 
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameName.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameName.m`

 * *Files 12% similar despite different names*

```diff
@@ -10,15 +10,16 @@
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %          - frameID: the ID associated to the given frame name.
     %
     % OUTPUTS: - frameName: a string specifying a valid frame name.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
 
     % get the ID of the given frame
     frameName = KinDynModel.kinDynComp.getFrameName(frameID);   
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFrameVelocityRepresentation.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/setFrameVelocityRepresentation.m`

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,55 @@
-function frameVelRepr = getFrameVelocityRepresentation(KinDynModel)
+function [] = setFrameVelocityRepresentation(KinDynModel,frameVelRepr)
 
-    % GETFRAMEVELOCITYREPRESENTATION retrieves the current frame velocity
-    %                                     representation. 
+    % SETFRAMEVELOCITYREPRESENTATION sets the frame velocity representation.
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT:  frameVelRepr = getFrameVelocityRepresentation(KinDynModel)
+    % FORMAT: [] = setFrameVelocityRepresentation(KinDynModel,frameVelRepr)
     %
-    % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
-    %
-    % OUTPUTS: - frameVelRepr: a string with one of the following possible values:
+    % INPUTS:  - frameVelRepr: a string with one of the following values:
     %                          'mixed', 'body', 'inertial';
+    %          - KinDynModel: a structure containing the loaded model and additional info.
     %
-    % Possible frame velocity representations:
+    % Mapping for the frame velocity reperesentation
     %
-    %  0 = INERTIAL_FIXED_REPRESENTATION 	
+    %  0 = INERTIAL_FIXED_REPRESENTATION
     %
     %  1 = BODY_FIXED_REPRESENTATION
     %
     %  2 = MIXED_REPRESENTATION
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
-    
-    frameVelRepr_idyntree = KinDynModel.kinDynComp.getFrameVelocityRepresentation();   
-    
-    % output the current frame velocity representation
-    switch frameVelRepr_idyntree  
+
+    switch frameVelRepr
         
-        case 2
+        case 'mixed'
             
-            frameVelRepr = 'mixed';
+            frameVelRepr_idyntree = iDynTree.MIXED_REPRESENTATION;
                     
-        case 1
+        case 'body'
             
-            frameVelRepr = 'body';
+            frameVelRepr_idyntree = iDynTree.BODY_FIXED_REPRESENTATION;
                     
-        case 0
+        case 'inertial'
             
-            frameVelRepr = 'inertial';
+            frameVelRepr_idyntree = iDynTree.INERTIAL_FIXED_REPRESENTATION;
                     
         otherwise        
             error('[setFrameVelocityRepresentation]: frameVelRepr is not a valid string.')
-    end   
+    end
+             
+    % set the desired frameVelRepr
+    ack = KinDynModel.kinDynComp.setFrameVelocityRepresentation(frameVelRepr_idyntree);
+    
+    % check for errors
+    if ~ack    
+        error('[setFrameVelocityRepresentation]: unable to set the frame velocity representation.')
+    end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getFreeFloatingMassMatrix.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFreeFloatingMassMatrix.m`

 * *Files 5% similar despite different names*

```diff
@@ -9,16 +9,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - M: [6+ndof x 6+ndof] free floating mass matrix.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % create the matrix that must be populated with the mass info
     M_iDyntree = iDynTree.MatrixDynSize(KinDynModel.NDOF+6,KinDynModel.NDOF+6);
     
     % get the mass matrix
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getJointPos.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/setJointPos.m`

 * *Files 16% similar despite different names*

```diff
@@ -1,34 +1,52 @@
-function jointPos = getJointPos(KinDynModel)
+function [] = setJointPos(KinDynModel,jointPos)
 
-    % GETJOINTPOS retrieves the joints configuration from the reduced model.
+    % SETJOINTPOS sets the joints configuration for kino-dynamic 
+    %                  computations.
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT:  jointPos = getJointPos(KinDynModel)
+    % FORMAT: [] = setJointPos(KinDynModel,jointPos)
     %
-    % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
-    %
-    % OUTPUTS: - jointPos: [ndof x 1] vector of joint positions.
+    % INPUTS: - jointPos: [ndof x 1] vector representing the joints 
+    %                     configuration in radians;
+    %         - KinDynModel: a structure containing the loaded model and additional info.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
+
+    % Debug input
+    if KinDynModel.DEBUG
+        
+        disp('[setJointPos]: debugging inputs...')
+        
+        % check joints position vector size
+        if length(jointPos) ~= KinDynModel.NDOF
+            
+            error('[setJointPos]: the length of jointPos is not KinDynModel.NDOF')
+        end
+            
+        disp('[setJointPos]: done.')     
+    end
     
-    % create the vector that must be populated with the joint positions
+    % convert the joint position to a dynamic size vector
     jointPos_iDyntree = iDynTree.VectorDynSize(KinDynModel.NDOF);
     
-    % get the joints positions
-    ack = KinDynModel.kinDynComp.getJointPos(jointPos_iDyntree);
-    
-    % check for errors
-    if ~ack   
-        error('[getJointPos]: unable to retrieve the joint positions from the reduced model.')
+    for k = 0:length(jointPos)-1
+        
+        jointPos_iDyntree.setVal(k,jointPos(k+1));
     end
     
-    % convert to Matlab format
-    jointPos = jointPos_iDyntree.toMatlab;
+    % set the current joint positions
+    ack = KinDynModel.kinDynComp.setJointPos(jointPos_iDyntree);
+    
+    % check for errors
+    if ~ack  
+        error('[setJointPos]: unable to set the joint positions.')
+    end  
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getMeshes.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getMeshes.m`

 * *Files 6% similar despite different names*

```diff
@@ -10,16 +10,17 @@
 %         - `map`        : Cell array having both the names of the meshes and the associated link
 %         - `linkMeshInfo` : Struct array that contain the link name and a struct (`meshInfo`) that contains the name of file or if is a simple geometry, the triangulation ( edges and vertices of the mesh ) and the link to geometry transform.
 %
 % NOTE: at the moment only STL files are supported.
 %
 % Author : Francisco Andrade (franciscojavier.andradechavez@iit.it)
 %
-% SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+% Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+% This software may be modified and distributed under the terms of the
+% GNU Lesser General Public License v2.1 or any later version.
 
 
 
 % get the linkSolidShapes containing the mesh information
 visual=model.visualSolidShapes;
 linkSolidShapesV=visual.getLinkSolidShapes;
 % get number of links
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getModelVel.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameBiasAcc.m`

 * *Files 24% similar despite different names*

```diff
@@ -1,35 +1,29 @@
-function stateVel = getModelVel(KinDynModel)
+function JDot_nu_frame = getFrameBiasAcc(KinDynModel,frameName)
 
-    % GETMODELVEL gets the joints and floating base velocities from the 
-    %                  reduced model.
+    % GETFRAMEBIASACC gets the bias accelerations of a specified frame. 
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT:  stateVel = getModelVel(KinDynModel)
+    % FORMAT:  JDot_nu_frame = getFrameBiasAcc(KinDynModel,frameName)
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
+    %          - frameName: a string that specifies the frame w.r.t. compute the 
+    %                       bias accelerations, or the associated ID;     
     %
-    % OUTPUTS: - stateVel: [6+ndof x 1] vector of joints and base velocities.
+    % OUTPUTS: - JDot_nu_frame: [6 x 6+ndof] frame bias accelerations.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
-    % create the vector that must be populated with the stae velocities
-    stateVel_iDyntree = iDynTree.VectorDynSize(KinDynModel.NDOF);
-    
-    % get the joints velocities
-    ack = KinDynModel.kinDynComp.getModelVel(stateVel_iDyntree);
-    
-    % check for errors
-    if ~ack  
-        error('[getModelVel]: unable to retrieve the state velocities from the reduced model.')
-    end
+    % get the bias acc
+    JDot_nu_frame_iDyntree = KinDynModel.kinDynComp.getFrameBiasAcc(frameName);
     
     % convert to Matlab format
-    stateVel = stateVel_iDyntree.toMatlab;
+    JDot_nu_frame = JDot_nu_frame_iDyntree.toMatlab;
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getNrOfDegreesOfFreedom.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getNrOfDegreesOfFreedom.m`

 * *Files 7% similar despite different names*

```diff
@@ -9,16 +9,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - nDof: number of DoFs of the system.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
 
     % get the number of DoF
     nDof = KinDynModel.kinDynComp.getNrOfDegreesOfFreedom(); 
     
     % Debug output
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getRelativeJacobian.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getRelativeJacobian.m`

 * *Files 6% similar despite different names*

```diff
@@ -15,16 +15,17 @@
     %                        is the one mapped by the jacobian;
     %          - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - J_frameVel: [6 x ndof] frameVel Jacobian.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
 
     % create the matrix that must be populated with the jacobian map
     J_frameVel_iDyntree = iDynTree.MatrixDynSize(6,KinDynModel.NDOF);
     
     % get the relative jacobian
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getRelativeTransform.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getRelativeTransform.m`

 * *Files 4% similar despite different names*

```diff
@@ -14,16 +14,17 @@
     %                        transfomation matrix, or the associated ID;   
     %          - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - frame1_H_frame2: [4 x 4] from frame2 to frame1 transformation matrix.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % get the transformation between the frame 1 and 2
     frame1_H_frame2_iDyntree = KinDynModel.kinDynComp.getRelativeTransform(frame1Name,frame2Name);  
     frame1_R_frame2_iDyntree = frame1_H_frame2_iDyntree.getRotation;
     framePos_iDyntree        = frame1_H_frame2_iDyntree.getPosition;
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getRobotState.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getRobotState.m`

 * *Files 2% similar despite different names*

```diff
@@ -12,16 +12,17 @@
     % OUTPUTS: - basePose: [4 x 4] from base frame to world frame transform;
     %          - jointPos: [ndof x 1] vector of joint positions;
     %          - baseVel: [6 x 1] vector of base velocity;
     %          - jointVel: [ndof x 1] vector of joint velocities.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
 
     % define all the iDyntree required quantities
     basePose_iDyntree   = iDynTree.Transform();
     jointPos_iDyntree   = iDynTree.VectorDynSize(KinDynModel.NDOF);
     baseVel_iDyntree    = iDynTree.Twist();
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getWorldBaseTransform.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getWorldBaseTransform.m`

 * *Files 3% similar despite different names*

```diff
@@ -10,16 +10,17 @@
     %
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - basePose: [4 x 4] from base to world transformation matrix.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % get the transformation between the base and the world frames 
     basePose_iDyntree     = KinDynModel.kinDynComp.getWorldBaseTransform();  
     baseRotation_iDyntree = basePose_iDyntree.getRotation;
     baseOrigin_iDyntree   = basePose_iDyntree.getPosition;
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getWorldTransform.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getWorldTransform.m`

 * *Files 10% similar despite different names*

```diff
@@ -13,16 +13,17 @@
     %          - KinDynModel: a structure containing the loaded model and additional info.
     %
     % OUTPUTS: - w_H_frame: [4 x 4] from frame to world transformation matrix.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it), Francisco Andrade
     % (franciscojavier.andradechavez@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % get the transformation between the frame and the world in Matlab
     % format
     w_H_frame = KinDynModel.kinDynComp.getWorldTransform(frameName).asHomogeneousTransform.toMatlab;
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/getWorldTransformsAsHomogeneous.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getWorldTransformsAsHomogeneous.m`

 * *Files 7% similar despite different names*

```diff
@@ -12,16 +12,17 @@
 %                       transfomation matrix;
 %          - KinDynModel: a structure containing the loaded model and additional info.
 %
 % OUTPUTS: - w_H_frames: [size(frameNames) x 4 x 4] from frame to world transformation matrices.
 %
 % Author : Francisco Andrade(franciscojavier.andradechavez@iit.it)
 %
-% SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+% Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+% This software may be modified and distributed under the terms of the
+% GNU Lesser General Public License v2.1 or any later version.
 
 %% ------------Initialization----------------
 
 % get the transformation between the frame and the world in Matlab
 % format
 transforms_idyn=KinDynModel.kinDynComp.getWorldTransformsAsHomogeneous(frameNames);
 w_H_frames= transforms_idyn.toMatlab();
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/initializeVisualizer.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/initializeVisualizer.m`

 * *Files 11% similar despite different names*

```diff
@@ -13,16 +13,17 @@
     % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
     %          - debugMode: if TRUE, the visualizer is used in "debug" mode;
     %
     % OUTPUTS: - Visualizer: a structure containing the visualizer and its options.
     % 
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     Visualizer.viz   = iDynTree.Visualizer();
     
     % load the model in the visualizer
     ack = Visualizer.viz.addModel(KinDynModel.kinDynComp.model(),'viz1');
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/loadReducedModel.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/loadReducedModel.m`

 * *Files 6% similar despite different names*

```diff
@@ -15,16 +15,17 @@
     %          - modelName: a string that specifies the model name;
     %          - debugMode: if TRUE, the wrappers are used in "debug" mode;
     %
     % OUTPUTS: - KinDynModel: a structure containing the loaded model and additional info.
     %
     % Author: Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     disp(['[loadReducedModel]: loading the following model: ',[modelPath,modelName]]);
         
     % if DEBUG option is set to TRUE, all the wrappers will be run in debug
     % mode. Wrappers concerning iDyntree simulator have their own debugger
     KinDynModel.DEBUG      = debugMode;
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/modifyLinkVisual.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/modifyLinkVisual.m`

 * *Files 9% similar despite different names*

```diff
@@ -13,16 +13,17 @@
 %         - `meshHandles`  : Struct that contains all the created handles for the meshes. There can be more than one mesh for each link.
 %         - `transform`    : The transform object for the link
 %         - `material` : Selects effect with which the patch is rendered. Options are : 'dull','metal','shiny';
 %         - `useDefault`  : Enables the use of the default values instead of ignoring non specified changes.
 %
 % Author : Francisco Andrade (franciscojavier.andradechavez@iit.it)
 %
-% SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+% Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+% This software may be modified and distributed under the terms of the
+% GNU Lesser General Public License v2.1 or any later version.
 %% input parser section
 p = inputParser;
 p.StructExpand = false;
 p.KeepUnmatched= true;
 % Default values
 default_color= [0.1843    0.3098    0.3098];
 default_transparency=0.5;
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/modifyLinksVisualization.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/modifyLinksVisualization.m`

 * *Files 4% similar despite different names*

```diff
@@ -9,16 +9,17 @@
 %       - Optional Inputs:
 %             - `linksToModify`  : Cell array containing the names of the links to modify
 %             - `linksIndices`   : array containing the indices of the links to modify
 % :exclamation:   Note: all extra variables are sent to `modifyLinkVisual`
 %
 % Author : Francisco Andrade (franciscojavier.andradechavez@iit.it)
 %
-% SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+% Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+% This software may be modified and distributed under the terms of the
+% GNU Lesser General Public License v2.1 or any later version.
 %% input parser section
 p = inputParser;
 p.StructExpand = false;
 p.KeepUnmatched= true;
 % Default values
 default_linksToModify={'all'};
 default_linksIndices=-99;
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/plotFrame.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/plotFrame.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/plotMeshInWorld.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/plotMeshInWorld.m`

 * *Files 6% similar despite different names*

```diff
@@ -12,16 +12,17 @@
 %         - `style` : Selects the style of display of meshes, either fullMesh or wireframe.
 %     - Outputs:
 %         - `meshHandles`  : Struct that contains all the created handles for the meshes. There can be more than one mesh for each link.
 %         - `transform`    : The transform object for the link
 %
 % Author : Francisco Andrade (franciscojavier.andradechavez@iit.it)
 %
-% SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+% Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+% This software may be modified and distributed under the terms of the
+% GNU Lesser General Public License v2.1 or any later version.
 %% input parser section
 p = inputParser;
 p.StructExpand = false;
 p.KeepUnmatched= true;
 % Default values
 default_color= [0.1843    0.3098    0.3098];
 default_transparency=0.5;
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/prepareVisualization.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/prepareVisualization.m`

 * *Files 2% similar despite different names*

```diff
@@ -28,16 +28,17 @@
 %           - `parent`     : Contains the axes object of the parent figure.
 %           - `mainHandler`: Is the handle of the overall figure.
 %           - `DEBUG` : Flag stating if the debug mode was set or not.
 %           Fields included if debug mode is on:
 %           - `map`       : Cell array having both the names of the meshes and the associated link
 %           - `linkMeshInfo` : Contains the link name and a struct (meshInfo) that contains the name of file or if is a simple geometry, the triangulation ( edges and vertices of the mesh ) and the link to geometry transform.% Author : Francisco Andrade (franciscojavier.andradechavez@iit.it)
 %
-% SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+% Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+% This software may be modified and distributed under the terms of the
+% GNU Lesser General Public License v2.1 or any later version.
 %% input parser section
 p = inputParser;
 p.StructExpand = false;
 p.KeepUnmatched= true;
 % Default values
 default_view=[128.0181 16.8000];
 default_material='dull';
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/setFloatingBase.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getBaseTwist.m`

 * *Files 23% similar despite different names*

```diff
@@ -1,28 +1,27 @@
-function [] = setFloatingBase(KinDynModel,floatBaseLinkName)
+function baseVel = getBaseTwist(KinDynModel)
 
-    % SETFLOATINGBASE sets the link that is used as floating base.
+    % GETBASETWIST retrieves the robot base velocity from the reduced model.
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT: [] = setFloatingBase(KinDynModel,floatBaseLinkName)
+    % FORMAT:  baseVel = getBaseTwist(KinDynModel)
     %
-    % INPUTS: - floatBaseLinkName: a string with the name of the link to be
-    %                              used as floating base;
-    %         - KinDynModel: a structure containing the loaded model and additional info.
+    % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
+    %
+    % OUTPUTS: - baseVel: [6 x 1] vector of base linear and angular velocity;
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
+
+    % get the base velocities
+    baseVel_iDyntree = KinDynModel.kinDynComp.getBaseTwist();
     
-    % set the floating base link
-    ack = KinDynModel.kinDynComp.setFloatingBase(floatBaseLinkName);
-    
-    % check for errors
-    if ~ack  
-        error('[setFloatingBase]: unable to set the floating base link.')
-    end  
+    % convert to Matlab format
+    baseVel = baseVel_iDyntree.toMatlab;
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/setFrameVelocityRepresentation.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/getFrameVelocityRepresentation.m`

 * *Files 18% similar despite different names*

```diff
@@ -1,54 +1,52 @@
-function [] = setFrameVelocityRepresentation(KinDynModel,frameVelRepr)
+function frameVelRepr = getFrameVelocityRepresentation(KinDynModel)
 
-    % SETFRAMEVELOCITYREPRESENTATION sets the frame velocity representation.
+    % GETFRAMEVELOCITYREPRESENTATION retrieves the current frame velocity
+    %                                     representation. 
     %
     % This matlab function wraps a functionality of the iDyntree library.                     
     % For further info see also: https://github.com/robotology/idyntree
     %
-    % FORMAT: [] = setFrameVelocityRepresentation(KinDynModel,frameVelRepr)
+    % FORMAT:  frameVelRepr = getFrameVelocityRepresentation(KinDynModel)
     %
-    % INPUTS:  - frameVelRepr: a string with one of the following values:
+    % INPUTS:  - KinDynModel: a structure containing the loaded model and additional info.
+    %
+    % OUTPUTS: - frameVelRepr: a string with one of the following possible values:
     %                          'mixed', 'body', 'inertial';
-    %          - KinDynModel: a structure containing the loaded model and additional info.
     %
-    % Mapping for the frame velocity reperesentation
+    % Possible frame velocity representations:
     %
-    %  0 = INERTIAL_FIXED_REPRESENTATION
+    %  0 = INERTIAL_FIXED_REPRESENTATION 	
     %
     %  1 = BODY_FIXED_REPRESENTATION
     %
     %  2 = MIXED_REPRESENTATION
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
-
-    switch frameVelRepr
+    
+    frameVelRepr_idyntree = KinDynModel.kinDynComp.getFrameVelocityRepresentation();   
+    
+    % output the current frame velocity representation
+    switch frameVelRepr_idyntree  
         
-        case 'mixed'
+        case 2
             
-            frameVelRepr_idyntree = iDynTree.MIXED_REPRESENTATION;
+            frameVelRepr = 'mixed';
                     
-        case 'body'
+        case 1
             
-            frameVelRepr_idyntree = iDynTree.BODY_FIXED_REPRESENTATION;
+            frameVelRepr = 'body';
                     
-        case 'inertial'
+        case 0
             
-            frameVelRepr_idyntree = iDynTree.INERTIAL_FIXED_REPRESENTATION;
+            frameVelRepr = 'inertial';
                     
         otherwise        
             error('[setFrameVelocityRepresentation]: frameVelRepr is not a valid string.')
-    end
-             
-    % set the desired frameVelRepr
-    ack = KinDynModel.kinDynComp.setFrameVelocityRepresentation(frameVelRepr_idyntree);
-    
-    % check for errors
-    if ~ack    
-        error('[setFrameVelocityRepresentation]: unable to set the frame velocity representation.')
-    end
+    end   
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/setRobotState.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/setRobotState.m`

 * *Files 2% similar despite different names*

```diff
@@ -28,16 +28,17 @@
     %          - baseVel: [6 x 1] vector of base velocities [lin, ang];
     %          - jointVel: [ndof x 1] vector of joints velocities;
     %          - gravAcc: [3 x 1] vector of the gravity acceleration in the
     %                             inertial frame.
     %
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
 
     KinDynModel = varargin{1};
     
     % check the number of inputs
     switch nargin
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/updateFrame.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/updateFrame.m`

 * *Files 15% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 
 %% updateFrame 
 % updateFrame updates a 3D frame added with the plotFrame function
 % Inputs:
 %    - frame: The struct output by plotFrame
 %    - newTransform : The new 3D transformation (4x4 matrix)
 %
-% SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+% Copyright (C) 2020 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+% This software may be modified and distributed under the terms of the
+% GNU Lesser General Public License v2.1 or any later version.
 
 R = newTransform(1:3, 1:3);
 
 or = newTransform(1:3, 4);
 
 p = [or, or, or] + frame.axisDimension * R;
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/updateVisualization.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/updateVisualization.m`

 * *Files 14% similar despite different names*

```diff
@@ -7,15 +7,16 @@
 %           - `visualizer` : variable output from the `prepareVisualization` function. It contains the relevant variables linkNames,transforms and NOBJ
 %               - `linkNames`  : variable that contains the link names.
 %               - `transforms` : variable that contains transform objects that are parent of the meshes.
 %               - `NOBJ` : variable that contains the number of visual objects to update.
 %
 % Author : Francisco Andrade (franciscojavier.andradechavez@iit.it)
 %
-% SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+% Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+% This software may be modified and distributed under the terms of the
+% GNU Lesser General Public License v2.1 or any later version.
 
 transforms_idyn=KinDynModel.kinDynComp.getWorldTransformsAsHomogeneous(Visualizer.linkNames_idyn);
 w_H_links= transforms_idyn.toMatlab();
 for it=1:Visualizer.NOBJ
     Visualizer.transforms(it).Matrix=squeeze(w_H_links(it,:,:));
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/updateVisualizer.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/updateVisualizer.m`

 * *Files 3% similar despite different names*

```diff
@@ -14,16 +14,17 @@
     %          - Visualizer: a structure containing the visualizer and its options.
     %          - jointPos: [ndof x 1] vector representing the joints
     %                      configuration in radians;
     %          - basePose: [4 x 4] from base frame to world frame transform.
     % 
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
 
     % Debug input
     if Visualizer.DEBUG
         
         disp('[updateVisualizer]: debugging inputs...')
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/+iDynTreeWrappers/visualizerSetup.m` & `idyntree-9.1.1.dev7/bindings/matlab/+iDynTreeWrappers/visualizerSetup.m`

 * *Files 13% similar despite different names*

```diff
@@ -15,16 +15,17 @@
     %                                      inertial frame;
     %          - lightDir: [3 x 1] vector describing the light direction;
     %          - cameraPos: [3 x 1] vector describing the camera position;
     %          - cameraTarget: [3 x 1] vector describing the camera target;
     % 
     % Author : Gabriele Nava (gabriele.nava@iit.it)
     %
-    % SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-% SPDX-License-Identifier: BSD-3-Clause
+    % Copyright (C) 2019 Istituto Italiano di Tecnologia (IIT). All rights reserved.
+    % This software may be modified and distributed under the terms of the
+    % GNU Lesser General Public License v2.1 or any later version.
 
     %% ------------Initialization----------------
     
     % disable environmental features  
     if disableViewInertialFrame
         
         enviroment = Visualizer.viz.enviroment();
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/CMakeLists.txt` & `idyntree-9.1.1.dev7/bindings/matlab/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AccelerometerSensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AccelerometerSensor.m`

 * *Files 3% similar despite different names*

```diff
@@ -3,61 +3,61 @@
     function self = AccelerometerSensor(varargin)
       self@iDynTree.LinkSensor(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1340, varargin{:});
+        tmp = iDynTreeMEX(1376, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1341, self);
+        iDynTreeMEX(1377, self);
         self.SwigClear();
       end
     end
     function varargout = setName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1342, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1378, self, varargin{:});
     end
     function varargout = setLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1343, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1379, self, varargin{:});
     end
     function varargout = setParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1344, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1380, self, varargin{:});
     end
     function varargout = setParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1345, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1381, self, varargin{:});
     end
     function varargout = getName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1346, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1382, self, varargin{:});
     end
     function varargout = getSensorType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1347, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1383, self, varargin{:});
     end
     function varargout = getParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1348, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1384, self, varargin{:});
     end
     function varargout = getParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1349, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1385, self, varargin{:});
     end
     function varargout = getLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1350, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1386, self, varargin{:});
     end
     function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1351, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1387, self, varargin{:});
     end
     function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1352, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1388, self, varargin{:});
     end
     function varargout = updateIndices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1353, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1389, self, varargin{:});
     end
     function varargout = predictMeasurement(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1354, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1390, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyAlgorithmInternalBuffers.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyAlgorithmInternalBuffers.m`

 * *Files 5% similar despite different names*

```diff
@@ -5,118 +5,118 @@
     end
     function self = ArticulatedBodyAlgorithmInternalBuffers(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1465, varargin{:});
+        tmp = iDynTreeMEX(1240, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1466, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1241, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1467, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1242, self, varargin{:});
     end
     function varargout = S(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1468, self);
+        varargout{1} = iDynTreeMEX(1243, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1469, self, varargin{1});
+        iDynTreeMEX(1244, self, varargin{1});
       end
     end
     function varargout = U(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1470, self);
+        varargout{1} = iDynTreeMEX(1245, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1471, self, varargin{1});
+        iDynTreeMEX(1246, self, varargin{1});
       end
     end
     function varargout = D(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1472, self);
+        varargout{1} = iDynTreeMEX(1247, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1473, self, varargin{1});
+        iDynTreeMEX(1248, self, varargin{1});
       end
     end
     function varargout = u(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1474, self);
+        varargout{1} = iDynTreeMEX(1249, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1475, self, varargin{1});
+        iDynTreeMEX(1250, self, varargin{1});
       end
     end
     function varargout = linksVel(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1476, self);
+        varargout{1} = iDynTreeMEX(1251, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1477, self, varargin{1});
+        iDynTreeMEX(1252, self, varargin{1});
       end
     end
     function varargout = linksBiasAcceleration(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1478, self);
+        varargout{1} = iDynTreeMEX(1253, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1479, self, varargin{1});
+        iDynTreeMEX(1254, self, varargin{1});
       end
     end
     function varargout = linksAccelerations(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1480, self);
+        varargout{1} = iDynTreeMEX(1255, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1481, self, varargin{1});
+        iDynTreeMEX(1256, self, varargin{1});
       end
     end
     function varargout = linkABIs(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1482, self);
+        varargout{1} = iDynTreeMEX(1257, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1483, self, varargin{1});
+        iDynTreeMEX(1258, self, varargin{1});
       end
     end
     function varargout = linksBiasWrench(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1484, self);
+        varargout{1} = iDynTreeMEX(1259, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1485, self, varargin{1});
+        iDynTreeMEX(1260, self, varargin{1});
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1486, self);
+        iDynTreeMEX(1261, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyInertia.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector10.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,65 +1,74 @@
-classdef ArticulatedBodyInertia < iDynTreeSwigRef
+classdef Vector10 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = ArticulatedBodyInertia(varargin)
+    function self = Vector10(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(648, varargin{:});
+        tmp = iDynTreeMEX(368, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = getLinearLinearSubmatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(649, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(369, self, varargin{:});
     end
-    function varargout = getLinearAngularSubmatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(650, self, varargin{:});
+    function varargout = brace(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(370, self, varargin{:});
     end
-    function varargout = getAngularAngularSubmatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(651, self, varargin{:});
+    function varargout = getVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(371, self, varargin{:});
     end
-    function varargout = applyInverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(653, self, varargin{:});
+    function varargout = setVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(372, self, varargin{:});
     end
-    function varargout = asMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(654, self, varargin{:});
+    function varargout = cbegin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(373, self, varargin{:});
     end
-    function varargout = getInverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(655, self, varargin{:});
+    function varargout = cend(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(374, self, varargin{:});
     end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(656, self, varargin{:});
+    function varargout = begin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(375, self, varargin{:});
     end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(657, self, varargin{:});
+    function varargout = end(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(376, self, varargin{:});
     end
-    function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(658, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(377, self, varargin{:});
+    end
+    function varargout = data(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(378, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(659, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(379, self, varargin{:});
+    end
+    function varargout = fillBuffer(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(380, self, varargin{:});
+    end
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(381, self, varargin{:});
+    end
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(382, self, varargin{:});
+    end
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(383, self, varargin{:});
+    end
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(384, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(662, self);
+        iDynTreeMEX(385, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
-    function varargout = combine(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(652, varargin{:});
-    end
-    function varargout = ABADyadHelper(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(660, varargin{:});
-    end
-    function varargout = ABADyadHelperLin(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(661, varargin{:});
-    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeEstimatorState.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IndexRange.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,56 +1,52 @@
-classdef AttitudeEstimatorState < iDynTreeSwigRef
+classdef IndexRange < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = m_orientation(self, varargin)
+    function varargout = offset(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1731, self);
+        varargout{1} = iDynTreeMEX(123, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1732, self, varargin{1});
+        iDynTreeMEX(124, self, varargin{1});
       end
     end
-    function varargout = m_angular_velocity(self, varargin)
+    function varargout = size(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1733, self);
+        varargout{1} = iDynTreeMEX(125, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1734, self, varargin{1});
+        iDynTreeMEX(126, self, varargin{1});
       end
     end
-    function varargout = m_gyroscope_bias(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1735, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(1736, self, varargin{1});
-      end
+    function varargout = isValid(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(127, self, varargin{:});
     end
-    function self = AttitudeEstimatorState(varargin)
+    function self = IndexRange(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1737, varargin{:});
+        tmp = iDynTreeMEX(129, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1738, self);
+        iDynTreeMEX(130, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
+    function varargout = InvalidRange(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(128, varargin{:});
+    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeMahonyFilter.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeMahonyFilter.m`

 * *Files 4% similar despite different names*

```diff
@@ -3,76 +3,76 @@
     function self = AttitudeMahonyFilter(varargin)
       self@iDynTree.IAttitudeEstimator(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1762, varargin{:});
+        tmp = iDynTreeMEX(1679, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = useMagnetoMeterMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1763, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1680, self, varargin{:});
     end
     function varargout = setConfidenceForMagnetometerMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1764, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1681, self, varargin{:});
     end
     function varargout = setGainkp(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1765, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1682, self, varargin{:});
     end
     function varargout = setGainki(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1766, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1683, self, varargin{:});
     end
     function varargout = setTimeStepInSeconds(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1767, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1684, self, varargin{:});
     end
     function varargout = setGravityDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1768, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1685, self, varargin{:});
     end
     function varargout = setParameters(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1769, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1686, self, varargin{:});
     end
     function varargout = getParameters(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1770, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1687, self, varargin{:});
     end
     function varargout = updateFilterWithMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1771, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1688, self, varargin{:});
     end
     function varargout = propagateStates(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1772, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1689, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsRotationMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1773, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1690, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsQuaternion(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1774, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1691, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsRPY(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1775, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1692, self, varargin{:});
     end
     function varargout = getInternalStateSize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1776, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1693, self, varargin{:});
     end
     function varargout = getInternalState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1777, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1694, self, varargin{:});
     end
     function varargout = getDefaultInternalInitialState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1778, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1695, self, varargin{:});
     end
     function varargout = setInternalState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1779, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1696, self, varargin{:});
     end
     function varargout = setInternalStateInitialOrientation(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1780, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1697, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1781, self);
+        iDynTreeMEX(1698, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeMahonyFilterParameters.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeMahonyFilterParameters.m`

 * *Files 6% similar despite different names*

```diff
@@ -3,74 +3,74 @@
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = time_step_in_seconds(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1750, self);
+        varargout{1} = iDynTreeMEX(1667, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1751, self, varargin{1});
+        iDynTreeMEX(1668, self, varargin{1});
       end
     end
     function varargout = kp(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1752, self);
+        varargout{1} = iDynTreeMEX(1669, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1753, self, varargin{1});
+        iDynTreeMEX(1670, self, varargin{1});
       end
     end
     function varargout = ki(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1754, self);
+        varargout{1} = iDynTreeMEX(1671, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1755, self, varargin{1});
+        iDynTreeMEX(1672, self, varargin{1});
       end
     end
     function varargout = use_magnetometer_measurements(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1756, self);
+        varargout{1} = iDynTreeMEX(1673, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1757, self, varargin{1});
+        iDynTreeMEX(1674, self, varargin{1});
       end
     end
     function varargout = confidence_magnetometer_measurements(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1758, self);
+        varargout{1} = iDynTreeMEX(1675, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1759, self, varargin{1});
+        iDynTreeMEX(1676, self, varargin{1});
       end
     end
     function self = AttitudeMahonyFilterParameters(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1760, varargin{:});
+        tmp = iDynTreeMEX(1677, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1761, self);
+        iDynTreeMEX(1678, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeQuaternionEKF.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeQuaternionEKF.m`

 * *Files 3% similar despite different names*

```diff
@@ -7,82 +7,82 @@
       self@iDynTree.IAttitudeEstimator(iDynTreeSwigRef.Null);
       self@iDynTree.DiscreteExtendedKalmanFilterHelper(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1827, varargin{:});
+        tmp = iDynTreeMEX(1744, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = getParameters(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1828, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1745, self, varargin{:});
     end
     function varargout = setParameters(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1829, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1746, self, varargin{:});
     end
     function varargout = setGravityDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1830, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1747, self, varargin{:});
     end
     function varargout = setTimeStepInSeconds(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1831, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1748, self, varargin{:});
     end
     function varargout = setBiasCorrelationTimeFactor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1832, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1749, self, varargin{:});
     end
     function varargout = useMagnetometerMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1833, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1750, self, varargin{:});
     end
     function varargout = setMeasurementNoiseVariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1834, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1751, self, varargin{:});
     end
     function varargout = setSystemNoiseVariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1835, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1752, self, varargin{:});
     end
     function varargout = setInitialStateCovariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1836, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1753, self, varargin{:});
     end
     function varargout = initializeFilter(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1837, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1754, self, varargin{:});
     end
     function varargout = updateFilterWithMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1838, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1755, self, varargin{:});
     end
     function varargout = propagateStates(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1839, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1756, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsRotationMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1840, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1757, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsQuaternion(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1841, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1758, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsRPY(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1842, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1759, self, varargin{:});
     end
     function varargout = getInternalStateSize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1843, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1760, self, varargin{:});
     end
     function varargout = getInternalState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1844, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1761, self, varargin{:});
     end
     function varargout = getDefaultInternalInitialState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1845, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1762, self, varargin{:});
     end
     function varargout = setInternalState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1846, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1763, self, varargin{:});
     end
     function varargout = setInternalStateInitialOrientation(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1847, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1764, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1848, self);
+        iDynTreeMEX(1765, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/AttitudeQuaternionEKFParameters.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeQuaternionEKFParameters.m`

 * *Files 2% similar despite different names*

```diff
@@ -3,124 +3,124 @@
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = time_step_in_seconds(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1805, self);
+        varargout{1} = iDynTreeMEX(1722, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1806, self, varargin{1});
+        iDynTreeMEX(1723, self, varargin{1});
       end
     end
     function varargout = bias_correlation_time_factor(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1807, self);
+        varargout{1} = iDynTreeMEX(1724, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1808, self, varargin{1});
+        iDynTreeMEX(1725, self, varargin{1});
       end
     end
     function varargout = accelerometer_noise_variance(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1809, self);
+        varargout{1} = iDynTreeMEX(1726, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1810, self, varargin{1});
+        iDynTreeMEX(1727, self, varargin{1});
       end
     end
     function varargout = magnetometer_noise_variance(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1811, self);
+        varargout{1} = iDynTreeMEX(1728, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1812, self, varargin{1});
+        iDynTreeMEX(1729, self, varargin{1});
       end
     end
     function varargout = gyroscope_noise_variance(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1813, self);
+        varargout{1} = iDynTreeMEX(1730, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1814, self, varargin{1});
+        iDynTreeMEX(1731, self, varargin{1});
       end
     end
     function varargout = gyro_bias_noise_variance(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1815, self);
+        varargout{1} = iDynTreeMEX(1732, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1816, self, varargin{1});
+        iDynTreeMEX(1733, self, varargin{1});
       end
     end
     function varargout = initial_orientation_error_variance(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1817, self);
+        varargout{1} = iDynTreeMEX(1734, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1818, self, varargin{1});
+        iDynTreeMEX(1735, self, varargin{1});
       end
     end
     function varargout = initial_ang_vel_error_variance(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1819, self);
+        varargout{1} = iDynTreeMEX(1736, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1820, self, varargin{1});
+        iDynTreeMEX(1737, self, varargin{1});
       end
     end
     function varargout = initial_gyro_bias_error_variance(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1821, self);
+        varargout{1} = iDynTreeMEX(1738, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1822, self, varargin{1});
+        iDynTreeMEX(1739, self, varargin{1});
       end
     end
     function varargout = use_magnetometer_measurements(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1823, self);
+        varargout{1} = iDynTreeMEX(1740, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1824, self, varargin{1});
+        iDynTreeMEX(1741, self, varargin{1});
       end
     end
     function self = AttitudeQuaternionEKFParameters(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1825, varargin{:});
+        tmp = iDynTreeMEX(1742, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1826, self);
+        iDynTreeMEX(1743, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Axis.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Axis.m`

 * *Files 6% similar despite different names*

```diff
@@ -5,70 +5,70 @@
     end
     function self = Axis(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(603, varargin{:});
+        tmp = iDynTreeMEX(537, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = getDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(604, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(538, self, varargin{:});
     end
     function varargout = getOrigin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(605, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(539, self, varargin{:});
     end
     function varargout = setDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(606, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(540, self, varargin{:});
     end
     function varargout = setOrigin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(607, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(541, self, varargin{:});
     end
     function varargout = getRotationTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(608, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(542, self, varargin{:});
     end
     function varargout = getRotationTransformDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(609, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(543, self, varargin{:});
     end
     function varargout = getRotationTwist(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(610, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(544, self, varargin{:});
     end
     function varargout = getRotationSpatialAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(611, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(545, self, varargin{:});
     end
     function varargout = getTranslationTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(612, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(546, self, varargin{:});
     end
     function varargout = getTranslationTransformDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(613, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(547, self, varargin{:});
     end
     function varargout = getTranslationTwist(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(614, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(548, self, varargin{:});
     end
     function varargout = getTranslationSpatialAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(615, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(549, self, varargin{:});
     end
     function varargout = isParallel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(616, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(550, self, varargin{:});
     end
     function varargout = reverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(617, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(551, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(618, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(552, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(619, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(553, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(620, self);
+        iDynTreeMEX(554, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdyDynamicVariable.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdySensor.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-classdef BerdyDynamicVariable < iDynTreeSwigRef
+classdef BerdySensor < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = type(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1672, self);
+        varargout{1} = iDynTreeMEX(1579, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1673, self, varargin{1});
+        iDynTreeMEX(1580, self, varargin{1});
       end
     end
     function varargout = id(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1674, self);
+        varargout{1} = iDynTreeMEX(1581, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1675, self, varargin{1});
+        iDynTreeMEX(1582, self, varargin{1});
       end
     end
     function varargout = range(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1676, self);
+        varargout{1} = iDynTreeMEX(1583, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1677, self, varargin{1});
+        iDynTreeMEX(1584, self, varargin{1});
       end
     end
     function varargout = eq(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1678, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1585, self, varargin{:});
     end
     function varargout = lt(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1679, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1586, self, varargin{:});
     end
-    function self = BerdyDynamicVariable(varargin)
+    function self = BerdySensor(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1680, varargin{:});
+        tmp = iDynTreeMEX(1587, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1681, self);
+        iDynTreeMEX(1588, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdyDynamicVariables.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdySensors.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-classdef BerdyDynamicVariables < iDynTreeSwigRef
+classdef BerdySensors < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(171, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(71, self, varargin{:});
     end
     function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(172, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(72, self, varargin{:});
     end
     function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(173, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(73, self, varargin{:});
     end
     function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(174, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(74, self, varargin{:});
     end
     function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(175, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(75, self, varargin{:});
     end
     function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(176, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(76, self, varargin{:});
     end
     function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(177, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(77, self, varargin{:});
     end
     function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(178, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(78, self, varargin{:});
     end
     function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(179, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(79, self, varargin{:});
     end
     function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(180, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(80, self, varargin{:});
     end
     function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(181, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(81, self, varargin{:});
     end
     function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(182, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(82, self, varargin{:});
     end
     function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(183, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(83, self, varargin{:});
     end
     function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(184, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(84, self, varargin{:});
     end
     function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(185, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(85, self, varargin{:});
     end
-    function self = BerdyDynamicVariables(varargin)
+    function self = BerdySensors(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(186, varargin{:});
+        tmp = iDynTreeMEX(86, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(187, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(87, self, varargin{:});
     end
     function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(188, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(88, self, varargin{:});
     end
     function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(189, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(89, self, varargin{:});
     end
     function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(190, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(90, self, varargin{:});
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(191, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(91, self, varargin{:});
     end
     function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(192, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(92, self, varargin{:});
     end
     function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(193, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(93, self, varargin{:});
     end
     function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(194, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(94, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(195, self);
+        iDynTreeMEX(95, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdyHelper.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdyHelper.m`

 * *Files 3% similar despite different names*

```diff
@@ -5,115 +5,115 @@
     end
     function self = BerdyHelper(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1682, varargin{:});
+        tmp = iDynTreeMEX(1599, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = dynamicTraversal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1683, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1600, self, varargin{:});
     end
     function varargout = model(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1684, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1601, self, varargin{:});
     end
     function varargout = sensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1685, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1602, self, varargin{:});
     end
     function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1686, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1603, self, varargin{:});
     end
     function varargout = init(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1687, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1604, self, varargin{:});
     end
     function varargout = getOptions(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1688, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1605, self, varargin{:});
     end
     function varargout = getNrOfDynamicVariables(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1689, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1606, self, varargin{:});
     end
     function varargout = getNrOfDynamicEquations(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1690, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1607, self, varargin{:});
     end
     function varargout = getNrOfSensorsMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1691, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1608, self, varargin{:});
     end
     function varargout = resizeAndZeroBerdyMatrices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1692, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1609, self, varargin{:});
     end
     function varargout = getBerdyMatrices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1693, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1610, self, varargin{:});
     end
     function varargout = getSensorsOrdering(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1694, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1611, self, varargin{:});
     end
     function varargout = getRangeSensorVariable(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1695, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1612, self, varargin{:});
     end
     function varargout = getRangeDOFSensorVariable(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1696, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1613, self, varargin{:});
     end
     function varargout = getRangeJointSensorVariable(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1697, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1614, self, varargin{:});
     end
     function varargout = getRangeLinkSensorVariable(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1698, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1615, self, varargin{:});
     end
     function varargout = getRangeRCMSensorVariable(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1699, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1616, self, varargin{:});
     end
     function varargout = getRangeLinkVariable(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1700, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1617, self, varargin{:});
     end
     function varargout = getRangeJointVariable(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1701, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1618, self, varargin{:});
     end
     function varargout = getRangeDOFVariable(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1702, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1619, self, varargin{:});
     end
     function varargout = getDynamicVariablesOrdering(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1703, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1620, self, varargin{:});
     end
     function varargout = serializeDynamicVariables(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1704, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1621, self, varargin{:});
     end
     function varargout = serializeSensorVariables(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1705, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1622, self, varargin{:});
     end
     function varargout = serializeDynamicVariablesComputedFromFixedBaseRNEA(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1706, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1623, self, varargin{:});
     end
     function varargout = extractJointTorquesFromDynamicVariables(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1707, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1624, self, varargin{:});
     end
     function varargout = extractLinkNetExternalWrenchesFromDynamicVariables(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1708, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1625, self, varargin{:});
     end
     function varargout = updateKinematicsFromFloatingBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1709, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1626, self, varargin{:});
     end
     function varargout = updateKinematicsFromFixedBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1710, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1627, self, varargin{:});
     end
     function varargout = updateKinematicsFromTraversalFixedBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1711, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1628, self, varargin{:});
     end
     function varargout = setNetExternalWrenchMeasurementFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1712, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1629, self, varargin{:});
     end
     function varargout = getNetExternalWrenchMeasurementFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1713, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1630, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1714, self);
+        iDynTreeMEX(1631, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdyOptions.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdyOptions.m`

 * *Files 4% similar despite different names*

```diff
@@ -5,105 +5,105 @@
     end
     function self = BerdyOptions(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1643, varargin{:});
+        tmp = iDynTreeMEX(1560, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = berdyVariant(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1644, self);
+        varargout{1} = iDynTreeMEX(1561, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1645, self, varargin{1});
+        iDynTreeMEX(1562, self, varargin{1});
       end
     end
     function varargout = includeAllNetExternalWrenchesAsDynamicVariables(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1646, self);
+        varargout{1} = iDynTreeMEX(1563, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1647, self, varargin{1});
+        iDynTreeMEX(1564, self, varargin{1});
       end
     end
     function varargout = includeAllJointAccelerationsAsSensors(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1648, self);
+        varargout{1} = iDynTreeMEX(1565, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1649, self, varargin{1});
+        iDynTreeMEX(1566, self, varargin{1});
       end
     end
     function varargout = includeAllJointTorquesAsSensors(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1650, self);
+        varargout{1} = iDynTreeMEX(1567, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1651, self, varargin{1});
+        iDynTreeMEX(1568, self, varargin{1});
       end
     end
     function varargout = includeAllNetExternalWrenchesAsSensors(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1652, self);
+        varargout{1} = iDynTreeMEX(1569, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1653, self, varargin{1});
+        iDynTreeMEX(1570, self, varargin{1});
       end
     end
     function varargout = includeFixedBaseExternalWrench(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1654, self);
+        varargout{1} = iDynTreeMEX(1571, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1655, self, varargin{1});
+        iDynTreeMEX(1572, self, varargin{1});
       end
     end
     function varargout = jointOnWhichTheInternalWrenchIsMeasured(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1656, self);
+        varargout{1} = iDynTreeMEX(1573, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1657, self, varargin{1});
+        iDynTreeMEX(1574, self, varargin{1});
       end
     end
     function varargout = baseLink(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1658, self);
+        varargout{1} = iDynTreeMEX(1575, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1659, self, varargin{1});
+        iDynTreeMEX(1576, self, varargin{1});
       end
     end
     function varargout = checkConsistency(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1660, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1577, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1661, self);
+        iDynTreeMEX(1578, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdySensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdyDynamicVariable.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-classdef BerdySensor < iDynTreeSwigRef
+classdef BerdyDynamicVariable < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = type(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1662, self);
+        varargout{1} = iDynTreeMEX(1589, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1663, self, varargin{1});
+        iDynTreeMEX(1590, self, varargin{1});
       end
     end
     function varargout = id(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1664, self);
+        varargout{1} = iDynTreeMEX(1591, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1665, self, varargin{1});
+        iDynTreeMEX(1592, self, varargin{1});
       end
     end
     function varargout = range(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1666, self);
+        varargout{1} = iDynTreeMEX(1593, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1667, self, varargin{1});
+        iDynTreeMEX(1594, self, varargin{1});
       end
     end
     function varargout = eq(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1668, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1595, self, varargin{:});
     end
     function varargout = lt(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1669, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1596, self, varargin{:});
     end
-    function self = BerdySensor(varargin)
+    function self = BerdyDynamicVariable(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1670, varargin{:});
+        tmp = iDynTreeMEX(1597, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1671, self);
+        iDynTreeMEX(1598, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdySensors.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IntVector.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-classdef BerdySensors < iDynTreeSwigRef
+classdef IntVector < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(146, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(46, self, varargin{:});
     end
     function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(147, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(47, self, varargin{:});
     end
     function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(148, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(48, self, varargin{:});
     end
     function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(149, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(49, self, varargin{:});
     end
     function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(150, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(50, self, varargin{:});
     end
     function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(151, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(51, self, varargin{:});
     end
     function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(152, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(52, self, varargin{:});
     end
     function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(153, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(53, self, varargin{:});
     end
     function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(154, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(54, self, varargin{:});
     end
     function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(155, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(55, self, varargin{:});
     end
     function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(156, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(56, self, varargin{:});
     end
     function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(157, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(57, self, varargin{:});
     end
     function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(158, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(58, self, varargin{:});
     end
     function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(159, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(59, self, varargin{:});
     end
     function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(160, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(60, self, varargin{:});
     end
-    function self = BerdySensors(varargin)
+    function self = IntVector(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(161, varargin{:});
+        tmp = iDynTreeMEX(61, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(162, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(62, self, varargin{:});
     end
     function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(163, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(63, self, varargin{:});
     end
     function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(164, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(64, self, varargin{:});
     end
     function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(165, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(65, self, varargin{:});
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(166, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(66, self, varargin{:});
     end
     function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(167, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(67, self, varargin{:});
     end
     function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(168, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(68, self, varargin{:});
     end
     function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(169, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(69, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(170, self);
+        iDynTreeMEX(70, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/BerdySparseMAPSolver.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdySparseMAPSolver.m`

 * *Files 7% similar despite different names*

```diff
@@ -5,64 +5,64 @@
     end
     function self = BerdySparseMAPSolver(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1715, varargin{:});
+        tmp = iDynTreeMEX(1632, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1716, self);
+        iDynTreeMEX(1633, self);
         self.SwigClear();
       end
     end
     function varargout = setDynamicsConstraintsPriorCovariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1717, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1634, self, varargin{:});
     end
     function varargout = setDynamicsRegularizationPriorCovariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1718, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1635, self, varargin{:});
     end
     function varargout = setDynamicsRegularizationPriorExpectedValue(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1719, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1636, self, varargin{:});
     end
     function varargout = setMeasurementsPriorCovariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1720, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1637, self, varargin{:});
     end
     function varargout = dynamicsConstraintsPriorCovarianceInverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1721, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1638, self, varargin{:});
     end
     function varargout = dynamicsRegularizationPriorCovarianceInverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1722, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1639, self, varargin{:});
     end
     function varargout = dynamicsRegularizationPriorExpectedValue(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1723, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1640, self, varargin{:});
     end
     function varargout = measurementsPriorCovarianceInverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1724, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1641, self, varargin{:});
     end
     function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1725, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1642, self, varargin{:});
     end
     function varargout = initialize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1726, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1643, self, varargin{:});
     end
     function varargout = updateEstimateInformationFixedBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1727, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1644, self, varargin{:});
     end
     function varargout = updateEstimateInformationFloatingBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1728, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1645, self, varargin{:});
     end
     function varargout = doEstimate(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1729, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1646, self, varargin{:});
     end
     function varargout = getLastEstimate(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1730, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1647, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Box.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Box.m`

 * *Files 2% similar despite different names*

```diff
@@ -1,44 +1,44 @@
 classdef Box < iDynTree.SolidShape
   methods
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1084, self);
+        iDynTreeMEX(1011, self);
         self.SwigClear();
       end
     end
     function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1085, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1012, self, varargin{:});
     end
     function varargout = getX(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1086, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1013, self, varargin{:});
     end
     function varargout = setX(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1087, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1014, self, varargin{:});
     end
     function varargout = getY(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1088, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1015, self, varargin{:});
     end
     function varargout = setY(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1089, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1016, self, varargin{:});
     end
     function varargout = getZ(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1090, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1017, self, varargin{:});
     end
     function varargout = setZ(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1091, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1018, self, varargin{:});
     end
     function self = Box(varargin)
       self@iDynTree.SolidShape(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1092, varargin{:});
+        tmp = iDynTreeMEX(1019, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
   end
   methods(Static)
   end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ClassicalAcc.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ClassicalAcc.m`

 * *Files 6% similar despite different names*

```diff
@@ -3,34 +3,34 @@
     function self = ClassicalAcc(varargin)
       self@iDynTree.Vector6(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(588, varargin{:});
+        tmp = iDynTreeMEX(522, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = changeCoordFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(589, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(523, self, varargin{:});
     end
     function varargout = fromSpatial(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(591, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(525, self, varargin{:});
     end
     function varargout = toSpatial(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(592, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(526, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(593, self);
+        iDynTreeMEX(527, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
     function varargout = Zero(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(590, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(524, varargin{:});
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ColorViz.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ColorViz.m`

 * *Files 4% similar despite different names*

```diff
@@ -3,64 +3,64 @@
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = r(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1949, self);
+        varargout{1} = iDynTreeMEX(1866, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1950, self, varargin{1});
+        iDynTreeMEX(1867, self, varargin{1});
       end
     end
     function varargout = g(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1951, self);
+        varargout{1} = iDynTreeMEX(1868, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1952, self, varargin{1});
+        iDynTreeMEX(1869, self, varargin{1});
       end
     end
     function varargout = b(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1953, self);
+        varargout{1} = iDynTreeMEX(1870, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1954, self, varargin{1});
+        iDynTreeMEX(1871, self, varargin{1});
       end
     end
     function varargout = a(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1955, self);
+        varargout{1} = iDynTreeMEX(1872, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1956, self, varargin{1});
+        iDynTreeMEX(1873, self, varargin{1});
       end
     end
     function self = ColorViz(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1957, varargin{:});
+        tmp = iDynTreeMEX(1874, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1958, self);
+        iDynTreeMEX(1875, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ContactWrench.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Twist.m`

 * *Files 9% similar despite different names*

```diff
@@ -1,35 +1,36 @@
-classdef ContactWrench < iDynTreeSwigRef
+classdef Twist < iDynTree.SpatialMotionVector
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function varargout = contactId(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1272, self, varargin{:});
-    end
-    function varargout = contactPoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1273, self, varargin{:});
-    end
-    function varargout = contactWrench(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1274, self, varargin{:});
-    end
-    function self = ContactWrench(varargin)
+    function self = Twist(varargin)
+      self@iDynTree.SpatialMotionVector(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1275, varargin{:});
+        tmp = iDynTreeMEX(501, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(502, self, varargin{:});
+    end
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(503, self, varargin{:});
+    end
+    function varargout = uminus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(504, self, varargin{:});
+    end
+    function varargout = mtimes(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(505, self, varargin{:});
+    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1276, self);
+        iDynTreeMEX(506, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ConvexHullProjectionConstraint.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ConvexHullProjectionConstraint.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,140 +1,140 @@
 classdef ConvexHullProjectionConstraint < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = setActive(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2107, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2024, self, varargin{:});
     end
     function varargout = isActive(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2108, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2025, self, varargin{:});
     end
     function varargout = getNrOfConstraints(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2109, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2026, self, varargin{:});
     end
     function varargout = projectedConvexHull(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2110, self);
+        varargout{1} = iDynTreeMEX(2027, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2111, self, varargin{1});
+        iDynTreeMEX(2028, self, varargin{1});
       end
     end
     function varargout = A(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2112, self);
+        varargout{1} = iDynTreeMEX(2029, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2113, self, varargin{1});
+        iDynTreeMEX(2030, self, varargin{1});
       end
     end
     function varargout = b(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2114, self);
+        varargout{1} = iDynTreeMEX(2031, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2115, self, varargin{1});
+        iDynTreeMEX(2032, self, varargin{1});
       end
     end
     function varargout = P(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2116, self);
+        varargout{1} = iDynTreeMEX(2033, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2117, self, varargin{1});
+        iDynTreeMEX(2034, self, varargin{1});
       end
     end
     function varargout = Pdirection(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2118, self);
+        varargout{1} = iDynTreeMEX(2035, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2119, self, varargin{1});
+        iDynTreeMEX(2036, self, varargin{1});
       end
     end
     function varargout = AtimesP(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2120, self);
+        varargout{1} = iDynTreeMEX(2037, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2121, self, varargin{1});
+        iDynTreeMEX(2038, self, varargin{1});
       end
     end
     function varargout = o(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2122, self);
+        varargout{1} = iDynTreeMEX(2039, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2123, self, varargin{1});
+        iDynTreeMEX(2040, self, varargin{1});
       end
     end
     function varargout = buildConvexHull(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2124, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2041, self, varargin{:});
     end
     function varargout = supportFrameIndices(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2125, self);
+        varargout{1} = iDynTreeMEX(2042, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2126, self, varargin{1});
+        iDynTreeMEX(2043, self, varargin{1});
       end
     end
     function varargout = absoluteFrame_X_supportFrame(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2127, self);
+        varargout{1} = iDynTreeMEX(2044, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2128, self, varargin{1});
+        iDynTreeMEX(2045, self, varargin{1});
       end
     end
     function varargout = project(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2129, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2046, self, varargin{:});
     end
     function varargout = computeMargin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2130, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2047, self, varargin{:});
     end
     function varargout = setProjectionAlongDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2131, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2048, self, varargin{:});
     end
     function varargout = projectAlongDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2132, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2049, self, varargin{:});
     end
     function self = ConvexHullProjectionConstraint(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(2133, varargin{:});
+        tmp = iDynTreeMEX(2050, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2134, self);
+        iDynTreeMEX(2051, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Cylinder.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Cylinder.m`

 * *Files 3% similar despite different names*

```diff
@@ -1,38 +1,38 @@
 classdef Cylinder < iDynTree.SolidShape
   methods
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1093, self);
+        iDynTreeMEX(1020, self);
         self.SwigClear();
       end
     end
     function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1094, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1021, self, varargin{:});
     end
     function varargout = getLength(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1095, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1022, self, varargin{:});
     end
     function varargout = setLength(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1096, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1023, self, varargin{:});
     end
     function varargout = getRadius(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1097, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1024, self, varargin{:});
     end
     function varargout = setRadius(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1098, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1025, self, varargin{:});
     end
     function self = Cylinder(varargin)
       self@iDynTree.SolidShape(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1099, varargin{:});
+        tmp = iDynTreeMEX(1026, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
   end
   methods(Static)
   end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DHChain.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DHChain.m`

 * *Files 2% similar despite different names*

```diff
@@ -1,59 +1,59 @@
 classdef DHChain < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = setNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1503, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1278, self, varargin{:});
     end
     function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1504, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1279, self, varargin{:});
     end
     function varargout = setH0(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1505, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1280, self, varargin{:});
     end
     function varargout = getH0(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1506, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1281, self, varargin{:});
     end
     function varargout = setHN(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1507, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1282, self, varargin{:});
     end
     function varargout = getHN(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1508, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1283, self, varargin{:});
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1509, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1284, self, varargin{:});
     end
     function varargout = getDOFName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1510, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1285, self, varargin{:});
     end
     function varargout = setDOFName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1511, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1286, self, varargin{:});
     end
     function varargout = toModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1512, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1287, self, varargin{:});
     end
     function varargout = fromModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1513, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1288, self, varargin{:});
     end
     function self = DHChain(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1514, varargin{:});
+        tmp = iDynTreeMEX(1289, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1515, self);
+        iDynTreeMEX(1290, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DHLink.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/VisualizerOptions.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,86 +1,66 @@
-classdef DHLink < iDynTreeSwigRef
+classdef VisualizerOptions < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = A(self, varargin)
+    function varargout = verbose(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1489, self);
+        varargout{1} = iDynTreeMEX(1969, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1490, self, varargin{1});
+        iDynTreeMEX(1970, self, varargin{1});
       end
     end
-    function varargout = D(self, varargin)
+    function varargout = winWidth(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1491, self);
+        varargout{1} = iDynTreeMEX(1971, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1492, self, varargin{1});
+        iDynTreeMEX(1972, self, varargin{1});
       end
     end
-    function varargout = Alpha(self, varargin)
+    function varargout = winHeight(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1493, self);
+        varargout{1} = iDynTreeMEX(1973, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1494, self, varargin{1});
+        iDynTreeMEX(1974, self, varargin{1});
       end
     end
-    function varargout = Offset(self, varargin)
+    function varargout = rootFrameArrowsDimension(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1495, self);
+        varargout{1} = iDynTreeMEX(1975, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1496, self, varargin{1});
+        iDynTreeMEX(1976, self, varargin{1});
       end
     end
-    function varargout = Min(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1497, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(1498, self, varargin{1});
-      end
-    end
-    function varargout = Max(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1499, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(1500, self, varargin{1});
-      end
-    end
-    function self = DHLink(varargin)
+    function self = VisualizerOptions(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1501, varargin{:});
+        tmp = iDynTreeMEX(1977, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1502, self);
+        iDynTreeMEX(1978, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOFSpatialForceArray.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingAcc.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,35 +1,38 @@
-classdef DOFSpatialForceArray < iDynTreeSwigRef
+classdef FreeFloatingAcc < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = DOFSpatialForceArray(varargin)
+    function self = FreeFloatingAcc(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1227, varargin{:});
+        tmp = iDynTreeMEX(1135, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1228, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1136, self, varargin{:});
     end
-    function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1229, self, varargin{:});
+    function varargout = baseAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1137, self, varargin{:});
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1230, self, varargin{:});
+    function varargout = jointAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1138, self, varargin{:});
+    end
+    function varargout = getNrOfDOFs(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1139, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1231, self);
+        iDynTreeMEX(1140, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DOFSpatialMotionArray.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOFSpatialForceArray.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-classdef DOFSpatialMotionArray < iDynTreeSwigRef
+classdef DOFSpatialForceArray < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = DOFSpatialMotionArray(varargin)
+    function self = DOFSpatialForceArray(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1232, varargin{:});
+        tmp = iDynTreeMEX(1096, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1233, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1097, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1234, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1098, self, varargin{:});
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1235, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1099, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1236, self);
+        iDynTreeMEX(1100, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Direction.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IEnvironment.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,45 +1,51 @@
-classdef Direction < iDynTree.Vector3
+classdef IEnvironment < iDynTreeSwigRef
   methods
-    function self = Direction(varargin)
-      self@iDynTree.Vector3(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(594, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1896, self);
+        self.SwigClear();
       end
     end
-    function varargout = Normalize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(595, self, varargin{:});
+    function varargout = getElements(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1897, self, varargin{:});
     end
-    function varargout = isParallel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(596, self, varargin{:});
+    function varargout = setElementVisibility(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1898, self, varargin{:});
     end
-    function varargout = isPerpendicular(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(597, self, varargin{:});
+    function varargout = setBackgroundColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1899, self, varargin{:});
     end
-    function varargout = reverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(598, self, varargin{:});
+    function varargout = setFloorGridColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1900, self, varargin{:});
     end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(599, self, varargin{:});
+    function varargout = setAmbientLight(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1901, self, varargin{:});
     end
-    function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(600, self, varargin{:});
+    function varargout = getLights(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1902, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(602, self);
-        self.SwigClear();
+    function varargout = addLight(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1903, self, varargin{:});
+    end
+    function varargout = lightViz(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1904, self, varargin{:});
+    end
+    function varargout = removeLight(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1905, self, varargin{:});
+    end
+    function self = IEnvironment(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
       end
     end
   end
   methods(Static)
-    function varargout = Default(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(601, varargin{:});
-    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DiscreteExtendedKalmanFilterHelper.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector6.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,81 +1,74 @@
-classdef DiscreteExtendedKalmanFilterHelper < iDynTreeSwigRef
+classdef Vector6 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = ekf_f(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1782, self, varargin{:});
-    end
-    function varargout = ekf_h(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1783, self, varargin{:});
-    end
-    function varargout = ekfComputeJacobianF(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1784, self, varargin{:});
+    function self = Vector6(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(350, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
     end
-    function varargout = ekfComputeJacobianH(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1785, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(351, self, varargin{:});
     end
-    function varargout = ekfPredict(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1786, self, varargin{:});
+    function varargout = brace(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(352, self, varargin{:});
     end
-    function varargout = ekfUpdate(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1787, self, varargin{:});
+    function varargout = getVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(353, self, varargin{:});
     end
-    function varargout = ekfInit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1788, self, varargin{:});
+    function varargout = setVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(354, self, varargin{:});
     end
-    function varargout = ekfReset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1789, self, varargin{:});
+    function varargout = cbegin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(355, self, varargin{:});
     end
-    function varargout = ekfSetMeasurementVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1790, self, varargin{:});
+    function varargout = cend(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(356, self, varargin{:});
     end
-    function varargout = ekfSetInputVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1791, self, varargin{:});
+    function varargout = begin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(357, self, varargin{:});
     end
-    function varargout = ekfSetInitialState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1792, self, varargin{:});
+    function varargout = end(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(358, self, varargin{:});
     end
-    function varargout = ekfSetStateCovariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1793, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(359, self, varargin{:});
     end
-    function varargout = ekfSetSystemNoiseCovariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1794, self, varargin{:});
+    function varargout = data(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(360, self, varargin{:});
     end
-    function varargout = ekfSetMeasurementNoiseCovariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1795, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(361, self, varargin{:});
     end
-    function varargout = ekfSetStateSize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1796, self, varargin{:});
+    function varargout = fillBuffer(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(362, self, varargin{:});
     end
-    function varargout = ekfSetInputSize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1797, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(363, self, varargin{:});
     end
-    function varargout = ekfSetOutputSize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1798, self, varargin{:});
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(364, self, varargin{:});
     end
-    function varargout = ekfGetStates(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1799, self, varargin{:});
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(365, self, varargin{:});
     end
-    function varargout = ekfGetStateCovariance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1800, self, varargin{:});
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(366, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1801, self);
+        iDynTreeMEX(367, self);
         self.SwigClear();
       end
     end
-    function self = DiscreteExtendedKalmanFilterHelper(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        error('No matching constructor');
-      end
-    end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Dummy.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Dummy.m`

 * *Files 2% similar despite different names*

```diff
@@ -5,22 +5,22 @@
     end
     function self = Dummy(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(555, varargin{:});
+        tmp = iDynTreeMEX(489, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(556, self);
+        iDynTreeMEX(490, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DynamicMatrixView.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DynamicMatrixView.m`

 * *Files 2% similar despite different names*

```diff
@@ -5,37 +5,37 @@
     end
     function self = DynamicMatrixView(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(769, varargin{:});
+        tmp = iDynTreeMEX(720, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = storageOrder(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(770, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(721, self, varargin{:});
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(771, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(722, self, varargin{:});
     end
     function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(772, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(723, self, varargin{:});
     end
     function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(773, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(724, self, varargin{:});
     end
     function varargout = block(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(774, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(725, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(775, self);
+        iDynTreeMEX(726, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/DynamicSpan.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DynamicSpan.m`

 * *Files 3% similar despite different names*

```diff
@@ -5,82 +5,82 @@
     end
     function self = DynamicSpan(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(748, varargin{:});
+        tmp = iDynTreeMEX(699, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(749, self);
+        iDynTreeMEX(700, self);
         self.SwigClear();
       end
     end
     function varargout = first(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(750, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(701, self, varargin{:});
     end
     function varargout = last(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(751, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(702, self, varargin{:});
     end
     function varargout = subspan(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(752, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(703, self, varargin{:});
     end
     function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(753, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(704, self, varargin{:});
     end
     function varargout = size_bytes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(754, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(705, self, varargin{:});
     end
     function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(755, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(706, self, varargin{:});
     end
     function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(756, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(707, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(757, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(708, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(758, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(709, self, varargin{:});
     end
     function varargout = at(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(759, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(710, self, varargin{:});
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(760, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(711, self, varargin{:});
     end
     function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(761, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(712, self, varargin{:});
     end
     function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(762, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(713, self, varargin{:});
     end
     function varargout = cbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(763, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(714, self, varargin{:});
     end
     function varargout = cend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(764, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(715, self, varargin{:});
     end
     function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(765, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(716, self, varargin{:});
     end
     function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(766, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(717, self, varargin{:});
     end
     function varargout = crbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(767, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(718, self, varargin{:});
     end
     function varargout = crend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(768, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(719, self, varargin{:});
     end
   end
   methods(Static)
     function v = extent()
-      v = iDynTreeMEX(747);
+      v = iDynTreeMEX(698);
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ExtWrenchesAndJointTorquesEstimator.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/GyroscopeSensor.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,68 +1,63 @@
-classdef ExtWrenchesAndJointTorquesEstimator < iDynTreeSwigRef
+classdef GyroscopeSensor < iDynTree.LinkSensor
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = ExtWrenchesAndJointTorquesEstimator(varargin)
+    function self = GyroscopeSensor(varargin)
+      self@iDynTree.LinkSensor(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1614, varargin{:});
+        tmp = iDynTreeMEX(1391, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1615, self);
+        iDynTreeMEX(1392, self);
         self.SwigClear();
       end
     end
-    function varargout = setModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1616, self, varargin{:});
-    end
-    function varargout = setModelAndSensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1617, self, varargin{:});
+    function varargout = setName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1393, self, varargin{:});
     end
-    function varargout = loadModelAndSensorsFromFile(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1618, self, varargin{:});
+    function varargout = setLinkSensorTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1394, self, varargin{:});
     end
-    function varargout = loadModelAndSensorsFromFileWithSpecifiedDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1619, self, varargin{:});
+    function varargout = setParentLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1395, self, varargin{:});
     end
-    function varargout = model(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1620, self, varargin{:});
+    function varargout = setParentLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1396, self, varargin{:});
     end
-    function varargout = sensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1621, self, varargin{:});
+    function varargout = getName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1397, self, varargin{:});
     end
-    function varargout = submodels(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1622, self, varargin{:});
+    function varargout = getSensorType(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1398, self, varargin{:});
     end
-    function varargout = updateKinematicsFromFloatingBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1623, self, varargin{:});
+    function varargout = getParentLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1399, self, varargin{:});
     end
-    function varargout = updateKinematicsFromFixedBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1624, self, varargin{:});
+    function varargout = getParentLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1400, self, varargin{:});
     end
-    function varargout = computeExpectedFTSensorsMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1625, self, varargin{:});
+    function varargout = getLinkSensorTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1401, self, varargin{:});
     end
-    function varargout = computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1626, self, varargin{:});
+    function varargout = isValid(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1402, self, varargin{:});
     end
-    function varargout = estimateExtWrenchesAndJointTorques(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1627, self, varargin{:});
+    function varargout = clone(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1403, self, varargin{:});
     end
-    function varargout = checkThatTheModelIsStill(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1628, self, varargin{:});
+    function varargout = updateIndices(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1404, self, varargin{:});
     end
-    function varargout = estimateLinkNetWrenchesWithoutGravity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1629, self, varargin{:});
+    function varargout = predictMeasurement(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1405, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ExternalMesh.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SubModelDecomposition.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,48 +1,47 @@
-classdef ExternalMesh < iDynTree.SolidShape
+classdef SubModelDecomposition < iDynTreeSwigRef
   methods
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
+    function self = SubModelDecomposition(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(1169, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
+    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1100, self);
+        iDynTreeMEX(1170, self);
         self.SwigClear();
       end
     end
-    function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1101, self, varargin{:});
+    function varargout = splitModelAlongJoints(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1171, self, varargin{:});
     end
-    function varargout = getFilename(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1102, self, varargin{:});
+    function varargout = setNrOfSubModels(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1172, self, varargin{:});
     end
-    function varargout = getPackageDirs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1103, self, varargin{:});
+    function varargout = getNrOfSubModels(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1173, self, varargin{:});
     end
-    function varargout = getFileLocationOnLocalFileSystem(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1104, self, varargin{:});
+    function varargout = getNrOfLinks(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1174, self, varargin{:});
     end
-    function varargout = setFilename(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1105, self, varargin{:});
+    function varargout = getTraversal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1175, self, varargin{:});
     end
-    function varargout = setPackageDirs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1106, self, varargin{:});
+    function varargout = getSubModelOfLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1176, self, varargin{:});
     end
-    function varargout = getScale(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1107, self, varargin{:});
-    end
-    function varargout = setScale(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1108, self, varargin{:});
-    end
-    function self = ExternalMesh(varargin)
-      self@iDynTree.SolidShape(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(1109, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
+    function varargout = getSubModelOfFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1177, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FixedJoint.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IJoint.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,129 +1,129 @@
-classdef FixedJoint < iDynTree.IJoint
+classdef IJoint < iDynTreeSwigRef
   methods
-    function self = FixedJoint(varargin)
-      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(882, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(883, self);
+        iDynTreeMEX(791, self);
         self.SwigClear();
       end
     end
     function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(884, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(792, self, varargin{:});
     end
     function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(885, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(793, self, varargin{:});
     end
     function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(886, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(794, self, varargin{:});
     end
     function varargout = setAttachedLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(887, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(795, self, varargin{:});
     end
     function varargout = setRestTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(888, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(796, self, varargin{:});
     end
     function varargout = getFirstAttachedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(889, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(797, self, varargin{:});
     end
     function varargout = getSecondAttachedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(890, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(798, self, varargin{:});
     end
     function varargout = getRestTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(891, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(799, self, varargin{:});
     end
     function varargout = getTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(892, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(800, self, varargin{:});
     end
     function varargout = getTransformDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(893, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(801, self, varargin{:});
     end
     function varargout = getMotionSubspaceVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(894, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(802, self, varargin{:});
     end
     function varargout = computeChildPosVelAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(895, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(803, self, varargin{:});
     end
     function varargout = computeChildVelAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(896, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(804, self, varargin{:});
     end
     function varargout = computeChildVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(897, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(805, self, varargin{:});
     end
     function varargout = computeChildAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(898, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(806, self, varargin{:});
     end
     function varargout = computeChildBiasAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(899, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(807, self, varargin{:});
     end
     function varargout = computeJointTorque(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(900, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(808, self, varargin{:});
     end
     function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(901, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(809, self, varargin{:});
     end
     function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(902, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(810, self, varargin{:});
     end
     function varargout = setPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(903, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(811, self, varargin{:});
     end
     function varargout = getPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(904, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(812, self, varargin{:});
     end
     function varargout = setDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(905, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(813, self, varargin{:});
     end
     function varargout = getDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(906, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(814, self, varargin{:});
     end
     function varargout = hasPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(907, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(815, self, varargin{:});
     end
     function varargout = enablePosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(908, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(816, self, varargin{:});
     end
     function varargout = getPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(909, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(817, self, varargin{:});
     end
     function varargout = getMinPosLimit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(910, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(818, self, varargin{:});
     end
     function varargout = getMaxPosLimit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(911, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(819, self, varargin{:});
     end
     function varargout = setPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(912, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(820, self, varargin{:});
+    end
+    function varargout = isRevoluteJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(821, self, varargin{:});
     end
-    function varargout = getJointDynamicsType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(913, self, varargin{:});
+    function varargout = isFixedJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(822, self, varargin{:});
     end
-    function varargout = setJointDynamicsType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(914, self, varargin{:});
+    function varargout = isPrismaticJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(823, self, varargin{:});
     end
-    function varargout = getDamping(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(915, self, varargin{:});
+    function varargout = asRevoluteJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(824, self, varargin{:});
     end
-    function varargout = getStaticFriction(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(916, self, varargin{:});
+    function varargout = asFixedJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(825, self, varargin{:});
     end
-    function varargout = setDamping(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(917, self, varargin{:});
+    function varargout = asPrismaticJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(826, self, varargin{:});
     end
-    function varargout = setStaticFriction(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(918, self, varargin{:});
+    function self = IJoint(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
+      end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FrameFreeFloatingJacobian.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JointPosDoubleArray.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-classdef FrameFreeFloatingJacobian < iDynTree.MatrixDynSize
+classdef JointPosDoubleArray < iDynTree.VectorDynSize
   methods
-    function self = FrameFreeFloatingJacobian(varargin)
-      self@iDynTree.MatrixDynSize(iDynTreeSwigRef.Null);
+    function self = JointPosDoubleArray(varargin)
+      self@iDynTree.VectorDynSize(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1237, varargin{:});
+        tmp = iDynTreeMEX(1088, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1238, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1089, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1239, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1090, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1240, self);
+        iDynTreeMEX(1091, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingAcc.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ICamera.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,38 +1,42 @@
-classdef FreeFloatingAcc < iDynTreeSwigRef
+classdef ICamera < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = FreeFloatingAcc(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(1266, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1859, self);
+        self.SwigClear();
       end
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1267, self, varargin{:});
+    function varargout = setPosition(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1860, self, varargin{:});
     end
-    function varargout = baseAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1268, self, varargin{:});
+    function varargout = setTarget(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1861, self, varargin{:});
     end
-    function varargout = jointAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1269, self, varargin{:});
+    function varargout = getPosition(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1862, self, varargin{:});
     end
-    function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1270, self, varargin{:});
+    function varargout = getTarget(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1863, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(1271, self);
-        self.SwigClear();
+    function varargout = setUpVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1864, self, varargin{:});
+    end
+    function varargout = animator(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1865, self, varargin{:});
+    end
+    function self = ICamera(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingGeneralizedTorques.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingGeneralizedTorques.m`

 * *Files 5% similar despite different names*

```diff
@@ -5,34 +5,34 @@
     end
     function self = FreeFloatingGeneralizedTorques(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1254, varargin{:});
+        tmp = iDynTreeMEX(1123, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1255, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1124, self, varargin{:});
     end
     function varargout = baseWrench(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1256, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1125, self, varargin{:});
     end
     function varargout = jointTorques(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1257, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1126, self, varargin{:});
     end
     function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1258, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1127, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1259, self);
+        iDynTreeMEX(1128, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingMassMatrix.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingMassMatrix.m`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,25 @@
     function self = FreeFloatingMassMatrix(varargin)
       self@iDynTree.MatrixDynSize(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1245, varargin{:});
+        tmp = iDynTreeMEX(1114, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1246, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1115, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1247, self);
+        iDynTreeMEX(1116, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingPos.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Polygon2D.m`

 * *Files 10% similar despite different names*

```diff
@@ -1,38 +1,48 @@
-classdef FreeFloatingPos < iDynTreeSwigRef
+classdef Polygon2D < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = FreeFloatingPos(varargin)
+    function varargout = m_vertices(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(2016, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(2017, self, varargin{1});
+      end
+    end
+    function self = Polygon2D(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1248, varargin{:});
+        tmp = iDynTreeMEX(2018, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1249, self, varargin{:});
+    function varargout = setNrOfVertices(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2019, self, varargin{:});
     end
-    function varargout = worldBasePos(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1250, self, varargin{:});
+    function varargout = getNrOfVertices(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2020, self, varargin{:});
     end
-    function varargout = jointPos(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1251, self, varargin{:});
+    function varargout = isValid(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2021, self, varargin{:});
     end
-    function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1252, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2022, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1253, self);
+        iDynTreeMEX(2023, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/FreeFloatingVel.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Polygon.m`

 * *Files 9% similar despite different names*

```diff
@@ -1,38 +1,54 @@
-classdef FreeFloatingVel < iDynTreeSwigRef
+classdef Polygon < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = FreeFloatingVel(varargin)
+    function varargout = m_vertices(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(2006, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(2007, self, varargin{1});
+      end
+    end
+    function self = Polygon(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1260, varargin{:});
+        tmp = iDynTreeMEX(2008, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1261, self, varargin{:});
+    function varargout = setNrOfVertices(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2009, self, varargin{:});
     end
-    function varargout = baseVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1262, self, varargin{:});
+    function varargout = getNrOfVertices(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2010, self, varargin{:});
     end
-    function varargout = jointVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1263, self, varargin{:});
+    function varargout = isValid(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2011, self, varargin{:});
     end
-    function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1264, self, varargin{:});
+    function varargout = applyTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2012, self, varargin{:});
+    end
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2013, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1265, self);
+        iDynTreeMEX(2015, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
+    function varargout = XYRectangleFromOffsets(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(2014, varargin{:});
+    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/GeomVector3.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MatlabSwigIterator.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,51 +1,69 @@
-classdef GeomVector3 < iDynTree.Vector3
+classdef MatlabSwigIterator < iDynTreeSwigRef
   methods
-    function self = GeomVector3(varargin)
-      self@iDynTree.Vector3(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(494, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(5, self);
+        self.SwigClear();
       end
     end
-    function varargout = changeCoordFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(495, self, varargin{:});
+    function varargout = value(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(6, self, varargin{:});
     end
-    function varargout = compose(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(496, self, varargin{:});
+    function varargout = incr(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(7, self, varargin{:});
     end
-    function varargout = inverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(497, self, varargin{:});
+    function varargout = decr(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(8, self, varargin{:});
     end
-    function varargout = dot(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(498, self, varargin{:});
+    function varargout = distance(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(9, self, varargin{:});
     end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(499, self, varargin{:});
+    function varargout = equal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(10, self, varargin{:});
     end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(500, self, varargin{:});
+    function varargout = copy(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(11, self, varargin{:});
     end
-    function varargout = uminus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(501, self, varargin{:});
+    function varargout = next(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(12, self, varargin{:});
     end
-    function varargout = exp(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(502, self, varargin{:});
+    function varargout = previous(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(13, self, varargin{:});
     end
-    function varargout = cross(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(503, self, varargin{:});
+    function varargout = advance(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(14, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(504, self);
-        self.SwigClear();
+    function varargout = eq(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(15, self, varargin{:});
+    end
+    function varargout = ne(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(16, self, varargin{:});
+    end
+    function varargout = TODOincr(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(17, self, varargin{:});
+    end
+    function varargout = TODOdecr(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(18, self, varargin{:});
+    end
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(19, self, varargin{:});
+    end
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(20, self, varargin{:});
+    end
+    function self = MatlabSwigIterator(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/GyroscopeSensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ThreeAxisAngularAccelerometerSensor.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,63 +1,63 @@
-classdef GyroscopeSensor < iDynTree.LinkSensor
+classdef ThreeAxisAngularAccelerometerSensor < iDynTree.LinkSensor
   methods
-    function self = GyroscopeSensor(varargin)
+    function self = ThreeAxisAngularAccelerometerSensor(varargin)
       self@iDynTree.LinkSensor(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1355, varargin{:});
+        tmp = iDynTreeMEX(1406, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1356, self);
+        iDynTreeMEX(1407, self);
         self.SwigClear();
       end
     end
     function varargout = setName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1357, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1408, self, varargin{:});
     end
     function varargout = setLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1358, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1409, self, varargin{:});
     end
     function varargout = setParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1359, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1410, self, varargin{:});
     end
     function varargout = setParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1360, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1411, self, varargin{:});
     end
     function varargout = getName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1361, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1412, self, varargin{:});
     end
     function varargout = getSensorType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1362, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1413, self, varargin{:});
     end
     function varargout = getParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1363, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1414, self, varargin{:});
     end
     function varargout = getParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1364, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1415, self, varargin{:});
     end
     function varargout = getLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1365, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1416, self, varargin{:});
     end
     function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1366, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1417, self, varargin{:});
     end
     function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1367, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1418, self, varargin{:});
     end
     function varargout = updateIndices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1368, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1419, self, varargin{:});
     end
     function varargout = predictMeasurement(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1369, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1420, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IAttitudeEstimator.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IAttitudeEstimator.m`

 * *Files 12% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 classdef IAttitudeEstimator < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1739, self);
+        iDynTreeMEX(1656, self);
         self.SwigClear();
       end
     end
     function varargout = updateFilterWithMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1740, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1657, self, varargin{:});
     end
     function varargout = propagateStates(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1741, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1658, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsRotationMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1742, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1659, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsQuaternion(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1743, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1660, self, varargin{:});
     end
     function varargout = getOrientationEstimateAsRPY(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1744, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1661, self, varargin{:});
     end
     function varargout = getInternalStateSize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1745, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1662, self, varargin{:});
     end
     function varargout = getInternalState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1746, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1663, self, varargin{:});
     end
     function varargout = getDefaultInternalInitialState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1747, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1664, self, varargin{:});
     end
     function varargout = setInternalState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1748, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1665, self, varargin{:});
     end
     function varargout = setInternalStateInitialOrientation(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1749, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1666, self, varargin{:});
     end
     function self = IAttitudeEstimator(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ICamera.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IFrameVisualization.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-classdef ICamera < iDynTreeSwigRef
+classdef IFrameVisualization < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1942, self);
+        iDynTreeMEX(1935, self);
         self.SwigClear();
       end
     end
-    function varargout = setPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1943, self, varargin{:});
+    function varargout = addFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1936, self, varargin{:});
     end
-    function varargout = setTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1944, self, varargin{:});
+    function varargout = setVisible(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1937, self, varargin{:});
     end
-    function varargout = getPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1945, self, varargin{:});
+    function varargout = getNrOfFrames(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1938, self, varargin{:});
     end
-    function varargout = getTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1946, self, varargin{:});
+    function varargout = getFrameTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1939, self, varargin{:});
     end
-    function varargout = setUpVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1947, self, varargin{:});
+    function varargout = updateFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1940, self, varargin{:});
     end
-    function varargout = animator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1948, self, varargin{:});
+    function varargout = getFrameLabel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1941, self, varargin{:});
     end
-    function self = ICamera(varargin)
+    function self = IFrameVisualization(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ICameraAnimator.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IJetsVisualization.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-classdef ICameraAnimator < iDynTreeSwigRef
+classdef IJetsVisualization < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = enableMouseControl(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1934, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1906, self);
+        self.SwigClear();
+      end
     end
-    function varargout = getMoveSpeed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1935, self, varargin{:});
+    function varargout = setJetsFrames(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1907, self, varargin{:});
     end
-    function varargout = setMoveSpeed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1936, self, varargin{:});
+    function varargout = getNrOfJets(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1908, self, varargin{:});
     end
-    function varargout = getRotateSpeed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1937, self, varargin{:});
+    function varargout = getJetDirection(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1909, self, varargin{:});
     end
-    function varargout = setRotateSpeed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1938, self, varargin{:});
+    function varargout = setJetDirection(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1910, self, varargin{:});
     end
-    function varargout = getZoomSpeed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1939, self, varargin{:});
+    function varargout = setJetColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1911, self, varargin{:});
     end
-    function varargout = setZoomSpeed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1940, self, varargin{:});
+    function varargout = setJetsDimensions(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1912, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(1941, self);
-        self.SwigClear();
-      end
+    function varargout = setJetsIntensity(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1913, self, varargin{:});
     end
-    function self = ICameraAnimator(varargin)
+    function self = IJetsVisualization(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IEnvironment.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ILight.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,46 +1,58 @@
-classdef IEnvironment < iDynTreeSwigRef
+classdef ILight < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1979, self);
+        iDynTreeMEX(1882, self);
         self.SwigClear();
       end
     end
-    function varargout = getElements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1980, self, varargin{:});
+    function varargout = getName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1883, self, varargin{:});
     end
-    function varargout = setElementVisibility(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1981, self, varargin{:});
+    function varargout = setType(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1884, self, varargin{:});
     end
-    function varargout = setBackgroundColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1982, self, varargin{:});
+    function varargout = getType(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1885, self, varargin{:});
     end
-    function varargout = setFloorGridColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1983, self, varargin{:});
+    function varargout = setPosition(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1886, self, varargin{:});
     end
-    function varargout = setAmbientLight(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1984, self, varargin{:});
+    function varargout = getPosition(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1887, self, varargin{:});
     end
-    function varargout = getLights(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1985, self, varargin{:});
+    function varargout = setDirection(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1888, self, varargin{:});
     end
-    function varargout = addLight(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1986, self, varargin{:});
+    function varargout = getDirection(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1889, self, varargin{:});
     end
-    function varargout = lightViz(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1987, self, varargin{:});
+    function varargout = setAmbientColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1890, self, varargin{:});
     end
-    function varargout = removeLight(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1988, self, varargin{:});
+    function varargout = getAmbientColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1891, self, varargin{:});
     end
-    function self = IEnvironment(varargin)
+    function varargout = setSpecularColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1892, self, varargin{:});
+    end
+    function varargout = getSpecularColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1893, self, varargin{:});
+    end
+    function varargout = setDiffuseColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1894, self, varargin{:});
+    end
+    function varargout = getDiffuseColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1895, self, varargin{:});
+    end
+    function self = ILight(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IFrameVisualization.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ExternalMesh.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-classdef IFrameVisualization < iDynTreeSwigRef
+classdef ExternalMesh < iDynTree.SolidShape
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2018, self);
+        iDynTreeMEX(1027, self);
         self.SwigClear();
       end
     end
-    function varargout = addFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2019, self, varargin{:});
+    function varargout = clone(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1028, self, varargin{:});
     end
-    function varargout = setVisible(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2020, self, varargin{:});
+    function varargout = getFilename(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1029, self, varargin{:});
     end
-    function varargout = getNrOfFrames(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2021, self, varargin{:});
+    function varargout = getFileLocationOnLocalFileSystem(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1030, self, varargin{:});
     end
-    function varargout = getFrameTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2022, self, varargin{:});
+    function varargout = setFilename(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1031, self, varargin{:});
     end
-    function varargout = updateFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2023, self, varargin{:});
+    function varargout = getScale(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1032, self, varargin{:});
     end
-    function varargout = getFrameLabel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2024, self, varargin{:});
+    function varargout = setScale(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1033, self, varargin{:});
     end
-    function self = IFrameVisualization(varargin)
+    function self = ExternalMesh(varargin)
+      self@iDynTree.SolidShape(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        error('No matching constructor');
+        tmp = iDynTreeMEX(1034, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IJetsVisualization.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ILabel.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,40 +1,46 @@
-classdef IJetsVisualization < iDynTreeSwigRef
+classdef ILabel < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1989, self);
+        iDynTreeMEX(1914, self);
         self.SwigClear();
       end
     end
-    function varargout = setJetsFrames(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1990, self, varargin{:});
+    function varargout = setText(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1915, self, varargin{:});
     end
-    function varargout = getNrOfJets(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1991, self, varargin{:});
+    function varargout = getText(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1916, self, varargin{:});
     end
-    function varargout = getJetDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1992, self, varargin{:});
+    function varargout = setSize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1917, self, varargin{:});
     end
-    function varargout = setJetDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1993, self, varargin{:});
+    function varargout = width(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1918, self, varargin{:});
     end
-    function varargout = setJetColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1994, self, varargin{:});
+    function varargout = height(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1919, self, varargin{:});
     end
-    function varargout = setJetsDimensions(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1995, self, varargin{:});
+    function varargout = setPosition(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1920, self, varargin{:});
     end
-    function varargout = setJetsIntensity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1996, self, varargin{:});
+    function varargout = getPosition(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1921, self, varargin{:});
     end
-    function self = IJetsVisualization(varargin)
+    function varargout = setColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1922, self, varargin{:});
+    end
+    function varargout = setVisible(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1923, self, varargin{:});
+    end
+    function self = ILabel(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IJoint.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FixedJoint.m`

 * *Files 13% similar despite different names*

```diff
@@ -1,147 +1,111 @@
-classdef IJoint < iDynTreeSwigRef
+classdef FixedJoint < iDynTree.IJoint
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
+    function self = FixedJoint(varargin)
+      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(827, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(840, self);
+        iDynTreeMEX(828, self);
         self.SwigClear();
       end
     end
     function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(841, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(829, self, varargin{:});
     end
     function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(842, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(830, self, varargin{:});
     end
     function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(843, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(831, self, varargin{:});
     end
     function varargout = setAttachedLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(844, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(832, self, varargin{:});
     end
     function varargout = setRestTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(845, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(833, self, varargin{:});
     end
     function varargout = getFirstAttachedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(846, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(834, self, varargin{:});
     end
     function varargout = getSecondAttachedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(847, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(835, self, varargin{:});
     end
     function varargout = getRestTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(848, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(836, self, varargin{:});
     end
     function varargout = getTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(849, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(837, self, varargin{:});
     end
     function varargout = getTransformDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(850, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(838, self, varargin{:});
     end
     function varargout = getMotionSubspaceVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(851, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(839, self, varargin{:});
     end
     function varargout = computeChildPosVelAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(852, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(840, self, varargin{:});
     end
     function varargout = computeChildVelAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(853, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(841, self, varargin{:});
     end
     function varargout = computeChildVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(854, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(842, self, varargin{:});
     end
     function varargout = computeChildAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(855, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(843, self, varargin{:});
     end
     function varargout = computeChildBiasAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(856, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(844, self, varargin{:});
     end
     function varargout = computeJointTorque(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(857, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(845, self, varargin{:});
     end
     function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(858, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(846, self, varargin{:});
     end
     function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(859, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(847, self, varargin{:});
     end
     function varargout = setPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(860, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(848, self, varargin{:});
     end
     function varargout = getPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(861, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(849, self, varargin{:});
     end
     function varargout = setDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(862, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(850, self, varargin{:});
     end
     function varargout = getDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(863, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(851, self, varargin{:});
     end
     function varargout = hasPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(864, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(852, self, varargin{:});
     end
     function varargout = enablePosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(865, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(853, self, varargin{:});
     end
     function varargout = getPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(866, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(854, self, varargin{:});
     end
     function varargout = getMinPosLimit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(867, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(855, self, varargin{:});
     end
     function varargout = getMaxPosLimit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(868, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(856, self, varargin{:});
     end
     function varargout = setPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(869, self, varargin{:});
-    end
-    function varargout = getJointDynamicsType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(870, self, varargin{:});
-    end
-    function varargout = setJointDynamicsType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(871, self, varargin{:});
-    end
-    function varargout = setDamping(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(872, self, varargin{:});
-    end
-    function varargout = setStaticFriction(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(873, self, varargin{:});
-    end
-    function varargout = getDamping(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(874, self, varargin{:});
-    end
-    function varargout = getStaticFriction(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(875, self, varargin{:});
-    end
-    function varargout = isRevoluteJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(876, self, varargin{:});
-    end
-    function varargout = isFixedJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(877, self, varargin{:});
-    end
-    function varargout = isPrismaticJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(878, self, varargin{:});
-    end
-    function varargout = asRevoluteJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(879, self, varargin{:});
-    end
-    function varargout = asFixedJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(880, self, varargin{:});
-    end
-    function varargout = asPrismaticJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(881, self, varargin{:});
-    end
-    function self = IJoint(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        error('No matching constructor');
-      end
+      [varargout{1:nargout}] = iDynTreeMEX(857, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ILabel.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ITexture.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,46 +1,43 @@
-classdef ILabel < iDynTreeSwigRef
+classdef ITexture < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1997, self);
+        iDynTreeMEX(1960, self);
         self.SwigClear();
       end
     end
-    function varargout = setText(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1998, self, varargin{:});
+    function varargout = environment(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1961, self, varargin{:});
     end
-    function varargout = getText(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1999, self, varargin{:});
+    function varargout = getPixelColor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1962, self, varargin{:});
     end
-    function varargout = setSize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2000, self, varargin{:});
+    function varargout = getPixels(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1963, self, varargin{:});
     end
-    function varargout = width(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2001, self, varargin{:});
-    end
-    function varargout = height(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2002, self, varargin{:});
+    function varargout = drawToFile(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1964, self, varargin{:});
     end
-    function varargout = setPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2003, self, varargin{:});
+    function varargout = enableDraw(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1965, self, varargin{:});
     end
-    function varargout = getPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2004, self, varargin{:});
+    function varargout = width(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1966, self, varargin{:});
     end
-    function varargout = setColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2005, self, varargin{:});
+    function varargout = height(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1967, self, varargin{:});
     end
-    function varargout = setVisible(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2006, self, varargin{:});
+    function varargout = setSubDrawArea(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1968, self, varargin{:});
     end
-    function self = ILabel(varargin)
+    function self = ITexture(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ILight.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector3.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,63 +1,74 @@
-classdef ILight < iDynTreeSwigRef
+classdef Vector3 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(1965, self);
-        self.SwigClear();
+    function self = Vector3(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(314, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
       end
     end
-    function varargout = getName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1966, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(315, self, varargin{:});
     end
-    function varargout = setType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1967, self, varargin{:});
+    function varargout = brace(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(316, self, varargin{:});
     end
-    function varargout = getType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1968, self, varargin{:});
+    function varargout = getVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(317, self, varargin{:});
     end
-    function varargout = setPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1969, self, varargin{:});
+    function varargout = setVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(318, self, varargin{:});
     end
-    function varargout = getPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1970, self, varargin{:});
+    function varargout = cbegin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(319, self, varargin{:});
     end
-    function varargout = setDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1971, self, varargin{:});
+    function varargout = cend(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(320, self, varargin{:});
     end
-    function varargout = getDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1972, self, varargin{:});
+    function varargout = begin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(321, self, varargin{:});
     end
-    function varargout = setAmbientColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1973, self, varargin{:});
+    function varargout = end(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(322, self, varargin{:});
     end
-    function varargout = getAmbientColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1974, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(323, self, varargin{:});
     end
-    function varargout = setSpecularColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1975, self, varargin{:});
+    function varargout = data(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(324, self, varargin{:});
     end
-    function varargout = getSpecularColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1976, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(325, self, varargin{:});
     end
-    function varargout = setDiffuseColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1977, self, varargin{:});
+    function varargout = fillBuffer(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(326, self, varargin{:});
     end
-    function varargout = getDiffuseColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1978, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(327, self, varargin{:});
     end
-    function self = ILight(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        error('No matching constructor');
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(328, self, varargin{:});
+    end
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(329, self, varargin{:});
+    end
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(330, self, varargin{:});
+    end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(331, self);
+        self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IModelVisualization.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IModelVisualization.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,68 +1,68 @@
 classdef IModelVisualization < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2025, self);
+        iDynTreeMEX(1942, self);
         self.SwigClear();
       end
     end
     function varargout = setPositions(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2026, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1943, self, varargin{:});
     end
     function varargout = setLinkPositions(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2027, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1944, self, varargin{:});
     end
     function varargout = model(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2028, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1945, self, varargin{:});
     end
     function varargout = getInstanceName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2029, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1946, self, varargin{:});
     end
     function varargout = setModelVisibility(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2030, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1947, self, varargin{:});
     end
     function varargout = setModelColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2031, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1948, self, varargin{:});
     end
     function varargout = resetModelColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2032, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1949, self, varargin{:});
     end
     function varargout = setLinkColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2033, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1950, self, varargin{:});
     end
     function varargout = resetLinkColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2034, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1951, self, varargin{:});
     end
     function varargout = getLinkNames(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2035, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1952, self, varargin{:});
     end
     function varargout = setLinkVisibility(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2036, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1953, self, varargin{:});
     end
     function varargout = getFeatures(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2037, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1954, self, varargin{:});
     end
     function varargout = setFeatureVisibility(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2038, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1955, self, varargin{:});
     end
     function varargout = jets(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2039, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1956, self, varargin{:});
     end
     function varargout = getWorldLinkTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2040, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1957, self, varargin{:});
     end
     function varargout = getWorldFrameTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2041, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1958, self, varargin{:});
     end
     function varargout = label(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2042, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1959, self, varargin{:});
     end
     function self = IModelVisualization(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ITexture.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ICameraAnimator.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,43 +1,40 @@
-classdef ITexture < iDynTreeSwigRef
+classdef ICameraAnimator < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(2043, self);
-        self.SwigClear();
-      end
-    end
-    function varargout = environment(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2044, self, varargin{:});
+    function varargout = enableMouseControl(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1851, self, varargin{:});
     end
-    function varargout = getPixelColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2045, self, varargin{:});
+    function varargout = getMoveSpeed(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1852, self, varargin{:});
     end
-    function varargout = getPixels(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2046, self, varargin{:});
+    function varargout = setMoveSpeed(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1853, self, varargin{:});
     end
-    function varargout = drawToFile(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2047, self, varargin{:});
+    function varargout = getRotateSpeed(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1854, self, varargin{:});
     end
-    function varargout = enableDraw(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2048, self, varargin{:});
+    function varargout = setRotateSpeed(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1855, self, varargin{:});
     end
-    function varargout = width(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2049, self, varargin{:});
+    function varargout = getZoomSpeed(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1856, self, varargin{:});
     end
-    function varargout = height(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2050, self, varargin{:});
+    function varargout = setZoomSpeed(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1857, self, varargin{:});
     end
-    function varargout = setSubDrawArea(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2051, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1858, self);
+        self.SwigClear();
+      end
     end
-    function self = ITexture(varargin)
+    function self = ICameraAnimator(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ITexturesHandler.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ITexturesHandler.m`

 * *Files 3% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 classdef ITexturesHandler < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2062, self);
+        iDynTreeMEX(1979, self);
         self.SwigClear();
       end
     end
     function varargout = add(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2063, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1980, self, varargin{:});
     end
     function varargout = get(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2064, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1981, self, varargin{:});
     end
     function self = ITexturesHandler(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IVectorsVisualization.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/IVectorsVisualization.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 classdef IVectorsVisualization < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2007, self);
+        iDynTreeMEX(1924, self);
         self.SwigClear();
       end
     end
     function varargout = addVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2008, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1925, self, varargin{:});
     end
     function varargout = getNrOfVectors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2009, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1926, self, varargin{:});
     end
     function varargout = getVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2010, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1927, self, varargin{:});
     end
     function varargout = updateVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2011, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1928, self, varargin{:});
     end
     function varargout = setVectorColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2012, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1929, self, varargin{:});
     end
     function varargout = setVectorsDefaultColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2013, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1930, self, varargin{:});
     end
     function varargout = setVectorsColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2014, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1931, self, varargin{:});
     end
     function varargout = setVectorsAspect(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2015, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1932, self, varargin{:});
     end
     function varargout = setVisible(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2016, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1933, self, varargin{:});
     end
     function varargout = getVectorLabel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2017, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1934, self, varargin{:});
     end
     function self = IVectorsVisualization(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IndexRange.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingVel.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,52 +1,38 @@
-classdef IndexRange < iDynTreeSwigRef
+classdef FreeFloatingVel < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = offset(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(198, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(199, self, varargin{1});
-      end
-    end
-    function varargout = size(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(200, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(201, self, varargin{1});
-      end
-    end
-    function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(202, self, varargin{:});
-    end
-    function self = IndexRange(varargin)
+    function self = FreeFloatingVel(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(204, varargin{:});
+        tmp = iDynTreeMEX(1129, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1130, self, varargin{:});
+    end
+    function varargout = baseVel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1131, self, varargin{:});
+    end
+    function varargout = jointVel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1132, self, varargin{:});
+    end
+    function varargout = getNrOfDOFs(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1133, self, varargin{:});
+    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(205, self);
+        iDynTreeMEX(1134, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
-    function varargout = InvalidRange(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(203, varargin{:});
-    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IndexVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/StringVector.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-classdef IndexVector < iDynTreeSwigRef
+classdef StringVector < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(121, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(21, self, varargin{:});
     end
     function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(122, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(22, self, varargin{:});
     end
     function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(123, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(23, self, varargin{:});
     end
     function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(124, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(24, self, varargin{:});
     end
     function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(125, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(25, self, varargin{:});
     end
     function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(126, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(26, self, varargin{:});
     end
     function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(127, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(27, self, varargin{:});
     end
     function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(128, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(28, self, varargin{:});
     end
     function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(129, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(29, self, varargin{:});
     end
     function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(130, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(30, self, varargin{:});
     end
     function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(131, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(31, self, varargin{:});
     end
     function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(132, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(32, self, varargin{:});
     end
     function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(133, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(33, self, varargin{:});
     end
     function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(134, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(34, self, varargin{:});
     end
     function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(135, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(35, self, varargin{:});
     end
-    function self = IndexVector(varargin)
+    function self = StringVector(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(136, varargin{:});
+        tmp = iDynTreeMEX(36, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(137, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(37, self, varargin{:});
     end
     function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(138, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(38, self, varargin{:});
     end
     function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(139, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(39, self, varargin{:});
     end
     function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(140, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(40, self, varargin{:});
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(141, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(41, self, varargin{:});
     end
     function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(142, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(42, self, varargin{:});
     end
     function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(143, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(43, self, varargin{:});
     end
     function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(144, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(44, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(145, self);
+        iDynTreeMEX(45, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/IntVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector16.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,95 +1,74 @@
-classdef IntVector < iDynTreeSwigRef
+classdef Vector16 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(46, self, varargin{:});
+    function self = Vector16(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(386, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
     end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(47, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(387, self, varargin{:});
     end
-    function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(48, self, varargin{:});
+    function varargout = brace(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(388, self, varargin{:});
     end
-    function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(49, self, varargin{:});
+    function varargout = getVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(389, self, varargin{:});
     end
-    function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(50, self, varargin{:});
+    function varargout = setVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(390, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(51, self, varargin{:});
+    function varargout = cbegin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(391, self, varargin{:});
     end
-    function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(52, self, varargin{:});
+    function varargout = cend(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(392, self, varargin{:});
     end
     function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(53, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(393, self, varargin{:});
     end
     function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(54, self, varargin{:});
-    end
-    function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(55, self, varargin{:});
-    end
-    function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(56, self, varargin{:});
-    end
-    function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(57, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(394, self, varargin{:});
     end
-    function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(58, self, varargin{:});
-    end
-    function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(59, self, varargin{:});
-    end
-    function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(60, self, varargin{:});
-    end
-    function self = IntVector(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(61, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
-    end
-    function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(62, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(395, self, varargin{:});
     end
-    function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(63, self, varargin{:});
+    function varargout = data(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(396, self, varargin{:});
     end
-    function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(64, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(397, self, varargin{:});
     end
-    function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(65, self, varargin{:});
+    function varargout = fillBuffer(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(398, self, varargin{:});
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(66, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(399, self, varargin{:});
     end
-    function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(67, self, varargin{:});
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(400, self, varargin{:});
     end
-    function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(68, self, varargin{:});
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(401, self, varargin{:});
     end
-    function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(69, self, varargin{:});
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(402, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(70, self);
+        iDynTreeMEX(403, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/InverseKinematics.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/InverseKinematics.m`

 * *Files 8% similar despite different names*

```diff
@@ -5,193 +5,193 @@
     end
     function self = InverseKinematics(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(2136, varargin{:});
+        tmp = iDynTreeMEX(2053, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2137, self);
+        iDynTreeMEX(2054, self);
         self.SwigClear();
       end
     end
     function varargout = loadModelFromFile(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2138, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2055, self, varargin{:});
     end
     function varargout = setModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2139, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2056, self, varargin{:});
     end
     function varargout = setJointLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2140, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2057, self, varargin{:});
     end
     function varargout = getJointLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2141, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2058, self, varargin{:});
     end
     function varargout = clearProblem(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2142, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2059, self, varargin{:});
     end
     function varargout = setFloatingBaseOnFrameNamed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2143, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2060, self, varargin{:});
     end
     function varargout = setCurrentRobotConfiguration(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2144, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2061, self, varargin{:});
     end
     function varargout = setJointConfiguration(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2145, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2062, self, varargin{:});
     end
     function varargout = setRotationParametrization(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2146, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2063, self, varargin{:});
     end
     function varargout = rotationParametrization(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2147, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2064, self, varargin{:});
     end
     function varargout = setMaxIterations(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2148, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2065, self, varargin{:});
     end
     function varargout = maxIterations(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2149, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2066, self, varargin{:});
     end
     function varargout = setMaxCPUTime(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2150, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2067, self, varargin{:});
     end
     function varargout = maxCPUTime(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2151, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2068, self, varargin{:});
     end
     function varargout = setCostTolerance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2152, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2069, self, varargin{:});
     end
     function varargout = costTolerance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2153, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2070, self, varargin{:});
     end
     function varargout = setConstraintsTolerance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2154, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2071, self, varargin{:});
     end
     function varargout = constraintsTolerance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2155, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2072, self, varargin{:});
     end
     function varargout = setVerbosity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2156, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2073, self, varargin{:});
     end
     function varargout = linearSolverName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2157, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2074, self, varargin{:});
     end
     function varargout = setLinearSolverName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2158, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2075, self, varargin{:});
     end
     function varargout = addFrameConstraint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2159, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2076, self, varargin{:});
     end
     function varargout = addFramePositionConstraint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2160, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2077, self, varargin{:});
     end
     function varargout = addFrameRotationConstraint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2161, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2078, self, varargin{:});
     end
     function varargout = activateFrameConstraint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2162, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2079, self, varargin{:});
     end
     function varargout = deactivateFrameConstraint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2163, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2080, self, varargin{:});
     end
     function varargout = isFrameConstraintActive(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2164, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2081, self, varargin{:});
     end
     function varargout = addCenterOfMassProjectionConstraint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2165, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2082, self, varargin{:});
     end
     function varargout = getCenterOfMassProjectionMargin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2166, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2083, self, varargin{:});
     end
     function varargout = getCenterOfMassProjectConstraintConvexHull(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2167, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2084, self, varargin{:});
     end
     function varargout = addTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2168, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2085, self, varargin{:});
     end
     function varargout = addPositionTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2169, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2086, self, varargin{:});
     end
     function varargout = addRotationTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2170, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2087, self, varargin{:});
     end
     function varargout = updateTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2171, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2088, self, varargin{:});
     end
     function varargout = updatePositionTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2172, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2089, self, varargin{:});
     end
     function varargout = updateRotationTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2173, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2090, self, varargin{:});
     end
     function varargout = setDefaultTargetResolutionMode(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2174, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2091, self, varargin{:});
     end
     function varargout = defaultTargetResolutionMode(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2175, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2092, self, varargin{:});
     end
     function varargout = setTargetResolutionMode(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2176, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2093, self, varargin{:});
     end
     function varargout = targetResolutionMode(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2177, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2094, self, varargin{:});
     end
     function varargout = setDesiredFullJointsConfiguration(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2178, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2095, self, varargin{:});
     end
     function varargout = setDesiredReducedJointConfiguration(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2179, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2096, self, varargin{:});
     end
     function varargout = setFullJointsInitialCondition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2180, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2097, self, varargin{:});
     end
     function varargout = setReducedInitialCondition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2181, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2098, self, varargin{:});
     end
     function varargout = solve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2182, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2099, self, varargin{:});
     end
     function varargout = getFullJointsSolution(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2183, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2100, self, varargin{:});
     end
     function varargout = getReducedSolution(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2184, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2101, self, varargin{:});
     end
     function varargout = getPoseForFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2185, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2102, self, varargin{:});
     end
     function varargout = fullModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2186, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2103, self, varargin{:});
     end
     function varargout = reducedModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2187, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2104, self, varargin{:});
     end
     function varargout = setCOMTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2188, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2105, self, varargin{:});
     end
     function varargout = setCOMAsConstraint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2189, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2106, self, varargin{:});
     end
     function varargout = setCOMAsConstraintTolerance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2190, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2107, self, varargin{:});
     end
     function varargout = isCOMAConstraint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2191, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2108, self, varargin{:});
     end
     function varargout = isCOMTargetActive(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2192, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2109, self, varargin{:});
     end
     function varargout = deactivateCOMTarget(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2193, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2110, self, varargin{:});
     end
     function varargout = setCOMConstraintProjectionDirection(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2194, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(2111, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JointDOFsDoubleArray.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JointDOFsDoubleArray.m`

 * *Files 5% similar despite different names*

```diff
@@ -3,28 +3,28 @@
     function self = JointDOFsDoubleArray(varargin)
       self@iDynTree.VectorDynSize(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1223, varargin{:});
+        tmp = iDynTreeMEX(1092, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1224, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1093, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1225, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1094, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1226, self);
+        iDynTreeMEX(1095, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JointPosDoubleArray.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DOFSpatialMotionArray.m`

 * *Files 10% similar despite different names*

```diff
@@ -1,30 +1,35 @@
-classdef JointPosDoubleArray < iDynTree.VectorDynSize
+classdef DOFSpatialMotionArray < iDynTreeSwigRef
   methods
-    function self = JointPosDoubleArray(varargin)
-      self@iDynTree.VectorDynSize(iDynTreeSwigRef.Null);
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
+    function self = DOFSpatialMotionArray(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1219, varargin{:});
+        tmp = iDynTreeMEX(1101, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1220, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1102, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1221, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1103, self, varargin{:});
+    end
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1104, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1222, self);
+        iDynTreeMEX(1105, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/JointSensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkWrenches.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,37 +1,44 @@
-classdef JointSensor < iDynTree.Sensor
+classdef LinkWrenches < iDynTreeSwigRef
   methods
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(1128, self);
-        self.SwigClear();
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
+    function self = LinkWrenches(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(752, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
       end
     end
-    function varargout = getParentJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1129, self, varargin{:});
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(753, self, varargin{:});
+    end
+    function varargout = isConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(754, self, varargin{:});
     end
-    function varargout = getParentJointIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1130, self, varargin{:});
+    function varargout = getNrOfLinks(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(755, self, varargin{:});
     end
-    function varargout = setParentJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1131, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(756, self, varargin{:});
     end
-    function varargout = setParentJointIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1132, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(757, self, varargin{:});
     end
-    function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1133, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(758, self, varargin{:});
     end
-    function self = JointSensor(varargin)
-      self@iDynTree.Sensor(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        error('No matching constructor');
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(759, self);
+        self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/KinDynComputations.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/KinDynComputations.m`

 * *Files 3% similar despite different names*

```diff
@@ -5,184 +5,184 @@
     end
     function self = KinDynComputations(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1852, varargin{:});
+        tmp = iDynTreeMEX(1769, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1853, self);
+        iDynTreeMEX(1770, self);
         self.SwigClear();
       end
     end
     function varargout = loadRobotModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1854, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1771, self, varargin{:});
     end
     function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1855, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1772, self, varargin{:});
     end
     function varargout = setFrameVelocityRepresentation(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1856, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1773, self, varargin{:});
     end
     function varargout = getFrameVelocityRepresentation(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1857, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1774, self, varargin{:});
     end
     function varargout = getNrOfDegreesOfFreedom(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1858, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1775, self, varargin{:});
     end
     function varargout = getDescriptionOfDegreeOfFreedom(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1859, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1776, self, varargin{:});
     end
     function varargout = getDescriptionOfDegreesOfFreedom(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1860, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1777, self, varargin{:});
     end
     function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1861, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1778, self, varargin{:});
     end
     function varargout = getNrOfFrames(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1862, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1779, self, varargin{:});
     end
     function varargout = getFloatingBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1863, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1780, self, varargin{:});
     end
     function varargout = setFloatingBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1864, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1781, self, varargin{:});
     end
     function varargout = model(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1865, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1782, self, varargin{:});
     end
     function varargout = getRobotModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1866, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1783, self, varargin{:});
     end
     function varargout = getRelativeJacobianSparsityPattern(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1867, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1784, self, varargin{:});
     end
     function varargout = getFrameFreeFloatingJacobianSparsityPattern(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1868, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1785, self, varargin{:});
     end
     function varargout = setJointPos(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1869, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1786, self, varargin{:});
     end
     function varargout = setRobotState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1870, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1787, self, varargin{:});
     end
     function varargout = getRobotState(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1871, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1788, self, varargin{:});
     end
     function varargout = getWorldBaseTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1872, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1789, self, varargin{:});
     end
     function varargout = getBaseTwist(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1873, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1790, self, varargin{:});
     end
     function varargout = getJointPos(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1874, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1791, self, varargin{:});
     end
     function varargout = getJointVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1875, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1792, self, varargin{:});
     end
     function varargout = getModelVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1876, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1793, self, varargin{:});
     end
     function varargout = getFrameIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1877, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1794, self, varargin{:});
     end
     function varargout = getFrameName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1878, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1795, self, varargin{:});
     end
     function varargout = getWorldTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1879, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1796, self, varargin{:});
     end
     function varargout = getWorldTransformsAsHomogeneous(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1880, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1797, self, varargin{:});
     end
     function varargout = getRelativeTransformExplicit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1881, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1798, self, varargin{:});
     end
     function varargout = getRelativeTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1882, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1799, self, varargin{:});
     end
     function varargout = getFrameVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1883, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1800, self, varargin{:});
     end
     function varargout = getFrameAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1884, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1801, self, varargin{:});
     end
     function varargout = getFrameFreeFloatingJacobian(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1885, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1802, self, varargin{:});
     end
     function varargout = getRelativeJacobian(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1886, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1803, self, varargin{:});
     end
     function varargout = getRelativeJacobianExplicit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1887, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1804, self, varargin{:});
     end
     function varargout = getFrameBiasAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1888, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1805, self, varargin{:});
     end
     function varargout = getCenterOfMassPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1889, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1806, self, varargin{:});
     end
     function varargout = getCenterOfMassVelocity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1890, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1807, self, varargin{:});
     end
     function varargout = getCenterOfMassJacobian(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1891, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1808, self, varargin{:});
     end
     function varargout = getCenterOfMassBiasAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1892, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1809, self, varargin{:});
     end
     function varargout = getAverageVelocity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1893, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1810, self, varargin{:});
     end
     function varargout = getAverageVelocityJacobian(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1894, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1811, self, varargin{:});
     end
     function varargout = getCentroidalAverageVelocity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1895, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1812, self, varargin{:});
     end
     function varargout = getCentroidalAverageVelocityJacobian(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1896, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1813, self, varargin{:});
     end
     function varargout = getLinearAngularMomentum(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1897, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1814, self, varargin{:});
     end
     function varargout = getLinearAngularMomentumJacobian(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1898, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1815, self, varargin{:});
     end
     function varargout = getCentroidalTotalMomentum(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1899, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1816, self, varargin{:});
     end
     function varargout = getCentroidalTotalMomentumJacobian(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1900, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1817, self, varargin{:});
     end
     function varargout = getFreeFloatingMassMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1901, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1818, self, varargin{:});
     end
     function varargout = inverseDynamics(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1902, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1819, self, varargin{:});
     end
     function varargout = inverseDynamicsWithInternalJointForceTorques(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1903, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1820, self, varargin{:});
     end
     function varargout = generalizedBiasForces(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1904, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1821, self, varargin{:});
     end
     function varargout = generalizedGravityForces(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1905, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1822, self, varargin{:});
     end
     function varargout = generalizedExternalForces(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1906, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1823, self, varargin{:});
     end
     function varargout = inverseDynamicsInertialParametersRegressor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1907, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1824, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Link.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Wrench.m`

 * *Files 9% similar despite different names*

```diff
@@ -1,41 +1,33 @@
-classdef Link < iDynTreeSwigRef
+classdef Wrench < iDynTree.SpatialForceVector
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = Link(varargin)
+    function self = Wrench(varargin)
+      self@iDynTree.SpatialForceVector(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(833, varargin{:});
+        tmp = iDynTreeMEX(507, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = inertia(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(834, self, varargin{:});
-    end
-    function varargout = setInertia(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(835, self, varargin{:});
-    end
-    function varargout = getInertia(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(836, self, varargin{:});
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(508, self, varargin{:});
     end
-    function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(837, self, varargin{:});
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(509, self, varargin{:});
     end
-    function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(838, self, varargin{:});
+    function varargout = uminus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(510, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(839, self);
+        iDynTreeMEX(511, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkAccArray.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl4.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,41 +1,46 @@
-classdef LinkAccArray < iDynTreeSwigRef
+classdef MovableJointImpl4 < iDynTree.IJoint
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = LinkAccArray(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(826, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(885, self);
+        self.SwigClear();
       end
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(827, self, varargin{:});
+    function varargout = getNrOfPosCoords(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(886, self, varargin{:});
     end
-    function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(828, self, varargin{:});
+    function varargout = getNrOfDOFs(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(887, self, varargin{:});
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(829, self, varargin{:});
+    function varargout = setIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(888, self, varargin{:});
     end
-    function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(830, self, varargin{:});
+    function varargout = getIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(889, self, varargin{:});
     end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(831, self, varargin{:});
+    function varargout = setPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(890, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(832, self);
-        self.SwigClear();
+    function varargout = getPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(891, self, varargin{:});
+    end
+    function varargout = setDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(892, self, varargin{:});
+    end
+    function varargout = getDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(893, self, varargin{:});
+    end
+    function self = MovableJointImpl4(varargin)
+      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkArticulatedBodyInertias.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkArticulatedBodyInertias.m`

 * *Files 3% similar despite different names*

```diff
@@ -5,31 +5,31 @@
     end
     function self = LinkArticulatedBodyInertias(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(814, varargin{:});
+        tmp = iDynTreeMEX(765, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(815, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(766, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(816, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(767, self, varargin{:});
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(817, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(768, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(818, self);
+        iDynTreeMEX(769, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkContactWrenches.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkContactWrenches.m`

 * *Files 2% similar despite different names*

```diff
@@ -5,43 +5,43 @@
     end
     function self = LinkContactWrenches(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1277, varargin{:});
+        tmp = iDynTreeMEX(1146, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1278, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1147, self, varargin{:});
     end
     function varargout = getNrOfContactsForLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1279, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1148, self, varargin{:});
     end
     function varargout = setNrOfContactsForLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1280, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1149, self, varargin{:});
     end
     function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1281, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1150, self, varargin{:});
     end
     function varargout = contactWrench(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1282, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1151, self, varargin{:});
     end
     function varargout = computeNetWrenches(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1283, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1152, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1284, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1153, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1285, self);
+        iDynTreeMEX(1154, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkInertias.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkInertias.m`

 * *Files 3% similar despite different names*

```diff
@@ -5,31 +5,31 @@
     end
     function self = LinkInertias(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(809, varargin{:});
+        tmp = iDynTreeMEX(760, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(810, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(761, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(811, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(762, self, varargin{:});
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(812, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(763, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(813, self);
+        iDynTreeMEX(764, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkPositions.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FreeFloatingPos.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,41 +1,38 @@
-classdef LinkPositions < iDynTreeSwigRef
+classdef FreeFloatingPos < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = LinkPositions(varargin)
+    function self = FreeFloatingPos(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(794, varargin{:});
+        tmp = iDynTreeMEX(1117, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(795, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1118, self, varargin{:});
     end
-    function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(796, self, varargin{:});
+    function varargout = worldBasePos(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1119, self, varargin{:});
     end
-    function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(797, self, varargin{:});
+    function varargout = jointPos(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1120, self, varargin{:});
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(798, self, varargin{:});
-    end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(799, self, varargin{:});
+    function varargout = getNrOfPosCoords(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1121, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(800, self);
+        iDynTreeMEX(1122, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkSensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl6.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,38 +1,41 @@
-classdef LinkSensor < iDynTree.Sensor
+classdef MovableJointImpl6 < iDynTree.IJoint
   methods
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1134, self);
+        iDynTreeMEX(903, self);
         self.SwigClear();
       end
     end
-    function varargout = getParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1135, self, varargin{:});
+    function varargout = getNrOfPosCoords(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(904, self, varargin{:});
     end
-    function varargout = getParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1136, self, varargin{:});
+    function varargout = getNrOfDOFs(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(905, self, varargin{:});
     end
-    function varargout = getLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1137, self, varargin{:});
+    function varargout = setIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(906, self, varargin{:});
     end
-    function varargout = setParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1138, self, varargin{:});
+    function varargout = getIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(907, self, varargin{:});
     end
-    function varargout = setParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1139, self, varargin{:});
+    function varargout = setPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(908, self, varargin{:});
     end
-    function varargout = setLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1140, self, varargin{:});
+    function varargout = getPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(909, self, varargin{:});
     end
-    function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1141, self, varargin{:});
+    function varargout = setDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(910, self, varargin{:});
     end
-    function self = LinkSensor(varargin)
-      self@iDynTree.Sensor(iDynTreeSwigRef.Null);
+    function varargout = getDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(911, self, varargin{:});
+    end
+    function self = MovableJointImpl6(varargin)
+      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkUnknownWrenchContacts.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkUnknownWrenchContacts.m`

 * *Files 2% similar despite different names*

```diff
@@ -5,49 +5,49 @@
     end
     function self = LinkUnknownWrenchContacts(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1581, varargin{:});
+        tmp = iDynTreeMEX(1500, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1582, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1501, self, varargin{:});
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1583, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1502, self, varargin{:});
     end
     function varargout = getNrOfContactsForLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1584, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1503, self, varargin{:});
     end
     function varargout = setNrOfContactsForLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1585, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1504, self, varargin{:});
     end
     function varargout = addNewContactForLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1586, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1505, self, varargin{:});
     end
     function varargout = addNewContactInFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1587, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1506, self, varargin{:});
     end
     function varargout = addNewUnknownFullWrenchInFrameOrigin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1588, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1507, self, varargin{:});
     end
     function varargout = contactWrench(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1589, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1508, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1590, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1509, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1591, self);
+        iDynTreeMEX(1510, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkVelArray.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkVelArray.m`

 * *Files 3% similar despite different names*

```diff
@@ -5,37 +5,37 @@
     end
     function self = LinkVelArray(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(819, varargin{:});
+        tmp = iDynTreeMEX(770, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(820, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(771, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(821, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(772, self, varargin{:});
     end
     function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(822, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(773, self, varargin{:});
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(823, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(774, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(824, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(775, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(825, self);
+        iDynTreeMEX(776, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinkWrenches.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkPositions.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,44 +1,41 @@
-classdef LinkWrenches < iDynTreeSwigRef
+classdef LinkPositions < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = LinkWrenches(varargin)
+    function self = LinkPositions(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(801, varargin{:});
+        tmp = iDynTreeMEX(745, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(802, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(746, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(803, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(747, self, varargin{:});
     end
     function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(804, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(748, self, varargin{:});
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(805, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(749, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(806, self, varargin{:});
-    end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(807, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(750, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(808, self);
+        iDynTreeMEX(751, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/LinksSolidShapesVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix4x4Vector.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,95 +1,98 @@
-classdef LinksSolidShapesVector < iDynTreeSwigRef
+classdef Matrix4x4Vector < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1430, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1825, self, varargin{:});
     end
     function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1431, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1826, self, varargin{:});
     end
     function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1432, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1827, self, varargin{:});
     end
     function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1433, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1828, self, varargin{:});
     end
     function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1434, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1829, self, varargin{:});
     end
     function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1435, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1830, self, varargin{:});
     end
     function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1436, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1831, self, varargin{:});
     end
     function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1437, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1832, self, varargin{:});
     end
     function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1438, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1833, self, varargin{:});
     end
     function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1439, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1834, self, varargin{:});
     end
     function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1440, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1835, self, varargin{:});
     end
     function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1441, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1836, self, varargin{:});
     end
     function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1442, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1837, self, varargin{:});
     end
     function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1443, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1838, self, varargin{:});
     end
     function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1444, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1839, self, varargin{:});
     end
-    function self = LinksSolidShapesVector(varargin)
+    function self = Matrix4x4Vector(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1445, varargin{:});
+        tmp = iDynTreeMEX(1840, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1446, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1841, self, varargin{:});
     end
     function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1447, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1842, self, varargin{:});
     end
     function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1448, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1843, self, varargin{:});
     end
     function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1449, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1844, self, varargin{:});
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1450, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1845, self, varargin{:});
     end
     function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1451, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1846, self, varargin{:});
     end
     function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1452, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1847, self, varargin{:});
     end
     function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1453, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1848, self, varargin{:});
+    end
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1849, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1454, self);
+        iDynTreeMEX(1850, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Material.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Material.m`

 * *Files 10% similar despite different names*

```diff
@@ -5,43 +5,43 @@
     end
     function self = Material(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1052, varargin{:});
+        tmp = iDynTreeMEX(979, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = name(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1053, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(980, self, varargin{:});
     end
     function varargout = hasColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1054, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(981, self, varargin{:});
     end
     function varargout = color(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1055, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(982, self, varargin{:});
     end
     function varargout = setColor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1056, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(983, self, varargin{:});
     end
     function varargout = hasTexture(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1057, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(984, self, varargin{:});
     end
     function varargout = texture(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1058, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(985, self, varargin{:});
     end
     function varargout = setTexture(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1059, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(986, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1060, self);
+        iDynTreeMEX(987, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MatlabSwigIterator.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Vector4.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,69 +1,74 @@
-classdef MatlabSwigIterator < iDynTreeSwigRef
+classdef Vector4 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(5, self);
-        self.SwigClear();
+    function self = Vector4(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(332, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
       end
     end
-    function varargout = value(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(6, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(333, self, varargin{:});
     end
-    function varargout = incr(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(7, self, varargin{:});
+    function varargout = brace(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(334, self, varargin{:});
     end
-    function varargout = decr(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(8, self, varargin{:});
+    function varargout = getVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(335, self, varargin{:});
     end
-    function varargout = distance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(9, self, varargin{:});
+    function varargout = setVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(336, self, varargin{:});
     end
-    function varargout = equal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(10, self, varargin{:});
+    function varargout = cbegin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(337, self, varargin{:});
     end
-    function varargout = copy(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(11, self, varargin{:});
+    function varargout = cend(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(338, self, varargin{:});
     end
-    function varargout = next(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(12, self, varargin{:});
+    function varargout = begin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(339, self, varargin{:});
     end
-    function varargout = previous(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(13, self, varargin{:});
+    function varargout = end(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(340, self, varargin{:});
     end
-    function varargout = advance(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(14, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(341, self, varargin{:});
     end
-    function varargout = eq(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(15, self, varargin{:});
+    function varargout = data(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(342, self, varargin{:});
     end
-    function varargout = ne(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(16, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(343, self, varargin{:});
     end
-    function varargout = TODOincr(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(17, self, varargin{:});
+    function varargout = fillBuffer(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(344, self, varargin{:});
     end
-    function varargout = TODOdecr(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(18, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(345, self, varargin{:});
     end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(19, self, varargin{:});
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(346, self, varargin{:});
     end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(20, self, varargin{:});
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(347, self, varargin{:});
     end
-    function self = MatlabSwigIterator(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        error('No matching constructor');
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(348, self, varargin{:});
+    end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(349, self);
+        self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix10x16.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix10x16.m`

 * *Files 4% similar despite different names*

```diff
@@ -5,61 +5,61 @@
     end
     function self = Matrix10x16(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(374, varargin{:});
+        tmp = iDynTreeMEX(299, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(375, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(300, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(376, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(301, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(377, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(302, self, varargin{:});
     end
     function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(378, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(303, self, varargin{:});
     end
     function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(379, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(304, self, varargin{:});
     end
     function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(380, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(305, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(381, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(306, self, varargin{:});
     end
     function varargout = fillRowMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(382, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(307, self, varargin{:});
     end
     function varargout = fillColMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(383, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(308, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(384, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(309, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(385, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(310, self, varargin{:});
     end
     function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(386, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(311, self, varargin{:});
     end
     function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(387, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(312, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(388, self);
+        iDynTreeMEX(313, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix1x6.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix6x6.m`

 * *Files 2% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-classdef Matrix1x6 < iDynTreeSwigRef
+classdef Matrix6x6 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = Matrix1x6(varargin)
+    function self = Matrix6x6(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(284, varargin{:});
+        tmp = iDynTreeMEX(269, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(285, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(270, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(286, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(271, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(287, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(272, self, varargin{:});
     end
     function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(288, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(273, self, varargin{:});
     end
     function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(289, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(274, self, varargin{:});
     end
     function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(290, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(275, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(291, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(276, self, varargin{:});
     end
     function varargout = fillRowMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(292, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(277, self, varargin{:});
     end
     function varargout = fillColMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(293, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(278, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(294, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(279, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(295, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(280, self, varargin{:});
     end
     function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(296, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(281, self, varargin{:});
     end
     function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(297, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(282, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(298, self);
+        iDynTreeMEX(283, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix2x3.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix2x3.m`

 * *Files 5% similar despite different names*

```diff
@@ -5,61 +5,61 @@
     end
     function self = Matrix2x3(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(299, varargin{:});
+        tmp = iDynTreeMEX(224, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(300, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(225, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(301, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(226, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(302, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(227, self, varargin{:});
     end
     function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(303, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(228, self, varargin{:});
     end
     function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(304, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(229, self, varargin{:});
     end
     function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(305, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(230, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(306, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(231, self, varargin{:});
     end
     function varargout = fillRowMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(307, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(232, self, varargin{:});
     end
     function varargout = fillColMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(308, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(233, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(309, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(234, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(310, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(235, self, varargin{:});
     end
     function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(311, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(236, self, varargin{:});
     end
     function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(312, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(237, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(313, self);
+        iDynTreeMEX(238, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix3x3.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix1x6.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-classdef Matrix3x3 < iDynTreeSwigRef
+classdef Matrix1x6 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = Matrix3x3(varargin)
+    function self = Matrix1x6(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(314, varargin{:});
+        tmp = iDynTreeMEX(209, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(315, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(210, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(316, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(211, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(317, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(212, self, varargin{:});
     end
     function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(318, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(213, self, varargin{:});
     end
     function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(319, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(214, self, varargin{:});
     end
     function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(320, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(215, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(321, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(216, self, varargin{:});
     end
     function varargout = fillRowMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(322, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(217, self, varargin{:});
     end
     function varargout = fillColMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(323, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(218, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(324, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(219, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(325, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(220, self, varargin{:});
     end
     function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(326, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(221, self, varargin{:});
     end
     function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(327, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(222, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(328, self);
+        iDynTreeMEX(223, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix4x4.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Position.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,65 +1,63 @@
-classdef Matrix4x4 < iDynTreeSwigRef
+classdef Position < iDynTree.PositionRaw
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = Matrix4x4(varargin)
+    function self = Position(varargin)
+      self@iDynTree.PositionRaw(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(329, varargin{:});
+        tmp = iDynTreeMEX(413, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(330, self, varargin{:});
-    end
-    function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(331, self, varargin{:});
+    function varargout = changePoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(414, self, varargin{:});
     end
-    function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(332, self, varargin{:});
+    function varargout = changeRefPoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(415, self, varargin{:});
     end
-    function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(333, self, varargin{:});
+    function varargout = changeCoordinateFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(416, self, varargin{:});
     end
-    function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(334, self, varargin{:});
+    function varargout = changePointOf(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(419, self, varargin{:});
     end
-    function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(335, self, varargin{:});
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(420, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(336, self, varargin{:});
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(421, self, varargin{:});
     end
-    function varargout = fillRowMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(337, self, varargin{:});
+    function varargout = uminus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(422, self, varargin{:});
     end
-    function varargout = fillColMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(338, self, varargin{:});
+    function varargout = mtimes(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(423, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(339, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(424, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(340, self, varargin{:});
-    end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(341, self, varargin{:});
-    end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(342, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(425, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(343, self);
+        iDynTreeMEX(427, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
+    function varargout = compose(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(417, varargin{:});
+    end
+    function varargout = inverse(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(418, varargin{:});
+    end
+    function varargout = Zero(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(426, varargin{:});
+    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix4x4Vector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SolidShapesVector.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,98 +1,95 @@
-classdef Matrix4x4Vector < iDynTreeSwigRef
+classdef SolidShapesVector < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1908, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1180, self, varargin{:});
     end
     function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1909, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1181, self, varargin{:});
     end
     function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1910, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1182, self, varargin{:});
     end
     function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1911, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1183, self, varargin{:});
     end
     function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1912, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1184, self, varargin{:});
     end
     function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1913, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1185, self, varargin{:});
     end
     function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1914, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1186, self, varargin{:});
     end
     function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1915, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1187, self, varargin{:});
     end
     function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1916, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1188, self, varargin{:});
     end
     function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1917, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1189, self, varargin{:});
     end
     function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1918, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1190, self, varargin{:});
     end
     function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1919, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1191, self, varargin{:});
     end
     function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1920, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1192, self, varargin{:});
     end
     function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1921, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1193, self, varargin{:});
     end
     function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1922, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1194, self, varargin{:});
     end
-    function self = Matrix4x4Vector(varargin)
+    function self = SolidShapesVector(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1923, varargin{:});
+        tmp = iDynTreeMEX(1195, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1924, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1196, self, varargin{:});
     end
     function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1925, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1197, self, varargin{:});
     end
     function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1926, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1198, self, varargin{:});
     end
     function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1927, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1199, self, varargin{:});
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1928, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1200, self, varargin{:});
     end
     function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1929, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1201, self, varargin{:});
     end
     function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1930, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1202, self, varargin{:});
     end
     function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1931, self, varargin{:});
-    end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1932, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1203, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1933, self);
+        iDynTreeMEX(1204, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix6x10.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix3x3.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-classdef Matrix6x10 < iDynTreeSwigRef
+classdef Matrix3x3 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = Matrix6x10(varargin)
+    function self = Matrix3x3(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(359, varargin{:});
+        tmp = iDynTreeMEX(239, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(360, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(240, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(361, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(241, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(362, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(242, self, varargin{:});
     end
     function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(363, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(243, self, varargin{:});
     end
     function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(364, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(244, self, varargin{:});
     end
     function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(365, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(245, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(366, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(246, self, varargin{:});
     end
     function varargout = fillRowMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(367, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(247, self, varargin{:});
     end
     function varargout = fillColMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(368, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(248, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(369, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(249, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(370, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(250, self, varargin{:});
     end
     function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(371, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(251, self, varargin{:});
     end
     function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(372, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(252, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(373, self);
+        iDynTreeMEX(253, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Matrix6x6.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MatrixDynSize.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,65 +1,77 @@
-classdef Matrix6x6 < iDynTreeSwigRef
+classdef MatrixDynSize < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = Matrix6x6(varargin)
+    function self = MatrixDynSize(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(344, varargin{:});
+        tmp = iDynTreeMEX(132, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(133, self);
+        self.SwigClear();
+      end
+    end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(345, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(134, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(346, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(135, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(347, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(136, self, varargin{:});
     end
     function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(348, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(137, self, varargin{:});
     end
     function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(349, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(138, self, varargin{:});
     end
     function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(350, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(139, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(351, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(140, self, varargin{:});
+    end
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(141, self, varargin{:});
+    end
+    function varargout = reserve(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(142, self, varargin{:});
+    end
+    function varargout = capacity(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(143, self, varargin{:});
+    end
+    function varargout = shrink_to_fit(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(144, self, varargin{:});
     end
     function varargout = fillRowMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(352, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(145, self, varargin{:});
     end
     function varargout = fillColMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(353, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(146, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(354, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(147, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(355, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(148, self, varargin{:});
     end
     function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(356, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(149, self, varargin{:});
     end
     function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(357, self, varargin{:});
-    end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(358, self);
-        self.SwigClear();
-      end
+      [varargout{1:nargout}] = iDynTreeMEX(150, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MatrixDynSize.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix6x10.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,77 +1,65 @@
-classdef MatrixDynSize < iDynTreeSwigRef
+classdef Matrix6x10 < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = MatrixDynSize(varargin)
+    function self = Matrix6x10(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(207, varargin{:});
+        tmp = iDynTreeMEX(284, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(208, self);
-        self.SwigClear();
-      end
-    end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(209, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(285, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(210, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(286, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(211, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(287, self, varargin{:});
     end
     function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(212, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(288, self, varargin{:});
     end
     function varargout = cols(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(213, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(289, self, varargin{:});
     end
     function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(214, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(290, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(215, self, varargin{:});
-    end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(216, self, varargin{:});
-    end
-    function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(217, self, varargin{:});
-    end
-    function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(218, self, varargin{:});
-    end
-    function varargout = shrink_to_fit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(219, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(291, self, varargin{:});
     end
     function varargout = fillRowMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(220, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(292, self, varargin{:});
     end
     function varargout = fillColMajorBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(221, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(293, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(222, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(294, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(223, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(295, self, varargin{:});
     end
     function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(224, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(296, self, varargin{:});
     end
     function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(225, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(297, self, varargin{:});
+    end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(298, self);
+        self.SwigClear();
+      end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MatrixDynSizeVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/BerdyDynamicVariables.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-classdef MatrixDynSizeVector < iDynTreeSwigRef
+classdef BerdyDynamicVariables < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(71, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(96, self, varargin{:});
     end
     function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(72, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(97, self, varargin{:});
     end
     function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(73, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(98, self, varargin{:});
     end
     function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(74, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(99, self, varargin{:});
     end
     function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(75, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(100, self, varargin{:});
     end
     function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(76, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(101, self, varargin{:});
     end
     function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(77, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(102, self, varargin{:});
     end
     function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(78, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(103, self, varargin{:});
     end
     function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(79, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(104, self, varargin{:});
     end
     function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(80, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(105, self, varargin{:});
     end
     function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(81, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(106, self, varargin{:});
     end
     function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(82, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(107, self, varargin{:});
     end
     function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(83, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(108, self, varargin{:});
     end
     function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(84, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(109, self, varargin{:});
     end
     function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(85, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(110, self, varargin{:});
     end
-    function self = MatrixDynSizeVector(varargin)
+    function self = BerdyDynamicVariables(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(86, varargin{:});
+        tmp = iDynTreeMEX(111, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(87, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(112, self, varargin{:});
     end
     function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(88, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(113, self, varargin{:});
     end
     function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(89, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(114, self, varargin{:});
     end
     function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(90, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(115, self, varargin{:});
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(91, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(116, self, varargin{:});
     end
     function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(92, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(117, self, varargin{:});
     end
     function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(93, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(118, self, varargin{:});
     end
     function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(94, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(119, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(95, self);
+        iDynTreeMEX(120, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Model.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Model.m`

 * *Files 12% similar despite different names*

```diff
@@ -5,151 +5,139 @@
     end
     function self = Model(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1174, varargin{:});
+        tmp = iDynTreeMEX(1047, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = copy(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1175, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1048, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1176, self);
+        iDynTreeMEX(1049, self);
         self.SwigClear();
       end
     end
     function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1177, self, varargin{:});
-    end
-    function varargout = getPackageDirs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1178, self, varargin{:});
-    end
-    function varargout = setPackageDirs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1179, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1050, self, varargin{:});
     end
     function varargout = getLinkName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1180, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1051, self, varargin{:});
     end
     function varargout = getLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1181, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1052, self, varargin{:});
     end
     function varargout = isValidLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1182, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1053, self, varargin{:});
     end
     function varargout = getLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1183, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1054, self, varargin{:});
     end
     function varargout = addLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1184, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1055, self, varargin{:});
     end
     function varargout = getNrOfJoints(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1185, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1056, self, varargin{:});
     end
     function varargout = getJointName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1186, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1057, self, varargin{:});
     end
     function varargout = getTotalMass(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1187, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1058, self, varargin{:});
     end
     function varargout = getJointIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1188, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1059, self, varargin{:});
     end
     function varargout = getJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1189, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1060, self, varargin{:});
     end
     function varargout = isValidJointIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1190, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1061, self, varargin{:});
     end
     function varargout = isLinkNameUsed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1191, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1062, self, varargin{:});
     end
     function varargout = isJointNameUsed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1192, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1063, self, varargin{:});
     end
     function varargout = isFrameNameUsed(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1193, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1064, self, varargin{:});
     end
     function varargout = addJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1194, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1065, self, varargin{:});
     end
     function varargout = addJointAndLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1195, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1066, self, varargin{:});
     end
     function varargout = insertLinkToExistingJointAndAddJointForDisplacedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1196, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1067, self, varargin{:});
     end
     function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1197, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1068, self, varargin{:});
     end
     function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1198, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1069, self, varargin{:});
     end
     function varargout = getNrOfFrames(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1199, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1070, self, varargin{:});
     end
     function varargout = addAdditionalFrameToLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1200, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1071, self, varargin{:});
     end
     function varargout = getFrameName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1201, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1072, self, varargin{:});
     end
     function varargout = getFrameIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1202, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1073, self, varargin{:});
     end
     function varargout = isValidFrameIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1203, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1074, self, varargin{:});
     end
     function varargout = getFrameTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1204, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1075, self, varargin{:});
     end
     function varargout = getFrameLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1205, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1076, self, varargin{:});
     end
     function varargout = getLinkAdditionalFrames(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1206, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1077, self, varargin{:});
     end
     function varargout = getNrOfNeighbors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1207, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1078, self, varargin{:});
     end
     function varargout = getNeighbor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1208, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1079, self, varargin{:});
     end
     function varargout = setDefaultBaseLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1209, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1080, self, varargin{:});
     end
     function varargout = getDefaultBaseLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1210, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1081, self, varargin{:});
     end
     function varargout = computeFullTreeTraversal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1211, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1082, self, varargin{:});
     end
     function varargout = getInertialParameters(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1212, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1083, self, varargin{:});
     end
     function varargout = updateInertialParameters(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1213, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1084, self, varargin{:});
     end
     function varargout = visualSolidShapes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1214, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1085, self, varargin{:});
     end
     function varargout = collisionSolidShapes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1215, self, varargin{:});
-    end
-    function varargout = sensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1216, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1086, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1217, self, varargin{:});
-    end
-    function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1218, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1087, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelCalibrationHelper.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelCalibrationHelper.m`

 * *Files 6% similar despite different names*

```diff
@@ -5,43 +5,43 @@
     end
     function self = ModelCalibrationHelper(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1560, varargin{:});
+        tmp = iDynTreeMEX(1479, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1561, self);
+        iDynTreeMEX(1480, self);
         self.SwigClear();
       end
     end
     function varargout = loadModelFromString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1562, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1481, self, varargin{:});
     end
     function varargout = loadModelFromFile(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1563, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1482, self, varargin{:});
     end
     function varargout = updateModelInertialParametersToString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1564, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1483, self, varargin{:});
     end
     function varargout = updateModelInertialParametersToFile(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1565, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1484, self, varargin{:});
     end
     function varargout = model(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1566, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1485, self, varargin{:});
     end
     function varargout = sensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1567, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1486, self, varargin{:});
     end
     function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1568, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1487, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelExporter.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelExporter.m`

 * *Files 3% similar despite different names*

```diff
@@ -5,46 +5,46 @@
     end
     function self = ModelExporter(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1550, varargin{:});
+        tmp = iDynTreeMEX(1469, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1551, self);
+        iDynTreeMEX(1470, self);
         self.SwigClear();
       end
     end
     function varargout = exportingOptions(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1552, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1471, self, varargin{:});
     end
     function varargout = setExportingOptions(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1553, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1472, self, varargin{:});
     end
     function varargout = init(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1554, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1473, self, varargin{:});
     end
     function varargout = model(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1555, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1474, self, varargin{:});
     end
     function varargout = sensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1556, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1475, self, varargin{:});
     end
     function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1557, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1476, self, varargin{:});
     end
     function varargout = exportModelToString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1558, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1477, self, varargin{:});
     end
     function varargout = exportModelToFile(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1559, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1478, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelExporterOptions.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelExporterOptions.m`

 * *Files 12% similar despite different names*

```diff
@@ -3,64 +3,54 @@
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = baseLink(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1540, self);
+        varargout{1} = iDynTreeMEX(1461, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1541, self, varargin{1});
+        iDynTreeMEX(1462, self, varargin{1});
       end
     end
     function varargout = exportFirstBaseLinkAdditionalFrameAsFakeURDFBase(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1542, self);
+        varargout{1} = iDynTreeMEX(1463, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1543, self, varargin{1});
+        iDynTreeMEX(1464, self, varargin{1});
       end
     end
     function varargout = robotExportedName(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1544, self);
+        varargout{1} = iDynTreeMEX(1465, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1545, self, varargin{1});
-      end
-    end
-    function varargout = xmlBlobs(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1546, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(1547, self, varargin{1});
+        iDynTreeMEX(1466, self, varargin{1});
       end
     end
     function self = ModelExporterOptions(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1548, varargin{:});
+        tmp = iDynTreeMEX(1467, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1549, self);
+        iDynTreeMEX(1468, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelLoader.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Traversal.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,56 +1,71 @@
-classdef ModelLoader < iDynTreeSwigRef
+classdef Traversal < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = ModelLoader(varargin)
+    function self = Traversal(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1528, varargin{:});
+        tmp = iDynTreeMEX(962, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1529, self);
+        iDynTreeMEX(963, self);
         self.SwigClear();
       end
     end
-    function varargout = parsingOptions(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1530, self, varargin{:});
+    function varargout = getNrOfVisitedLinks(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(964, self, varargin{:});
     end
-    function varargout = setParsingOptions(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1531, self, varargin{:});
+    function varargout = getLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(965, self, varargin{:});
     end
-    function varargout = loadModelFromString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1532, self, varargin{:});
+    function varargout = getBaseLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(966, self, varargin{:});
     end
-    function varargout = loadModelFromFile(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1533, self, varargin{:});
+    function varargout = getParentLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(967, self, varargin{:});
     end
-    function varargout = loadReducedModelFromFullModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1534, self, varargin{:});
+    function varargout = getParentJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(968, self, varargin{:});
     end
-    function varargout = loadReducedModelFromString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1535, self, varargin{:});
+    function varargout = getParentLinkFromLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(969, self, varargin{:});
     end
-    function varargout = loadReducedModelFromFile(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1536, self, varargin{:});
+    function varargout = getParentJointFromLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(970, self, varargin{:});
     end
-    function varargout = model(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1537, self, varargin{:});
+    function varargout = getTraversalIndexFromLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(971, self, varargin{:});
     end
-    function varargout = sensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1538, self, varargin{:});
+    function varargout = reset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(972, self, varargin{:});
     end
-    function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1539, self, varargin{:});
+    function varargout = addTraversalBase(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(973, self, varargin{:});
+    end
+    function varargout = addTraversalElement(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(974, self, varargin{:});
+    end
+    function varargout = isParentOf(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(975, self, varargin{:});
+    end
+    function varargout = getChildLinkIndexFromJointIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(976, self, varargin{:});
+    end
+    function varargout = getParentLinkIndexFromJointIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(977, self, varargin{:});
+    end
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(978, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelParserOptions.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/AttitudeEstimatorState.m`

 * *Files 17% similar despite different names*

```diff
@@ -1,46 +1,56 @@
-classdef ModelParserOptions < iDynTreeSwigRef
+classdef AttitudeEstimatorState < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = addSensorFramesAsAdditionalFrames(self, varargin)
+    function varargout = m_orientation(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1522, self);
+        varargout{1} = iDynTreeMEX(1648, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1523, self, varargin{1});
+        iDynTreeMEX(1649, self, varargin{1});
       end
     end
-    function varargout = originalFilename(self, varargin)
+    function varargout = m_angular_velocity(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1524, self);
+        varargout{1} = iDynTreeMEX(1650, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1525, self, varargin{1});
+        iDynTreeMEX(1651, self, varargin{1});
       end
     end
-    function self = ModelParserOptions(varargin)
+    function varargout = m_gyroscope_bias(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(1652, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(1653, self, varargin{1});
+      end
+    end
+    function self = AttitudeEstimatorState(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1526, varargin{:});
+        tmp = iDynTreeMEX(1654, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1527, self);
+        iDynTreeMEX(1655, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ModelSolidShapes.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SensorsMeasurements.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,38 +1,47 @@
-classdef ModelSolidShapes < iDynTreeSwigRef
+classdef SensorsMeasurements < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(1110, self);
-        self.SwigClear();
-      end
-    end
-    function self = ModelSolidShapes(varargin)
+    function self = SensorsMeasurements(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1111, varargin{:});
+        tmp = iDynTreeMEX(1338, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1112, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1339, self);
+        self.SwigClear();
+      end
+    end
+    function varargout = setNrOfSensors(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1340, self, varargin{:});
+    end
+    function varargout = getNrOfSensors(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1341, self, varargin{:});
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1113, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1342, self, varargin{:});
+    end
+    function varargout = toVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1343, self, varargin{:});
+    end
+    function varargout = setMeasurement(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1344, self, varargin{:});
     end
-    function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1114, self, varargin{:});
+    function varargout = getMeasurement(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1345, self, varargin{:});
     end
-    function varargout = getLinkSolidShapes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1115, self, varargin{:});
+    function varargout = getSizeOfAllSensorsMeasurements(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1346, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MomentumFreeFloatingJacobian.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/FrameFreeFloatingJacobian.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-classdef MomentumFreeFloatingJacobian < iDynTree.MatrixDynSize
+classdef FrameFreeFloatingJacobian < iDynTree.MatrixDynSize
   methods
-    function self = MomentumFreeFloatingJacobian(varargin)
+    function self = FrameFreeFloatingJacobian(varargin)
       self@iDynTree.MatrixDynSize(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1241, varargin{:});
+        tmp = iDynTreeMEX(1106, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1242, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1107, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1243, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1108, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1244, self);
+        iDynTreeMEX(1109, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl1.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Matrix4x4.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,46 +1,65 @@
-classdef MovableJointImpl1 < iDynTree.IJoint
+classdef Matrix4x4 < iDynTreeSwigRef
   methods
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(919, self);
-        self.SwigClear();
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
+    function self = Matrix4x4(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(254, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
       end
     end
-    function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(920, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(255, self, varargin{:});
     end
-    function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(921, self, varargin{:});
+    function varargout = getVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(256, self, varargin{:});
     end
-    function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(922, self, varargin{:});
+    function varargout = setVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(257, self, varargin{:});
     end
-    function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(923, self, varargin{:});
+    function varargout = rows(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(258, self, varargin{:});
     end
-    function varargout = setPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(924, self, varargin{:});
+    function varargout = cols(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(259, self, varargin{:});
     end
-    function varargout = getPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(925, self, varargin{:});
+    function varargout = data(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(260, self, varargin{:});
     end
-    function varargout = setDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(926, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(261, self, varargin{:});
     end
-    function varargout = getDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(927, self, varargin{:});
+    function varargout = fillRowMajorBuffer(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(262, self, varargin{:});
     end
-    function self = MovableJointImpl1(varargin)
-      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        error('No matching constructor');
+    function varargout = fillColMajorBuffer(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(263, self, varargin{:});
+    end
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(264, self, varargin{:});
+    end
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(265, self, varargin{:});
+    end
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(266, self, varargin{:});
+    end
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(267, self, varargin{:});
+    end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(268, self);
+        self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl2.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl5.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-classdef MovableJointImpl2 < iDynTree.IJoint
+classdef MovableJointImpl5 < iDynTree.IJoint
   methods
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(928, self);
+        iDynTreeMEX(894, self);
         self.SwigClear();
       end
     end
     function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(929, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(895, self, varargin{:});
     end
     function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(930, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(896, self, varargin{:});
     end
     function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(931, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(897, self, varargin{:});
     end
     function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(932, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(898, self, varargin{:});
     end
     function varargout = setPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(933, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(899, self, varargin{:});
     end
     function varargout = getPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(934, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(900, self, varargin{:});
     end
     function varargout = setDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(935, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(901, self, varargin{:});
     end
     function varargout = getDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(936, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(902, self, varargin{:});
     end
-    function self = MovableJointImpl2(varargin)
+    function self = MovableJointImpl5(varargin)
       self@iDynTree.IJoint(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl3.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkSensor.m`

 * *Files 10% similar despite different names*

```diff
@@ -1,41 +1,38 @@
-classdef MovableJointImpl3 < iDynTree.IJoint
+classdef LinkSensor < iDynTree.Sensor
   methods
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(937, self);
+        iDynTreeMEX(1313, self);
         self.SwigClear();
       end
     end
-    function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(938, self, varargin{:});
+    function varargout = getParentLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1314, self, varargin{:});
     end
-    function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(939, self, varargin{:});
+    function varargout = getParentLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1315, self, varargin{:});
     end
-    function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(940, self, varargin{:});
+    function varargout = getLinkSensorTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1316, self, varargin{:});
     end
-    function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(941, self, varargin{:});
+    function varargout = setParentLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1317, self, varargin{:});
     end
-    function varargout = setPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(942, self, varargin{:});
+    function varargout = setParentLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1318, self, varargin{:});
     end
-    function varargout = getPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(943, self, varargin{:});
+    function varargout = setLinkSensorTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1319, self, varargin{:});
     end
-    function varargout = setDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(944, self, varargin{:});
+    function varargout = isConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1320, self, varargin{:});
     end
-    function varargout = getDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(945, self, varargin{:});
-    end
-    function self = MovableJointImpl3(varargin)
-      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
+    function self = LinkSensor(varargin)
+      self@iDynTree.Sensor(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl4.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Sensor.m`

 * *Files 13% similar despite different names*

```diff
@@ -1,41 +1,40 @@
-classdef MovableJointImpl4 < iDynTree.IJoint
+classdef Sensor < iDynTreeSwigRef
   methods
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(946, self);
+        iDynTreeMEX(1299, self);
         self.SwigClear();
       end
     end
-    function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(947, self, varargin{:});
-    end
-    function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(948, self, varargin{:});
+    function varargout = getName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1300, self, varargin{:});
     end
-    function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(949, self, varargin{:});
+    function varargout = getSensorType(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1301, self, varargin{:});
     end
-    function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(950, self, varargin{:});
+    function varargout = isValid(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1302, self, varargin{:});
     end
-    function varargout = setPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(951, self, varargin{:});
+    function varargout = setName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1303, self, varargin{:});
     end
-    function varargout = getPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(952, self, varargin{:});
+    function varargout = clone(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1304, self, varargin{:});
     end
-    function varargout = setDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(953, self, varargin{:});
+    function varargout = isConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1305, self, varargin{:});
     end
-    function varargout = getDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(954, self, varargin{:});
+    function varargout = updateIndices(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1306, self, varargin{:});
     end
-    function self = MovableJointImpl4(varargin)
-      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
+    function self = Sensor(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl5.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelSolidShapes.m`

 * *Files 10% similar despite different names*

```diff
@@ -1,46 +1,38 @@
-classdef MovableJointImpl5 < iDynTree.IJoint
+classdef ModelSolidShapes < iDynTreeSwigRef
   methods
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(955, self);
+        iDynTreeMEX(1035, self);
         self.SwigClear();
       end
     end
-    function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(956, self, varargin{:});
-    end
-    function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(957, self, varargin{:});
-    end
-    function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(958, self, varargin{:});
-    end
-    function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(959, self, varargin{:});
-    end
-    function varargout = setPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(960, self, varargin{:});
-    end
-    function varargout = getPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(961, self, varargin{:});
-    end
-    function varargout = setDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(962, self, varargin{:});
-    end
-    function varargout = getDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(963, self, varargin{:});
-    end
-    function self = MovableJointImpl5(varargin)
-      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
+    function self = ModelSolidShapes(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        error('No matching constructor');
+        tmp = iDynTreeMEX(1036, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
       end
     end
+    function varargout = clear(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1037, self, varargin{:});
+    end
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1038, self, varargin{:});
+    end
+    function varargout = isConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1039, self, varargin{:});
+    end
+    function varargout = getLinkSolidShapes(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1040, self, varargin{:});
+    end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl6.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/UnknownWrenchContact.m`

 * *Files 20% similar despite different names*

```diff
@@ -1,46 +1,76 @@
-classdef MovableJointImpl6 < iDynTree.IJoint
+classdef UnknownWrenchContact < iDynTreeSwigRef
   methods
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(964, self);
-        self.SwigClear();
-      end
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
     end
-    function varargout = getNrOfPosCoords(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(965, self, varargin{:});
-    end
-    function varargout = getNrOfDOFs(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(966, self, varargin{:});
-    end
-    function varargout = setIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(967, self, varargin{:});
-    end
-    function varargout = getIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(968, self, varargin{:});
+    function self = UnknownWrenchContact(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(1488, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
     end
-    function varargout = setPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(969, self, varargin{:});
+    function varargout = unknownType(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(1489, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(1490, self, varargin{1});
+      end
     end
-    function varargout = getPosCoordsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(970, self, varargin{:});
+    function varargout = contactPoint(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(1491, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(1492, self, varargin{1});
+      end
     end
-    function varargout = setDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(971, self, varargin{:});
+    function varargout = forceDirection(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(1493, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(1494, self, varargin{1});
+      end
     end
-    function varargout = getDOFsOffset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(972, self, varargin{:});
+    function varargout = knownWrench(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(1495, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(1496, self, varargin{1});
+      end
     end
-    function self = MovableJointImpl6(varargin)
-      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
+    function varargout = contactId(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(1497, self);
       else
-        error('No matching constructor');
+        nargoutchk(0, 0)
+        iDynTreeMEX(1498, self, varargin{1});
+      end
+    end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1499, self);
+        self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Neighbor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Neighbor.m`

 * *Files 6% similar despite different names*

```diff
@@ -3,44 +3,44 @@
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = neighborLink(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1168, self);
+        varargout{1} = iDynTreeMEX(1041, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1169, self, varargin{1});
+        iDynTreeMEX(1042, self, varargin{1});
       end
     end
     function varargout = neighborJoint(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1170, self);
+        varargout{1} = iDynTreeMEX(1043, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1171, self, varargin{1});
+        iDynTreeMEX(1044, self, varargin{1});
       end
     end
     function self = Neighbor(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1172, varargin{:});
+        tmp = iDynTreeMEX(1045, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1173, self);
+        iDynTreeMEX(1046, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/PixelViz.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/PixelViz.m`

 * *Files 4% similar despite different names*

```diff
@@ -1,44 +1,44 @@
 classdef PixelViz < iDynTree.ColorViz
   methods
     function varargout = width(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1959, self);
+        varargout{1} = iDynTreeMEX(1876, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1960, self, varargin{1});
+        iDynTreeMEX(1877, self, varargin{1});
       end
     end
     function varargout = height(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1961, self);
+        varargout{1} = iDynTreeMEX(1878, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1962, self, varargin{1});
+        iDynTreeMEX(1879, self, varargin{1});
       end
     end
     function self = PixelViz(varargin)
       self@iDynTree.ColorViz(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1963, varargin{:});
+        tmp = iDynTreeMEX(1880, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1964, self);
+        iDynTreeMEX(1881, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Polygon.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Direction.m`

 * *Files 16% similar despite different names*

```diff
@@ -1,54 +1,45 @@
-classdef Polygon < iDynTreeSwigRef
+classdef Direction < iDynTree.Vector3
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function varargout = m_vertices(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2089, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(2090, self, varargin{1});
-      end
-    end
-    function self = Polygon(varargin)
+    function self = Direction(varargin)
+      self@iDynTree.Vector3(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(2091, varargin{:});
+        tmp = iDynTreeMEX(528, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = setNrOfVertices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2092, self, varargin{:});
+    function varargout = Normalize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(529, self, varargin{:});
+    end
+    function varargout = isParallel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(530, self, varargin{:});
     end
-    function varargout = getNrOfVertices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2093, self, varargin{:});
+    function varargout = isPerpendicular(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(531, self, varargin{:});
     end
-    function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2094, self, varargin{:});
+    function varargout = reverse(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(532, self, varargin{:});
     end
-    function varargout = applyTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2095, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(533, self, varargin{:});
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2096, self, varargin{:});
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(534, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2098, self);
+        iDynTreeMEX(536, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
-    function varargout = XYRectangleFromOffsets(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(2097, varargin{:});
+    function varargout = Default(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(535, varargin{:});
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Polygon2D.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ContactWrench.m`

 * *Files 10% similar despite different names*

```diff
@@ -1,48 +1,35 @@
-classdef Polygon2D < iDynTreeSwigRef
+classdef ContactWrench < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = m_vertices(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2099, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(2100, self, varargin{1});
-      end
+    function varargout = contactId(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1141, self, varargin{:});
+    end
+    function varargout = contactPoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1142, self, varargin{:});
+    end
+    function varargout = contactWrench(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1143, self, varargin{:});
     end
-    function self = Polygon2D(varargin)
+    function self = ContactWrench(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(2101, varargin{:});
+        tmp = iDynTreeMEX(1144, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = setNrOfVertices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2102, self, varargin{:});
-    end
-    function varargout = getNrOfVertices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2103, self, varargin{:});
-    end
-    function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2104, self, varargin{:});
-    end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(2105, self, varargin{:});
-    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2106, self);
+        iDynTreeMEX(1145, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Position.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialInertia.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,63 +1,69 @@
-classdef Position < iDynTree.Vector3
+classdef SpatialInertia < iDynTree.SpatialInertiaRaw
   methods
-    function self = Position(varargin)
-      self@iDynTree.Vector3(iDynTreeSwigRef.Null);
+    function self = SpatialInertia(varargin)
+      self@iDynTree.SpatialInertiaRaw(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(479, varargin{:});
+        tmp = iDynTreeMEX(568, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = changePoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(480, self, varargin{:});
+    function varargout = asMatrix(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(570, self, varargin{:});
     end
-    function varargout = changeRefPoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(481, self, varargin{:});
+    function varargout = applyInverse(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(571, self, varargin{:});
     end
-    function varargout = changeCoordinateFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(482, self, varargin{:});
-    end
-    function varargout = changePointOf(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(485, self, varargin{:});
+    function varargout = getInverse(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(572, self, varargin{:});
     end
     function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(486, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(573, self, varargin{:});
+    end
+    function varargout = mtimes(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(574, self, varargin{:});
     end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(487, self, varargin{:});
+    function varargout = biasWrench(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(575, self, varargin{:});
     end
-    function varargout = uminus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(488, self, varargin{:});
+    function varargout = biasWrenchDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(576, self, varargin{:});
     end
-    function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(489, self, varargin{:});
+    function varargout = asVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(578, self, varargin{:});
     end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(490, self, varargin{:});
+    function varargout = fromVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(579, self, varargin{:});
     end
-    function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(491, self, varargin{:});
+    function varargout = isPhysicallyConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(580, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(493, self);
+        iDynTreeMEX(584, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
-    function varargout = compose(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(483, varargin{:});
-    end
-    function varargout = inverse(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(484, varargin{:});
+    function varargout = combine(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(569, varargin{:});
     end
     function varargout = Zero(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(492, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(577, varargin{:});
+    end
+    function varargout = momentumRegressor(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(581, varargin{:});
+    end
+    function varargout = momentumDerivativeRegressor(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(582, varargin{:});
+    end
+    function varargout = momentumDerivativeSlotineLiRegressor(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(583, varargin{:});
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/PrismaticJoint.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SixAxisForceTorqueSensor.m`

 * *Files 13% similar despite different names*

```diff
@@ -1,111 +1,105 @@
-classdef PrismaticJoint < iDynTree.MovableJointImpl1
+classdef SixAxisForceTorqueSensor < iDynTree.JointSensor
   methods
-    function self = PrismaticJoint(varargin)
-      self@iDynTree.MovableJointImpl1(iDynTreeSwigRef.Null);
+    function self = SixAxisForceTorqueSensor(varargin)
+      self@iDynTree.JointSensor(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1004, varargin{:});
+        tmp = iDynTreeMEX(1347, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1005, self);
+        iDynTreeMEX(1348, self);
         self.SwigClear();
       end
     end
-    function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1006, self, varargin{:});
-    end
-    function varargout = setAttachedLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1007, self, varargin{:});
+    function varargout = setName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1349, self, varargin{:});
     end
-    function varargout = setRestTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1008, self, varargin{:});
+    function varargout = setFirstLinkSensorTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1350, self, varargin{:});
     end
-    function varargout = setAxis(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1009, self, varargin{:});
+    function varargout = setSecondLinkSensorTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1351, self, varargin{:});
     end
-    function varargout = getFirstAttachedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1010, self, varargin{:});
+    function varargout = getFirstLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1352, self, varargin{:});
     end
-    function varargout = getSecondAttachedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1011, self, varargin{:});
+    function varargout = getSecondLinkIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1353, self, varargin{:});
     end
-    function varargout = getAxis(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1012, self, varargin{:});
+    function varargout = setFirstLinkName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1354, self, varargin{:});
     end
-    function varargout = getRestTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1013, self, varargin{:});
+    function varargout = setSecondLinkName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1355, self, varargin{:});
     end
-    function varargout = getTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1014, self, varargin{:});
+    function varargout = getFirstLinkName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1356, self, varargin{:});
     end
-    function varargout = getTransformDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1015, self, varargin{:});
+    function varargout = getSecondLinkName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1357, self, varargin{:});
     end
-    function varargout = getMotionSubspaceVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1016, self, varargin{:});
+    function varargout = setParentJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1358, self, varargin{:});
     end
-    function varargout = computeChildPosVelAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1017, self, varargin{:});
+    function varargout = setParentJointIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1359, self, varargin{:});
     end
-    function varargout = computeChildVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1018, self, varargin{:});
+    function varargout = setAppliedWrenchLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1360, self, varargin{:});
     end
-    function varargout = computeChildVelAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1019, self, varargin{:});
+    function varargout = getName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1361, self, varargin{:});
     end
-    function varargout = computeChildAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1020, self, varargin{:});
+    function varargout = getSensorType(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1362, self, varargin{:});
     end
-    function varargout = computeChildBiasAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1021, self, varargin{:});
+    function varargout = getParentJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1363, self, varargin{:});
     end
-    function varargout = computeJointTorque(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1022, self, varargin{:});
+    function varargout = getParentJointIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1364, self, varargin{:});
     end
-    function varargout = hasPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1023, self, varargin{:});
+    function varargout = isValid(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1365, self, varargin{:});
     end
-    function varargout = enablePosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1024, self, varargin{:});
-    end
-    function varargout = getPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1025, self, varargin{:});
+    function varargout = clone(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1366, self, varargin{:});
     end
-    function varargout = getMinPosLimit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1026, self, varargin{:});
+    function varargout = updateIndices(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1367, self, varargin{:});
     end
-    function varargout = getMaxPosLimit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1027, self, varargin{:});
+    function varargout = getAppliedWrenchLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1368, self, varargin{:});
     end
-    function varargout = setPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1028, self, varargin{:});
+    function varargout = isLinkAttachedToSensor(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1369, self, varargin{:});
     end
-    function varargout = getJointDynamicsType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1029, self, varargin{:});
+    function varargout = getLinkSensorTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1370, self, varargin{:});
     end
-    function varargout = setJointDynamicsType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1030, self, varargin{:});
+    function varargout = getWrenchAppliedOnLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1371, self, varargin{:});
     end
-    function varargout = getDamping(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1031, self, varargin{:});
+    function varargout = getWrenchAppliedOnLinkMatrix(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1372, self, varargin{:});
     end
-    function varargout = getStaticFriction(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1032, self, varargin{:});
+    function varargout = getWrenchAppliedOnLinkInverseMatrix(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1373, self, varargin{:});
     end
-    function varargout = setDamping(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1033, self, varargin{:});
+    function varargout = predictMeasurement(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1374, self, varargin{:});
     end
-    function varargout = setStaticFriction(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1034, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1375, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RevoluteJoint.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialMotionVectorBase.m`

 * *Files 18% similar despite different names*

```diff
@@ -1,111 +1,95 @@
-classdef RevoluteJoint < iDynTree.MovableJointImpl1
+classdef SpatialMotionVectorBase < iDynTreeSwigRef
   methods
-    function self = RevoluteJoint(varargin)
-      self@iDynTree.MovableJointImpl1(iDynTreeSwigRef.Null);
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
+    function self = SpatialMotionVectorBase(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(973, varargin{:});
+        tmp = iDynTreeMEX(439, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(974, self);
-        self.SwigClear();
-      end
-    end
-    function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(975, self, varargin{:});
-    end
-    function varargout = setAttachedLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(976, self, varargin{:});
-    end
-    function varargout = setRestTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(977, self, varargin{:});
-    end
-    function varargout = setAxis(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(978, self, varargin{:});
-    end
-    function varargout = getFirstAttachedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(979, self, varargin{:});
+    function varargout = getLinearVec3(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(440, self, varargin{:});
     end
-    function varargout = getSecondAttachedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(980, self, varargin{:});
+    function varargout = getAngularVec3(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(441, self, varargin{:});
     end
-    function varargout = getAxis(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(981, self, varargin{:});
+    function varargout = setLinearVec3(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(442, self, varargin{:});
     end
-    function varargout = getRestTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(982, self, varargin{:});
+    function varargout = setAngularVec3(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(443, self, varargin{:});
     end
-    function varargout = getTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(983, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(444, self, varargin{:});
     end
-    function varargout = getTransformDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(984, self, varargin{:});
+    function varargout = getVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(445, self, varargin{:});
     end
-    function varargout = getMotionSubspaceVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(985, self, varargin{:});
+    function varargout = setVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(446, self, varargin{:});
     end
-    function varargout = computeChildPosVelAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(986, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(447, self, varargin{:});
     end
-    function varargout = computeChildVel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(987, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(448, self, varargin{:});
     end
-    function varargout = computeChildVelAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(988, self, varargin{:});
+    function varargout = changePoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(449, self, varargin{:});
     end
-    function varargout = computeChildAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(989, self, varargin{:});
+    function varargout = changeCoordFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(450, self, varargin{:});
     end
-    function varargout = computeChildBiasAcc(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(990, self, varargin{:});
+    function varargout = dot(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(453, self, varargin{:});
     end
-    function varargout = computeJointTorque(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(991, self, varargin{:});
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(454, self, varargin{:});
     end
-    function varargout = hasPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(992, self, varargin{:});
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(455, self, varargin{:});
     end
-    function varargout = enablePosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(993, self, varargin{:});
+    function varargout = uminus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(456, self, varargin{:});
     end
-    function varargout = getPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(994, self, varargin{:});
+    function varargout = asVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(458, self, varargin{:});
     end
-    function varargout = getMinPosLimit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(995, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(459, self, varargin{:});
     end
-    function varargout = getMaxPosLimit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(996, self, varargin{:});
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(460, self, varargin{:});
     end
-    function varargout = setPosLimits(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(997, self, varargin{:});
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(461, self, varargin{:});
     end
-    function varargout = getJointDynamicsType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(998, self, varargin{:});
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(462, self, varargin{:});
     end
-    function varargout = setJointDynamicsType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(999, self, varargin{:});
-    end
-    function varargout = getDamping(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1000, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(463, self);
+        self.SwigClear();
+      end
     end
-    function varargout = getStaticFriction(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1001, self, varargin{:});
+  end
+  methods(Static)
+    function varargout = compose(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(451, varargin{:});
     end
-    function varargout = setDamping(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1002, self, varargin{:});
+    function varargout = inverse(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(452, varargin{:});
     end
-    function varargout = setStaticFriction(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1003, self, varargin{:});
+    function varargout = Zero(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(457, varargin{:});
     end
   end
-  methods(Static)
-  end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RigidBodyInertiaNonLinearParametrization.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RigidBodyInertiaNonLinearParametrization.m`

 * *Files 4% similar despite different names*

```diff
@@ -3,88 +3,88 @@
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
     function varargout = mass(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(663, self);
+        varargout{1} = iDynTreeMEX(600, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(664, self, varargin{1});
+        iDynTreeMEX(601, self, varargin{1});
       end
     end
     function varargout = com(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(665, self);
+        varargout{1} = iDynTreeMEX(602, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(666, self, varargin{1});
+        iDynTreeMEX(603, self, varargin{1});
       end
     end
     function varargout = link_R_centroidal(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(667, self);
+        varargout{1} = iDynTreeMEX(604, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(668, self, varargin{1});
+        iDynTreeMEX(605, self, varargin{1});
       end
     end
     function varargout = centralSecondMomentOfMass(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(669, self);
+        varargout{1} = iDynTreeMEX(606, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(670, self, varargin{1});
+        iDynTreeMEX(607, self, varargin{1});
       end
     end
     function varargout = getLinkCentroidalTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(671, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(608, self, varargin{:});
     end
     function varargout = fromRigidBodyInertia(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(672, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(609, self, varargin{:});
     end
     function varargout = fromInertialParameters(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(673, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(610, self, varargin{:});
     end
     function varargout = toRigidBodyInertia(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(674, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(611, self, varargin{:});
     end
     function varargout = isPhysicallyConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(675, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(612, self, varargin{:});
     end
     function varargout = asVectorWithRotationAsVec(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(676, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(613, self, varargin{:});
     end
     function varargout = fromVectorWithRotationAsVec(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(677, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(614, self, varargin{:});
     end
     function varargout = getGradientWithRotationAsVec(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(678, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(615, self, varargin{:});
     end
     function self = RigidBodyInertiaNonLinearParametrization(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(679, varargin{:});
+        tmp = iDynTreeMEX(616, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(680, self);
+        iDynTreeMEX(617, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Rotation.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Rotation.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,120 +1,120 @@
-classdef Rotation < iDynTree.Matrix3x3
+classdef Rotation < iDynTree.RotationRaw
   methods
     function self = Rotation(varargin)
-      self@iDynTree.Matrix3x3(iDynTreeSwigRef.Null);
+      self@iDynTree.RotationRaw(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(681, varargin{:});
+        tmp = iDynTreeMEX(632, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = changeOrientFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(682, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(633, self, varargin{:});
     end
     function varargout = changeRefOrientFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(683, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(634, self, varargin{:});
     end
     function varargout = changeCoordinateFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(684, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(635, self, varargin{:});
     end
     function varargout = changeCoordFrameOf(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(687, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(638, self, varargin{:});
     end
     function varargout = inverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(688, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(639, self, varargin{:});
     end
     function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(689, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(640, self, varargin{:});
     end
     function varargout = log(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(690, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(641, self, varargin{:});
     end
     function varargout = fromQuaternion(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(691, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(642, self, varargin{:});
     end
     function varargout = getRPY(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(692, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(643, self, varargin{:});
     end
     function varargout = asRPY(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(693, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(644, self, varargin{:});
     end
     function varargout = getQuaternion(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(694, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(645, self, varargin{:});
     end
     function varargout = asQuaternion(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(695, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(646, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(712, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(663, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(713, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(664, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(714, self);
+        iDynTreeMEX(665, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
     function varargout = compose(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(685, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(636, varargin{:});
     end
     function varargout = inverse2(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(686, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(637, varargin{:});
     end
     function varargout = RotX(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(696, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(647, varargin{:});
     end
     function varargout = RotY(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(697, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(648, varargin{:});
     end
     function varargout = RotZ(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(698, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(649, varargin{:});
     end
     function varargout = RotAxis(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(699, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(650, varargin{:});
     end
     function varargout = RotAxisDerivative(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(700, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(651, varargin{:});
     end
     function varargout = RPY(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(701, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(652, varargin{:});
     end
     function varargout = RPYRightTrivializedDerivative(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(702, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(653, varargin{:});
     end
     function varargout = RPYRightTrivializedDerivativeRateOfChange(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(703, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(654, varargin{:});
     end
     function varargout = RPYRightTrivializedDerivativeInverse(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(704, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(655, varargin{:});
     end
     function varargout = RPYRightTrivializedDerivativeInverseRateOfChange(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(705, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(656, varargin{:});
     end
     function varargout = QuaternionRightTrivializedDerivative(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(706, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(657, varargin{:});
     end
     function varargout = QuaternionRightTrivializedDerivativeInverse(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(707, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(658, varargin{:});
     end
     function varargout = Identity(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(708, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(659, varargin{:});
     end
     function varargout = RotationFromQuaternion(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(709, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(660, varargin{:});
     end
     function varargout = leftJacobian(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(710, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(661, varargin{:});
     end
     function varargout = leftJacobianInverse(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(711, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(662, varargin{:});
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/RotationalInertia.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialAcc.m`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,33 @@
-classdef RotationalInertia < iDynTree.Matrix3x3
+classdef SpatialAcc < iDynTree.SpatialMotionVector
   methods
-    function self = RotationalInertia(varargin)
-      self@iDynTree.Matrix3x3(iDynTreeSwigRef.Null);
+    function self = SpatialAcc(varargin)
+      self@iDynTree.SpatialMotionVector(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(621, varargin{:});
+        tmp = iDynTreeMEX(517, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(518, self, varargin{:});
+    end
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(519, self, varargin{:});
+    end
+    function varargout = uminus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(520, self, varargin{:});
+    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(623, self);
+        iDynTreeMEX(521, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
-    function varargout = Zero(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(622, varargin{:});
-    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Sensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl3.m`

 * *Files 10% similar despite different names*

```diff
@@ -1,40 +1,41 @@
-classdef Sensor < iDynTreeSwigRef
+classdef MovableJointImpl3 < iDynTree.IJoint
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1120, self);
+        iDynTreeMEX(876, self);
         self.SwigClear();
       end
     end
-    function varargout = getName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1121, self, varargin{:});
+    function varargout = getNrOfPosCoords(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(877, self, varargin{:});
+    end
+    function varargout = getNrOfDOFs(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(878, self, varargin{:});
     end
-    function varargout = getSensorType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1122, self, varargin{:});
+    function varargout = setIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(879, self, varargin{:});
     end
-    function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1123, self, varargin{:});
+    function varargout = getIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(880, self, varargin{:});
     end
-    function varargout = setName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1124, self, varargin{:});
+    function varargout = setPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(881, self, varargin{:});
     end
-    function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1125, self, varargin{:});
+    function varargout = getPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(882, self, varargin{:});
     end
-    function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1126, self, varargin{:});
+    function varargout = setDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(883, self, varargin{:});
     end
-    function varargout = updateIndices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1127, self, varargin{:});
+    function varargout = getDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(884, self, varargin{:});
     end
-    function self = Sensor(varargin)
+    function self = MovableJointImpl3(varargin)
+      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
         error('No matching constructor');
       end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SensorsList.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SensorsList.m`

 * *Files 4% similar despite different names*

```diff
@@ -5,67 +5,67 @@
     end
     function self = SensorsList(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1142, varargin{:});
+        tmp = iDynTreeMEX(1321, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1143, self);
+        iDynTreeMEX(1322, self);
         self.SwigClear();
       end
     end
     function varargout = addSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1144, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1323, self, varargin{:});
     end
     function varargout = setSerialization(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1145, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1324, self, varargin{:});
     end
     function varargout = getSerialization(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1146, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1325, self, varargin{:});
     end
     function varargout = getNrOfSensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1147, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1326, self, varargin{:});
     end
     function varargout = getSensorIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1148, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1327, self, varargin{:});
     end
     function varargout = getSizeOfAllSensorsMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1149, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1328, self, varargin{:});
     end
     function varargout = getSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1150, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1329, self, varargin{:});
     end
     function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1151, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1330, self, varargin{:});
     end
     function varargout = removeSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1152, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1331, self, varargin{:});
     end
     function varargout = removeAllSensorsOfType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1153, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1332, self, varargin{:});
     end
     function varargout = getSixAxisForceTorqueSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1154, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1333, self, varargin{:});
     end
     function varargout = getAccelerometerSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1155, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1334, self, varargin{:});
     end
     function varargout = getGyroscopeSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1156, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1335, self, varargin{:});
     end
     function varargout = getThreeAxisAngularAccelerometerSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1157, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1336, self, varargin{:});
     end
     function varargout = getThreeAxisForceTorqueContactSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1158, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1337, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SensorsMeasurements.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/PositionRaw.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,47 +1,45 @@
-classdef SensorsMeasurements < iDynTreeSwigRef
+classdef PositionRaw < iDynTree.Vector3
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = SensorsMeasurements(varargin)
+    function self = PositionRaw(varargin)
+      self@iDynTree.Vector3(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1159, varargin{:});
+        tmp = iDynTreeMEX(404, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(1160, self);
-        self.SwigClear();
-      end
-    end
-    function varargout = setNrOfSensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1161, self, varargin{:});
-    end
-    function varargout = getNrOfSensors(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1162, self, varargin{:});
+    function varargout = changePoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(405, self, varargin{:});
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1163, self, varargin{:});
+    function varargout = changeRefPoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(406, self, varargin{:});
     end
-    function varargout = toVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1164, self, varargin{:});
+    function varargout = changePointOf(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(409, self, varargin{:});
     end
-    function varargout = setMeasurement(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1165, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(410, self, varargin{:});
     end
-    function varargout = getMeasurement(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1166, self, varargin{:});
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(411, self, varargin{:});
     end
-    function varargout = getSizeOfAllSensorsMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1167, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(412, self);
+        self.SwigClear();
+      end
     end
   end
   methods(Static)
+    function varargout = compose(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(407, varargin{:});
+    end
+    function varargout = inverse(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(408, varargin{:});
+    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SimpleLeggedOdometry.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SimpleLeggedOdometry.m`

 * *Files 3% similar despite different names*

```diff
@@ -5,46 +5,46 @@
     end
     function self = SimpleLeggedOdometry(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1630, varargin{:});
+        tmp = iDynTreeMEX(1547, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1631, self);
+        iDynTreeMEX(1548, self);
         self.SwigClear();
       end
     end
     function varargout = setModel(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1632, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1549, self, varargin{:});
     end
     function varargout = model(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1633, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1550, self, varargin{:});
     end
     function varargout = updateKinematics(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1634, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1551, self, varargin{:});
     end
     function varargout = init(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1635, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1552, self, varargin{:});
     end
     function varargout = changeFixedFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1636, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1553, self, varargin{:});
     end
     function varargout = getCurrentFixedLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1637, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1554, self, varargin{:});
     end
     function varargout = getWorldLinkTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1638, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1555, self, varargin{:});
     end
     function varargout = getWorldFrameTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1639, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1556, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SixAxisForceTorqueSensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinksSolidShapesVector.m`

 * *Files 20% similar despite different names*

```diff
@@ -1,105 +1,95 @@
-classdef SixAxisForceTorqueSensor < iDynTree.JointSensor
+classdef LinksSolidShapesVector < iDynTreeSwigRef
   methods
-    function self = SixAxisForceTorqueSensor(varargin)
-      self@iDynTree.JointSensor(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(1311, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
-    end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(1312, self);
-        self.SwigClear();
-      end
-    end
-    function varargout = setName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1313, self, varargin{:});
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
     end
-    function varargout = setFirstLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1314, self, varargin{:});
+    function varargout = pop(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1205, self, varargin{:});
     end
-    function varargout = setSecondLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1315, self, varargin{:});
+    function varargout = brace(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1206, self, varargin{:});
     end
-    function varargout = getFirstLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1316, self, varargin{:});
+    function varargout = setbrace(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1207, self, varargin{:});
     end
-    function varargout = getSecondLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1317, self, varargin{:});
+    function varargout = append(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1208, self, varargin{:});
     end
-    function varargout = setFirstLinkName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1318, self, varargin{:});
+    function varargout = empty(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1209, self, varargin{:});
     end
-    function varargout = setSecondLinkName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1319, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1210, self, varargin{:});
     end
-    function varargout = getFirstLinkName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1320, self, varargin{:});
+    function varargout = swap(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1211, self, varargin{:});
     end
-    function varargout = getSecondLinkName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1321, self, varargin{:});
+    function varargout = begin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1212, self, varargin{:});
     end
-    function varargout = setParentJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1322, self, varargin{:});
+    function varargout = end(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1213, self, varargin{:});
     end
-    function varargout = setParentJointIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1323, self, varargin{:});
+    function varargout = rbegin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1214, self, varargin{:});
     end
-    function varargout = setAppliedWrenchLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1324, self, varargin{:});
+    function varargout = rend(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1215, self, varargin{:});
     end
-    function varargout = getName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1325, self, varargin{:});
+    function varargout = clear(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1216, self, varargin{:});
     end
-    function varargout = getSensorType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1326, self, varargin{:});
+    function varargout = get_allocator(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1217, self, varargin{:});
     end
-    function varargout = getParentJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1327, self, varargin{:});
+    function varargout = pop_back(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1218, self, varargin{:});
     end
-    function varargout = getParentJointIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1328, self, varargin{:});
+    function varargout = erase(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1219, self, varargin{:});
     end
-    function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1329, self, varargin{:});
-    end
-    function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1330, self, varargin{:});
+    function self = LinksSolidShapesVector(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(1220, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
     end
-    function varargout = updateIndices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1331, self, varargin{:});
+    function varargout = push_back(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1221, self, varargin{:});
     end
-    function varargout = getAppliedWrenchLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1332, self, varargin{:});
+    function varargout = front(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1222, self, varargin{:});
     end
-    function varargout = isLinkAttachedToSensor(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1333, self, varargin{:});
+    function varargout = back(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1223, self, varargin{:});
     end
-    function varargout = getLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1334, self, varargin{:});
+    function varargout = assign(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1224, self, varargin{:});
     end
-    function varargout = getWrenchAppliedOnLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1335, self, varargin{:});
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1225, self, varargin{:});
     end
-    function varargout = getWrenchAppliedOnLinkMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1336, self, varargin{:});
+    function varargout = insert(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1226, self, varargin{:});
     end
-    function varargout = getWrenchAppliedOnLinkInverseMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1337, self, varargin{:});
+    function varargout = reserve(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1227, self, varargin{:});
     end
-    function varargout = predictMeasurement(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1338, self, varargin{:});
+    function varargout = capacity(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1228, self, varargin{:});
     end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1339, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1229, self);
+        self.SwigClear();
+      end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SolidShape.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SparseMatrixRowMajor.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,75 +1,74 @@
-classdef SolidShape < iDynTreeSwigRef
+classdef SparseMatrixRowMajor < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
+    function self = SparseMatrixRowMajor(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(151, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
+    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1061, self);
+        iDynTreeMEX(152, self);
         self.SwigClear();
       end
     end
-    function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1062, self, varargin{:});
-    end
-    function varargout = getName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1063, self, varargin{:});
-    end
-    function varargout = setName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1064, self, varargin{:});
+    function varargout = numberOfNonZeros(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(153, self, varargin{:});
     end
-    function varargout = isNameValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1065, self, varargin{:});
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(154, self, varargin{:});
     end
-    function varargout = getLink_H_geometry(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1066, self, varargin{:});
+    function varargout = reserve(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(155, self, varargin{:});
     end
-    function varargout = setLink_H_geometry(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1067, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(156, self, varargin{:});
     end
-    function varargout = isMaterialSet(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1068, self, varargin{:});
+    function varargout = setFromConstTriplets(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(157, self, varargin{:});
     end
-    function varargout = getMaterial(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1069, self, varargin{:});
+    function varargout = setFromTriplets(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(158, self, varargin{:});
     end
-    function varargout = setMaterial(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1070, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(160, self, varargin{:});
     end
-    function varargout = isSphere(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1071, self, varargin{:});
+    function varargout = getValue(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(161, self, varargin{:});
     end
-    function varargout = isBox(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1072, self, varargin{:});
+    function varargout = setValue(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(162, self, varargin{:});
     end
-    function varargout = isCylinder(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1073, self, varargin{:});
+    function varargout = rows(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(163, self, varargin{:});
     end
-    function varargout = isExternalMesh(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1074, self, varargin{:});
+    function varargout = columns(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(164, self, varargin{:});
     end
-    function varargout = asSphere(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1075, self, varargin{:});
+    function varargout = description(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(165, self, varargin{:});
     end
-    function varargout = asBox(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1076, self, varargin{:});
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(166, self, varargin{:});
     end
-    function varargout = asCylinder(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1077, self, varargin{:});
+    function varargout = toMatlabDense(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(167, self, varargin{:});
     end
-    function varargout = asExternalMesh(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1078, self, varargin{:});
-    end
-    function self = SolidShape(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        error('No matching constructor');
-      end
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(168, self, varargin{:});
     end
   end
   methods(Static)
+    function varargout = sparseMatrixFromTriplets(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(159, varargin{:});
+    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SolidShapesVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialForceVectorBase.m`

 * *Files 5% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-classdef SolidShapesVector < iDynTreeSwigRef
+classdef SpatialForceVectorBase < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1405, self, varargin{:});
-    end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1406, self, varargin{:});
-    end
-    function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1407, self, varargin{:});
-    end
-    function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1408, self, varargin{:});
+    function self = SpatialForceVectorBase(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(464, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
     end
-    function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1409, self, varargin{:});
+    function varargout = getLinearVec3(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(465, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1410, self, varargin{:});
+    function varargout = getAngularVec3(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(466, self, varargin{:});
     end
-    function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1411, self, varargin{:});
+    function varargout = setLinearVec3(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(467, self, varargin{:});
     end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1412, self, varargin{:});
+    function varargout = setAngularVec3(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(468, self, varargin{:});
     end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1413, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(469, self, varargin{:});
     end
-    function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1414, self, varargin{:});
+    function varargout = getVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(470, self, varargin{:});
     end
-    function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1415, self, varargin{:});
+    function varargout = setVal(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(471, self, varargin{:});
     end
-    function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1416, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(472, self, varargin{:});
     end
-    function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1417, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(473, self, varargin{:});
     end
-    function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1418, self, varargin{:});
+    function varargout = changePoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(474, self, varargin{:});
     end
-    function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1419, self, varargin{:});
+    function varargout = changeCoordFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(475, self, varargin{:});
     end
-    function self = SolidShapesVector(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(1420, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
+    function varargout = dot(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(478, self, varargin{:});
     end
-    function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1421, self, varargin{:});
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(479, self, varargin{:});
     end
-    function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1422, self, varargin{:});
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(480, self, varargin{:});
     end
-    function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1423, self, varargin{:});
+    function varargout = uminus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(481, self, varargin{:});
     end
-    function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1424, self, varargin{:});
+    function varargout = asVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(483, self, varargin{:});
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1425, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(484, self, varargin{:});
     end
-    function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1426, self, varargin{:});
+    function varargout = display(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(485, self, varargin{:});
     end
-    function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1427, self, varargin{:});
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(486, self, varargin{:});
     end
-    function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1428, self, varargin{:});
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(487, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1429, self);
+        iDynTreeMEX(488, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
+    function varargout = compose(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(476, varargin{:});
+    end
+    function varargout = inverse(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(477, varargin{:});
+    end
+    function varargout = Zero(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(482, varargin{:});
+    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SparseMatrixColMajor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/TransformDerivative.m`

 * *Files 9% similar despite different names*

```diff
@@ -1,74 +1,59 @@
-classdef SparseMatrixColMajor < iDynTreeSwigRef
+classdef TransformDerivative < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = SparseMatrixColMajor(varargin)
+    function self = TransformDerivative(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(244, varargin{:});
+        tmp = iDynTreeMEX(684, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(245, self);
+        iDynTreeMEX(685, self);
         self.SwigClear();
       end
     end
-    function varargout = numberOfNonZeros(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(246, self, varargin{:});
+    function varargout = getRotationDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(686, self, varargin{:});
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(247, self, varargin{:});
+    function varargout = getPositionDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(687, self, varargin{:});
     end
-    function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(248, self, varargin{:});
+    function varargout = setRotationDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(688, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(249, self, varargin{:});
+    function varargout = setPositionDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(689, self, varargin{:});
     end
-    function varargout = setFromConstTriplets(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(250, self, varargin{:});
+    function varargout = asHomogeneousTransformDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(691, self, varargin{:});
     end
-    function varargout = setFromTriplets(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(251, self, varargin{:});
+    function varargout = asAdjointTransformDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(692, self, varargin{:});
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(253, self, varargin{:});
+    function varargout = asAdjointTransformWrenchDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(693, self, varargin{:});
     end
-    function varargout = getValue(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(254, self, varargin{:});
+    function varargout = mtimes(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(694, self, varargin{:});
     end
-    function varargout = setValue(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(255, self, varargin{:});
+    function varargout = derivativeOfInverse(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(695, self, varargin{:});
     end
-    function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(256, self, varargin{:});
-    end
-    function varargout = columns(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(257, self, varargin{:});
-    end
-    function varargout = description(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(258, self, varargin{:});
-    end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(259, self, varargin{:});
-    end
-    function varargout = toMatlabDense(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(260, self, varargin{:});
-    end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(261, self, varargin{:});
+    function varargout = transform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(696, self, varargin{:});
     end
   end
   methods(Static)
-    function varargout = sparseMatrixFromTriplets(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(252, varargin{:});
+    function varargout = Zero(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(690, varargin{:});
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SparseMatrixRowMajor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ArticulatedBodyInertia.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,74 +1,65 @@
-classdef SparseMatrixRowMajor < iDynTreeSwigRef
+classdef ArticulatedBodyInertia < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = SparseMatrixRowMajor(varargin)
+    function self = ArticulatedBodyInertia(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(226, varargin{:});
+        tmp = iDynTreeMEX(585, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(227, self);
-        self.SwigClear();
-      end
-    end
-    function varargout = numberOfNonZeros(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(228, self, varargin{:});
-    end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(229, self, varargin{:});
-    end
-    function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(230, self, varargin{:});
-    end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(231, self, varargin{:});
+    function varargout = getLinearLinearSubmatrix(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(586, self, varargin{:});
     end
-    function varargout = setFromConstTriplets(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(232, self, varargin{:});
+    function varargout = getLinearAngularSubmatrix(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(587, self, varargin{:});
     end
-    function varargout = setFromTriplets(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(233, self, varargin{:});
+    function varargout = getAngularAngularSubmatrix(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(588, self, varargin{:});
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(235, self, varargin{:});
+    function varargout = applyInverse(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(590, self, varargin{:});
     end
-    function varargout = getValue(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(236, self, varargin{:});
+    function varargout = asMatrix(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(591, self, varargin{:});
     end
-    function varargout = setValue(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(237, self, varargin{:});
+    function varargout = getInverse(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(592, self, varargin{:});
     end
-    function varargout = rows(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(238, self, varargin{:});
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(593, self, varargin{:});
     end
-    function varargout = columns(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(239, self, varargin{:});
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(594, self, varargin{:});
     end
-    function varargout = description(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(240, self, varargin{:});
+    function varargout = mtimes(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(595, self, varargin{:});
     end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(241, self, varargin{:});
-    end
-    function varargout = toMatlabDense(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(242, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(596, self, varargin{:});
     end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(243, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(599, self);
+        self.SwigClear();
+      end
     end
   end
   methods(Static)
-    function varargout = sparseMatrixFromTriplets(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(234, varargin{:});
+    function varargout = combine(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(589, varargin{:});
+    end
+    function varargout = ABADyadHelper(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(597, varargin{:});
+    end
+    function varargout = ABADyadHelperLin(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(598, varargin{:});
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialAcc.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialMotionVector.m`

 * *Files 10% similar despite different names*

```diff
@@ -1,33 +1,39 @@
-classdef SpatialAcc < iDynTree.SpatialMotionVector
+classdef SpatialMotionVector < iDynTree.SpatialMotionVectorBase
   methods
-    function self = SpatialAcc(varargin)
-      self@iDynTree.SpatialMotionVector(iDynTreeSwigRef.Null);
+    function self = SpatialMotionVector(varargin)
+      self@iDynTree.SpatialMotionVectorBase(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(583, varargin{:});
+        tmp = iDynTreeMEX(491, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(584, self, varargin{:});
+    function varargout = mtimes(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(492, self, varargin{:});
     end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(585, self, varargin{:});
+    function varargout = cross(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(493, self, varargin{:});
     end
-    function varargout = uminus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(586, self, varargin{:});
+    function varargout = asCrossProductMatrix(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(494, self, varargin{:});
+    end
+    function varargout = asCrossProductMatrixWrench(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(495, self, varargin{:});
+    end
+    function varargout = exp(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(496, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(587, self);
+        iDynTreeMEX(497, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialForceVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialForceVector.m`

 * *Files 2% similar despite different names*

```diff
@@ -3,25 +3,25 @@
     function self = SpatialForceVector(varargin)
       self@iDynTree.SpatialForceVectorBase(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(564, varargin{:});
+        tmp = iDynTreeMEX(498, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(565, self);
+        iDynTreeMEX(499, self);
         self.SwigClear();
       end
     end
     function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(566, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(500, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialForceVectorBase.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/VectorDynSize.m`

 * *Files 12% similar despite different names*

```diff
@@ -1,95 +1,86 @@
-classdef SpatialForceVectorBase < iDynTreeSwigRef
+classdef VectorDynSize < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = SpatialForceVectorBase(varargin)
+    function self = VectorDynSize(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(530, varargin{:});
+        tmp = iDynTreeMEX(187, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = getLinearVec3(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(531, self, varargin{:});
-    end
-    function varargout = getAngularVec3(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(532, self, varargin{:});
-    end
-    function varargout = setLinearVec3(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(533, self, varargin{:});
-    end
-    function varargout = setAngularVec3(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(534, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(188, self);
+        self.SwigClear();
+      end
     end
     function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(535, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(189, self, varargin{:});
+    end
+    function varargout = brace(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(190, self, varargin{:});
     end
     function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(536, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(191, self, varargin{:});
     end
     function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(537, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(192, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(538, self, varargin{:});
+    function varargout = cbegin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(193, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(539, self, varargin{:});
+    function varargout = cend(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(194, self, varargin{:});
     end
-    function varargout = changePoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(540, self, varargin{:});
+    function varargout = begin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(195, self, varargin{:});
     end
-    function varargout = changeCoordFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(541, self, varargin{:});
+    function varargout = end(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(196, self, varargin{:});
     end
-    function varargout = dot(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(544, self, varargin{:});
+    function varargout = size(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(197, self, varargin{:});
     end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(545, self, varargin{:});
+    function varargout = data(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(198, self, varargin{:});
     end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(546, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(199, self, varargin{:});
     end
-    function varargout = uminus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(547, self, varargin{:});
+    function varargout = reserve(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(200, self, varargin{:});
     end
-    function varargout = asVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(549, self, varargin{:});
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(201, self, varargin{:});
+    end
+    function varargout = shrink_to_fit(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(202, self, varargin{:});
+    end
+    function varargout = capacity(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(203, self, varargin{:});
+    end
+    function varargout = fillBuffer(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(204, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(550, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(205, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(551, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(206, self, varargin{:});
     end
     function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(552, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(207, self, varargin{:});
     end
     function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(553, self, varargin{:});
-    end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(554, self);
-        self.SwigClear();
-      end
+      [varargout{1:nargout}] = iDynTreeMEX(208, self, varargin{:});
     end
   end
   methods(Static)
-    function varargout = compose(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(542, varargin{:});
-    end
-    function varargout = inverse(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(543, varargin{:});
-    end
-    function varargout = Zero(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(548, varargin{:});
-    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialInertia.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Visualizer.m`

 * *Files 8% similar despite different names*

```diff
@@ -1,92 +1,92 @@
-classdef SpatialInertia < iDynTreeSwigRef
+classdef Visualizer < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = SpatialInertia(varargin)
+    function self = Visualizer(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(624, varargin{:});
+        tmp = iDynTreeMEX(1982, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = fromRotationalInertiaWrtCenterOfMass(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(626, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1983, self);
+        self.SwigClear();
+      end
     end
-    function varargout = getMass(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(627, self, varargin{:});
+    function varargout = init(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1984, self, varargin{:});
     end
-    function varargout = getCenterOfMass(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(628, self, varargin{:});
+    function varargout = getNrOfVisualizedModels(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1985, self, varargin{:});
     end
-    function varargout = getRotationalInertiaWrtFrameOrigin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(629, self, varargin{:});
+    function varargout = getModelInstanceName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1986, self, varargin{:});
     end
-    function varargout = getRotationalInertiaWrtCenterOfMass(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(630, self, varargin{:});
+    function varargout = getModelInstanceIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1987, self, varargin{:});
     end
-    function varargout = multiply(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(631, self, varargin{:});
+    function varargout = addModel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1988, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(632, self, varargin{:});
+    function varargout = modelViz(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1989, self, varargin{:});
     end
-    function varargout = asMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(633, self, varargin{:});
+    function varargout = camera(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1990, self, varargin{:});
     end
-    function varargout = applyInverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(634, self, varargin{:});
+    function varargout = enviroment(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1991, self, varargin{:});
     end
-    function varargout = getInverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(635, self, varargin{:});
+    function varargout = environment(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1992, self, varargin{:});
     end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(636, self, varargin{:});
+    function varargout = vectors(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1993, self, varargin{:});
     end
-    function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(637, self, varargin{:});
+    function varargout = frames(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1994, self, varargin{:});
     end
-    function varargout = biasWrench(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(638, self, varargin{:});
+    function varargout = textures(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1995, self, varargin{:});
     end
-    function varargout = biasWrenchDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(639, self, varargin{:});
+    function varargout = getLabel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1996, self, varargin{:});
     end
-    function varargout = asVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(641, self, varargin{:});
+    function varargout = width(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1997, self, varargin{:});
     end
-    function varargout = fromVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(642, self, varargin{:});
+    function varargout = height(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1998, self, varargin{:});
     end
-    function varargout = isPhysicallyConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(643, self, varargin{:});
+    function varargout = run(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1999, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(647, self);
-        self.SwigClear();
-      end
+    function varargout = draw(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2000, self, varargin{:});
     end
-  end
-  methods(Static)
-    function varargout = combine(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(625, varargin{:});
+    function varargout = subDraw(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2001, self, varargin{:});
     end
-    function varargout = Zero(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(640, varargin{:});
+    function varargout = drawToFile(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2002, self, varargin{:});
     end
-    function varargout = momentumRegressor(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(644, varargin{:});
+    function varargout = close(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2003, self, varargin{:});
     end
-    function varargout = momentumDerivativeRegressor(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(645, varargin{:});
+    function varargout = isWindowActive(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2004, self, varargin{:});
     end
-    function varargout = momentumDerivativeSlotineLiRegressor(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(646, varargin{:});
+    function varargout = setColorPalette(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(2005, self, varargin{:});
     end
   end
+  methods(Static)
+  end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialMomentum.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialMomentum.m`

 * *Files 6% similar despite different names*

```diff
@@ -3,31 +3,31 @@
     function self = SpatialMomentum(varargin)
       self@iDynTree.SpatialForceVector(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(578, varargin{:});
+        tmp = iDynTreeMEX(512, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(579, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(513, self, varargin{:});
     end
     function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(580, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(514, self, varargin{:});
     end
     function varargout = uminus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(581, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(515, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(582, self);
+        iDynTreeMEX(516, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialMotionVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Sphere.m`

 * *Files 9% similar despite different names*

```diff
@@ -1,39 +1,33 @@
-classdef SpatialMotionVector < iDynTree.SpatialMotionVectorBase
+classdef Sphere < iDynTree.SolidShape
   methods
-    function self = SpatialMotionVector(varargin)
-      self@iDynTree.SpatialMotionVectorBase(iDynTreeSwigRef.Null);
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1006, self);
+        self.SwigClear();
+      end
+    end
+    function varargout = clone(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1007, self, varargin{:});
+    end
+    function varargout = getRadius(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1008, self, varargin{:});
+    end
+    function varargout = setRadius(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1009, self, varargin{:});
+    end
+    function self = Sphere(varargin)
+      self@iDynTree.SolidShape(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(557, varargin{:});
+        tmp = iDynTreeMEX(1010, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(558, self, varargin{:});
-    end
-    function varargout = cross(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(559, self, varargin{:});
-    end
-    function varargout = asCrossProductMatrix(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(560, self, varargin{:});
-    end
-    function varargout = asCrossProductMatrixWrench(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(561, self, varargin{:});
-    end
-    function varargout = exp(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(562, self, varargin{:});
-    end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(563, self);
-        self.SwigClear();
-      end
-    end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SpatialMotionVectorBase.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Transform.m`

 * *Files 12% similar despite different names*

```diff
@@ -1,95 +1,74 @@
-classdef SpatialMotionVectorBase < iDynTreeSwigRef
+classdef Transform < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = SpatialMotionVectorBase(varargin)
+    function self = Transform(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(505, varargin{:});
+        tmp = iDynTreeMEX(666, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = getLinearVec3(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(506, self, varargin{:});
+    function varargout = fromHomogeneousTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(667, self, varargin{:});
     end
-    function varargout = getAngularVec3(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(507, self, varargin{:});
+    function varargout = getRotation(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(668, self, varargin{:});
     end
-    function varargout = setLinearVec3(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(508, self, varargin{:});
+    function varargout = getPosition(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(669, self, varargin{:});
     end
-    function varargout = setAngularVec3(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(509, self, varargin{:});
+    function varargout = setRotation(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(670, self, varargin{:});
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(510, self, varargin{:});
+    function varargout = setPosition(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(671, self, varargin{:});
     end
-    function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(511, self, varargin{:});
+    function varargout = inverse(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(674, self, varargin{:});
     end
-    function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(512, self, varargin{:});
+    function varargout = mtimes(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(675, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(513, self, varargin{:});
+    function varargout = asHomogeneousTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(677, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(514, self, varargin{:});
+    function varargout = asAdjointTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(678, self, varargin{:});
     end
-    function varargout = changePoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(515, self, varargin{:});
+    function varargout = asAdjointTransformWrench(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(679, self, varargin{:});
     end
-    function varargout = changeCoordFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(516, self, varargin{:});
-    end
-    function varargout = dot(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(519, self, varargin{:});
-    end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(520, self, varargin{:});
-    end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(521, self, varargin{:});
-    end
-    function varargout = uminus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(522, self, varargin{:});
-    end
-    function varargout = asVector(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(524, self, varargin{:});
+    function varargout = log(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(680, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(525, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(681, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(526, self, varargin{:});
-    end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(527, self, varargin{:});
-    end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(528, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(682, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(529, self);
+        iDynTreeMEX(683, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
     function varargout = compose(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(517, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(672, varargin{:});
     end
-    function varargout = inverse(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(518, varargin{:});
+    function varargout = inverse2(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(673, varargin{:});
     end
-    function varargout = Zero(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(523, varargin{:});
+    function varargout = Identity(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(676, varargin{:});
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Sphere.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MomentumFreeFloatingJacobian.m`

 * *Files 12% similar despite different names*

```diff
@@ -1,33 +1,30 @@
-classdef Sphere < iDynTree.SolidShape
+classdef MomentumFreeFloatingJacobian < iDynTree.MatrixDynSize
   methods
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(1079, self);
-        self.SwigClear();
-      end
-    end
-    function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1080, self, varargin{:});
-    end
-    function varargout = getRadius(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1081, self, varargin{:});
-    end
-    function varargout = setRadius(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1082, self, varargin{:});
-    end
-    function self = Sphere(varargin)
-      self@iDynTree.SolidShape(iDynTreeSwigRef.Null);
+    function self = MomentumFreeFloatingJacobian(varargin)
+      self@iDynTree.MatrixDynSize(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1083, varargin{:});
+        tmp = iDynTreeMEX(1110, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1111, self, varargin{:});
+    end
+    function varargout = isConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1112, self, varargin{:});
+    end
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1113, self);
+        self.SwigClear();
+      end
+    end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/StringVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SparseMatrixColMajor.m`

 * *Files 13% similar despite different names*

```diff
@@ -1,95 +1,74 @@
-classdef StringVector < iDynTreeSwigRef
+classdef SparseMatrixColMajor < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(21, self, varargin{:});
-    end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(22, self, varargin{:});
-    end
-    function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(23, self, varargin{:});
-    end
-    function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(24, self, varargin{:});
-    end
-    function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(25, self, varargin{:});
-    end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(26, self, varargin{:});
-    end
-    function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(27, self, varargin{:});
-    end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(28, self, varargin{:});
-    end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(29, self, varargin{:});
-    end
-    function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(30, self, varargin{:});
-    end
-    function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(31, self, varargin{:});
-    end
-    function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(32, self, varargin{:});
-    end
-    function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(33, self, varargin{:});
-    end
-    function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(34, self, varargin{:});
-    end
-    function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(35, self, varargin{:});
-    end
-    function self = StringVector(varargin)
+    function self = SparseMatrixColMajor(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(36, varargin{:});
+        tmp = iDynTreeMEX(169, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(37, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(170, self);
+        self.SwigClear();
+      end
     end
-    function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(38, self, varargin{:});
+    function varargout = numberOfNonZeros(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(171, self, varargin{:});
     end
-    function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(39, self, varargin{:});
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(172, self, varargin{:});
     end
-    function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(40, self, varargin{:});
+    function varargout = reserve(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(173, self, varargin{:});
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(41, self, varargin{:});
+    function varargout = zero(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(174, self, varargin{:});
     end
-    function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(42, self, varargin{:});
+    function varargout = setFromConstTriplets(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(175, self, varargin{:});
     end
-    function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(43, self, varargin{:});
+    function varargout = setFromTriplets(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(176, self, varargin{:});
     end
-    function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(44, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(178, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(45, self);
-        self.SwigClear();
-      end
+    function varargout = getValue(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(179, self, varargin{:});
+    end
+    function varargout = setValue(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(180, self, varargin{:});
+    end
+    function varargout = rows(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(181, self, varargin{:});
+    end
+    function varargout = columns(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(182, self, varargin{:});
+    end
+    function varargout = description(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(183, self, varargin{:});
+    end
+    function varargout = toMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(184, self, varargin{:});
+    end
+    function varargout = toMatlabDense(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(185, self, varargin{:});
+    end
+    function varargout = fromMatlab(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(186, self, varargin{:});
     end
   end
   methods(Static)
+    function varargout = sparseMatrixFromTriplets(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(177, varargin{:});
+    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/SubModelDecomposition.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ExtWrenchesAndJointTorquesEstimator.m`

 * *Files 9% similar despite different names*

```diff
@@ -1,47 +1,62 @@
-classdef SubModelDecomposition < iDynTreeSwigRef
+classdef ExtWrenchesAndJointTorquesEstimator < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = SubModelDecomposition(varargin)
+    function self = ExtWrenchesAndJointTorquesEstimator(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1300, varargin{:});
+        tmp = iDynTreeMEX(1533, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1301, self);
+        iDynTreeMEX(1534, self);
         self.SwigClear();
       end
     end
-    function varargout = splitModelAlongJoints(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1302, self, varargin{:});
+    function varargout = setModelAndSensors(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1535, self, varargin{:});
     end
-    function varargout = setNrOfSubModels(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1303, self, varargin{:});
+    function varargout = loadModelAndSensorsFromFile(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1536, self, varargin{:});
     end
-    function varargout = getNrOfSubModels(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1304, self, varargin{:});
+    function varargout = loadModelAndSensorsFromFileWithSpecifiedDOFs(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1537, self, varargin{:});
     end
-    function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1305, self, varargin{:});
+    function varargout = model(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1538, self, varargin{:});
     end
-    function varargout = getTraversal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1306, self, varargin{:});
+    function varargout = sensors(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1539, self, varargin{:});
     end
-    function varargout = getSubModelOfLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1307, self, varargin{:});
+    function varargout = submodels(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1540, self, varargin{:});
     end
-    function varargout = getSubModelOfFrame(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1308, self, varargin{:});
+    function varargout = updateKinematicsFromFloatingBase(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1541, self, varargin{:});
+    end
+    function varargout = updateKinematicsFromFixedBase(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1542, self, varargin{:});
+    end
+    function varargout = computeExpectedFTSensorsMeasurements(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1543, self, varargin{:});
+    end
+    function varargout = estimateExtWrenchesAndJointTorques(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1544, self, varargin{:});
+    end
+    function varargout = checkThatTheModelIsStill(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1545, self, varargin{:});
+    end
+    function varargout = estimateLinkNetWrenchesWithoutGravity(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1546, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ThreeAxisAngularAccelerometerSensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl2.m`

 * *Files 9% similar despite different names*

```diff
@@ -1,63 +1,46 @@
-classdef ThreeAxisAngularAccelerometerSensor < iDynTree.LinkSensor
+classdef MovableJointImpl2 < iDynTree.IJoint
   methods
-    function self = ThreeAxisAngularAccelerometerSensor(varargin)
-      self@iDynTree.LinkSensor(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(1370, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
-    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1371, self);
+        iDynTreeMEX(867, self);
         self.SwigClear();
       end
     end
-    function varargout = setName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1372, self, varargin{:});
-    end
-    function varargout = setLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1373, self, varargin{:});
-    end
-    function varargout = setParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1374, self, varargin{:});
+    function varargout = getNrOfPosCoords(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(868, self, varargin{:});
     end
-    function varargout = setParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1375, self, varargin{:});
+    function varargout = getNrOfDOFs(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(869, self, varargin{:});
     end
-    function varargout = getName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1376, self, varargin{:});
+    function varargout = setIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(870, self, varargin{:});
     end
-    function varargout = getSensorType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1377, self, varargin{:});
+    function varargout = getIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(871, self, varargin{:});
     end
-    function varargout = getParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1378, self, varargin{:});
+    function varargout = setPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(872, self, varargin{:});
     end
-    function varargout = getParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1379, self, varargin{:});
+    function varargout = getPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(873, self, varargin{:});
     end
-    function varargout = getLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1380, self, varargin{:});
+    function varargout = setDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(874, self, varargin{:});
     end
-    function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1381, self, varargin{:});
+    function varargout = getDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(875, self, varargin{:});
     end
-    function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1382, self, varargin{:});
-    end
-    function varargout = updateIndices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1383, self, varargin{:});
-    end
-    function varargout = predictMeasurement(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1384, self, varargin{:});
+    function self = MovableJointImpl2(varargin)
+      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
+      end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/ThreeAxisForceTorqueContactSensor.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ThreeAxisForceTorqueContactSensor.m`

 * *Files 4% similar despite different names*

```diff
@@ -3,70 +3,70 @@
     function self = ThreeAxisForceTorqueContactSensor(varargin)
       self@iDynTree.LinkSensor(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1385, varargin{:});
+        tmp = iDynTreeMEX(1421, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1386, self);
+        iDynTreeMEX(1422, self);
         self.SwigClear();
       end
     end
     function varargout = setName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1387, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1423, self, varargin{:});
     end
     function varargout = setLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1388, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1424, self, varargin{:});
     end
     function varargout = setParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1389, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1425, self, varargin{:});
     end
     function varargout = setParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1390, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1426, self, varargin{:});
     end
     function varargout = getName(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1391, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1427, self, varargin{:});
     end
     function varargout = getSensorType(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1392, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1428, self, varargin{:});
     end
     function varargout = getParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1393, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1429, self, varargin{:});
     end
     function varargout = getParentLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1394, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1430, self, varargin{:});
     end
     function varargout = getLinkSensorTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1395, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1431, self, varargin{:});
     end
     function varargout = isValid(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1396, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1432, self, varargin{:});
     end
     function varargout = clone(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1397, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1433, self, varargin{:});
     end
     function varargout = updateIndices(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1398, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1434, self, varargin{:});
     end
     function varargout = setLoadCellLocations(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1399, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1435, self, varargin{:});
     end
     function varargout = getLoadCellLocations(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1400, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1436, self, varargin{:});
     end
     function varargout = computeThreeAxisForceTorqueFromLoadCellMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1401, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1437, self, varargin{:});
     end
     function varargout = computeCenterOfPressureFromLoadCellMeasurements(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1402, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(1438, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Transform.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RotationRaw.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,74 +1,60 @@
-classdef Transform < iDynTreeSwigRef
+classdef RotationRaw < iDynTree.Matrix3x3
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = Transform(varargin)
+    function self = RotationRaw(varargin)
+      self@iDynTree.Matrix3x3(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(715, varargin{:});
+        tmp = iDynTreeMEX(618, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = fromHomogeneousTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(716, self, varargin{:});
-    end
-    function varargout = getRotation(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(717, self, varargin{:});
-    end
-    function varargout = getPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(718, self, varargin{:});
-    end
-    function varargout = setRotation(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(719, self, varargin{:});
-    end
-    function varargout = setPosition(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(720, self, varargin{:});
-    end
-    function varargout = inverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(723, self, varargin{:});
-    end
-    function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(724, self, varargin{:});
+    function varargout = changeOrientFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(619, self, varargin{:});
     end
-    function varargout = asHomogeneousTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(726, self, varargin{:});
+    function varargout = changeRefOrientFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(620, self, varargin{:});
     end
-    function varargout = asAdjointTransform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(727, self, varargin{:});
-    end
-    function varargout = asAdjointTransformWrench(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(728, self, varargin{:});
-    end
-    function varargout = log(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(729, self, varargin{:});
+    function varargout = changeCoordFrameOf(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(623, self, varargin{:});
     end
     function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(730, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(629, self, varargin{:});
     end
     function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(731, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(630, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(732, self);
+        iDynTreeMEX(631, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
     function varargout = compose(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(721, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(621, varargin{:});
     end
     function varargout = inverse2(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(722, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(622, varargin{:});
+    end
+    function varargout = RotX(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(624, varargin{:});
+    end
+    function varargout = RotY(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(625, varargin{:});
+    end
+    function varargout = RotZ(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(626, varargin{:});
+    end
+    function varargout = RPY(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(627, varargin{:});
     end
     function varargout = Identity(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(725, varargin{:});
+     [varargout{1:nargout}] = iDynTreeMEX(628, varargin{:});
     end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/TransformDerivative.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SolidShape.m`

 * *Files 7% similar despite different names*

```diff
@@ -1,59 +1,75 @@
-classdef TransformDerivative < iDynTreeSwigRef
+classdef SolidShape < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = TransformDerivative(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(733, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
-    end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(734, self);
+        iDynTreeMEX(988, self);
         self.SwigClear();
       end
     end
-    function varargout = getRotationDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(735, self, varargin{:});
+    function varargout = clone(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(989, self, varargin{:});
+    end
+    function varargout = getName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(990, self, varargin{:});
+    end
+    function varargout = setName(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(991, self, varargin{:});
+    end
+    function varargout = isNameValid(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(992, self, varargin{:});
+    end
+    function varargout = getLink_H_geometry(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(993, self, varargin{:});
     end
-    function varargout = getPositionDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(736, self, varargin{:});
+    function varargout = setLink_H_geometry(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(994, self, varargin{:});
     end
-    function varargout = setRotationDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(737, self, varargin{:});
+    function varargout = isMaterialSet(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(995, self, varargin{:});
     end
-    function varargout = setPositionDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(738, self, varargin{:});
+    function varargout = getMaterial(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(996, self, varargin{:});
     end
-    function varargout = asHomogeneousTransformDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(740, self, varargin{:});
+    function varargout = setMaterial(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(997, self, varargin{:});
     end
-    function varargout = asAdjointTransformDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(741, self, varargin{:});
+    function varargout = isSphere(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(998, self, varargin{:});
     end
-    function varargout = asAdjointTransformWrenchDerivative(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(742, self, varargin{:});
+    function varargout = isBox(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(999, self, varargin{:});
     end
-    function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(743, self, varargin{:});
+    function varargout = isCylinder(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1000, self, varargin{:});
     end
-    function varargout = derivativeOfInverse(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(744, self, varargin{:});
+    function varargout = isExternalMesh(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1001, self, varargin{:});
     end
-    function varargout = transform(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(745, self, varargin{:});
+    function varargout = asSphere(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1002, self, varargin{:});
+    end
+    function varargout = asBox(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1003, self, varargin{:});
+    end
+    function varargout = asCylinder(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1004, self, varargin{:});
+    end
+    function varargout = asExternalMesh(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1005, self, varargin{:});
+    end
+    function self = SolidShape(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
+      end
     end
   end
   methods(Static)
-    function varargout = Zero(varargin)
-     [varargout{1:nargout}] = iDynTreeMEX(739, varargin{:});
-    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Traversal.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelLoader.m`

 * *Files 19% similar despite different names*

```diff
@@ -1,71 +1,56 @@
-classdef Traversal < iDynTreeSwigRef
+classdef ModelLoader < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = Traversal(varargin)
+    function self = ModelLoader(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1035, varargin{:});
+        tmp = iDynTreeMEX(1449, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1036, self);
+        iDynTreeMEX(1450, self);
         self.SwigClear();
       end
     end
-    function varargout = getNrOfVisitedLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1037, self, varargin{:});
+    function varargout = parsingOptions(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1451, self, varargin{:});
     end
-    function varargout = getLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1038, self, varargin{:});
+    function varargout = setParsingOptions(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1452, self, varargin{:});
     end
-    function varargout = getBaseLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1039, self, varargin{:});
+    function varargout = loadModelFromString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1453, self, varargin{:});
     end
-    function varargout = getParentLink(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1040, self, varargin{:});
+    function varargout = loadModelFromFile(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1454, self, varargin{:});
     end
-    function varargout = getParentJoint(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1041, self, varargin{:});
+    function varargout = loadReducedModelFromFullModel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1455, self, varargin{:});
     end
-    function varargout = getParentLinkFromLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1042, self, varargin{:});
+    function varargout = loadReducedModelFromString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1456, self, varargin{:});
     end
-    function varargout = getParentJointFromLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1043, self, varargin{:});
+    function varargout = loadReducedModelFromFile(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1457, self, varargin{:});
     end
-    function varargout = getTraversalIndexFromLinkIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1044, self, varargin{:});
+    function varargout = model(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1458, self, varargin{:});
     end
-    function varargout = reset(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1045, self, varargin{:});
+    function varargout = sensors(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1459, self, varargin{:});
     end
-    function varargout = addTraversalBase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1046, self, varargin{:});
-    end
-    function varargout = addTraversalElement(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1047, self, varargin{:});
-    end
-    function varargout = isParentOf(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1048, self, varargin{:});
-    end
-    function varargout = getChildLinkIndexFromJointIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1049, self, varargin{:});
-    end
-    function varargout = getParentLinkIndexFromJointIndex(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1050, self, varargin{:});
-    end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1051, self, varargin{:});
+    function varargout = isValid(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1460, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Twist.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/LinkAccArray.m`

 * *Files 9% similar despite different names*

```diff
@@ -1,36 +1,41 @@
-classdef Twist < iDynTree.SpatialMotionVector
+classdef LinkAccArray < iDynTreeSwigRef
   methods
-    function self = Twist(varargin)
-      self@iDynTree.SpatialMotionVector(iDynTreeSwigRef.Null);
+    function this = swig_this(self)
+      this = iDynTreeMEX(3, self);
+    end
+    function self = LinkAccArray(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(567, varargin{:});
+        tmp = iDynTreeMEX(777, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(568, self, varargin{:});
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(778, self, varargin{:});
+    end
+    function varargout = isConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(779, self, varargin{:});
     end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(569, self, varargin{:});
+    function varargout = paren(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(780, self, varargin{:});
     end
-    function varargout = uminus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(570, self, varargin{:});
+    function varargout = getNrOfLinks(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(781, self, varargin{:});
     end
-    function varargout = mtimes(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(571, self, varargin{:});
+    function varargout = toString(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(782, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(572, self);
+        iDynTreeMEX(783, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/UnknownWrenchContact.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/estimateExternalWrenchesBuffers.m`

 * *Files 21% similar despite different names*

```diff
@@ -1,76 +1,88 @@
-classdef UnknownWrenchContact < iDynTreeSwigRef
+classdef estimateExternalWrenchesBuffers < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = UnknownWrenchContact(varargin)
+    function self = estimateExternalWrenchesBuffers(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(1569, varargin{:});
+        tmp = iDynTreeMEX(1511, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = unknownType(self, varargin)
+    function varargout = resize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1512, self, varargin{:});
+    end
+    function varargout = getNrOfSubModels(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1513, self, varargin{:});
+    end
+    function varargout = getNrOfLinks(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1514, self, varargin{:});
+    end
+    function varargout = isConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1515, self, varargin{:});
+    end
+    function varargout = A(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1570, self);
+        varargout{1} = iDynTreeMEX(1516, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1571, self, varargin{1});
+        iDynTreeMEX(1517, self, varargin{1});
       end
     end
-    function varargout = contactPoint(self, varargin)
+    function varargout = x(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1572, self);
+        varargout{1} = iDynTreeMEX(1518, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1573, self, varargin{1});
+        iDynTreeMEX(1519, self, varargin{1});
       end
     end
-    function varargout = forceDirection(self, varargin)
+    function varargout = b(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1574, self);
+        varargout{1} = iDynTreeMEX(1520, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1575, self, varargin{1});
+        iDynTreeMEX(1521, self, varargin{1});
       end
     end
-    function varargout = knownWrench(self, varargin)
+    function varargout = b_contacts_subtree(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1576, self);
+        varargout{1} = iDynTreeMEX(1522, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1577, self, varargin{1});
+        iDynTreeMEX(1523, self, varargin{1});
       end
     end
-    function varargout = contactId(self, varargin)
+    function varargout = subModelBase_H_link(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1578, self);
+        varargout{1} = iDynTreeMEX(1524, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1579, self, varargin{1});
+        iDynTreeMEX(1525, self, varargin{1});
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1580, self);
+        iDynTreeMEX(1526, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector10.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/GeomVector3.m`

 * *Files 12% similar despite different names*

```diff
@@ -1,74 +1,51 @@
-classdef Vector10 < iDynTreeSwigRef
+classdef GeomVector3 < iDynTree.Vector3
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = Vector10(varargin)
+    function self = GeomVector3(varargin)
+      self@iDynTree.Vector3(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(443, varargin{:});
+        tmp = iDynTreeMEX(428, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(444, self, varargin{:});
-    end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(445, self, varargin{:});
-    end
-    function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(446, self, varargin{:});
-    end
-    function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(447, self, varargin{:});
-    end
-    function varargout = cbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(448, self, varargin{:});
-    end
-    function varargout = cend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(449, self, varargin{:});
-    end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(450, self, varargin{:});
-    end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(451, self, varargin{:});
+    function varargout = changeCoordFrame(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(429, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(452, self, varargin{:});
+    function varargout = compose(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(430, self, varargin{:});
     end
-    function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(453, self, varargin{:});
+    function varargout = inverse(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(431, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(454, self, varargin{:});
+    function varargout = dot(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(432, self, varargin{:});
     end
-    function varargout = fillBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(455, self, varargin{:});
+    function varargout = plus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(433, self, varargin{:});
     end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(456, self, varargin{:});
+    function varargout = minus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(434, self, varargin{:});
     end
-    function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(457, self, varargin{:});
+    function varargout = uminus(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(435, self, varargin{:});
     end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(458, self, varargin{:});
+    function varargout = exp(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(436, self, varargin{:});
     end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(459, self, varargin{:});
+    function varargout = cross(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(437, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(460, self);
+        iDynTreeMEX(438, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector16.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/MovableJointImpl1.m`

 * *Files 13% similar despite different names*

```diff
@@ -1,74 +1,46 @@
-classdef Vector16 < iDynTreeSwigRef
+classdef MovableJointImpl1 < iDynTree.IJoint
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = Vector16(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(461, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(858, self);
+        self.SwigClear();
       end
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(462, self, varargin{:});
-    end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(463, self, varargin{:});
-    end
-    function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(464, self, varargin{:});
-    end
-    function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(465, self, varargin{:});
-    end
-    function varargout = cbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(466, self, varargin{:});
+    function varargout = getNrOfPosCoords(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(859, self, varargin{:});
     end
-    function varargout = cend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(467, self, varargin{:});
+    function varargout = getNrOfDOFs(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(860, self, varargin{:});
     end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(468, self, varargin{:});
+    function varargout = setIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(861, self, varargin{:});
     end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(469, self, varargin{:});
+    function varargout = getIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(862, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(470, self, varargin{:});
+    function varargout = setPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(863, self, varargin{:});
     end
-    function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(471, self, varargin{:});
+    function varargout = getPosCoordsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(864, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(472, self, varargin{:});
+    function varargout = setDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(865, self, varargin{:});
     end
-    function varargout = fillBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(473, self, varargin{:});
+    function varargout = getDOFsOffset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(866, self, varargin{:});
     end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(474, self, varargin{:});
-    end
-    function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(475, self, varargin{:});
-    end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(476, self, varargin{:});
-    end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(477, self, varargin{:});
-    end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(478, self);
-        self.SwigClear();
+    function self = MovableJointImpl1(varargin)
+      self@iDynTree.IJoint(iDynTreeSwigRef.Null);
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector3.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DiscreteExtendedKalmanFilterHelper.m`

 * *Files 12% similar despite different names*

```diff
@@ -1,74 +1,81 @@
-classdef Vector3 < iDynTreeSwigRef
+classdef DiscreteExtendedKalmanFilterHelper < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = Vector3(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(389, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
+    function varargout = ekf_f(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1699, self, varargin{:});
+    end
+    function varargout = ekf_h(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1700, self, varargin{:});
+    end
+    function varargout = ekfComputeJacobianF(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1701, self, varargin{:});
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(390, self, varargin{:});
+    function varargout = ekfComputeJacobianH(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1702, self, varargin{:});
     end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(391, self, varargin{:});
+    function varargout = ekfPredict(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1703, self, varargin{:});
     end
-    function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(392, self, varargin{:});
+    function varargout = ekfUpdate(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1704, self, varargin{:});
     end
-    function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(393, self, varargin{:});
+    function varargout = ekfInit(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1705, self, varargin{:});
     end
-    function varargout = cbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(394, self, varargin{:});
+    function varargout = ekfReset(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1706, self, varargin{:});
     end
-    function varargout = cend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(395, self, varargin{:});
+    function varargout = ekfSetMeasurementVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1707, self, varargin{:});
     end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(396, self, varargin{:});
+    function varargout = ekfSetInputVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1708, self, varargin{:});
     end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(397, self, varargin{:});
+    function varargout = ekfSetInitialState(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1709, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(398, self, varargin{:});
+    function varargout = ekfSetStateCovariance(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1710, self, varargin{:});
     end
-    function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(399, self, varargin{:});
+    function varargout = ekfSetSystemNoiseCovariance(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1711, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(400, self, varargin{:});
+    function varargout = ekfSetMeasurementNoiseCovariance(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1712, self, varargin{:});
     end
-    function varargout = fillBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(401, self, varargin{:});
+    function varargout = ekfSetStateSize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1713, self, varargin{:});
     end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(402, self, varargin{:});
+    function varargout = ekfSetInputSize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1714, self, varargin{:});
     end
-    function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(403, self, varargin{:});
+    function varargout = ekfSetOutputSize(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1715, self, varargin{:});
     end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(404, self, varargin{:});
+    function varargout = ekfGetStates(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1716, self, varargin{:});
     end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(405, self, varargin{:});
+    function varargout = ekfGetStateCovariance(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1717, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(406, self);
+        iDynTreeMEX(1718, self);
         self.SwigClear();
       end
     end
+    function self = DiscreteExtendedKalmanFilterHelper(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
+      end
+    end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector4.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/SpatialInertiaRaw.m`

 * *Files 23% similar despite different names*

```diff
@@ -1,74 +1,50 @@
-classdef Vector4 < iDynTreeSwigRef
+classdef SpatialInertiaRaw < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = Vector4(varargin)
+    function self = SpatialInertiaRaw(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(407, varargin{:});
+        tmp = iDynTreeMEX(558, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(408, self, varargin{:});
+    function varargout = fromRotationalInertiaWrtCenterOfMass(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(559, self, varargin{:});
     end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(409, self, varargin{:});
+    function varargout = getMass(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(560, self, varargin{:});
     end
-    function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(410, self, varargin{:});
+    function varargout = getCenterOfMass(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(561, self, varargin{:});
     end
-    function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(411, self, varargin{:});
+    function varargout = getRotationalInertiaWrtFrameOrigin(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(562, self, varargin{:});
     end
-    function varargout = cbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(412, self, varargin{:});
+    function varargout = getRotationalInertiaWrtCenterOfMass(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(563, self, varargin{:});
     end
-    function varargout = cend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(413, self, varargin{:});
-    end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(414, self, varargin{:});
-    end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(415, self, varargin{:});
-    end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(416, self, varargin{:});
-    end
-    function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(417, self, varargin{:});
+    function varargout = multiply(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(565, self, varargin{:});
     end
     function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(418, self, varargin{:});
-    end
-    function varargout = fillBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(419, self, varargin{:});
-    end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(420, self, varargin{:});
-    end
-    function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(421, self, varargin{:});
-    end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(422, self, varargin{:});
-    end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(423, self, varargin{:});
+      [varargout{1:nargout}] = iDynTreeMEX(566, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(424, self);
+        iDynTreeMEX(567, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
+    function varargout = combine(varargin)
+     [varargout{1:nargout}] = iDynTreeMEX(564, varargin{:});
+    end
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Vector6.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/Link.m`

 * *Files 26% similar despite different names*

```diff
@@ -1,74 +1,41 @@
-classdef Vector6 < iDynTreeSwigRef
+classdef Link < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = Vector6(varargin)
+    function self = Link(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(425, varargin{:});
+        tmp = iDynTreeMEX(784, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(426, self, varargin{:});
+    function varargout = inertia(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(785, self, varargin{:});
     end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(427, self, varargin{:});
+    function varargout = setInertia(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(786, self, varargin{:});
     end
-    function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(428, self, varargin{:});
+    function varargout = getInertia(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(787, self, varargin{:});
     end
-    function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(429, self, varargin{:});
+    function varargout = setIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(788, self, varargin{:});
     end
-    function varargout = cbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(430, self, varargin{:});
-    end
-    function varargout = cend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(431, self, varargin{:});
-    end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(432, self, varargin{:});
-    end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(433, self, varargin{:});
-    end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(434, self, varargin{:});
-    end
-    function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(435, self, varargin{:});
-    end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(436, self, varargin{:});
-    end
-    function varargout = fillBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(437, self, varargin{:});
-    end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(438, self, varargin{:});
-    end
-    function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(439, self, varargin{:});
-    end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(440, self, varargin{:});
-    end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(441, self, varargin{:});
+    function varargout = getIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(789, self, varargin{:});
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(442, self);
+        iDynTreeMEX(790, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/VectorDynSize.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/PrismaticJoint.m`

 * *Files 24% similar despite different names*

```diff
@@ -1,86 +1,93 @@
-classdef VectorDynSize < iDynTreeSwigRef
+classdef PrismaticJoint < iDynTree.MovableJointImpl1
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
-    end
-    function self = VectorDynSize(varargin)
+    function self = PrismaticJoint(varargin)
+      self@iDynTree.MovableJointImpl1(iDynTreeSwigRef.Null);
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(262, varargin{:});
+        tmp = iDynTreeMEX(937, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(263, self);
+        iDynTreeMEX(938, self);
         self.SwigClear();
       end
     end
-    function varargout = paren(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(264, self, varargin{:});
+    function varargout = clone(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(939, self, varargin{:});
+    end
+    function varargout = setAttachedLinks(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(940, self, varargin{:});
+    end
+    function varargout = setRestTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(941, self, varargin{:});
+    end
+    function varargout = setAxis(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(942, self, varargin{:});
     end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(265, self, varargin{:});
+    function varargout = getFirstAttachedLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(943, self, varargin{:});
     end
-    function varargout = getVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(266, self, varargin{:});
+    function varargout = getSecondAttachedLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(944, self, varargin{:});
     end
-    function varargout = setVal(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(267, self, varargin{:});
+    function varargout = getAxis(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(945, self, varargin{:});
     end
-    function varargout = cbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(268, self, varargin{:});
+    function varargout = getRestTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(946, self, varargin{:});
     end
-    function varargout = cend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(269, self, varargin{:});
+    function varargout = getTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(947, self, varargin{:});
     end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(270, self, varargin{:});
+    function varargout = getTransformDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(948, self, varargin{:});
     end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(271, self, varargin{:});
+    function varargout = getMotionSubspaceVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(949, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(272, self, varargin{:});
+    function varargout = computeChildPosVelAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(950, self, varargin{:});
     end
-    function varargout = data(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(273, self, varargin{:});
+    function varargout = computeChildVel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(951, self, varargin{:});
     end
-    function varargout = zero(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(274, self, varargin{:});
+    function varargout = computeChildVelAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(952, self, varargin{:});
     end
-    function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(275, self, varargin{:});
+    function varargout = computeChildAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(953, self, varargin{:});
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(276, self, varargin{:});
+    function varargout = computeChildBiasAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(954, self, varargin{:});
     end
-    function varargout = shrink_to_fit(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(277, self, varargin{:});
+    function varargout = computeJointTorque(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(955, self, varargin{:});
     end
-    function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(278, self, varargin{:});
+    function varargout = hasPosLimits(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(956, self, varargin{:});
     end
-    function varargout = fillBuffer(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(279, self, varargin{:});
+    function varargout = enablePosLimits(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(957, self, varargin{:});
     end
-    function varargout = toString(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(280, self, varargin{:});
+    function varargout = getPosLimits(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(958, self, varargin{:});
     end
-    function varargout = display(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(281, self, varargin{:});
+    function varargout = getMinPosLimit(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(959, self, varargin{:});
     end
-    function varargout = toMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(282, self, varargin{:});
+    function varargout = getMaxPosLimit(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(960, self, varargin{:});
     end
-    function varargout = fromMatlab(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(283, self, varargin{:});
+    function varargout = setPosLimits(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(961, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/VectorDynSizeVector.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/RevoluteJoint.m`

 * *Files 25% similar despite different names*

```diff
@@ -1,95 +1,93 @@
-classdef VectorDynSizeVector < iDynTreeSwigRef
+classdef RevoluteJoint < iDynTree.MovableJointImpl1
   methods
-    function this = swig_this(self)
-      this = iDynTreeMEX(3, self);
+    function self = RevoluteJoint(varargin)
+      self@iDynTree.MovableJointImpl1(iDynTreeSwigRef.Null);
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        tmp = iDynTreeMEX(912, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
+      end
     end
-    function varargout = pop(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(96, self, varargin{:});
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(913, self);
+        self.SwigClear();
+      end
     end
-    function varargout = brace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(97, self, varargin{:});
+    function varargout = clone(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(914, self, varargin{:});
     end
-    function varargout = setbrace(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(98, self, varargin{:});
+    function varargout = setAttachedLinks(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(915, self, varargin{:});
     end
-    function varargout = append(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(99, self, varargin{:});
+    function varargout = setRestTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(916, self, varargin{:});
     end
-    function varargout = empty(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(100, self, varargin{:});
+    function varargout = setAxis(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(917, self, varargin{:});
     end
-    function varargout = size(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(101, self, varargin{:});
+    function varargout = getFirstAttachedLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(918, self, varargin{:});
     end
-    function varargout = swap(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(102, self, varargin{:});
+    function varargout = getSecondAttachedLink(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(919, self, varargin{:});
     end
-    function varargout = begin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(103, self, varargin{:});
+    function varargout = getAxis(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(920, self, varargin{:});
     end
-    function varargout = end(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(104, self, varargin{:});
+    function varargout = getRestTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(921, self, varargin{:});
     end
-    function varargout = rbegin(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(105, self, varargin{:});
+    function varargout = getTransform(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(922, self, varargin{:});
     end
-    function varargout = rend(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(106, self, varargin{:});
+    function varargout = getTransformDerivative(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(923, self, varargin{:});
     end
-    function varargout = clear(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(107, self, varargin{:});
+    function varargout = getMotionSubspaceVector(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(924, self, varargin{:});
     end
-    function varargout = get_allocator(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(108, self, varargin{:});
+    function varargout = computeChildPosVelAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(925, self, varargin{:});
     end
-    function varargout = pop_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(109, self, varargin{:});
+    function varargout = computeChildVel(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(926, self, varargin{:});
     end
-    function varargout = erase(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(110, self, varargin{:});
+    function varargout = computeChildVelAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(927, self, varargin{:});
     end
-    function self = VectorDynSizeVector(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(111, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
-    end
-    function varargout = push_back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(112, self, varargin{:});
+    function varargout = computeChildAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(928, self, varargin{:});
     end
-    function varargout = front(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(113, self, varargin{:});
+    function varargout = computeChildBiasAcc(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(929, self, varargin{:});
     end
-    function varargout = back(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(114, self, varargin{:});
+    function varargout = computeJointTorque(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(930, self, varargin{:});
     end
-    function varargout = assign(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(115, self, varargin{:});
+    function varargout = hasPosLimits(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(931, self, varargin{:});
     end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(116, self, varargin{:});
+    function varargout = enablePosLimits(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(932, self, varargin{:});
     end
-    function varargout = insert(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(117, self, varargin{:});
+    function varargout = getPosLimits(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(933, self, varargin{:});
     end
-    function varargout = reserve(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(118, self, varargin{:});
+    function varargout = getMinPosLimit(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(934, self, varargin{:});
     end
-    function varargout = capacity(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(119, self, varargin{:});
+    function varargout = getMaxPosLimit(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(935, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(120, self);
-        self.SwigClear();
-      end
+    function varargout = setPosLimits(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(936, self, varargin{:});
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/VisualizerOptions.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/DHLink.m`

 * *Files 20% similar despite different names*

```diff
@@ -1,66 +1,86 @@
-classdef VisualizerOptions < iDynTreeSwigRef
+classdef DHLink < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function varargout = verbose(self, varargin)
+    function varargout = A(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2052, self);
+        varargout{1} = iDynTreeMEX(1264, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2053, self, varargin{1});
+        iDynTreeMEX(1265, self, varargin{1});
       end
     end
-    function varargout = winWidth(self, varargin)
+    function varargout = D(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2054, self);
+        varargout{1} = iDynTreeMEX(1266, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2055, self, varargin{1});
+        iDynTreeMEX(1267, self, varargin{1});
       end
     end
-    function varargout = winHeight(self, varargin)
+    function varargout = Alpha(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2056, self);
+        varargout{1} = iDynTreeMEX(1268, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2057, self, varargin{1});
+        iDynTreeMEX(1269, self, varargin{1});
       end
     end
-    function varargout = rootFrameArrowsDimension(self, varargin)
+    function varargout = Offset(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(2058, self);
+        varargout{1} = iDynTreeMEX(1270, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(2059, self, varargin{1});
+        iDynTreeMEX(1271, self, varargin{1});
       end
     end
-    function self = VisualizerOptions(varargin)
+    function varargout = Min(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(1272, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(1273, self, varargin{1});
+      end
+    end
+    function varargout = Max(self, varargin)
+      narginchk(1, 2)
+      if nargin==1
+        nargoutchk(0, 1)
+        varargout{1} = iDynTreeMEX(1274, self);
+      else
+        nargoutchk(0, 0)
+        iDynTreeMEX(1275, self, varargin{1});
+      end
+    end
+    function self = DHLink(varargin)
       if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
         if ~isnull(varargin{1})
           self.swigPtr = varargin{1}.swigPtr;
         end
       else
-        tmp = iDynTreeMEX(2060, varargin{:});
+        tmp = iDynTreeMEX(1276, varargin{:});
         self.swigPtr = tmp.swigPtr;
         tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(2061, self);
+        iDynTreeMEX(1277, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/Wrench.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/JointSensor.m`

 * *Files 20% similar despite different names*

```diff
@@ -1,33 +1,37 @@
-classdef Wrench < iDynTree.SpatialForceVector
+classdef JointSensor < iDynTree.Sensor
   methods
-    function self = Wrench(varargin)
-      self@iDynTree.SpatialForceVector(iDynTreeSwigRef.Null);
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(573, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
+    function delete(self)
+      if self.swigPtr
+        iDynTreeMEX(1307, self);
+        self.SwigClear();
       end
     end
-    function varargout = plus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(574, self, varargin{:});
+    function varargout = getParentJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1308, self, varargin{:});
     end
-    function varargout = minus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(575, self, varargin{:});
+    function varargout = getParentJointIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1309, self, varargin{:});
     end
-    function varargout = uminus(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(576, self, varargin{:});
+    function varargout = setParentJoint(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1310, self, varargin{:});
     end
-    function delete(self)
-      if self.swigPtr
-        iDynTreeMEX(577, self);
-        self.SwigClear();
+    function varargout = setParentJointIndex(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1311, self, varargin{:});
+    end
+    function varargout = isConsistent(self,varargin)
+      [varargout{1:nargout}] = iDynTreeMEX(1312, self, varargin{:});
+    end
+    function self = JointSensor(varargin)
+      self@iDynTree.Sensor(iDynTreeSwigRef.Null);
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
+      else
+        error('No matching constructor');
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/+iDynTree/estimateExternalWrenchesBuffers.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/+iDynTree/ModelParserOptions.m`

 * *Files 26% similar despite different names*

```diff
@@ -1,88 +1,46 @@
-classdef estimateExternalWrenchesBuffers < iDynTreeSwigRef
+classdef ModelParserOptions < iDynTreeSwigRef
   methods
     function this = swig_this(self)
       this = iDynTreeMEX(3, self);
     end
-    function self = estimateExternalWrenchesBuffers(varargin)
-      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
-        if ~isnull(varargin{1})
-          self.swigPtr = varargin{1}.swigPtr;
-        end
-      else
-        tmp = iDynTreeMEX(1592, varargin{:});
-        self.swigPtr = tmp.swigPtr;
-        tmp.SwigClear();
-      end
-    end
-    function varargout = resize(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1593, self, varargin{:});
-    end
-    function varargout = getNrOfSubModels(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1594, self, varargin{:});
-    end
-    function varargout = getNrOfLinks(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1595, self, varargin{:});
-    end
-    function varargout = isConsistent(self,varargin)
-      [varargout{1:nargout}] = iDynTreeMEX(1596, self, varargin{:});
-    end
-    function varargout = A(self, varargin)
+    function varargout = addSensorFramesAsAdditionalFrames(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1597, self);
+        varargout{1} = iDynTreeMEX(1443, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1598, self, varargin{1});
+        iDynTreeMEX(1444, self, varargin{1});
       end
     end
-    function varargout = x(self, varargin)
+    function varargout = originalFilename(self, varargin)
       narginchk(1, 2)
       if nargin==1
         nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1599, self);
+        varargout{1} = iDynTreeMEX(1445, self);
       else
         nargoutchk(0, 0)
-        iDynTreeMEX(1600, self, varargin{1});
+        iDynTreeMEX(1446, self, varargin{1});
       end
     end
-    function varargout = b(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1601, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(1602, self, varargin{1});
-      end
-    end
-    function varargout = b_contacts_subtree(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1603, self);
-      else
-        nargoutchk(0, 0)
-        iDynTreeMEX(1604, self, varargin{1});
-      end
-    end
-    function varargout = subModelBase_H_link(self, varargin)
-      narginchk(1, 2)
-      if nargin==1
-        nargoutchk(0, 1)
-        varargout{1} = iDynTreeMEX(1605, self);
+    function self = ModelParserOptions(varargin)
+      if nargin==1 && strcmp(class(varargin{1}),'iDynTreeSwigRef')
+        if ~isnull(varargin{1})
+          self.swigPtr = varargin{1}.swigPtr;
+        end
       else
-        nargoutchk(0, 0)
-        iDynTreeMEX(1606, self, varargin{1});
+        tmp = iDynTreeMEX(1447, varargin{:});
+        self.swigPtr = tmp.swigPtr;
+        tmp.SwigClear();
       end
     end
     function delete(self)
       if self.swigPtr
-        iDynTreeMEX(1607, self);
+        iDynTreeMEX(1448, self);
         self.SwigClear();
       end
     end
   end
   methods(Static)
   end
 end
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/iDynTreeMATLAB_wrap.cxx` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/iDynTreeMATLAB_wrap.cxx`

 * *Files 2% similar despite different names*

```diff
@@ -1319,80 +1319,80 @@
 #define SWIGTYPE_p_iDynTree__MovableJointImplT_5_5_t swig_types[107]
 #define SWIGTYPE_p_iDynTree__MovableJointImplT_6_6_t swig_types[108]
 #define SWIGTYPE_p_iDynTree__Neighbor swig_types[109]
 #define SWIGTYPE_p_iDynTree__PixelViz swig_types[110]
 #define SWIGTYPE_p_iDynTree__Polygon swig_types[111]
 #define SWIGTYPE_p_iDynTree__Polygon2D swig_types[112]
 #define SWIGTYPE_p_iDynTree__Position swig_types[113]
-#define SWIGTYPE_p_iDynTree__PrismaticJoint swig_types[114]
-#define SWIGTYPE_p_iDynTree__RevoluteJoint swig_types[115]
-#define SWIGTYPE_p_iDynTree__RigidBodyInertiaNonLinearParametrization swig_types[116]
-#define SWIGTYPE_p_iDynTree__Rotation swig_types[117]
-#define SWIGTYPE_p_iDynTree__RotationalInertia swig_types[118]
-#define SWIGTYPE_p_iDynTree__Sensor swig_types[119]
-#define SWIGTYPE_p_iDynTree__SensorsList swig_types[120]
-#define SWIGTYPE_p_iDynTree__SensorsMeasurements swig_types[121]
-#define SWIGTYPE_p_iDynTree__SimpleLeggedOdometry swig_types[122]
-#define SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor swig_types[123]
-#define SWIGTYPE_p_iDynTree__SolidShape swig_types[124]
-#define SWIGTYPE_p_iDynTree__SpanT_double__1_t swig_types[125]
-#define SWIGTYPE_p_iDynTree__SpanT_double_const__1_t swig_types[126]
-#define SWIGTYPE_p_iDynTree__SparseMatrixT_iDynTree__ColumnMajor_t swig_types[127]
-#define SWIGTYPE_p_iDynTree__SparseMatrixT_iDynTree__RowMajor_t swig_types[128]
-#define SWIGTYPE_p_iDynTree__SpatialAcc swig_types[129]
-#define SWIGTYPE_p_iDynTree__SpatialForceVector swig_types[130]
-#define SWIGTYPE_p_iDynTree__SpatialInertia swig_types[131]
-#define SWIGTYPE_p_iDynTree__SpatialMomentum swig_types[132]
-#define SWIGTYPE_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__AngularVector3Type swig_types[133]
-#define SWIGTYPE_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__LinearVector3Type swig_types[134]
-#define SWIGTYPE_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__AngularVector3Type swig_types[135]
-#define SWIGTYPE_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__LinearVector3Type swig_types[136]
-#define SWIGTYPE_p_iDynTree__SpatialMotionVector swig_types[137]
-#define SWIGTYPE_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t swig_types[138]
-#define SWIGTYPE_p_iDynTree__SpatialVectorT_iDynTree__SpatialMotionVector_t swig_types[139]
-#define SWIGTYPE_p_iDynTree__Sphere swig_types[140]
-#define SWIGTYPE_p_iDynTree__SubModelDecomposition swig_types[141]
-#define SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor swig_types[142]
-#define SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor swig_types[143]
-#define SWIGTYPE_p_iDynTree__Transform swig_types[144]
-#define SWIGTYPE_p_iDynTree__TransformDerivative swig_types[145]
-#define SWIGTYPE_p_iDynTree__Traversal swig_types[146]
-#define SWIGTYPE_p_iDynTree__Triplets swig_types[147]
-#define SWIGTYPE_p_iDynTree__Twist swig_types[148]
-#define SWIGTYPE_p_iDynTree__UnknownWrenchContact swig_types[149]
-#define SWIGTYPE_p_iDynTree__VectorDynSize swig_types[150]
-#define SWIGTYPE_p_iDynTree__VectorFixSizeT_10_t swig_types[151]
-#define SWIGTYPE_p_iDynTree__VectorFixSizeT_16_t swig_types[152]
-#define SWIGTYPE_p_iDynTree__VectorFixSizeT_2_t swig_types[153]
-#define SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t swig_types[154]
-#define SWIGTYPE_p_iDynTree__VectorFixSizeT_4_t swig_types[155]
-#define SWIGTYPE_p_iDynTree__VectorFixSizeT_6_t swig_types[156]
-#define SWIGTYPE_p_iDynTree__Visualizer swig_types[157]
-#define SWIGTYPE_p_iDynTree__VisualizerOptions swig_types[158]
-#define SWIGTYPE_p_iDynTree__Wrench swig_types[159]
-#define SWIGTYPE_p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t swig_types[160]
-#define SWIGTYPE_p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t swig_types[161]
-#define SWIGTYPE_p_iDynTree__estimateExternalWrenchesBuffers swig_types[162]
-#define SWIGTYPE_p_index_type swig_types[163]
-#define SWIGTYPE_p_iterator swig_types[164]
-#define SWIGTYPE_p_pointer swig_types[165]
-#define SWIGTYPE_p_ptrdiff_t swig_types[166]
-#define SWIGTYPE_p_reference swig_types[167]
-#define SWIGTYPE_p_reverse_iterator swig_types[168]
-#define SWIGTYPE_p_size_type swig_types[169]
-#define SWIGTYPE_p_std__allocatorT_iDynTree__BerdyDynamicVariable_t swig_types[170]
-#define SWIGTYPE_p_std__allocatorT_iDynTree__BerdySensor_t swig_types[171]
-#define SWIGTYPE_p_std__allocatorT_iDynTree__MatrixDynSize_t swig_types[172]
-#define SWIGTYPE_p_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t swig_types[173]
-#define SWIGTYPE_p_std__allocatorT_iDynTree__SolidShape_p_t swig_types[174]
-#define SWIGTYPE_p_std__allocatorT_iDynTree__VectorDynSize_t swig_types[175]
+#define SWIGTYPE_p_iDynTree__PositionRaw swig_types[114]
+#define SWIGTYPE_p_iDynTree__PrismaticJoint swig_types[115]
+#define SWIGTYPE_p_iDynTree__RevoluteJoint swig_types[116]
+#define SWIGTYPE_p_iDynTree__RigidBodyInertiaNonLinearParametrization swig_types[117]
+#define SWIGTYPE_p_iDynTree__Rotation swig_types[118]
+#define SWIGTYPE_p_iDynTree__RotationRaw swig_types[119]
+#define SWIGTYPE_p_iDynTree__RotationalInertiaRaw swig_types[120]
+#define SWIGTYPE_p_iDynTree__Sensor swig_types[121]
+#define SWIGTYPE_p_iDynTree__SensorsList swig_types[122]
+#define SWIGTYPE_p_iDynTree__SensorsMeasurements swig_types[123]
+#define SWIGTYPE_p_iDynTree__SimpleLeggedOdometry swig_types[124]
+#define SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor swig_types[125]
+#define SWIGTYPE_p_iDynTree__SolidShape swig_types[126]
+#define SWIGTYPE_p_iDynTree__SpanT_double__1_t swig_types[127]
+#define SWIGTYPE_p_iDynTree__SpanT_double_const__1_t swig_types[128]
+#define SWIGTYPE_p_iDynTree__SparseMatrixT_iDynTree__ColumnMajor_t swig_types[129]
+#define SWIGTYPE_p_iDynTree__SparseMatrixT_iDynTree__RowMajor_t swig_types[130]
+#define SWIGTYPE_p_iDynTree__SpatialAcc swig_types[131]
+#define SWIGTYPE_p_iDynTree__SpatialForceVector swig_types[132]
+#define SWIGTYPE_p_iDynTree__SpatialInertia swig_types[133]
+#define SWIGTYPE_p_iDynTree__SpatialInertiaRaw swig_types[134]
+#define SWIGTYPE_p_iDynTree__SpatialMomentum swig_types[135]
+#define SWIGTYPE_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__AngularVector3Type swig_types[136]
+#define SWIGTYPE_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__LinearVector3Type swig_types[137]
+#define SWIGTYPE_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__AngularVector3Type swig_types[138]
+#define SWIGTYPE_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__LinearVector3Type swig_types[139]
+#define SWIGTYPE_p_iDynTree__SpatialMotionVector swig_types[140]
+#define SWIGTYPE_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t swig_types[141]
+#define SWIGTYPE_p_iDynTree__SpatialVectorT_iDynTree__SpatialMotionVector_t swig_types[142]
+#define SWIGTYPE_p_iDynTree__Sphere swig_types[143]
+#define SWIGTYPE_p_iDynTree__SubModelDecomposition swig_types[144]
+#define SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor swig_types[145]
+#define SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor swig_types[146]
+#define SWIGTYPE_p_iDynTree__Transform swig_types[147]
+#define SWIGTYPE_p_iDynTree__TransformDerivative swig_types[148]
+#define SWIGTYPE_p_iDynTree__Traversal swig_types[149]
+#define SWIGTYPE_p_iDynTree__Triplets swig_types[150]
+#define SWIGTYPE_p_iDynTree__Twist swig_types[151]
+#define SWIGTYPE_p_iDynTree__UnknownWrenchContact swig_types[152]
+#define SWIGTYPE_p_iDynTree__VectorDynSize swig_types[153]
+#define SWIGTYPE_p_iDynTree__VectorFixSizeT_10_t swig_types[154]
+#define SWIGTYPE_p_iDynTree__VectorFixSizeT_16_t swig_types[155]
+#define SWIGTYPE_p_iDynTree__VectorFixSizeT_2_t swig_types[156]
+#define SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t swig_types[157]
+#define SWIGTYPE_p_iDynTree__VectorFixSizeT_4_t swig_types[158]
+#define SWIGTYPE_p_iDynTree__VectorFixSizeT_6_t swig_types[159]
+#define SWIGTYPE_p_iDynTree__Visualizer swig_types[160]
+#define SWIGTYPE_p_iDynTree__VisualizerOptions swig_types[161]
+#define SWIGTYPE_p_iDynTree__Wrench swig_types[162]
+#define SWIGTYPE_p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t swig_types[163]
+#define SWIGTYPE_p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t swig_types[164]
+#define SWIGTYPE_p_iDynTree__estimateExternalWrenchesBuffers swig_types[165]
+#define SWIGTYPE_p_index_type swig_types[166]
+#define SWIGTYPE_p_iterator swig_types[167]
+#define SWIGTYPE_p_pointer swig_types[168]
+#define SWIGTYPE_p_reference swig_types[169]
+#define SWIGTYPE_p_reverse_iterator swig_types[170]
+#define SWIGTYPE_p_size_type swig_types[171]
+#define SWIGTYPE_p_std__allocatorT_iDynTree__BerdyDynamicVariable_t swig_types[172]
+#define SWIGTYPE_p_std__allocatorT_iDynTree__BerdySensor_t swig_types[173]
+#define SWIGTYPE_p_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t swig_types[174]
+#define SWIGTYPE_p_std__allocatorT_iDynTree__SolidShape_p_t swig_types[175]
 #define SWIGTYPE_p_std__allocatorT_int_t swig_types[176]
-#define SWIGTYPE_p_std__allocatorT_std__ptrdiff_t_t swig_types[177]
-#define SWIGTYPE_p_std__allocatorT_std__string_t swig_types[178]
-#define SWIGTYPE_p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t swig_types[179]
+#define SWIGTYPE_p_std__allocatorT_std__string_t swig_types[177]
+#define SWIGTYPE_p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t swig_types[178]
+#define SWIGTYPE_p_std__ptrdiff_t swig_types[179]
 #define SWIGTYPE_p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t_t swig_types[180]
 #define SWIGTYPE_p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t_t swig_types[181]
 #define SWIGTYPE_p_std__size_t swig_types[182]
 #define SWIGTYPE_p_std__string swig_types[183]
 #define SWIGTYPE_p_std__vectorT_iDynTree__BerdyDynamicVariable_std__allocatorT_iDynTree__BerdyDynamicVariable_t_t swig_types[184]
 #define SWIGTYPE_p_std__vectorT_iDynTree__BerdySensor_std__allocatorT_iDynTree__BerdySensor_t_t swig_types[185]
 #define SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t swig_types[186]
@@ -2968,101 +2968,104 @@
 SWIGINTERN std::vector< int >::iterator std_vector_Sl_int_Sg__erase__SWIG_0(std::vector< int > *self,std::vector< int >::iterator pos){ return self->erase(pos); }
 SWIGINTERN std::vector< int >::iterator std_vector_Sl_int_Sg__erase__SWIG_1(std::vector< int > *self,std::vector< int >::iterator first,std::vector< int >::iterator last){ return self->erase(first, last); }
 SWIGINTERN std::vector< int >::iterator std_vector_Sl_int_Sg__insert__SWIG_0(std::vector< int > *self,std::vector< int >::iterator pos,std::vector< int >::value_type const &x){ return self->insert(pos, x); }
 SWIGINTERN void std_vector_Sl_int_Sg__insert__SWIG_1(std::vector< int > *self,std::vector< int >::iterator pos,std::vector< int >::size_type n,std::vector< int >::value_type const &x){ self->insert(pos, n, x); }
 
 /* Note : always include headers following the inheritance order */
 #include <cmath>
-#include <cstddef>
 
 //Utils
-#include "iDynTree/Utils.h"
+#include "iDynTree/Core/Utils.h"
 
 // Basic math classes
-#include "iDynTree/MatrixDynSize.h"
-#include "iDynTree/MatrixFixSize.h"
-#include "iDynTree/SparseMatrix.h"
+#include "iDynTree/Core/MatrixDynSize.h"
+#include "iDynTree/Core/MatrixFixSize.h"
+#include "iDynTree/Core/SparseMatrix.h"
 
-#include "iDynTree/VectorDynSize.h"
-#include "iDynTree/VectorFixSize.h"
+#include "iDynTree/Core/VectorDynSize.h"
+#include "iDynTree/Core/VectorFixSize.h"
 
 // Basic Vectors: Point Vectors and Spatial Vectors
-#include "iDynTree/Position.h"
-#include "iDynTree/SpatialForceVector.h"
-#include "iDynTree/SpatialMotionVector.h"
-#include "iDynTree/Twist.h"
-#include "iDynTree/Wrench.h"
-#include "iDynTree/SpatialMomentum.h"
-#include "iDynTree/SpatialAcc.h"
-#include "iDynTree/ClassicalAcc.h"
-#include "iDynTree/Direction.h"
-#include "iDynTree/Axis.h"
+#include "iDynTree/Core/PositionRaw.h"
+#include "iDynTree/Core/Position.h"
+#include "iDynTree/Core/SpatialForceVector.h"
+#include "iDynTree/Core/SpatialMotionVector.h"
+#include "iDynTree/Core/Twist.h"
+#include "iDynTree/Core/Wrench.h"
+#include "iDynTree/Core/SpatialMomentum.h"
+#include "iDynTree/Core/SpatialAcc.h"
+#include "iDynTree/Core/ClassicalAcc.h"
+#include "iDynTree/Core/Direction.h"
+#include "iDynTree/Core/Axis.h"
 
 // Inertias
-#include "iDynTree/RotationalInertia.h"
-#include "iDynTree/SpatialInertia.h"
-#include "iDynTree/SpatialInertia.h"
-#include "iDynTree/ArticulatedBodyInertia.h"
-#include "iDynTree/InertiaNonLinearParametrization.h"
+#include "iDynTree/Core/RotationalInertiaRaw.h"
+#include "iDynTree/Core/SpatialInertiaRaw.h"
+#include "iDynTree/Core/SpatialInertia.h"
+#include "iDynTree/Core/ArticulatedBodyInertia.h"
+#include "iDynTree/Core/InertiaNonLinearParametrization.h"
 
 // Transformations: Rotation and Transform
-#include "iDynTree/Rotation.h"
-#include "iDynTree/Transform.h"
-#include "iDynTree/TransformDerivative.h"
-#include "iDynTree/Span.h"
+#include "iDynTree/Core/RotationRaw.h"
+#include "iDynTree/Core/Rotation.h"
+#include "iDynTree/Core/Transform.h"
+#include "iDynTree/Core/TransformDerivative.h"
+#include "iDynTree/Core/Span.h"
 
 // Model related data structures
-#include "iDynTree/Indices.h"
-#include "iDynTree/LinkState.h"
-#include "iDynTree/Link.h"
-#include "iDynTree/IJoint.h"
-#include "iDynTree/FixedJoint.h"
-#include "iDynTree/MovableJointImpl.h"
-#include "iDynTree/RevoluteJoint.h"
-#include "iDynTree/PrismaticJoint.h"
-#include "iDynTree/Traversal.h"
-#include "iDynTree/SolidShapes.h"
-#include "iDynTree/Sensors.h"
-#include "iDynTree/Model.h"
-#include "iDynTree/JointState.h"
-#include "iDynTree/FreeFloatingMatrices.h"
-#include "iDynTree/FreeFloatingState.h"
-#include "iDynTree/ContactWrench.h"
-#include "iDynTree/ModelTestUtils.h"
-#include "iDynTree/ModelTransformers.h"
-#include "iDynTree/SubModel.h"
-#include "iDynTree/SixAxisForceTorqueSensor.h"
-#include "iDynTree/AccelerometerSensor.h"
-#include "iDynTree/GyroscopeSensor.h"
-#include "iDynTree/ThreeAxisAngularAccelerometerSensor.h"
-#include "iDynTree/ThreeAxisForceTorqueContactSensor.h"
-#include "iDynTree/PredictSensorsMeasurements.h"
+#include "iDynTree/Model/Indices.h"
+#include "iDynTree/Model/LinkState.h"
+#include "iDynTree/Model/Link.h"
+#include "iDynTree/Model/IJoint.h"
+#include "iDynTree/Model/FixedJoint.h"
+#include "iDynTree/Model/MovableJointImpl.h"
+#include "iDynTree/Model/RevoluteJoint.h"
+#include "iDynTree/Model/PrismaticJoint.h"
+#include "iDynTree/Model/Traversal.h"
+#include "iDynTree/Model/SolidShapes.h"
+#include "iDynTree/Model/Model.h"
+#include "iDynTree/Model/JointState.h"
+#include "iDynTree/Model/FreeFloatingMatrices.h"
+#include "iDynTree/Model/FreeFloatingState.h"
+#include "iDynTree/Model/ContactWrench.h"
+#include "iDynTree/Model/ModelTestUtils.h"
+#include "iDynTree/Model/ModelTransformers.h"
+#include "iDynTree/Model/SubModel.h"
 
 // Kinematics & Dynamics related functions
-#include "iDynTree/ForwardKinematics.h"
-#include "iDynTree/Dynamics.h"
-#include "iDynTree/DenavitHartenberg.h"
+#include "iDynTree/Model/ForwardKinematics.h"
+#include "iDynTree/Model/Dynamics.h"
+#include "iDynTree/Model/DenavitHartenberg.h"
+
+// Sensors related data structures
+#include "iDynTree/Sensors/Sensors.h"
+#include "iDynTree/Sensors/SixAxisForceTorqueSensor.h"
+#include "iDynTree/Sensors/AccelerometerSensor.h"
+#include "iDynTree/Sensors/GyroscopeSensor.h"
+#include "iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h"
+#include "iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h"
+#include "iDynTree/Sensors/PredictSensorsMeasurements.h"
 
 // Model loading from external formats
-#include "iDynTree/URDFDofsImport.h"
-#include "iDynTree/ModelLoader.h"
-#include "iDynTree/ModelExporter.h"
-#include "iDynTree/ModelCalibrationHelper.h"
+#include "iDynTree/ModelIO/URDFDofsImport.h"
+#include "iDynTree/ModelIO/ModelLoader.h"
+#include "iDynTree/ModelIO/ModelExporter.h"
+#include "iDynTree/ModelIO/ModelCalibrationHelper.h"
 
 
 // Estimation related classes
-#include "iDynTree/ExternalWrenchesEstimation.h"
-#include "iDynTree/ExtWrenchesAndJointTorquesEstimator.h"
-#include "iDynTree/SimpleLeggedOdometry.h"
-#include "iDynTree/BerdyHelper.h"
-#include "iDynTree/BerdySparseMAPSolver.h"
-#include "iDynTree/AttitudeEstimator.h"
-#include "iDynTree/AttitudeMahonyFilter.h"
-#include "iDynTree/ExtendedKalmanFilter.h"
-#include "iDynTree/AttitudeQuaternionEKF.h"
+#include "iDynTree/Estimation/ExternalWrenchesEstimation.h"
+#include "iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h"
+#include "iDynTree/Estimation/SimpleLeggedOdometry.h"
+#include "iDynTree/Estimation/BerdyHelper.h"
+#include "iDynTree/Estimation/BerdySparseMAPSolver.h"
+#include "iDynTree/Estimation/AttitudeEstimator.h"
+#include "iDynTree/Estimation/AttitudeMahonyFilter.h"
+#include "iDynTree/Estimation/ExtendedKalmanFilter.h"
+#include "iDynTree/Estimation/AttitudeQuaternionEKF.h"
 
 // SolidShapes related classes
 #include "iDynTree/InertialParametersSolidShapesHelpers.h"
 
 // High level interfaces
 #include "iDynTree/KinDynComputations.h"
 
@@ -3072,128 +3075,14 @@
 // Inverse Kinematics
 #include "iDynTree/ConvexHullHelpers.h"
 #include "iDynTree/InverseKinematics.h"
 
 
 
   namespace swig {
-    template <>  struct traits< iDynTree::MatrixDynSize > {
-      typedef pointer_category category;
-      static const char* type_name() { return"iDynTree::MatrixDynSize"; }
-    };
-  }
-
-
-      namespace swig {
-	template <>  struct traits<std::vector< iDynTree::MatrixDynSize, std::allocator< iDynTree::MatrixDynSize > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "iDynTree::MatrixDynSize" "," "std::allocator< iDynTree::MatrixDynSize >" " >";
-	  }
-	};
-      }
-    
-SWIGINTERN std::vector< iDynTree::MatrixDynSize >::value_type std_vector_Sl_iDynTree_MatrixDynSize_Sg__pop(std::vector< iDynTree::MatrixDynSize > *self){
-      if (self->size() == 0)
-	throw std::out_of_range("pop from empty container");
-      std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > >::value_type x = self->back();
-      self->pop_back();
-      return x;
-    }
-SWIGINTERN std::vector< iDynTree::MatrixDynSize >::value_type std_vector_Sl_iDynTree_MatrixDynSize_Sg__brace(std::vector< iDynTree::MatrixDynSize > *self,std::vector< iDynTree::MatrixDynSize >::difference_type i){
-      return *(swig::cgetpos(self, i));
-    }
-SWIGINTERN void std_vector_Sl_iDynTree_MatrixDynSize_Sg__setbrace(std::vector< iDynTree::MatrixDynSize > *self,std::vector< iDynTree::MatrixDynSize >::value_type x,std::vector< iDynTree::MatrixDynSize >::difference_type i){
-      *(swig::getpos(self,i)) = x;
-    }
-SWIGINTERN void std_vector_Sl_iDynTree_MatrixDynSize_Sg__append(std::vector< iDynTree::MatrixDynSize > *self,std::vector< iDynTree::MatrixDynSize >::value_type x){
-      self->push_back(x);
-    }
-SWIGINTERN std::vector< iDynTree::MatrixDynSize >::iterator std_vector_Sl_iDynTree_MatrixDynSize_Sg__erase__SWIG_0(std::vector< iDynTree::MatrixDynSize > *self,std::vector< iDynTree::MatrixDynSize >::iterator pos){ return self->erase(pos); }
-SWIGINTERN std::vector< iDynTree::MatrixDynSize >::iterator std_vector_Sl_iDynTree_MatrixDynSize_Sg__erase__SWIG_1(std::vector< iDynTree::MatrixDynSize > *self,std::vector< iDynTree::MatrixDynSize >::iterator first,std::vector< iDynTree::MatrixDynSize >::iterator last){ return self->erase(first, last); }
-SWIGINTERN std::vector< iDynTree::MatrixDynSize >::iterator std_vector_Sl_iDynTree_MatrixDynSize_Sg__insert__SWIG_0(std::vector< iDynTree::MatrixDynSize > *self,std::vector< iDynTree::MatrixDynSize >::iterator pos,std::vector< iDynTree::MatrixDynSize >::value_type const &x){ return self->insert(pos, x); }
-SWIGINTERN void std_vector_Sl_iDynTree_MatrixDynSize_Sg__insert__SWIG_1(std::vector< iDynTree::MatrixDynSize > *self,std::vector< iDynTree::MatrixDynSize >::iterator pos,std::vector< iDynTree::MatrixDynSize >::size_type n,std::vector< iDynTree::MatrixDynSize >::value_type const &x){ self->insert(pos, n, x); }
-
-  namespace swig {
-    template <>  struct traits< iDynTree::VectorDynSize > {
-      typedef pointer_category category;
-      static const char* type_name() { return"iDynTree::VectorDynSize"; }
-    };
-  }
-
-
-      namespace swig {
-	template <>  struct traits<std::vector< iDynTree::VectorDynSize, std::allocator< iDynTree::VectorDynSize > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "iDynTree::VectorDynSize" "," "std::allocator< iDynTree::VectorDynSize >" " >";
-	  }
-	};
-      }
-    
-SWIGINTERN std::vector< iDynTree::VectorDynSize >::value_type std_vector_Sl_iDynTree_VectorDynSize_Sg__pop(std::vector< iDynTree::VectorDynSize > *self){
-      if (self->size() == 0)
-	throw std::out_of_range("pop from empty container");
-      std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > >::value_type x = self->back();
-      self->pop_back();
-      return x;
-    }
-SWIGINTERN std::vector< iDynTree::VectorDynSize >::value_type std_vector_Sl_iDynTree_VectorDynSize_Sg__brace(std::vector< iDynTree::VectorDynSize > *self,std::vector< iDynTree::VectorDynSize >::difference_type i){
-      return *(swig::cgetpos(self, i));
-    }
-SWIGINTERN void std_vector_Sl_iDynTree_VectorDynSize_Sg__setbrace(std::vector< iDynTree::VectorDynSize > *self,std::vector< iDynTree::VectorDynSize >::value_type x,std::vector< iDynTree::VectorDynSize >::difference_type i){
-      *(swig::getpos(self,i)) = x;
-    }
-SWIGINTERN void std_vector_Sl_iDynTree_VectorDynSize_Sg__append(std::vector< iDynTree::VectorDynSize > *self,std::vector< iDynTree::VectorDynSize >::value_type x){
-      self->push_back(x);
-    }
-SWIGINTERN std::vector< iDynTree::VectorDynSize >::iterator std_vector_Sl_iDynTree_VectorDynSize_Sg__erase__SWIG_0(std::vector< iDynTree::VectorDynSize > *self,std::vector< iDynTree::VectorDynSize >::iterator pos){ return self->erase(pos); }
-SWIGINTERN std::vector< iDynTree::VectorDynSize >::iterator std_vector_Sl_iDynTree_VectorDynSize_Sg__erase__SWIG_1(std::vector< iDynTree::VectorDynSize > *self,std::vector< iDynTree::VectorDynSize >::iterator first,std::vector< iDynTree::VectorDynSize >::iterator last){ return self->erase(first, last); }
-SWIGINTERN std::vector< iDynTree::VectorDynSize >::iterator std_vector_Sl_iDynTree_VectorDynSize_Sg__insert__SWIG_0(std::vector< iDynTree::VectorDynSize > *self,std::vector< iDynTree::VectorDynSize >::iterator pos,std::vector< iDynTree::VectorDynSize >::value_type const &x){ return self->insert(pos, x); }
-SWIGINTERN void std_vector_Sl_iDynTree_VectorDynSize_Sg__insert__SWIG_1(std::vector< iDynTree::VectorDynSize > *self,std::vector< iDynTree::VectorDynSize >::iterator pos,std::vector< iDynTree::VectorDynSize >::size_type n,std::vector< iDynTree::VectorDynSize >::value_type const &x){ self->insert(pos, n, x); }
-
-  namespace swig {
-    template <>  struct traits< ::ptrdiff_t > {
-      typedef pointer_category category;
-      static const char* type_name() { return"::ptrdiff_t"; }
-    };
-  }
-
-
-      namespace swig {
-	template <>  struct traits<std::vector< ::ptrdiff_t, std::allocator< ::ptrdiff_t > > > {
-	  typedef pointer_category category;
-	  static const char* type_name() {
-	    return "std::vector<" "::ptrdiff_t" "," "std::allocator< ::ptrdiff_t >" " >";
-	  }
-	};
-      }
-    
-SWIGINTERN std::vector< ::ptrdiff_t >::value_type std_vector_Sl_std_ptrdiff_t_Sg__pop(std::vector< std::ptrdiff_t > *self){
-      if (self->size() == 0)
-	throw std::out_of_range("pop from empty container");
-      std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > >::value_type x = self->back();
-      self->pop_back();
-      return x;
-    }
-SWIGINTERN std::vector< ::ptrdiff_t >::value_type std_vector_Sl_std_ptrdiff_t_Sg__brace(std::vector< std::ptrdiff_t > *self,std::vector< ::ptrdiff_t >::difference_type i){
-      return *(swig::cgetpos(self, i));
-    }
-SWIGINTERN void std_vector_Sl_std_ptrdiff_t_Sg__setbrace(std::vector< std::ptrdiff_t > *self,std::vector< ::ptrdiff_t >::value_type x,std::vector< ::ptrdiff_t >::difference_type i){
-      *(swig::getpos(self,i)) = x;
-    }
-SWIGINTERN void std_vector_Sl_std_ptrdiff_t_Sg__append(std::vector< std::ptrdiff_t > *self,std::vector< ::ptrdiff_t >::value_type x){
-      self->push_back(x);
-    }
-SWIGINTERN std::vector< ::ptrdiff_t >::iterator std_vector_Sl_std_ptrdiff_t_Sg__erase__SWIG_0(std::vector< std::ptrdiff_t > *self,std::vector< ::ptrdiff_t >::iterator pos){ return self->erase(pos); }
-SWIGINTERN std::vector< ::ptrdiff_t >::iterator std_vector_Sl_std_ptrdiff_t_Sg__erase__SWIG_1(std::vector< std::ptrdiff_t > *self,std::vector< ::ptrdiff_t >::iterator first,std::vector< ::ptrdiff_t >::iterator last){ return self->erase(first, last); }
-SWIGINTERN std::vector< ::ptrdiff_t >::iterator std_vector_Sl_std_ptrdiff_t_Sg__insert__SWIG_0(std::vector< std::ptrdiff_t > *self,std::vector< ::ptrdiff_t >::iterator pos,std::vector< ::ptrdiff_t >::value_type const &x){ return self->insert(pos, x); }
-SWIGINTERN void std_vector_Sl_std_ptrdiff_t_Sg__insert__SWIG_1(std::vector< std::ptrdiff_t > *self,std::vector< ::ptrdiff_t >::iterator pos,std::vector< ::ptrdiff_t >::size_type n,std::vector< ::ptrdiff_t >::value_type const &x){ self->insert(pos, n, x); }
-
-  namespace swig {
     template <>  struct traits< iDynTree::BerdySensor > {
       typedef pointer_category category;
       static const char* type_name() { return"iDynTree::BerdySensor"; }
     };
   }
 
 
@@ -4486,39 +4375,14 @@
         return p;
     }
 SWIGINTERN iDynTree::PrismaticJoint *iDynTree_IJoint_asPrismaticJoint(iDynTree::IJoint *self){
         iDynTree::PrismaticJoint * p =
             static_cast<iDynTree::PrismaticJoint*>(self);
         return p;
     }
-SWIGINTERN iDynTree::SixAxisForceTorqueSensor *iDynTree_SensorsList_getSixAxisForceTorqueSensor(iDynTree::SensorsList const *self,int sensor_index){
-        iDynTree::SixAxisForceTorqueSensor* p =
-            static_cast<iDynTree::SixAxisForceTorqueSensor*>(self->getSensor(iDynTree::SIX_AXIS_FORCE_TORQUE,sensor_index));
-        return p;
-    }
-SWIGINTERN iDynTree::AccelerometerSensor *iDynTree_SensorsList_getAccelerometerSensor(iDynTree::SensorsList const *self,int sensor_index){
-        iDynTree::AccelerometerSensor* p =
-            static_cast<iDynTree::AccelerometerSensor*>(self->getSensor(iDynTree::ACCELEROMETER,sensor_index));
-        return p;
-    }
-SWIGINTERN iDynTree::GyroscopeSensor *iDynTree_SensorsList_getGyroscopeSensor(iDynTree::SensorsList const *self,int sensor_index){
-        iDynTree::GyroscopeSensor* p =
-            static_cast<iDynTree::GyroscopeSensor*>(self->getSensor(iDynTree::GYROSCOPE,sensor_index));
-        return p;
-    }
-SWIGINTERN iDynTree::ThreeAxisAngularAccelerometerSensor *iDynTree_SensorsList_getThreeAxisAngularAccelerometerSensor(iDynTree::SensorsList const *self,int sensor_index){
-        iDynTree::ThreeAxisAngularAccelerometerSensor* p =
-            static_cast<iDynTree::ThreeAxisAngularAccelerometerSensor*>(self->getSensor(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER,sensor_index));
-        return p;
-    }
-SWIGINTERN iDynTree::ThreeAxisForceTorqueContactSensor *iDynTree_SensorsList_getThreeAxisForceTorqueContactSensor(iDynTree::SensorsList const *self,int sensor_index){
-        iDynTree::ThreeAxisForceTorqueContactSensor* p =
-            static_cast<iDynTree::ThreeAxisForceTorqueContactSensor*>(self->getSensor(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT,sensor_index));
-        return p;
-    }
 
   namespace swig {
     template <>  struct traits< iDynTree::SolidShape > {
       typedef pointer_category category;
       static const char* type_name() { return"iDynTree::SolidShape"; }
     };
   }
@@ -4579,14 +4443,39 @@
 SWIGINTERN void std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__append(std::vector< std::vector< iDynTree::SolidShape * > > *self,std::vector< std::vector< iDynTree::SolidShape * > >::value_type x){
       self->push_back(x);
     }
 SWIGINTERN std::vector< std::vector< iDynTree::SolidShape * > >::iterator std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__erase__SWIG_0(std::vector< std::vector< iDynTree::SolidShape * > > *self,std::vector< std::vector< iDynTree::SolidShape * > >::iterator pos){ return self->erase(pos); }
 SWIGINTERN std::vector< std::vector< iDynTree::SolidShape * > >::iterator std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__erase__SWIG_1(std::vector< std::vector< iDynTree::SolidShape * > > *self,std::vector< std::vector< iDynTree::SolidShape * > >::iterator first,std::vector< std::vector< iDynTree::SolidShape * > >::iterator last){ return self->erase(first, last); }
 SWIGINTERN std::vector< std::vector< iDynTree::SolidShape * > >::iterator std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__insert__SWIG_0(std::vector< std::vector< iDynTree::SolidShape * > > *self,std::vector< std::vector< iDynTree::SolidShape * > >::iterator pos,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &x){ return self->insert(pos, x); }
 SWIGINTERN void std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__insert__SWIG_1(std::vector< std::vector< iDynTree::SolidShape * > > *self,std::vector< std::vector< iDynTree::SolidShape * > >::iterator pos,std::vector< std::vector< iDynTree::SolidShape * > >::size_type n,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &x){ self->insert(pos, n, x); }
+SWIGINTERN iDynTree::SixAxisForceTorqueSensor *iDynTree_SensorsList_getSixAxisForceTorqueSensor(iDynTree::SensorsList const *self,int sensor_index){
+        iDynTree::SixAxisForceTorqueSensor* p =
+            static_cast<iDynTree::SixAxisForceTorqueSensor*>(self->getSensor(iDynTree::SIX_AXIS_FORCE_TORQUE,sensor_index));
+        return p;
+    }
+SWIGINTERN iDynTree::AccelerometerSensor *iDynTree_SensorsList_getAccelerometerSensor(iDynTree::SensorsList const *self,int sensor_index){
+        iDynTree::AccelerometerSensor* p =
+            static_cast<iDynTree::AccelerometerSensor*>(self->getSensor(iDynTree::ACCELEROMETER,sensor_index));
+        return p;
+    }
+SWIGINTERN iDynTree::GyroscopeSensor *iDynTree_SensorsList_getGyroscopeSensor(iDynTree::SensorsList const *self,int sensor_index){
+        iDynTree::GyroscopeSensor* p =
+            static_cast<iDynTree::GyroscopeSensor*>(self->getSensor(iDynTree::GYROSCOPE,sensor_index));
+        return p;
+    }
+SWIGINTERN iDynTree::ThreeAxisAngularAccelerometerSensor *iDynTree_SensorsList_getThreeAxisAngularAccelerometerSensor(iDynTree::SensorsList const *self,int sensor_index){
+        iDynTree::ThreeAxisAngularAccelerometerSensor* p =
+            static_cast<iDynTree::ThreeAxisAngularAccelerometerSensor*>(self->getSensor(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER,sensor_index));
+        return p;
+    }
+SWIGINTERN iDynTree::ThreeAxisForceTorqueContactSensor *iDynTree_SensorsList_getThreeAxisForceTorqueContactSensor(iDynTree::SensorsList const *self,int sensor_index){
+        iDynTree::ThreeAxisForceTorqueContactSensor* p =
+            static_cast<iDynTree::ThreeAxisForceTorqueContactSensor*>(self->getSensor(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT,sensor_index));
+        return p;
+    }
 
   namespace swig {
     template <>  struct traits< iDynTree::MatrixFixSize< 4,4 > > {
       typedef pointer_category category;
       static const char* type_name() { return"iDynTree::MatrixFixSize< 4,4 >"; }
     };
   }
@@ -7812,3528 +7701,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_MatrixDynSizeVector_pop(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::value_type result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_pop",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_pop" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  try {
-    result = std_vector_Sl_iDynTree_MatrixDynSize_Sg__pop(arg1);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = SWIG_NewPointerObj((new std::vector< iDynTree::MatrixDynSize >::value_type(static_cast< const std::vector< iDynTree::MatrixDynSize >::value_type& >(result))), SWIGTYPE_p_iDynTree__MatrixDynSize, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_brace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::value_type result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_brace",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_brace" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MatrixDynSizeVector_brace" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::MatrixDynSize >::difference_type >(val2);
-  try {
-    result = std_vector_Sl_iDynTree_MatrixDynSize_Sg__brace(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = SWIG_NewPointerObj((new std::vector< iDynTree::MatrixDynSize >::value_type(static_cast< const std::vector< iDynTree::MatrixDynSize >::value_type& >(result))), SWIGTYPE_p_iDynTree__MatrixDynSize, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_setbrace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::value_type arg2 ;
-  std::vector< iDynTree::MatrixDynSize >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_setbrace",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_setbrace" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatrixDynSizeVector_setbrace" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MatrixDynSizeVector_setbrace" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type""'");
-    } else {
-      arg2 = *(reinterpret_cast< std::vector< iDynTree::MatrixDynSize >::value_type * >(argp2));
-    }
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MatrixDynSizeVector_setbrace" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< iDynTree::MatrixDynSize >::difference_type >(val3);
-  try {
-    std_vector_Sl_iDynTree_MatrixDynSize_Sg__setbrace(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_append(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::value_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_append",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_append" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatrixDynSizeVector_append" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MatrixDynSizeVector_append" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type""'");
-    } else {
-      arg2 = *(reinterpret_cast< std::vector< iDynTree::MatrixDynSize >::value_type * >(argp2));
-    }
-  }
-  std_vector_Sl_iDynTree_MatrixDynSize_Sg__append(arg1,arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_MatrixDynSizeVector__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_MatrixDynSizeVector",argc,0,0,0)) {
-    SWIG_fail;
-  }
-  (void)argv;
-  result = (std::vector< iDynTree::MatrixDynSize > *)new std::vector< iDynTree::MatrixDynSize >();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_MatrixDynSizeVector__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = 0 ;
-  int res1 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_MatrixDynSizeVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  {
-    std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > > *ptr = (std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > > *)0;
-    res1 = swig::asptr(argv[0], &ptr);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MatrixDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > const &""'"); 
-    }
-    arg1 = ptr;
-  }
-  result = (std::vector< iDynTree::MatrixDynSize > *)new std::vector< iDynTree::MatrixDynSize >((std::vector< iDynTree::MatrixDynSize > const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_empty(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_empty",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_empty" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = (bool)((std::vector< iDynTree::MatrixDynSize > const *)arg1)->empty();
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_size(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::size_type result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_size",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_size" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = ((std::vector< iDynTree::MatrixDynSize > const *)arg1)->size();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_swap(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize > *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_swap",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_swap" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatrixDynSizeVector_swap" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize > &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MatrixDynSizeVector_swap" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize > &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp2);
-  (arg1)->swap(*arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_begin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_begin",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_begin" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = (arg1)->begin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::MatrixDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_end(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_end",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_end" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = (arg1)->end();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::MatrixDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_rbegin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::reverse_iterator result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_rbegin",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_rbegin" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = (arg1)->rbegin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::MatrixDynSize >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_rend(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::reverse_iterator result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_rend",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_rend" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = (arg1)->rend();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::MatrixDynSize >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_clear(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_clear",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_clear" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  (arg1)->clear();
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_get_allocator(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  SwigValueWrapper< std::allocator< iDynTree::MatrixDynSize > > result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_get_allocator",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_get_allocator" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = ((std::vector< iDynTree::MatrixDynSize > const *)arg1)->get_allocator();
-  _out = SWIG_NewPointerObj((new std::vector< iDynTree::MatrixDynSize >::allocator_type(static_cast< const std::vector< iDynTree::MatrixDynSize >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_iDynTree__MatrixDynSize_t, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_MatrixDynSizeVector__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize >::size_type arg1 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_MatrixDynSizeVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_MatrixDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< iDynTree::MatrixDynSize >::size_type >(val1);
-  result = (std::vector< iDynTree::MatrixDynSize > *)new std::vector< iDynTree::MatrixDynSize >(arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_pop_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_pop_back",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_pop_back" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  (arg1)->pop_back();
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_resize__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_resize",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_resize" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MatrixDynSizeVector_resize" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::MatrixDynSize >::size_type >(val2);
-  (arg1)->resize(arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_erase__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::iterator arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_erase",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_erase" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-    }
-  }
-  result = std_vector_Sl_iDynTree_MatrixDynSize_Sg__erase__SWIG_0(arg1,arg2);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::MatrixDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_erase__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::iterator arg2 ;
-  std::vector< iDynTree::MatrixDynSize >::iterator arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  swig::MatlabSwigIterator *iter3 = 0 ;
-  int res3 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_erase",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_erase" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter3), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res3) || !iter3) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_erase" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter3);
-    if (iter_t) {
-      arg3 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_erase" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-    }
-  }
-  result = std_vector_Sl_iDynTree_MatrixDynSize_Sg__erase__SWIG_1(arg1,arg2,arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::MatrixDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_erase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter) != 0));
-      if (_v) {
-        return _wrap_MatrixDynSizeVector_erase__SWIG_0(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter) != 0));
-      if (_v) {
-        swig::MatlabSwigIterator *iter = 0;
-        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter) != 0));
-        if (_v) {
-          return _wrap_MatrixDynSizeVector_erase__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'MatrixDynSizeVector_erase'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::MatrixDynSize >::erase(std::vector< iDynTree::MatrixDynSize >::iterator)\n"
-    "    std::vector< iDynTree::MatrixDynSize >::erase(std::vector< iDynTree::MatrixDynSize >::iterator,std::vector< iDynTree::MatrixDynSize >::iterator)\n");
-  return 1;
-}
-
-
-int _wrap_new_MatrixDynSizeVector__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize >::size_type arg1 ;
-  std::vector< iDynTree::MatrixDynSize >::value_type *arg2 = 0 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_MatrixDynSizeVector",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_MatrixDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< iDynTree::MatrixDynSize >::size_type >(val1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_MatrixDynSizeVector" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixDynSizeVector" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize >::value_type * >(argp2);
-  result = (std::vector< iDynTree::MatrixDynSize > *)new std::vector< iDynTree::MatrixDynSize >(arg1,(std::vector< iDynTree::MatrixDynSize >::value_type const &)*arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_MatrixDynSizeVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_MatrixDynSizeVector__SWIG_0(resc,resv,argc,argv);
-  }
-  if (argc == 1) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      return _wrap_new_MatrixDynSizeVector__SWIG_2(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_MatrixDynSizeVector__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__MatrixDynSize, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_new_MatrixDynSizeVector__SWIG_3(resc,resv,argc,argv);
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_MatrixDynSizeVector'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::MatrixDynSize >::vector()\n"
-    "    std::vector< iDynTree::MatrixDynSize >::vector(std::vector< iDynTree::MatrixDynSize > const &)\n"
-    "    std::vector< iDynTree::MatrixDynSize >::vector(std::vector< iDynTree::MatrixDynSize >::size_type)\n"
-    "    std::vector< iDynTree::MatrixDynSize >::vector(std::vector< iDynTree::MatrixDynSize >::size_type,std::vector< iDynTree::MatrixDynSize >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_push_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_push_back",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_push_back" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MatrixDynSizeVector_push_back" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MatrixDynSizeVector_push_back" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize >::value_type * >(argp2);
-  (arg1)->push_back((std::vector< iDynTree::MatrixDynSize >::value_type const &)*arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_front(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::value_type *result = 0 ;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_front",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_front" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = (std::vector< iDynTree::MatrixDynSize >::value_type *) &((std::vector< iDynTree::MatrixDynSize > const *)arg1)->front();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__MatrixDynSize, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::value_type *result = 0 ;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_back",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_back" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = (std::vector< iDynTree::MatrixDynSize >::value_type *) &((std::vector< iDynTree::MatrixDynSize > const *)arg1)->back();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__MatrixDynSize, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_assign(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::size_type arg2 ;
-  std::vector< iDynTree::MatrixDynSize >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_assign",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_assign" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MatrixDynSizeVector_assign" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::MatrixDynSize >::size_type >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MatrixDynSizeVector_assign" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MatrixDynSizeVector_assign" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize >::value_type * >(argp3);
-  (arg1)->assign(arg2,(std::vector< iDynTree::MatrixDynSize >::value_type const &)*arg3);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_resize__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::size_type arg2 ;
-  std::vector< iDynTree::MatrixDynSize >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_resize",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_resize" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MatrixDynSizeVector_resize" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::MatrixDynSize >::size_type >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MatrixDynSizeVector_resize" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MatrixDynSizeVector_resize" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize >::value_type * >(argp3);
-  (arg1)->resize(arg2,(std::vector< iDynTree::MatrixDynSize >::value_type const &)*arg3);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_MatrixDynSizeVector_resize__SWIG_0(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__MatrixDynSize, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_MatrixDynSizeVector_resize__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'MatrixDynSizeVector_resize'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::MatrixDynSize >::resize(std::vector< iDynTree::MatrixDynSize >::size_type)\n"
-    "    std::vector< iDynTree::MatrixDynSize >::resize(std::vector< iDynTree::MatrixDynSize >::size_type,std::vector< iDynTree::MatrixDynSize >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_insert__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::iterator arg2 ;
-  std::vector< iDynTree::MatrixDynSize >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_insert",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_insert" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MatrixDynSizeVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MatrixDynSizeVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize >::value_type * >(argp3);
-  result = std_vector_Sl_iDynTree_MatrixDynSize_Sg__insert__SWIG_0(arg1,arg2,(iDynTree::MatrixDynSize const &)*arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::MatrixDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_insert__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::iterator arg2 ;
-  std::vector< iDynTree::MatrixDynSize >::size_type arg3 ;
-  std::vector< iDynTree::MatrixDynSize >::value_type *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_insert",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_insert" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "MatrixDynSizeVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MatrixDynSizeVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize >::size_type""'");
-  } 
-  arg3 = static_cast< std::vector< iDynTree::MatrixDynSize >::size_type >(val3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "MatrixDynSizeVector_insert" "', argument " "4"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MatrixDynSizeVector_insert" "', argument " "4"" of type '" "std::vector< iDynTree::MatrixDynSize >::value_type const &""'"); 
-  }
-  arg4 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize >::value_type * >(argp4);
-  std_vector_Sl_iDynTree_MatrixDynSize_Sg__insert__SWIG_1(arg1,arg2,arg3,(iDynTree::MatrixDynSize const &)*arg4);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_insert(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter) != 0));
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__MatrixDynSize, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_MatrixDynSizeVector_insert__SWIG_0(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::MatrixDynSize >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_size_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__MatrixDynSize, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_MatrixDynSizeVector_insert__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'MatrixDynSizeVector_insert'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::MatrixDynSize >::insert(std::vector< iDynTree::MatrixDynSize >::iterator,std::vector< iDynTree::MatrixDynSize >::value_type const &)\n"
-    "    std::vector< iDynTree::MatrixDynSize >::insert(std::vector< iDynTree::MatrixDynSize >::iterator,std::vector< iDynTree::MatrixDynSize >::size_type,std::vector< iDynTree::MatrixDynSize >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_reserve(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  std::vector< iDynTree::MatrixDynSize >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_reserve",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_reserve" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MatrixDynSizeVector_reserve" "', argument " "2"" of type '" "std::vector< iDynTree::MatrixDynSize >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::MatrixDynSize >::size_type >(val2);
-  (arg1)->reserve(arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_MatrixDynSizeVector_capacity(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::MatrixDynSize >::size_type result;
-  
-  if (!SWIG_check_num_args("MatrixDynSizeVector_capacity",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MatrixDynSizeVector_capacity" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  result = ((std::vector< iDynTree::MatrixDynSize > const *)arg1)->capacity();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_delete_MatrixDynSizeVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::MatrixDynSize > *arg1 = (std::vector< iDynTree::MatrixDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  int is_owned;
-  if (!SWIG_check_num_args("delete_MatrixDynSizeVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MatrixDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::MatrixDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize > * >(argp1);
-  if (is_owned) {
-    delete arg1;
-  }
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_pop(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::value_type result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_pop",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_pop" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  try {
-    result = std_vector_Sl_iDynTree_VectorDynSize_Sg__pop(arg1);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = SWIG_NewPointerObj((new std::vector< iDynTree::VectorDynSize >::value_type(static_cast< const std::vector< iDynTree::VectorDynSize >::value_type& >(result))), SWIGTYPE_p_iDynTree__VectorDynSize, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_brace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::value_type result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_brace",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_brace" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VectorDynSizeVector_brace" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::VectorDynSize >::difference_type >(val2);
-  try {
-    result = std_vector_Sl_iDynTree_VectorDynSize_Sg__brace(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = SWIG_NewPointerObj((new std::vector< iDynTree::VectorDynSize >::value_type(static_cast< const std::vector< iDynTree::VectorDynSize >::value_type& >(result))), SWIGTYPE_p_iDynTree__VectorDynSize, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_setbrace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::value_type arg2 ;
-  std::vector< iDynTree::VectorDynSize >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_setbrace",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_setbrace" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorDynSizeVector_setbrace" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorDynSizeVector_setbrace" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type""'");
-    } else {
-      arg2 = *(reinterpret_cast< std::vector< iDynTree::VectorDynSize >::value_type * >(argp2));
-    }
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VectorDynSizeVector_setbrace" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< iDynTree::VectorDynSize >::difference_type >(val3);
-  try {
-    std_vector_Sl_iDynTree_VectorDynSize_Sg__setbrace(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_append(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::value_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_append",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_append" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  {
-    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorDynSizeVector_append" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type""'"); 
-    }  
-    if (!argp2) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorDynSizeVector_append" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type""'");
-    } else {
-      arg2 = *(reinterpret_cast< std::vector< iDynTree::VectorDynSize >::value_type * >(argp2));
-    }
-  }
-  std_vector_Sl_iDynTree_VectorDynSize_Sg__append(arg1,arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_VectorDynSizeVector__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_VectorDynSizeVector",argc,0,0,0)) {
-    SWIG_fail;
-  }
-  (void)argv;
-  result = (std::vector< iDynTree::VectorDynSize > *)new std::vector< iDynTree::VectorDynSize >();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_VectorDynSizeVector__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = 0 ;
-  int res1 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_VectorDynSizeVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  {
-    std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > > *ptr = (std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > > *)0;
-    res1 = swig::asptr(argv[0], &ptr);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_VectorDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VectorDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > const &""'"); 
-    }
-    arg1 = ptr;
-  }
-  result = (std::vector< iDynTree::VectorDynSize > *)new std::vector< iDynTree::VectorDynSize >((std::vector< iDynTree::VectorDynSize > const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_empty(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_empty",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_empty" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = (bool)((std::vector< iDynTree::VectorDynSize > const *)arg1)->empty();
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_size(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::size_type result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_size",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_size" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = ((std::vector< iDynTree::VectorDynSize > const *)arg1)->size();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_swap(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize > *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_swap",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_swap" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorDynSizeVector_swap" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize > &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorDynSizeVector_swap" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize > &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp2);
-  (arg1)->swap(*arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_begin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_begin",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_begin" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = (arg1)->begin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::VectorDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_end(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_end",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_end" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = (arg1)->end();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::VectorDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_rbegin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::reverse_iterator result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_rbegin",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_rbegin" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = (arg1)->rbegin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::VectorDynSize >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_rend(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::reverse_iterator result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_rend",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_rend" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = (arg1)->rend();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::VectorDynSize >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_clear(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_clear",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_clear" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  (arg1)->clear();
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_get_allocator(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  SwigValueWrapper< std::allocator< iDynTree::VectorDynSize > > result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_get_allocator",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_get_allocator" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = ((std::vector< iDynTree::VectorDynSize > const *)arg1)->get_allocator();
-  _out = SWIG_NewPointerObj((new std::vector< iDynTree::VectorDynSize >::allocator_type(static_cast< const std::vector< iDynTree::VectorDynSize >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_iDynTree__VectorDynSize_t, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_VectorDynSizeVector__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize >::size_type arg1 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_VectorDynSizeVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VectorDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< iDynTree::VectorDynSize >::size_type >(val1);
-  result = (std::vector< iDynTree::VectorDynSize > *)new std::vector< iDynTree::VectorDynSize >(arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_pop_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_pop_back",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_pop_back" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  (arg1)->pop_back();
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_resize__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_resize",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_resize" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VectorDynSizeVector_resize" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::VectorDynSize >::size_type >(val2);
-  (arg1)->resize(arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_erase__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::iterator arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_erase",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_erase" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-    }
-  }
-  result = std_vector_Sl_iDynTree_VectorDynSize_Sg__erase__SWIG_0(arg1,arg2);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::VectorDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_erase__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::iterator arg2 ;
-  std::vector< iDynTree::VectorDynSize >::iterator arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  swig::MatlabSwigIterator *iter3 = 0 ;
-  int res3 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_erase",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_erase" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter3), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res3) || !iter3) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_erase" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter3);
-    if (iter_t) {
-      arg3 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_erase" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-    }
-  }
-  result = std_vector_Sl_iDynTree_VectorDynSize_Sg__erase__SWIG_1(arg1,arg2,arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::VectorDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_erase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter) != 0));
-      if (_v) {
-        return _wrap_VectorDynSizeVector_erase__SWIG_0(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter) != 0));
-      if (_v) {
-        swig::MatlabSwigIterator *iter = 0;
-        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter) != 0));
-        if (_v) {
-          return _wrap_VectorDynSizeVector_erase__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'VectorDynSizeVector_erase'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::VectorDynSize >::erase(std::vector< iDynTree::VectorDynSize >::iterator)\n"
-    "    std::vector< iDynTree::VectorDynSize >::erase(std::vector< iDynTree::VectorDynSize >::iterator,std::vector< iDynTree::VectorDynSize >::iterator)\n");
-  return 1;
-}
-
-
-int _wrap_new_VectorDynSizeVector__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize >::size_type arg1 ;
-  std::vector< iDynTree::VectorDynSize >::value_type *arg2 = 0 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_VectorDynSizeVector",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_VectorDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< iDynTree::VectorDynSize >::size_type >(val1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_VectorDynSizeVector" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_VectorDynSizeVector" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< iDynTree::VectorDynSize >::value_type * >(argp2);
-  result = (std::vector< iDynTree::VectorDynSize > *)new std::vector< iDynTree::VectorDynSize >(arg1,(std::vector< iDynTree::VectorDynSize >::value_type const &)*arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_VectorDynSizeVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_VectorDynSizeVector__SWIG_0(resc,resv,argc,argv);
-  }
-  if (argc == 1) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      return _wrap_new_VectorDynSizeVector__SWIG_2(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_VectorDynSizeVector__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__VectorDynSize, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_new_VectorDynSizeVector__SWIG_3(resc,resv,argc,argv);
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_VectorDynSizeVector'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::VectorDynSize >::vector()\n"
-    "    std::vector< iDynTree::VectorDynSize >::vector(std::vector< iDynTree::VectorDynSize > const &)\n"
-    "    std::vector< iDynTree::VectorDynSize >::vector(std::vector< iDynTree::VectorDynSize >::size_type)\n"
-    "    std::vector< iDynTree::VectorDynSize >::vector(std::vector< iDynTree::VectorDynSize >::size_type,std::vector< iDynTree::VectorDynSize >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_push_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_push_back",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_push_back" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "VectorDynSizeVector_push_back" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorDynSizeVector_push_back" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< iDynTree::VectorDynSize >::value_type * >(argp2);
-  (arg1)->push_back((std::vector< iDynTree::VectorDynSize >::value_type const &)*arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_front(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::value_type *result = 0 ;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_front",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_front" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = (std::vector< iDynTree::VectorDynSize >::value_type *) &((std::vector< iDynTree::VectorDynSize > const *)arg1)->front();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__VectorDynSize, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::value_type *result = 0 ;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_back",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_back" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = (std::vector< iDynTree::VectorDynSize >::value_type *) &((std::vector< iDynTree::VectorDynSize > const *)arg1)->back();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__VectorDynSize, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_assign(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::size_type arg2 ;
-  std::vector< iDynTree::VectorDynSize >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_assign",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_assign" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VectorDynSizeVector_assign" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::VectorDynSize >::size_type >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorDynSizeVector_assign" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorDynSizeVector_assign" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< iDynTree::VectorDynSize >::value_type * >(argp3);
-  (arg1)->assign(arg2,(std::vector< iDynTree::VectorDynSize >::value_type const &)*arg3);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_resize__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::size_type arg2 ;
-  std::vector< iDynTree::VectorDynSize >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_resize",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_resize" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VectorDynSizeVector_resize" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::VectorDynSize >::size_type >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorDynSizeVector_resize" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorDynSizeVector_resize" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< iDynTree::VectorDynSize >::value_type * >(argp3);
-  (arg1)->resize(arg2,(std::vector< iDynTree::VectorDynSize >::value_type const &)*arg3);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_VectorDynSizeVector_resize__SWIG_0(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__VectorDynSize, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_VectorDynSizeVector_resize__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'VectorDynSizeVector_resize'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::VectorDynSize >::resize(std::vector< iDynTree::VectorDynSize >::size_type)\n"
-    "    std::vector< iDynTree::VectorDynSize >::resize(std::vector< iDynTree::VectorDynSize >::size_type,std::vector< iDynTree::VectorDynSize >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_insert__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::iterator arg2 ;
-  std::vector< iDynTree::VectorDynSize >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::iterator result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_insert",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_insert" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "VectorDynSizeVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorDynSizeVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< iDynTree::VectorDynSize >::value_type * >(argp3);
-  result = std_vector_Sl_iDynTree_VectorDynSize_Sg__insert__SWIG_0(arg1,arg2,(iDynTree::VectorDynSize const &)*arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::VectorDynSize >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_insert__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::iterator arg2 ;
-  std::vector< iDynTree::VectorDynSize >::size_type arg3 ;
-  std::vector< iDynTree::VectorDynSize >::value_type *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_insert",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_insert" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "VectorDynSizeVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "VectorDynSizeVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::VectorDynSize >::size_type""'");
-  } 
-  arg3 = static_cast< std::vector< iDynTree::VectorDynSize >::size_type >(val3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "VectorDynSizeVector_insert" "', argument " "4"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "VectorDynSizeVector_insert" "', argument " "4"" of type '" "std::vector< iDynTree::VectorDynSize >::value_type const &""'"); 
-  }
-  arg4 = reinterpret_cast< std::vector< iDynTree::VectorDynSize >::value_type * >(argp4);
-  std_vector_Sl_iDynTree_VectorDynSize_Sg__insert__SWIG_1(arg1,arg2,arg3,(iDynTree::VectorDynSize const &)*arg4);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_insert(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter) != 0));
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__VectorDynSize, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_VectorDynSizeVector_insert__SWIG_0(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::VectorDynSize >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_size_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__VectorDynSize, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_VectorDynSizeVector_insert__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'VectorDynSizeVector_insert'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::VectorDynSize >::insert(std::vector< iDynTree::VectorDynSize >::iterator,std::vector< iDynTree::VectorDynSize >::value_type const &)\n"
-    "    std::vector< iDynTree::VectorDynSize >::insert(std::vector< iDynTree::VectorDynSize >::iterator,std::vector< iDynTree::VectorDynSize >::size_type,std::vector< iDynTree::VectorDynSize >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_reserve(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  std::vector< iDynTree::VectorDynSize >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_reserve",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_reserve" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "VectorDynSizeVector_reserve" "', argument " "2"" of type '" "std::vector< iDynTree::VectorDynSize >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::VectorDynSize >::size_type >(val2);
-  (arg1)->reserve(arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_VectorDynSizeVector_capacity(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< iDynTree::VectorDynSize >::size_type result;
-  
-  if (!SWIG_check_num_args("VectorDynSizeVector_capacity",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VectorDynSizeVector_capacity" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  result = ((std::vector< iDynTree::VectorDynSize > const *)arg1)->capacity();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_delete_VectorDynSizeVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::VectorDynSize > *arg1 = (std::vector< iDynTree::VectorDynSize > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  int is_owned;
-  if (!SWIG_check_num_args("delete_VectorDynSizeVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_VectorDynSizeVector" "', argument " "1"" of type '" "std::vector< iDynTree::VectorDynSize > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::VectorDynSize > * >(argp1);
-  if (is_owned) {
-    delete arg1;
-  }
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_pop(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< ::ptrdiff_t >::value_type result;
-  
-  if (!SWIG_check_num_args("IndexVector_pop",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_pop" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  try {
-    result = std_vector_Sl_std_ptrdiff_t_Sg__pop(arg1);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_brace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< ::ptrdiff_t >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  std::vector< ::ptrdiff_t >::value_type result;
-  
-  if (!SWIG_check_num_args("IndexVector_brace",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_brace" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IndexVector_brace" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::difference_type""'");
-  } 
-  arg2 = static_cast< std::vector< ::ptrdiff_t >::difference_type >(val2);
-  try {
-    result = std_vector_Sl_std_ptrdiff_t_Sg__brace(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_setbrace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< ::ptrdiff_t >::value_type arg2 ;
-  std::vector< ::ptrdiff_t >::difference_type arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_setbrace",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_setbrace" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IndexVector_setbrace" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::value_type""'");
-  } 
-  arg2 = static_cast< std::vector< ::ptrdiff_t >::value_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IndexVector_setbrace" "', argument " "3"" of type '" "std::vector< ::ptrdiff_t >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< ::ptrdiff_t >::difference_type >(val3);
-  try {
-    std_vector_Sl_std_ptrdiff_t_Sg__setbrace(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_append(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< ::ptrdiff_t >::value_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_append",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_append" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IndexVector_append" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::value_type""'");
-  } 
-  arg2 = static_cast< std::vector< ::ptrdiff_t >::value_type >(val2);
-  std_vector_Sl_std_ptrdiff_t_Sg__append(arg1,arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_IndexVector__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  mxArray * _out;
-  std::vector< std::ptrdiff_t > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_IndexVector",argc,0,0,0)) {
-    SWIG_fail;
-  }
-  (void)argv;
-  result = (std::vector< std::ptrdiff_t > *)new std::vector< std::ptrdiff_t >();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_IndexVector__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = 0 ;
-  int res1 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  std::vector< std::ptrdiff_t > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_IndexVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  {
-    std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > > *ptr = (std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > > *)0;
-    res1 = swig::asptr(argv[0], &ptr);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_IndexVector" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IndexVector" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > const &""'"); 
-    }
-    arg1 = ptr;
-  }
-  result = (std::vector< std::ptrdiff_t > *)new std::vector< std::ptrdiff_t >((std::vector< std::ptrdiff_t > const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res1)) delete arg1;
-  return 1;
-}
-
-
-int _wrap_IndexVector_empty(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("IndexVector_empty",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_empty" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = (bool)((std::vector< std::ptrdiff_t > const *)arg1)->empty();
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_size(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< ::ptrdiff_t >::size_type result;
-  
-  if (!SWIG_check_num_args("IndexVector_size",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_size" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = ((std::vector< std::ptrdiff_t > const *)arg1)->size();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_swap(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< std::ptrdiff_t > *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_swap",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_swap" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IndexVector_swap" "', argument " "2"" of type '" "std::vector< std::ptrdiff_t > &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IndexVector_swap" "', argument " "2"" of type '" "std::vector< std::ptrdiff_t > &""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp2);
-  (arg1)->swap(*arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_begin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > result;
-  
-  if (!SWIG_check_num_args("IndexVector_begin",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_begin" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = (arg1)->begin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< ::ptrdiff_t >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_end(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > result;
-  
-  if (!SWIG_check_num_args("IndexVector_end",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_end" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = (arg1)->end();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< ::ptrdiff_t >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_rbegin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::reverse_iterator > result;
-  
-  if (!SWIG_check_num_args("IndexVector_rbegin",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_rbegin" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = (arg1)->rbegin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< ::ptrdiff_t >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_rend(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::reverse_iterator > result;
-  
-  if (!SWIG_check_num_args("IndexVector_rend",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_rend" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = (arg1)->rend();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< ::ptrdiff_t >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_clear(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_clear",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_clear" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  (arg1)->clear();
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_get_allocator(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  SwigValueWrapper< std::allocator< ::ptrdiff_t > > result;
-  
-  if (!SWIG_check_num_args("IndexVector_get_allocator",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_get_allocator" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = ((std::vector< std::ptrdiff_t > const *)arg1)->get_allocator();
-  _out = SWIG_NewPointerObj((new std::vector< ::ptrdiff_t >::allocator_type(static_cast< const std::vector< ::ptrdiff_t >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__ptrdiff_t_t, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_IndexVector__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< ::ptrdiff_t >::size_type arg1 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  mxArray * _out;
-  std::vector< std::ptrdiff_t > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_IndexVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_IndexVector" "', argument " "1"" of type '" "std::vector< ::ptrdiff_t >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< ::ptrdiff_t >::size_type >(val1);
-  result = (std::vector< std::ptrdiff_t > *)new std::vector< std::ptrdiff_t >(arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_pop_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_pop_back",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_pop_back" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  (arg1)->pop_back();
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_resize__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< ::ptrdiff_t >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_resize",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_resize" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IndexVector_resize" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< ::ptrdiff_t >::size_type >(val2);
-  (arg1)->resize(arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_erase__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  mxArray * _out;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > result;
-  
-  if (!SWIG_check_num_args("IndexVector_erase",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_erase" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_erase" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_erase" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-    }
-  }
-  result = std_vector_Sl_std_ptrdiff_t_Sg__erase__SWIG_0(arg1,arg2);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< ::ptrdiff_t >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_erase__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > arg2 ;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  swig::MatlabSwigIterator *iter3 = 0 ;
-  int res3 ;
-  mxArray * _out;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > result;
-  
-  if (!SWIG_check_num_args("IndexVector_erase",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_erase" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_erase" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_erase" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-    }
-  }
-  res3 = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter3), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res3) || !iter3) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_erase" "', argument " "3"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter3);
-    if (iter_t) {
-      arg3 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_erase" "', argument " "3"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-    }
-  }
-  result = std_vector_Sl_std_ptrdiff_t_Sg__erase__SWIG_1(arg1,arg2,arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< ::ptrdiff_t >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_erase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter) != 0));
-      if (_v) {
-        return _wrap_IndexVector_erase__SWIG_0(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter) != 0));
-      if (_v) {
-        swig::MatlabSwigIterator *iter = 0;
-        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter) != 0));
-        if (_v) {
-          return _wrap_IndexVector_erase__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'IndexVector_erase'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< std::ptrdiff_t >::erase(std::vector< ::ptrdiff_t >::iterator)\n"
-    "    std::vector< std::ptrdiff_t >::erase(std::vector< ::ptrdiff_t >::iterator,std::vector< ::ptrdiff_t >::iterator)\n");
-  return 1;
-}
-
-
-int _wrap_new_IndexVector__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< ::ptrdiff_t >::size_type arg1 ;
-  std::vector< ::ptrdiff_t >::value_type *arg2 = 0 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  std::vector< ::ptrdiff_t >::value_type temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  std::vector< std::ptrdiff_t > *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_IndexVector",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_IndexVector" "', argument " "1"" of type '" "std::vector< ::ptrdiff_t >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< ::ptrdiff_t >::size_type >(val1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_IndexVector" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::value_type""'");
-  } 
-  temp2 = static_cast< std::vector< ::ptrdiff_t >::value_type >(val2);
-  arg2 = &temp2;
-  result = (std::vector< std::ptrdiff_t > *)new std::vector< std::ptrdiff_t >(arg1,(std::vector< ::ptrdiff_t >::value_type const &)*arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_IndexVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_IndexVector__SWIG_0(resc,resv,argc,argv);
-  }
-  if (argc == 1) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      return _wrap_new_IndexVector__SWIG_2(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_IndexVector__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      {
-        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_new_IndexVector__SWIG_3(resc,resv,argc,argv);
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_IndexVector'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< std::ptrdiff_t >::vector()\n"
-    "    std::vector< std::ptrdiff_t >::vector(std::vector< std::ptrdiff_t > const &)\n"
-    "    std::vector< std::ptrdiff_t >::vector(std::vector< ::ptrdiff_t >::size_type)\n"
-    "    std::vector< std::ptrdiff_t >::vector(std::vector< ::ptrdiff_t >::size_type,std::vector< ::ptrdiff_t >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_IndexVector_push_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< ::ptrdiff_t >::value_type *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  std::vector< ::ptrdiff_t >::value_type temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_push_back",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_push_back" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IndexVector_push_back" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::value_type""'");
-  } 
-  temp2 = static_cast< std::vector< ::ptrdiff_t >::value_type >(val2);
-  arg2 = &temp2;
-  (arg1)->push_back((std::vector< ::ptrdiff_t >::value_type const &)*arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_front(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< ::ptrdiff_t >::value_type *result = 0 ;
-  
-  if (!SWIG_check_num_args("IndexVector_front",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_front" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = (std::vector< ::ptrdiff_t >::value_type *) &((std::vector< std::ptrdiff_t > const *)arg1)->front();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(*result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< ::ptrdiff_t >::value_type *result = 0 ;
-  
-  if (!SWIG_check_num_args("IndexVector_back",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_back" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = (std::vector< ::ptrdiff_t >::value_type *) &((std::vector< std::ptrdiff_t > const *)arg1)->back();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(*result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_assign(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< ::ptrdiff_t >::size_type arg2 ;
-  std::vector< ::ptrdiff_t >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  std::vector< ::ptrdiff_t >::value_type temp3 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_assign",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_assign" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IndexVector_assign" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< ::ptrdiff_t >::size_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IndexVector_assign" "', argument " "3"" of type '" "std::vector< ::ptrdiff_t >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< ::ptrdiff_t >::value_type >(val3);
-  arg3 = &temp3;
-  (arg1)->assign(arg2,(std::vector< ::ptrdiff_t >::value_type const &)*arg3);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_resize__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< ::ptrdiff_t >::size_type arg2 ;
-  std::vector< ::ptrdiff_t >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  std::vector< ::ptrdiff_t >::value_type temp3 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_resize",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_resize" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IndexVector_resize" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< ::ptrdiff_t >::size_type >(val2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IndexVector_resize" "', argument " "3"" of type '" "std::vector< ::ptrdiff_t >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< ::ptrdiff_t >::value_type >(val3);
-  arg3 = &temp3;
-  (arg1)->resize(arg2,(std::vector< ::ptrdiff_t >::value_type const &)*arg3);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_IndexVector_resize__SWIG_0(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_IndexVector_resize__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'IndexVector_resize'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< std::ptrdiff_t >::resize(std::vector< ::ptrdiff_t >::size_type)\n"
-    "    std::vector< std::ptrdiff_t >::resize(std::vector< ::ptrdiff_t >::size_type,std::vector< ::ptrdiff_t >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_IndexVector_insert__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > arg2 ;
-  std::vector< ::ptrdiff_t >::value_type *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  std::vector< ::ptrdiff_t >::value_type temp3 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > result;
-  
-  if (!SWIG_check_num_args("IndexVector_insert",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_insert" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_insert" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_insert" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IndexVector_insert" "', argument " "3"" of type '" "std::vector< ::ptrdiff_t >::value_type""'");
-  } 
-  temp3 = static_cast< std::vector< ::ptrdiff_t >::value_type >(val3);
-  arg3 = &temp3;
-  result = std_vector_Sl_std_ptrdiff_t_Sg__insert__SWIG_0(arg1,arg2,(::ptrdiff_t const &)*arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< ::ptrdiff_t >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_insert__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  SwigValueWrapper< std::vector< ::ptrdiff_t >::iterator > arg2 ;
-  std::vector< ::ptrdiff_t >::size_type arg3 ;
-  std::vector< ::ptrdiff_t >::value_type *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  std::vector< ::ptrdiff_t >::value_type temp4 ;
-  ptrdiff_t val4 ;
-  int ecode4 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_insert",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_insert" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_insert" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "IndexVector_insert" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::iterator""'");
-    }
-  }
-  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "IndexVector_insert" "', argument " "3"" of type '" "std::vector< ::ptrdiff_t >::size_type""'");
-  } 
-  arg3 = static_cast< std::vector< ::ptrdiff_t >::size_type >(val3);
-  ecode4 = SWIG_AsVal_ptrdiff_t(argv[3], &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "IndexVector_insert" "', argument " "4"" of type '" "std::vector< ::ptrdiff_t >::value_type""'");
-  } 
-  temp4 = static_cast< std::vector< ::ptrdiff_t >::value_type >(val4);
-  arg4 = &temp4;
-  std_vector_Sl_std_ptrdiff_t_Sg__insert__SWIG_1(arg1,arg2,arg3,(::ptrdiff_t const &)*arg4);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_insert(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_IndexVector_insert__SWIG_0(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< ::ptrdiff_t >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_size_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          {
-            int res = SWIG_AsVal_ptrdiff_t(argv[3], NULL);
-            _v = SWIG_CheckState(res);
-          }
-          if (_v) {
-            return _wrap_IndexVector_insert__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'IndexVector_insert'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< std::ptrdiff_t >::insert(std::vector< ::ptrdiff_t >::iterator,std::vector< ::ptrdiff_t >::value_type const &)\n"
-    "    std::vector< std::ptrdiff_t >::insert(std::vector< ::ptrdiff_t >::iterator,std::vector< ::ptrdiff_t >::size_type,std::vector< ::ptrdiff_t >::value_type const &)\n");
-  return 1;
-}
-
-
-int _wrap_IndexVector_reserve(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  std::vector< ::ptrdiff_t >::size_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("IndexVector_reserve",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_reserve" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IndexVector_reserve" "', argument " "2"" of type '" "std::vector< ::ptrdiff_t >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< ::ptrdiff_t >::size_type >(val2);
-  (arg1)->reserve(arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IndexVector_capacity(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< ::ptrdiff_t >::size_type result;
-  
-  if (!SWIG_check_num_args("IndexVector_capacity",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexVector_capacity" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > const *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  result = ((std::vector< std::ptrdiff_t > const *)arg1)->capacity();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_delete_IndexVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::ptrdiff_t > *arg1 = (std::vector< std::ptrdiff_t > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  int is_owned;
-  if (!SWIG_check_num_args("delete_IndexVector",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IndexVector" "', argument " "1"" of type '" "std::vector< std::ptrdiff_t > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::ptrdiff_t > * >(argp1);
-  if (is_owned) {
-    delete arg1;
-  }
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_BerdySensors_pop(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   std::vector< iDynTree::BerdySensor > *arg1 = (std::vector< iDynTree::BerdySensor > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   std::vector< iDynTree::BerdySensor >::value_type result;
   
@@ -26345,14 +22720,549 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
+int _wrap_new_PositionRaw__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::PositionRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_PositionRaw",argc,0,0,0)) {
+    SWIG_fail;
+  }
+  (void)argv;
+  result = (iDynTree::PositionRaw *)new iDynTree::PositionRaw();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PositionRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_PositionRaw__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_PositionRaw",argc,3,3,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_PositionRaw" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PositionRaw" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_PositionRaw" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  result = (iDynTree::PositionRaw *)new iDynTree::PositionRaw(arg1,arg2,arg3);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PositionRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_PositionRaw__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double *arg1 = (double *) 0 ;
+  unsigned int arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_PositionRaw",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PositionRaw" "', argument " "1"" of type '" "double const *""'"); 
+  }
+  arg1 = reinterpret_cast< double * >(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_PositionRaw" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = static_cast< unsigned int >(val2);
+  result = (iDynTree::PositionRaw *)new iDynTree::PositionRaw((double const *)arg1,arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PositionRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_PositionRaw__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_PositionRaw",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PositionRaw" "', argument " "1"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PositionRaw" "', argument " "1"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  result = (iDynTree::PositionRaw *)new iDynTree::PositionRaw((iDynTree::PositionRaw const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PositionRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_PositionRaw__SWIG_4(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  SwigValueWrapper< iDynTree::Span< double const,-1 > > arg1 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_PositionRaw",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  {
+    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SpanT_double_const__1_t,  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PositionRaw" "', argument " "1"" of type '" "iDynTree::Span< double const,-1 >""'"); 
+    }  
+    if (!argp1) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PositionRaw" "', argument " "1"" of type '" "iDynTree::Span< double const,-1 >""'");
+    } else {
+      arg1 = *(reinterpret_cast< iDynTree::Span< double const,-1 > * >(argp1));
+    }
+  }
+  result = (iDynTree::PositionRaw *)new iDynTree::PositionRaw(arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PositionRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_PositionRaw(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_PositionRaw__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__PositionRaw, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_PositionRaw__SWIG_3(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SpanT_double_const__1_t, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_PositionRaw__SWIG_4(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_double, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_new_PositionRaw__SWIG_2(resc,resv,argc,argv);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          return _wrap_new_PositionRaw__SWIG_1(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_PositionRaw'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::PositionRaw::PositionRaw()\n"
+    "    iDynTree::PositionRaw::PositionRaw(double,double,double)\n"
+    "    iDynTree::PositionRaw::PositionRaw(double const *,unsigned int const)\n"
+    "    iDynTree::PositionRaw::PositionRaw(iDynTree::PositionRaw const &)\n"
+    "    iDynTree::PositionRaw::PositionRaw(iDynTree::Span< double const,-1 >)\n");
+  return 1;
+}
+
+
+int _wrap_PositionRaw_changePoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = (iDynTree::PositionRaw *) 0 ;
+  iDynTree::PositionRaw *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("PositionRaw_changePoint",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PositionRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PositionRaw_changePoint" "', argument " "1"" of type '" "iDynTree::PositionRaw *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PositionRaw_changePoint" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PositionRaw_changePoint" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::PositionRaw * >(argp2);
+  result = (iDynTree::PositionRaw *) &(arg1)->changePoint((iDynTree::PositionRaw const &)*arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PositionRaw, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_PositionRaw_changeRefPoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = (iDynTree::PositionRaw *) 0 ;
+  iDynTree::PositionRaw *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("PositionRaw_changeRefPoint",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PositionRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PositionRaw_changeRefPoint" "', argument " "1"" of type '" "iDynTree::PositionRaw *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PositionRaw_changeRefPoint" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PositionRaw_changeRefPoint" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::PositionRaw * >(argp2);
+  result = (iDynTree::PositionRaw *) &(arg1)->changeRefPoint((iDynTree::PositionRaw const &)*arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PositionRaw, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_PositionRaw_compose(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = 0 ;
+  iDynTree::PositionRaw *arg2 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw result;
+  
+  if (!SWIG_check_num_args("PositionRaw_compose",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PositionRaw_compose" "', argument " "1"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PositionRaw_compose" "', argument " "1"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PositionRaw_compose" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PositionRaw_compose" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::PositionRaw * >(argp2);
+  result = iDynTree::PositionRaw::compose((iDynTree::PositionRaw const &)*arg1,(iDynTree::PositionRaw const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::PositionRaw(static_cast< const iDynTree::PositionRaw& >(result))), SWIGTYPE_p_iDynTree__PositionRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_PositionRaw_inverse(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw result;
+  
+  if (!SWIG_check_num_args("PositionRaw_inverse",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PositionRaw_inverse" "', argument " "1"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PositionRaw_inverse" "', argument " "1"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  result = iDynTree::PositionRaw::inverse((iDynTree::PositionRaw const &)*arg1);
+  _out = SWIG_NewPointerObj((new iDynTree::PositionRaw(static_cast< const iDynTree::PositionRaw& >(result))), SWIGTYPE_p_iDynTree__PositionRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_PositionRaw_changePointOf__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = (iDynTree::PositionRaw *) 0 ;
+  iDynTree::SpatialMotionVector *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::SpatialMotionVector result;
+  
+  if (!SWIG_check_num_args("PositionRaw_changePointOf",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PositionRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PositionRaw_changePointOf" "', argument " "1"" of type '" "iDynTree::PositionRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialMotionVector,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PositionRaw_changePointOf" "', argument " "2"" of type '" "iDynTree::SpatialMotionVector const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PositionRaw_changePointOf" "', argument " "2"" of type '" "iDynTree::SpatialMotionVector const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::SpatialMotionVector * >(argp2);
+  result = ((iDynTree::PositionRaw const *)arg1)->changePointOf((iDynTree::SpatialMotionVector const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::SpatialMotionVector(static_cast< const iDynTree::SpatialMotionVector& >(result))), SWIGTYPE_p_iDynTree__SpatialMotionVector, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_PositionRaw_changePointOf__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = (iDynTree::PositionRaw *) 0 ;
+  iDynTree::SpatialForceVector *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::SpatialForceVector result;
+  
+  if (!SWIG_check_num_args("PositionRaw_changePointOf",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PositionRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PositionRaw_changePointOf" "', argument " "1"" of type '" "iDynTree::PositionRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialForceVector,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PositionRaw_changePointOf" "', argument " "2"" of type '" "iDynTree::SpatialForceVector const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PositionRaw_changePointOf" "', argument " "2"" of type '" "iDynTree::SpatialForceVector const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::SpatialForceVector * >(argp2);
+  result = ((iDynTree::PositionRaw const *)arg1)->changePointOf((iDynTree::SpatialForceVector const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::SpatialForceVector(static_cast< const iDynTree::SpatialForceVector& >(result))), SWIGTYPE_p_iDynTree__SpatialForceVector, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_PositionRaw_changePointOf(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__PositionRaw, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__SpatialMotionVector, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_PositionRaw_changePointOf__SWIG_0(resc,resv,argc,argv);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__PositionRaw, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__SpatialForceVector, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_PositionRaw_changePointOf__SWIG_1(resc,resv,argc,argv);
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'PositionRaw_changePointOf'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::PositionRaw::changePointOf(iDynTree::SpatialMotionVector const &) const\n"
+    "    iDynTree::PositionRaw::changePointOf(iDynTree::SpatialForceVector const &) const\n");
+  return 1;
+}
+
+
+int _wrap_PositionRaw_toString(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = (iDynTree::PositionRaw *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  std::string result;
+  
+  if (!SWIG_check_num_args("PositionRaw_toString",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PositionRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PositionRaw_toString" "', argument " "1"" of type '" "iDynTree::PositionRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  result = ((iDynTree::PositionRaw const *)arg1)->toString();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_PositionRaw_display(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = (iDynTree::PositionRaw *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  std::string result;
+  
+  if (!SWIG_check_num_args("PositionRaw_display",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PositionRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PositionRaw_display" "', argument " "1"" of type '" "iDynTree::PositionRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  result = ((iDynTree::PositionRaw const *)arg1)->reservedToString();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_delete_PositionRaw(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::PositionRaw *arg1 = (iDynTree::PositionRaw *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  
+  int is_owned;
+  if (!SWIG_check_num_args("delete_PositionRaw",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PositionRaw, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PositionRaw" "', argument " "1"" of type '" "iDynTree::PositionRaw *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  if (is_owned) {
+    delete arg1;
+  }
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
 int _wrap_new_Position__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
   iDynTree::Position *result = 0 ;
   
   if (!SWIG_check_num_args("new_Position",argc,0,0,0)) {
     SWIG_fail;
   }
@@ -26430,37 +23340,32 @@
   return 0;
 fail:
   return 1;
 }
 
 
 int _wrap_new_Position__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  double *arg1 = (double *) 0 ;
-  unsigned int arg2 ;
-  void *argp1 = 0 ;
+  iDynTree::PositionRaw *arg1 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
-  unsigned int val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
   iDynTree::Position *result = 0 ;
   
-  if (!SWIG_check_num_args("new_Position",argc,2,2,0)) {
+  if (!SWIG_check_num_args("new_Position",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Position" "', argument " "1"" of type '" "double const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Position" "', argument " "1"" of type '" "iDynTree::PositionRaw const &""'"); 
   }
-  arg1 = reinterpret_cast< double * >(argp1);
-  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Position" "', argument " "2"" of type '" "unsigned int""'");
-  } 
-  arg2 = static_cast< unsigned int >(val2);
-  result = (iDynTree::Position *)new iDynTree::Position((double const *)arg1,arg2);
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Position" "', argument " "1"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::PositionRaw * >(argp1);
+  result = (iDynTree::Position *)new iDynTree::Position((iDynTree::PositionRaw const &)*arg1);
   _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Position, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
@@ -26507,33 +23412,27 @@
     if (_v) {
       return _wrap_new_Position__SWIG_2(resc,resv,argc,argv);
     }
   }
   if (argc == 1) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SpanT_double_const__1_t, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__PositionRaw, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      return _wrap_new_Position__SWIG_4(resc,resv,argc,argv);
+      return _wrap_new_Position__SWIG_3(resc,resv,argc,argv);
     }
   }
-  if (argc == 2) {
+  if (argc == 1) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_double, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SpanT_double_const__1_t, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      {
-        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_new_Position__SWIG_3(resc,resv,argc,argv);
-      }
+      return _wrap_new_Position__SWIG_4(resc,resv,argc,argv);
     }
   }
   if (argc == 3) {
     int _v;
     {
       int res = SWIG_AsVal_double(argv[0], NULL);
       _v = SWIG_CheckState(res);
@@ -26556,15 +23455,15 @@
   }
   
   SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_Position'."
     "  Possible C/C++ prototypes are:\n"
     "    iDynTree::Position::Position()\n"
     "    iDynTree::Position::Position(double,double,double)\n"
     "    iDynTree::Position::Position(iDynTree::Position const &)\n"
-    "    iDynTree::Position::Position(double const *,unsigned int const)\n"
+    "    iDynTree::Position::Position(iDynTree::PositionRaw const &)\n"
     "    iDynTree::Position::Position(iDynTree::Span< double const,-1 >)\n");
   return 1;
 }
 
 
 int _wrap_Position_changePoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Position *arg1 = (iDynTree::Position *) 0 ;
@@ -31691,15 +28590,15 @@
     "    iDynTree::ClassicalAcc::ClassicalAcc(iDynTree::ClassicalAcc const &)\n");
   return 1;
 }
 
 
 int _wrap_ClassicalAcc_changeCoordFrame(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ClassicalAcc *arg1 = (iDynTree::ClassicalAcc *) 0 ;
-  iDynTree::Rotation *arg2 = 0 ;
+  iDynTree::RotationRaw *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
   iDynTree::ClassicalAcc *result = 0 ;
   
@@ -31707,23 +28606,23 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ClassicalAcc, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClassicalAcc_changeCoordFrame" "', argument " "1"" of type '" "iDynTree::ClassicalAcc *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::ClassicalAcc * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Rotation,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationRaw,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ClassicalAcc_changeCoordFrame" "', argument " "2"" of type '" "iDynTree::Rotation const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ClassicalAcc_changeCoordFrame" "', argument " "2"" of type '" "iDynTree::RotationRaw const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ClassicalAcc_changeCoordFrame" "', argument " "2"" of type '" "iDynTree::Rotation const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ClassicalAcc_changeCoordFrame" "', argument " "2"" of type '" "iDynTree::RotationRaw const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Rotation * >(argp2);
-  result = (iDynTree::ClassicalAcc *) &(arg1)->changeCoordFrame((iDynTree::Rotation const &)*arg2);
+  arg2 = reinterpret_cast< iDynTree::RotationRaw * >(argp2);
+  result = (iDynTree::ClassicalAcc *) &(arg1)->changeCoordFrame((iDynTree::RotationRaw const &)*arg2);
   _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ClassicalAcc, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
@@ -32958,109 +29857,109 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_RotationalInertia__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_RotationalInertiaRaw__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  iDynTree::RotationalInertia *result = 0 ;
+  iDynTree::RotationalInertiaRaw *result = 0 ;
   
-  if (!SWIG_check_num_args("new_RotationalInertia",argc,0,0,0)) {
+  if (!SWIG_check_num_args("new_RotationalInertiaRaw",argc,0,0,0)) {
     SWIG_fail;
   }
   (void)argv;
-  result = (iDynTree::RotationalInertia *)new iDynTree::RotationalInertia();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationalInertia, 1 |  0 );
+  result = (iDynTree::RotationalInertiaRaw *)new iDynTree::RotationalInertiaRaw();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_RotationalInertia__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_RotationalInertiaRaw__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   double *arg1 = (double *) 0 ;
   unsigned int arg2 ;
   unsigned int arg3 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   unsigned int val2 ;
   int ecode2 = 0 ;
   unsigned int val3 ;
   int ecode3 = 0 ;
   mxArray * _out;
-  iDynTree::RotationalInertia *result = 0 ;
+  iDynTree::RotationalInertiaRaw *result = 0 ;
   
-  if (!SWIG_check_num_args("new_RotationalInertia",argc,3,3,0)) {
+  if (!SWIG_check_num_args("new_RotationalInertiaRaw",argc,3,3,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RotationalInertia" "', argument " "1"" of type '" "double const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RotationalInertiaRaw" "', argument " "1"" of type '" "double const *""'"); 
   }
   arg1 = reinterpret_cast< double * >(argp1);
   ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_RotationalInertia" "', argument " "2"" of type '" "unsigned int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_RotationalInertiaRaw" "', argument " "2"" of type '" "unsigned int""'");
   } 
   arg2 = static_cast< unsigned int >(val2);
   ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
   if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_RotationalInertia" "', argument " "3"" of type '" "unsigned int""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_RotationalInertiaRaw" "', argument " "3"" of type '" "unsigned int""'");
   } 
   arg3 = static_cast< unsigned int >(val3);
-  result = (iDynTree::RotationalInertia *)new iDynTree::RotationalInertia((double const *)arg1,arg2,arg3);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationalInertia, 1 |  0 );
+  result = (iDynTree::RotationalInertiaRaw *)new iDynTree::RotationalInertiaRaw((double const *)arg1,arg2,arg3);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_RotationalInertia__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::RotationalInertia *arg1 = 0 ;
+int _wrap_new_RotationalInertiaRaw__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationalInertiaRaw *arg1 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::RotationalInertia *result = 0 ;
+  iDynTree::RotationalInertiaRaw *result = 0 ;
   
-  if (!SWIG_check_num_args("new_RotationalInertia",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_RotationalInertiaRaw",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__RotationalInertia,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__RotationalInertiaRaw,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RotationalInertia" "', argument " "1"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RotationalInertiaRaw" "', argument " "1"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RotationalInertia" "', argument " "1"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RotationalInertiaRaw" "', argument " "1"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::RotationalInertia * >(argp1);
-  result = (iDynTree::RotationalInertia *)new iDynTree::RotationalInertia((iDynTree::RotationalInertia const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationalInertia, 1 |  0 );
+  arg1 = reinterpret_cast< iDynTree::RotationalInertiaRaw * >(argp1);
+  result = (iDynTree::RotationalInertiaRaw *)new iDynTree::RotationalInertiaRaw((iDynTree::RotationalInertiaRaw const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_RotationalInertia(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_RotationalInertiaRaw(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   if (argc == 0) {
-    return _wrap_new_RotationalInertia__SWIG_0(resc,resv,argc,argv);
+    return _wrap_new_RotationalInertiaRaw__SWIG_0(resc,resv,argc,argv);
   }
   if (argc == 1) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__RotationalInertia, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      return _wrap_new_RotationalInertia__SWIG_2(resc,resv,argc,argv);
+      return _wrap_new_RotationalInertiaRaw__SWIG_2(resc,resv,argc,argv);
     }
   }
   if (argc == 3) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_double, 0);
     _v = SWIG_CheckState(res);
@@ -33071,451 +29970,686 @@
       }
       if (_v) {
         {
           int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
           _v = SWIG_CheckState(res);
         }
         if (_v) {
-          return _wrap_new_RotationalInertia__SWIG_1(resc,resv,argc,argv);
+          return _wrap_new_RotationalInertiaRaw__SWIG_1(resc,resv,argc,argv);
         }
       }
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_RotationalInertia'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_RotationalInertiaRaw'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::RotationalInertia::RotationalInertia()\n"
-    "    iDynTree::RotationalInertia::RotationalInertia(double const *,unsigned int const,unsigned int const)\n"
-    "    iDynTree::RotationalInertia::RotationalInertia(iDynTree::RotationalInertia const &)\n");
+    "    iDynTree::RotationalInertiaRaw::RotationalInertiaRaw()\n"
+    "    iDynTree::RotationalInertiaRaw::RotationalInertiaRaw(double const *,unsigned int const,unsigned int const)\n"
+    "    iDynTree::RotationalInertiaRaw::RotationalInertiaRaw(iDynTree::RotationalInertiaRaw const &)\n");
   return 1;
 }
 
 
-int _wrap_RotationalInertia_Zero(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_RotationalInertiaRaw_Zero(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  iDynTree::RotationalInertia result;
+  iDynTree::RotationalInertiaRaw result;
   
-  if (!SWIG_check_num_args("RotationalInertia_Zero",argc,0,0,0)) {
+  if (!SWIG_check_num_args("RotationalInertiaRaw_Zero",argc,0,0,0)) {
     SWIG_fail;
   }
   (void)argv;
-  result = iDynTree::RotationalInertia::Zero();
-  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertia(static_cast< const iDynTree::RotationalInertia& >(result))), SWIGTYPE_p_iDynTree__RotationalInertia, SWIG_POINTER_OWN |  0 );
+  result = iDynTree::RotationalInertiaRaw::Zero();
+  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertiaRaw(static_cast< const iDynTree::RotationalInertiaRaw& >(result))), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_delete_RotationalInertia(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::RotationalInertia *arg1 = (iDynTree::RotationalInertia *) 0 ;
+int _wrap_delete_RotationalInertiaRaw(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationalInertiaRaw *arg1 = (iDynTree::RotationalInertiaRaw *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   
   int is_owned;
-  if (!SWIG_check_num_args("delete_RotationalInertia",argc,1,1,0)) {
+  if (!SWIG_check_num_args("delete_RotationalInertiaRaw",argc,1,1,0)) {
     SWIG_fail;
   }
   is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationalInertia, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationalInertiaRaw, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RotationalInertia" "', argument " "1"" of type '" "iDynTree::RotationalInertia *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RotationalInertiaRaw" "', argument " "1"" of type '" "iDynTree::RotationalInertiaRaw *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::RotationalInertia * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::RotationalInertiaRaw * >(argp1);
   if (is_owned) {
     delete arg1;
   }
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SpatialInertia__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_SpatialInertiaRaw__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  iDynTree::SpatialInertia *result = 0 ;
+  iDynTree::SpatialInertiaRaw *result = 0 ;
   
-  if (!SWIG_check_num_args("new_SpatialInertia",argc,0,0,0)) {
+  if (!SWIG_check_num_args("new_SpatialInertiaRaw",argc,0,0,0)) {
     SWIG_fail;
   }
   (void)argv;
-  result = (iDynTree::SpatialInertia *)new iDynTree::SpatialInertia();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertia, 1 |  0 );
+  result = (iDynTree::SpatialInertiaRaw *)new iDynTree::SpatialInertiaRaw();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SpatialInertia__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_SpatialInertiaRaw__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   double arg1 ;
-  iDynTree::Position *arg2 = 0 ;
-  iDynTree::RotationalInertia *arg3 = 0 ;
+  iDynTree::PositionRaw *arg2 = 0 ;
+  iDynTree::RotationalInertiaRaw *arg3 = 0 ;
   double val1 ;
   int ecode1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   void *argp3 ;
   int res3 = 0 ;
   mxArray * _out;
-  iDynTree::SpatialInertia *result = 0 ;
+  iDynTree::SpatialInertiaRaw *result = 0 ;
   
-  if (!SWIG_check_num_args("new_SpatialInertia",argc,3,3,0)) {
+  if (!SWIG_check_num_args("new_SpatialInertiaRaw",argc,3,3,0)) {
     SWIG_fail;
   }
   ecode1 = SWIG_AsVal_double(argv[0], &val1);
   if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SpatialInertia" "', argument " "1"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SpatialInertiaRaw" "', argument " "1"" of type '" "double""'");
   } 
   arg1 = static_cast< double >(val1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Position,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_SpatialInertia" "', argument " "2"" of type '" "iDynTree::Position const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_SpatialInertiaRaw" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertia" "', argument " "2"" of type '" "iDynTree::Position const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertiaRaw" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Position * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__RotationalInertia,  0 );
+  arg2 = reinterpret_cast< iDynTree::PositionRaw * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__RotationalInertiaRaw,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_SpatialInertia" "', argument " "3"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_SpatialInertiaRaw" "', argument " "3"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertia" "', argument " "3"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertiaRaw" "', argument " "3"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::RotationalInertia * >(argp3);
-  result = (iDynTree::SpatialInertia *)new iDynTree::SpatialInertia(arg1,(iDynTree::Position const &)*arg2,(iDynTree::RotationalInertia const &)*arg3);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertia, 1 |  0 );
+  arg3 = reinterpret_cast< iDynTree::RotationalInertiaRaw * >(argp3);
+  result = (iDynTree::SpatialInertiaRaw *)new iDynTree::SpatialInertiaRaw(arg1,(iDynTree::PositionRaw const &)*arg2,(iDynTree::RotationalInertiaRaw const &)*arg3);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SpatialInertia__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = 0 ;
+int _wrap_new_SpatialInertiaRaw__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::SpatialInertia *result = 0 ;
+  iDynTree::SpatialInertiaRaw *result = 0 ;
   
-  if (!SWIG_check_num_args("new_SpatialInertia",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_SpatialInertiaRaw",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SpatialInertia,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SpatialInertiaRaw,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpatialInertia" "', argument " "1"" of type '" "iDynTree::SpatialInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpatialInertiaRaw" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertia" "', argument " "1"" of type '" "iDynTree::SpatialInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertiaRaw" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
-  result = (iDynTree::SpatialInertia *)new iDynTree::SpatialInertia((iDynTree::SpatialInertia const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertia, 1 |  0 );
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
+  result = (iDynTree::SpatialInertiaRaw *)new iDynTree::SpatialInertiaRaw((iDynTree::SpatialInertiaRaw const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SpatialInertia(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_SpatialInertiaRaw(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   if (argc == 0) {
-    return _wrap_new_SpatialInertia__SWIG_0(resc,resv,argc,argv);
+    return _wrap_new_SpatialInertiaRaw__SWIG_0(resc,resv,argc,argv);
   }
   if (argc == 1) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SpatialInertia, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      return _wrap_new_SpatialInertia__SWIG_2(resc,resv,argc,argv);
+      return _wrap_new_SpatialInertiaRaw__SWIG_2(resc,resv,argc,argv);
     }
   }
   if (argc == 3) {
     int _v;
     {
       int res = SWIG_AsVal_double(argv[0], NULL);
       _v = SWIG_CheckState(res);
     }
     if (_v) {
       void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Position, 0);
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__PositionRaw, 0);
       _v = SWIG_CheckState(res);
       if (_v) {
         void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__RotationalInertia, 0);
+        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 0);
         _v = SWIG_CheckState(res);
         if (_v) {
-          return _wrap_new_SpatialInertia__SWIG_1(resc,resv,argc,argv);
+          return _wrap_new_SpatialInertiaRaw__SWIG_1(resc,resv,argc,argv);
         }
       }
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SpatialInertia'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SpatialInertiaRaw'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::SpatialInertia::SpatialInertia()\n"
-    "    iDynTree::SpatialInertia::SpatialInertia(double const,iDynTree::Position const &,iDynTree::RotationalInertia const &)\n"
-    "    iDynTree::SpatialInertia::SpatialInertia(iDynTree::SpatialInertia const &)\n");
-  return 1;
-}
-
-
-int _wrap_SpatialInertia_combine(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = 0 ;
-  iDynTree::SpatialInertia *arg2 = 0 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  iDynTree::SpatialInertia result;
-  
-  if (!SWIG_check_num_args("SpatialInertia_combine",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SpatialInertia,  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_combine" "', argument " "1"" of type '" "iDynTree::SpatialInertia const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertia_combine" "', argument " "1"" of type '" "iDynTree::SpatialInertia const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialInertia,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialInertia_combine" "', argument " "2"" of type '" "iDynTree::SpatialInertia const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertia_combine" "', argument " "2"" of type '" "iDynTree::SpatialInertia const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::SpatialInertia * >(argp2);
-  result = iDynTree::SpatialInertia::combine((iDynTree::SpatialInertia const &)*arg1,(iDynTree::SpatialInertia const &)*arg2);
-  _out = SWIG_NewPointerObj((new iDynTree::SpatialInertia(static_cast< const iDynTree::SpatialInertia& >(result))), SWIGTYPE_p_iDynTree__SpatialInertia, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
+    "    iDynTree::SpatialInertiaRaw::SpatialInertiaRaw()\n"
+    "    iDynTree::SpatialInertiaRaw::SpatialInertiaRaw(double const,iDynTree::PositionRaw const &,iDynTree::RotationalInertiaRaw const &)\n"
+    "    iDynTree::SpatialInertiaRaw::SpatialInertiaRaw(iDynTree::SpatialInertiaRaw const &)\n");
   return 1;
 }
 
 
-int _wrap_SpatialInertia_fromRotationalInertiaWrtCenterOfMass(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = (iDynTree::SpatialInertia *) 0 ;
+int _wrap_SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = (iDynTree::SpatialInertiaRaw *) 0 ;
   double arg2 ;
-  iDynTree::Position *arg3 = 0 ;
-  iDynTree::RotationalInertia *arg4 = 0 ;
+  iDynTree::PositionRaw *arg3 = 0 ;
+  iDynTree::RotationalInertiaRaw *arg4 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   double val2 ;
   int ecode2 = 0 ;
   void *argp3 ;
   int res3 = 0 ;
   void *argp4 ;
   int res4 = 0 ;
   mxArray * _out;
   
-  if (!SWIG_check_num_args("SpatialInertia_fromRotationalInertiaWrtCenterOfMass",argc,4,4,0)) {
+  if (!SWIG_check_num_args("SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertia, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_fromRotationalInertiaWrtCenterOfMass" "', argument " "1"" of type '" "iDynTree::SpatialInertia *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
   ecode2 = SWIG_AsVal_double(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialInertia_fromRotationalInertiaWrtCenterOfMass" "', argument " "2"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass" "', argument " "2"" of type '" "double""'");
   } 
   arg2 = static_cast< double >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Position,  0 );
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SpatialInertia_fromRotationalInertiaWrtCenterOfMass" "', argument " "3"" of type '" "iDynTree::Position const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass" "', argument " "3"" of type '" "iDynTree::PositionRaw const &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertia_fromRotationalInertiaWrtCenterOfMass" "', argument " "3"" of type '" "iDynTree::Position const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass" "', argument " "3"" of type '" "iDynTree::PositionRaw const &""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::Position * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__RotationalInertia,  0 );
+  arg3 = reinterpret_cast< iDynTree::PositionRaw * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__RotationalInertiaRaw,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SpatialInertia_fromRotationalInertiaWrtCenterOfMass" "', argument " "4"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass" "', argument " "4"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertia_fromRotationalInertiaWrtCenterOfMass" "', argument " "4"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass" "', argument " "4"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::RotationalInertia * >(argp4);
-  (arg1)->fromRotationalInertiaWrtCenterOfMass(arg2,(iDynTree::Position const &)*arg3,(iDynTree::RotationalInertia const &)*arg4);
+  arg4 = reinterpret_cast< iDynTree::RotationalInertiaRaw * >(argp4);
+  (arg1)->fromRotationalInertiaWrtCenterOfMass(arg2,(iDynTree::PositionRaw const &)*arg3,(iDynTree::RotationalInertiaRaw const &)*arg4);
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SpatialInertia_getMass(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = (iDynTree::SpatialInertia *) 0 ;
+int _wrap_SpatialInertiaRaw_getMass(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = (iDynTree::SpatialInertiaRaw *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   double result;
   
-  if (!SWIG_check_num_args("SpatialInertia_getMass",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SpatialInertiaRaw_getMass",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertia, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_getMass" "', argument " "1"" of type '" "iDynTree::SpatialInertia const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertiaRaw_getMass" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
-  result = (double)((iDynTree::SpatialInertia const *)arg1)->getMass();
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
+  result = (double)((iDynTree::SpatialInertiaRaw const *)arg1)->getMass();
   _out = SWIG_From_double(static_cast< double >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SpatialInertia_getCenterOfMass(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = (iDynTree::SpatialInertia *) 0 ;
+int _wrap_SpatialInertiaRaw_getCenterOfMass(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = (iDynTree::SpatialInertiaRaw *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::Position result;
+  iDynTree::PositionRaw result;
   
-  if (!SWIG_check_num_args("SpatialInertia_getCenterOfMass",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SpatialInertiaRaw_getCenterOfMass",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertia, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_getCenterOfMass" "', argument " "1"" of type '" "iDynTree::SpatialInertia const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertiaRaw_getCenterOfMass" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
-  result = ((iDynTree::SpatialInertia const *)arg1)->getCenterOfMass();
-  _out = SWIG_NewPointerObj((new iDynTree::Position(static_cast< const iDynTree::Position& >(result))), SWIGTYPE_p_iDynTree__Position, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
+  result = ((iDynTree::SpatialInertiaRaw const *)arg1)->getCenterOfMass();
+  _out = SWIG_NewPointerObj((new iDynTree::PositionRaw(static_cast< const iDynTree::PositionRaw& >(result))), SWIGTYPE_p_iDynTree__PositionRaw, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SpatialInertia_getRotationalInertiaWrtFrameOrigin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = (iDynTree::SpatialInertia *) 0 ;
+int _wrap_SpatialInertiaRaw_getRotationalInertiaWrtFrameOrigin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = (iDynTree::SpatialInertiaRaw *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::RotationalInertia *result = 0 ;
+  iDynTree::RotationalInertiaRaw *result = 0 ;
   
-  if (!SWIG_check_num_args("SpatialInertia_getRotationalInertiaWrtFrameOrigin",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SpatialInertiaRaw_getRotationalInertiaWrtFrameOrigin",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertia, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_getRotationalInertiaWrtFrameOrigin" "', argument " "1"" of type '" "iDynTree::SpatialInertia const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertiaRaw_getRotationalInertiaWrtFrameOrigin" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
-  result = (iDynTree::RotationalInertia *) &((iDynTree::SpatialInertia const *)arg1)->getRotationalInertiaWrtFrameOrigin();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationalInertia, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
+  result = (iDynTree::RotationalInertiaRaw *) &((iDynTree::SpatialInertiaRaw const *)arg1)->getRotationalInertiaWrtFrameOrigin();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SpatialInertia_getRotationalInertiaWrtCenterOfMass(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = (iDynTree::SpatialInertia *) 0 ;
+int _wrap_SpatialInertiaRaw_getRotationalInertiaWrtCenterOfMass(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = (iDynTree::SpatialInertiaRaw *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::RotationalInertia result;
+  iDynTree::RotationalInertiaRaw result;
   
-  if (!SWIG_check_num_args("SpatialInertia_getRotationalInertiaWrtCenterOfMass",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SpatialInertiaRaw_getRotationalInertiaWrtCenterOfMass",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertia, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_getRotationalInertiaWrtCenterOfMass" "', argument " "1"" of type '" "iDynTree::SpatialInertia const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertiaRaw_getRotationalInertiaWrtCenterOfMass" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
-  result = ((iDynTree::SpatialInertia const *)arg1)->getRotationalInertiaWrtCenterOfMass();
-  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertia(static_cast< const iDynTree::RotationalInertia& >(result))), SWIGTYPE_p_iDynTree__RotationalInertia, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
+  result = ((iDynTree::SpatialInertiaRaw const *)arg1)->getRotationalInertiaWrtCenterOfMass();
+  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertiaRaw(static_cast< const iDynTree::RotationalInertiaRaw& >(result))), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SpatialInertia_multiply(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = (iDynTree::SpatialInertia *) 0 ;
+int _wrap_SpatialInertiaRaw_combine(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = 0 ;
+  iDynTree::SpatialInertiaRaw *arg2 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::SpatialInertiaRaw result;
+  
+  if (!SWIG_check_num_args("SpatialInertiaRaw_combine",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SpatialInertiaRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertiaRaw_combine" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertiaRaw_combine" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialInertiaRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialInertiaRaw_combine" "', argument " "2"" of type '" "iDynTree::SpatialInertiaRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertiaRaw_combine" "', argument " "2"" of type '" "iDynTree::SpatialInertiaRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp2);
+  result = iDynTree::SpatialInertiaRaw::combine((iDynTree::SpatialInertiaRaw const &)*arg1,(iDynTree::SpatialInertiaRaw const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::SpatialInertiaRaw(static_cast< const iDynTree::SpatialInertiaRaw& >(result))), SWIGTYPE_p_iDynTree__SpatialInertiaRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_SpatialInertiaRaw_multiply(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = (iDynTree::SpatialInertiaRaw *) 0 ;
   iDynTree::SpatialMotionVector *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
   iDynTree::SpatialForceVector result;
   
-  if (!SWIG_check_num_args("SpatialInertia_multiply",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SpatialInertiaRaw_multiply",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertia, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_multiply" "', argument " "1"" of type '" "iDynTree::SpatialInertia const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertiaRaw_multiply" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
   res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialMotionVector,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialInertia_multiply" "', argument " "2"" of type '" "iDynTree::SpatialMotionVector const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialInertiaRaw_multiply" "', argument " "2"" of type '" "iDynTree::SpatialMotionVector const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertia_multiply" "', argument " "2"" of type '" "iDynTree::SpatialMotionVector const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertiaRaw_multiply" "', argument " "2"" of type '" "iDynTree::SpatialMotionVector const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::SpatialMotionVector * >(argp2);
-  result = ((iDynTree::SpatialInertia const *)arg1)->multiply((iDynTree::SpatialMotionVector const &)*arg2);
+  result = ((iDynTree::SpatialInertiaRaw const *)arg1)->multiply((iDynTree::SpatialMotionVector const &)*arg2);
   _out = SWIG_NewPointerObj((new iDynTree::SpatialForceVector(static_cast< const iDynTree::SpatialForceVector& >(result))), SWIGTYPE_p_iDynTree__SpatialForceVector, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SpatialInertia_zero(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SpatialInertia *arg1 = (iDynTree::SpatialInertia *) 0 ;
+int _wrap_SpatialInertiaRaw_zero(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = (iDynTree::SpatialInertiaRaw *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   
-  if (!SWIG_check_num_args("SpatialInertia_zero",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SpatialInertiaRaw_zero",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertia, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_zero" "', argument " "1"" of type '" "iDynTree::SpatialInertia *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertiaRaw_zero" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
   (arg1)->zero();
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
+int _wrap_delete_SpatialInertiaRaw(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = (iDynTree::SpatialInertiaRaw *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  
+  int is_owned;
+  if (!SWIG_check_num_args("delete_SpatialInertiaRaw",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SpatialInertiaRaw, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SpatialInertiaRaw" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
+  if (is_owned) {
+    delete arg1;
+  }
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_SpatialInertia__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::SpatialInertia *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_SpatialInertia",argc,0,0,0)) {
+    SWIG_fail;
+  }
+  (void)argv;
+  result = (iDynTree::SpatialInertia *)new iDynTree::SpatialInertia();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertia, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_SpatialInertia__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  iDynTree::PositionRaw *arg2 = 0 ;
+  iDynTree::RotationalInertiaRaw *arg3 = 0 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  mxArray * _out;
+  iDynTree::SpatialInertia *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_SpatialInertia",argc,3,3,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SpatialInertia" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_SpatialInertia" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertia" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::PositionRaw * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__RotationalInertiaRaw,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_SpatialInertia" "', argument " "3"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertia" "', argument " "3"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::RotationalInertiaRaw * >(argp3);
+  result = (iDynTree::SpatialInertia *)new iDynTree::SpatialInertia(arg1,(iDynTree::PositionRaw const &)*arg2,(iDynTree::RotationalInertiaRaw const &)*arg3);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertia, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_SpatialInertia__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertiaRaw *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::SpatialInertia *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_SpatialInertia",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SpatialInertiaRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpatialInertia" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertia" "', argument " "1"" of type '" "iDynTree::SpatialInertiaRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SpatialInertiaRaw * >(argp1);
+  result = (iDynTree::SpatialInertia *)new iDynTree::SpatialInertia((iDynTree::SpatialInertiaRaw const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertia, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_SpatialInertia__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertia *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::SpatialInertia *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_SpatialInertia",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SpatialInertia,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpatialInertia" "', argument " "1"" of type '" "iDynTree::SpatialInertia const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpatialInertia" "', argument " "1"" of type '" "iDynTree::SpatialInertia const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
+  result = (iDynTree::SpatialInertia *)new iDynTree::SpatialInertia((iDynTree::SpatialInertia const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SpatialInertia, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_SpatialInertia(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_SpatialInertia__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SpatialInertia, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_SpatialInertia__SWIG_3(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SpatialInertiaRaw, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_SpatialInertia__SWIG_2(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__PositionRaw, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        void *vptr = 0;
+        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 0);
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_new_SpatialInertia__SWIG_1(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SpatialInertia'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::SpatialInertia::SpatialInertia()\n"
+    "    iDynTree::SpatialInertia::SpatialInertia(double const,iDynTree::PositionRaw const &,iDynTree::RotationalInertiaRaw const &)\n"
+    "    iDynTree::SpatialInertia::SpatialInertia(iDynTree::SpatialInertiaRaw const &)\n"
+    "    iDynTree::SpatialInertia::SpatialInertia(iDynTree::SpatialInertia const &)\n");
+  return 1;
+}
+
+
+int _wrap_SpatialInertia_combine(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SpatialInertia *arg1 = 0 ;
+  iDynTree::SpatialInertia *arg2 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::SpatialInertia result;
+  
+  if (!SWIG_check_num_args("SpatialInertia_combine",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SpatialInertia,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpatialInertia_combine" "', argument " "1"" of type '" "iDynTree::SpatialInertia const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertia_combine" "', argument " "1"" of type '" "iDynTree::SpatialInertia const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SpatialInertia * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialInertia,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpatialInertia_combine" "', argument " "2"" of type '" "iDynTree::SpatialInertia const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpatialInertia_combine" "', argument " "2"" of type '" "iDynTree::SpatialInertia const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::SpatialInertia * >(argp2);
+  result = iDynTree::SpatialInertia::combine((iDynTree::SpatialInertia const &)*arg1,(iDynTree::SpatialInertia const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::SpatialInertia(static_cast< const iDynTree::SpatialInertia& >(result))), SWIGTYPE_p_iDynTree__SpatialInertia, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
 int _wrap_SpatialInertia_asMatrix(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::SpatialInertia *arg1 = (iDynTree::SpatialInertia *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   iDynTree::Matrix6x6 result;
   
@@ -35411,14 +32545,826 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
+int _wrap_new_RotationRaw__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::RotationRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_RotationRaw",argc,0,0,0)) {
+    SWIG_fail;
+  }
+  (void)argv;
+  result = (iDynTree::RotationRaw *)new iDynTree::RotationRaw();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_RotationRaw__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  double arg5 ;
+  double arg6 ;
+  double arg7 ;
+  double arg8 ;
+  double arg9 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  double val5 ;
+  int ecode5 = 0 ;
+  double val6 ;
+  int ecode6 = 0 ;
+  double val7 ;
+  int ecode7 = 0 ;
+  double val8 ;
+  int ecode8 = 0 ;
+  double val9 ;
+  int ecode9 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_RotationRaw",argc,9,9,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_RotationRaw" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_RotationRaw" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_RotationRaw" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(argv[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_RotationRaw" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  ecode5 = SWIG_AsVal_double(argv[4], &val5);
+  if (!SWIG_IsOK(ecode5)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_RotationRaw" "', argument " "5"" of type '" "double""'");
+  } 
+  arg5 = static_cast< double >(val5);
+  ecode6 = SWIG_AsVal_double(argv[5], &val6);
+  if (!SWIG_IsOK(ecode6)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_RotationRaw" "', argument " "6"" of type '" "double""'");
+  } 
+  arg6 = static_cast< double >(val6);
+  ecode7 = SWIG_AsVal_double(argv[6], &val7);
+  if (!SWIG_IsOK(ecode7)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_RotationRaw" "', argument " "7"" of type '" "double""'");
+  } 
+  arg7 = static_cast< double >(val7);
+  ecode8 = SWIG_AsVal_double(argv[7], &val8);
+  if (!SWIG_IsOK(ecode8)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_RotationRaw" "', argument " "8"" of type '" "double""'");
+  } 
+  arg8 = static_cast< double >(val8);
+  ecode9 = SWIG_AsVal_double(argv[8], &val9);
+  if (!SWIG_IsOK(ecode9)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_RotationRaw" "', argument " "9"" of type '" "double""'");
+  } 
+  arg9 = static_cast< double >(val9);
+  result = (iDynTree::RotationRaw *)new iDynTree::RotationRaw(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_RotationRaw__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double *arg1 = (double *) 0 ;
+  unsigned int arg2 ;
+  unsigned int arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  unsigned int val2 ;
+  int ecode2 = 0 ;
+  unsigned int val3 ;
+  int ecode3 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_RotationRaw",argc,3,3,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RotationRaw" "', argument " "1"" of type '" "double const *""'"); 
+  }
+  arg1 = reinterpret_cast< double * >(argp1);
+  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_RotationRaw" "', argument " "2"" of type '" "unsigned int""'");
+  } 
+  arg2 = static_cast< unsigned int >(val2);
+  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_RotationRaw" "', argument " "3"" of type '" "unsigned int""'");
+  } 
+  arg3 = static_cast< unsigned int >(val3);
+  result = (iDynTree::RotationRaw *)new iDynTree::RotationRaw((double const *)arg1,arg2,arg3);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_RotationRaw__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  SwigValueWrapper< iDynTree::MatrixView< double const > > arg1 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_RotationRaw",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  {
+    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__MatrixViewT_double_const_t,  0 );
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RotationRaw" "', argument " "1"" of type '" "iDynTree::MatrixView< double const >""'"); 
+    }  
+    if (!argp1) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RotationRaw" "', argument " "1"" of type '" "iDynTree::MatrixView< double const >""'");
+    } else {
+      arg1 = *(reinterpret_cast< iDynTree::MatrixView< double const > * >(argp1));
+    }
+  }
+  result = (iDynTree::RotationRaw *)new iDynTree::RotationRaw(arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_RotationRaw__SWIG_4(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_RotationRaw",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__RotationRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RotationRaw" "', argument " "1"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RotationRaw" "', argument " "1"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  result = (iDynTree::RotationRaw *)new iDynTree::RotationRaw((iDynTree::RotationRaw const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationRaw, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_RotationRaw(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_RotationRaw__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__MatrixViewT_double_const_t, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_RotationRaw__SWIG_3(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__RotationRaw, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_RotationRaw__SWIG_4(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_double, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          return _wrap_new_RotationRaw__SWIG_2(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  if (argc == 9) {
+    int _v;
+    {
+      int res = SWIG_AsVal_double(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      {
+        int res = SWIG_AsVal_double(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_double(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          {
+            int res = SWIG_AsVal_double(argv[3], NULL);
+            _v = SWIG_CheckState(res);
+          }
+          if (_v) {
+            {
+              int res = SWIG_AsVal_double(argv[4], NULL);
+              _v = SWIG_CheckState(res);
+            }
+            if (_v) {
+              {
+                int res = SWIG_AsVal_double(argv[5], NULL);
+                _v = SWIG_CheckState(res);
+              }
+              if (_v) {
+                {
+                  int res = SWIG_AsVal_double(argv[6], NULL);
+                  _v = SWIG_CheckState(res);
+                }
+                if (_v) {
+                  {
+                    int res = SWIG_AsVal_double(argv[7], NULL);
+                    _v = SWIG_CheckState(res);
+                  }
+                  if (_v) {
+                    {
+                      int res = SWIG_AsVal_double(argv[8], NULL);
+                      _v = SWIG_CheckState(res);
+                    }
+                    if (_v) {
+                      return _wrap_new_RotationRaw__SWIG_1(resc,resv,argc,argv);
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_RotationRaw'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::RotationRaw::RotationRaw()\n"
+    "    iDynTree::RotationRaw::RotationRaw(double,double,double,double,double,double,double,double,double)\n"
+    "    iDynTree::RotationRaw::RotationRaw(double const *,unsigned int const,unsigned int const)\n"
+    "    iDynTree::RotationRaw::RotationRaw(iDynTree::MatrixView< double const >)\n"
+    "    iDynTree::RotationRaw::RotationRaw(iDynTree::RotationRaw const &)\n");
+  return 1;
+}
+
+
+int _wrap_RotationRaw_changeOrientFrame(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = (iDynTree::RotationRaw *) 0 ;
+  iDynTree::RotationRaw *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("RotationRaw_changeOrientFrame",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_changeOrientFrame" "', argument " "1"" of type '" "iDynTree::RotationRaw *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RotationRaw_changeOrientFrame" "', argument " "2"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RotationRaw_changeOrientFrame" "', argument " "2"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::RotationRaw * >(argp2);
+  result = (iDynTree::RotationRaw *) &(arg1)->changeOrientFrame((iDynTree::RotationRaw const &)*arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_changeRefOrientFrame(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = (iDynTree::RotationRaw *) 0 ;
+  iDynTree::RotationRaw *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw *result = 0 ;
+  
+  if (!SWIG_check_num_args("RotationRaw_changeRefOrientFrame",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_changeRefOrientFrame" "', argument " "1"" of type '" "iDynTree::RotationRaw *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RotationRaw_changeRefOrientFrame" "', argument " "2"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RotationRaw_changeRefOrientFrame" "', argument " "2"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::RotationRaw * >(argp2);
+  result = (iDynTree::RotationRaw *) &(arg1)->changeRefOrientFrame((iDynTree::RotationRaw const &)*arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_compose(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = 0 ;
+  iDynTree::RotationRaw *arg2 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_compose",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__RotationRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_compose" "', argument " "1"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RotationRaw_compose" "', argument " "1"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RotationRaw_compose" "', argument " "2"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RotationRaw_compose" "', argument " "2"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::RotationRaw * >(argp2);
+  result = iDynTree::RotationRaw::compose((iDynTree::RotationRaw const &)*arg1,(iDynTree::RotationRaw const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationRaw(static_cast< const iDynTree::RotationRaw& >(result))), SWIGTYPE_p_iDynTree__RotationRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_inverse2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_inverse2",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__RotationRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_inverse2" "', argument " "1"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RotationRaw_inverse2" "', argument " "1"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  result = iDynTree::RotationRaw::inverse2((iDynTree::RotationRaw const &)*arg1);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationRaw(static_cast< const iDynTree::RotationRaw& >(result))), SWIGTYPE_p_iDynTree__RotationRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_changeCoordFrameOf__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = (iDynTree::RotationRaw *) 0 ;
+  iDynTree::PositionRaw *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::PositionRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_changeCoordFrameOf",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "1"" of type '" "iDynTree::RotationRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__PositionRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::PositionRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::PositionRaw * >(argp2);
+  result = ((iDynTree::RotationRaw const *)arg1)->changeCoordFrameOf((iDynTree::PositionRaw const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::PositionRaw(static_cast< const iDynTree::PositionRaw& >(result))), SWIGTYPE_p_iDynTree__PositionRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_changeCoordFrameOf__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = (iDynTree::RotationRaw *) 0 ;
+  iDynTree::ClassicalAcc *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::ClassicalAcc result;
+  
+  if (!SWIG_check_num_args("RotationRaw_changeCoordFrameOf",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "1"" of type '" "iDynTree::RotationRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__ClassicalAcc,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::ClassicalAcc const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::ClassicalAcc const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::ClassicalAcc * >(argp2);
+  result = ((iDynTree::RotationRaw const *)arg1)->changeCoordFrameOf((iDynTree::ClassicalAcc const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::ClassicalAcc(static_cast< const iDynTree::ClassicalAcc& >(result))), SWIGTYPE_p_iDynTree__ClassicalAcc, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_changeCoordFrameOf__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = (iDynTree::RotationRaw *) 0 ;
+  iDynTree::RotationalInertiaRaw *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationalInertiaRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_changeCoordFrameOf",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "1"" of type '" "iDynTree::RotationRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationalInertiaRaw,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RotationRaw_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::RotationalInertiaRaw * >(argp2);
+  result = ((iDynTree::RotationRaw const *)arg1)->changeCoordFrameOf((iDynTree::RotationalInertiaRaw const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertiaRaw(static_cast< const iDynTree::RotationalInertiaRaw& >(result))), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_changeCoordFrameOf(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__RotationRaw, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__PositionRaw, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_RotationRaw_changeCoordFrameOf__SWIG_0(resc,resv,argc,argv);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__RotationRaw, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__ClassicalAcc, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_RotationRaw_changeCoordFrameOf__SWIG_1(resc,resv,argc,argv);
+      }
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__RotationRaw, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_RotationRaw_changeCoordFrameOf__SWIG_2(resc,resv,argc,argv);
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'RotationRaw_changeCoordFrameOf'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::RotationRaw::changeCoordFrameOf(iDynTree::PositionRaw const &) const\n"
+    "    iDynTree::RotationRaw::changeCoordFrameOf(iDynTree::ClassicalAcc const &) const\n"
+    "    iDynTree::RotationRaw::changeCoordFrameOf(iDynTree::RotationalInertiaRaw const &) const\n");
+  return 1;
+}
+
+
+int _wrap_RotationRaw_RotX(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_RotX",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "RotationRaw_RotX" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  result = iDynTree::RotationRaw::RotX(arg1);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationRaw(static_cast< const iDynTree::RotationRaw& >(result))), SWIGTYPE_p_iDynTree__RotationRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_RotY(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_RotY",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "RotationRaw_RotY" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  result = iDynTree::RotationRaw::RotY(arg1);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationRaw(static_cast< const iDynTree::RotationRaw& >(result))), SWIGTYPE_p_iDynTree__RotationRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_RotZ(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_RotZ",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "RotationRaw_RotZ" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  result = iDynTree::RotationRaw::RotZ(arg1);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationRaw(static_cast< const iDynTree::RotationRaw& >(result))), SWIGTYPE_p_iDynTree__RotationRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_RPY(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  mxArray * _out;
+  iDynTree::RotationRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_RPY",argc,3,3,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "RotationRaw_RPY" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RotationRaw_RPY" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "RotationRaw_RPY" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  result = iDynTree::RotationRaw::RPY(arg1,arg2,arg3);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationRaw(static_cast< const iDynTree::RotationRaw& >(result))), SWIGTYPE_p_iDynTree__RotationRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_Identity(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::RotationRaw result;
+  
+  if (!SWIG_check_num_args("RotationRaw_Identity",argc,0,0,0)) {
+    SWIG_fail;
+  }
+  (void)argv;
+  result = iDynTree::RotationRaw::Identity();
+  _out = SWIG_NewPointerObj((new iDynTree::RotationRaw(static_cast< const iDynTree::RotationRaw& >(result))), SWIGTYPE_p_iDynTree__RotationRaw, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_toString(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = (iDynTree::RotationRaw *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  std::string result;
+  
+  if (!SWIG_check_num_args("RotationRaw_toString",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_toString" "', argument " "1"" of type '" "iDynTree::RotationRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  result = ((iDynTree::RotationRaw const *)arg1)->toString();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_RotationRaw_display(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = (iDynTree::RotationRaw *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  std::string result;
+  
+  if (!SWIG_check_num_args("RotationRaw_display",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationRaw, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RotationRaw_display" "', argument " "1"" of type '" "iDynTree::RotationRaw const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  result = ((iDynTree::RotationRaw const *)arg1)->reservedToString();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_delete_RotationRaw(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = (iDynTree::RotationRaw *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  
+  int is_owned;
+  if (!SWIG_check_num_args("delete_RotationRaw",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RotationRaw, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RotationRaw" "', argument " "1"" of type '" "iDynTree::RotationRaw *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  if (is_owned) {
+    delete arg1;
+  }
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
 int _wrap_new_Rotation__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
   iDynTree::Rotation *result = 0 ;
   
   if (!SWIG_check_num_args("new_Rotation",argc,0,0,0)) {
     SWIG_fail;
   }
@@ -35517,14 +33463,41 @@
   return 0;
 fail:
   return 1;
 }
 
 
 int _wrap_new_Rotation__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::RotationRaw *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::Rotation *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_Rotation",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__RotationRaw,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Rotation" "', argument " "1"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Rotation" "', argument " "1"" of type '" "iDynTree::RotationRaw const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::RotationRaw * >(argp1);
+  result = (iDynTree::Rotation *)new iDynTree::Rotation((iDynTree::RotationRaw const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Rotation, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_Rotation__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Rotation *arg1 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
   iDynTree::Rotation *result = 0 ;
   
   if (!SWIG_check_num_args("new_Rotation",argc,1,1,0)) {
@@ -35543,15 +33516,15 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_Rotation__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_Rotation__SWIG_4(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   SwigValueWrapper< iDynTree::MatrixView< double const > > arg1 ;
   void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
   iDynTree::Rotation *result = 0 ;
   
   if (!SWIG_check_num_args("new_Rotation",argc,1,1,0)) {
@@ -35573,95 +33546,43 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_Rotation__SWIG_4(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  double *arg1 = (double *) 0 ;
-  unsigned int arg2 ;
-  unsigned int arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  unsigned int val2 ;
-  int ecode2 = 0 ;
-  unsigned int val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  iDynTree::Rotation *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_Rotation",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Rotation" "', argument " "1"" of type '" "double const *""'"); 
-  }
-  arg1 = reinterpret_cast< double * >(argp1);
-  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Rotation" "', argument " "2"" of type '" "unsigned int""'");
-  } 
-  arg2 = static_cast< unsigned int >(val2);
-  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Rotation" "', argument " "3"" of type '" "unsigned int""'");
-  } 
-  arg3 = static_cast< unsigned int >(val3);
-  result = (iDynTree::Rotation *)new iDynTree::Rotation((double const *)arg1,arg2,arg3);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Rotation, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_new_Rotation(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   if (argc == 0) {
     return _wrap_new_Rotation__SWIG_0(resc,resv,argc,argv);
   }
   if (argc == 1) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Rotation, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      return _wrap_new_Rotation__SWIG_2(resc,resv,argc,argv);
+      return _wrap_new_Rotation__SWIG_3(resc,resv,argc,argv);
     }
   }
   if (argc == 1) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__MatrixViewT_double_const_t, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__RotationRaw, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      return _wrap_new_Rotation__SWIG_3(resc,resv,argc,argv);
+      return _wrap_new_Rotation__SWIG_2(resc,resv,argc,argv);
     }
   }
-  if (argc == 3) {
+  if (argc == 1) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_double, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__MatrixViewT_double_const_t, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      {
-        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_new_Rotation__SWIG_4(resc,resv,argc,argv);
-        }
-      }
+      return _wrap_new_Rotation__SWIG_4(resc,resv,argc,argv);
     }
   }
   if (argc == 9) {
     int _v;
     {
       int res = SWIG_AsVal_double(argv[0], NULL);
       _v = SWIG_CheckState(res);
@@ -35719,17 +33640,17 @@
     }
   }
   
   SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_Rotation'."
     "  Possible C/C++ prototypes are:\n"
     "    iDynTree::Rotation::Rotation()\n"
     "    iDynTree::Rotation::Rotation(double,double,double,double,double,double,double,double,double)\n"
+    "    iDynTree::Rotation::Rotation(iDynTree::RotationRaw const &)\n"
     "    iDynTree::Rotation::Rotation(iDynTree::Rotation const &)\n"
-    "    iDynTree::Rotation::Rotation(iDynTree::MatrixView< double const >)\n"
-    "    iDynTree::Rotation::Rotation(double const *,unsigned int const,unsigned int const)\n");
+    "    iDynTree::Rotation::Rotation(iDynTree::MatrixView< double const >)\n");
   return 1;
 }
 
 
 int _wrap_Rotation_changeOrientFrame(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Rotation *arg1 = (iDynTree::Rotation *) 0 ;
   iDynTree::Rotation *arg2 = 0 ;
@@ -36248,40 +34169,40 @@
 fail:
   return 1;
 }
 
 
 int _wrap_Rotation_changeCoordFrameOf__SWIG_10(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Rotation *arg1 = (iDynTree::Rotation *) 0 ;
-  iDynTree::RotationalInertia *arg2 = 0 ;
+  iDynTree::RotationalInertiaRaw *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
-  iDynTree::RotationalInertia result;
+  iDynTree::RotationalInertiaRaw result;
   
   if (!SWIG_check_num_args("Rotation_changeCoordFrameOf",argc,2,2,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Rotation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rotation_changeCoordFrameOf" "', argument " "1"" of type '" "iDynTree::Rotation const *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::Rotation * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationalInertia,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationalInertiaRaw,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotation_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotation_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rotation_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rotation_changeCoordFrameOf" "', argument " "2"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::RotationalInertia * >(argp2);
-  result = ((iDynTree::Rotation const *)arg1)->changeCoordFrameOf((iDynTree::RotationalInertia const &)*arg2);
-  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertia(static_cast< const iDynTree::RotationalInertia& >(result))), SWIGTYPE_p_iDynTree__RotationalInertia, SWIG_POINTER_OWN |  0 );
+  arg2 = reinterpret_cast< iDynTree::RotationalInertiaRaw * >(argp2);
+  result = ((iDynTree::Rotation const *)arg1)->changeCoordFrameOf((iDynTree::RotationalInertiaRaw const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertiaRaw(static_cast< const iDynTree::RotationalInertiaRaw& >(result))), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
@@ -36429,15 +34350,15 @@
   if (argc == 2) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Rotation, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
       void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__RotationalInertia, 0);
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 0);
       _v = SWIG_CheckState(res);
       if (_v) {
         return _wrap_Rotation_changeCoordFrameOf__SWIG_10(resc,resv,argc,argv);
       }
     }
   }
   
@@ -36449,15 +34370,15 @@
     "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::Twist const &) const\n"
     "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::SpatialAcc const &) const\n"
     "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::SpatialMomentum const &) const\n"
     "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::Wrench const &) const\n"
     "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::Direction const &) const\n"
     "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::Axis const &) const\n"
     "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::ClassicalAcc const &) const\n"
-    "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::RotationalInertia const &) const\n");
+    "    iDynTree::Rotation::changeCoordFrameOf(iDynTree::RotationalInertiaRaw const &) const\n");
   return 1;
 }
 
 
 int _wrap_Rotation_mtimes__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Rotation *arg1 = (iDynTree::Rotation *) 0 ;
   iDynTree::Rotation *arg2 = 0 ;
@@ -36830,40 +34751,40 @@
 fail:
   return 1;
 }
 
 
 int _wrap_Rotation_mtimes__SWIG_10(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Rotation *arg1 = (iDynTree::Rotation *) 0 ;
-  iDynTree::RotationalInertia *arg2 = 0 ;
+  iDynTree::RotationalInertiaRaw *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
-  iDynTree::RotationalInertia result;
+  iDynTree::RotationalInertiaRaw result;
   
   if (!SWIG_check_num_args("Rotation_mtimes",argc,2,2,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Rotation, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rotation_mtimes" "', argument " "1"" of type '" "iDynTree::Rotation const *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::Rotation * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationalInertia,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__RotationalInertiaRaw,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotation_mtimes" "', argument " "2"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rotation_mtimes" "', argument " "2"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rotation_mtimes" "', argument " "2"" of type '" "iDynTree::RotationalInertia const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rotation_mtimes" "', argument " "2"" of type '" "iDynTree::RotationalInertiaRaw const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::RotationalInertia * >(argp2);
-  result = ((iDynTree::Rotation const *)arg1)->operator *((iDynTree::RotationalInertia const &)*arg2);
-  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertia(static_cast< const iDynTree::RotationalInertia& >(result))), SWIGTYPE_p_iDynTree__RotationalInertia, SWIG_POINTER_OWN |  0 );
+  arg2 = reinterpret_cast< iDynTree::RotationalInertiaRaw * >(argp2);
+  result = ((iDynTree::Rotation const *)arg1)->operator *((iDynTree::RotationalInertiaRaw const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::RotationalInertiaRaw(static_cast< const iDynTree::RotationalInertiaRaw& >(result))), SWIGTYPE_p_iDynTree__RotationalInertiaRaw, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
@@ -37011,15 +34932,15 @@
   if (argc == 2) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Rotation, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
       void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__RotationalInertia, 0);
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__RotationalInertiaRaw, 0);
       _v = SWIG_CheckState(res);
       if (_v) {
         return _wrap_Rotation_mtimes__SWIG_10(resc,resv,argc,argv);
       }
     }
   }
   
@@ -37031,15 +34952,15 @@
     "    iDynTree::Rotation::operator *(iDynTree::Twist const &) const\n"
     "    iDynTree::Rotation::operator *(iDynTree::Wrench const &) const\n"
     "    iDynTree::Rotation::operator *(iDynTree::Direction const &) const\n"
     "    iDynTree::Rotation::operator *(iDynTree::Axis const &) const\n"
     "    iDynTree::Rotation::operator *(iDynTree::SpatialAcc const &) const\n"
     "    iDynTree::Rotation::operator *(iDynTree::SpatialMomentum const &) const\n"
     "    iDynTree::Rotation::operator *(iDynTree::ClassicalAcc const &) const\n"
-    "    iDynTree::Rotation::operator *(iDynTree::RotationalInertia const &) const\n");
+    "    iDynTree::Rotation::operator *(iDynTree::RotationalInertiaRaw const &) const\n");
   return 1;
 }
 
 
 int _wrap_Rotation_log(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Rotation *arg1 = (iDynTree::Rotation *) 0 ;
   void *argp1 = 0 ;
@@ -43871,15 +41792,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Link, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Link_setIndex" "', argument " "1"" of type '" "iDynTree::Link *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::Link * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Link_setIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Link_setIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::LinkIndex * >(argp2);
@@ -44894,15 +42815,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_setIndex" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "IJoint_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IJoint_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::JointIndex * >(argp2);
@@ -45273,357 +43194,151 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_IJoint_getJointDynamicsType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_IJoint_isRevoluteJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::JointDynamicsType result;
+  bool result;
   
-  if (!SWIG_check_num_args("IJoint_getJointDynamicsType",argc,1,1,0)) {
+  if (!SWIG_check_num_args("IJoint_isRevoluteJoint",argc,1,1,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_getJointDynamicsType" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_isRevoluteJoint" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  result = (iDynTree::JointDynamicsType)((iDynTree::IJoint const *)arg1)->getJointDynamicsType();
-  _out = SWIG_From_int(static_cast< int >(result));
+  result = (bool)iDynTree_IJoint_isRevoluteJoint((iDynTree::IJoint const *)arg1);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_IJoint_setJointDynamicsType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_IJoint_isFixedJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  iDynTree::JointDynamicsType arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("IJoint_setJointDynamicsType",argc,2,2,0)) {
+  if (!SWIG_check_num_args("IJoint_isFixedJoint",argc,1,1,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_setJointDynamicsType" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_isFixedJoint" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IJoint_setJointDynamicsType" "', argument " "2"" of type '" "iDynTree::JointDynamicsType""'");
-  } 
-  arg2 = static_cast< iDynTree::JointDynamicsType >(val2);
-  result = (bool)(arg1)->setJointDynamicsType(arg2);
+  result = (bool)iDynTree_IJoint_isFixedJoint((iDynTree::IJoint const *)arg1);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_IJoint_setDamping(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_IJoint_isPrismaticJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  size_t arg2 ;
-  double *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("IJoint_setDamping",argc,3,3,0)) {
+  if (!SWIG_check_num_args("IJoint_isPrismaticJoint",argc,1,1,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_setDamping" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_isPrismaticJoint" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IJoint_setDamping" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_double,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "IJoint_setDamping" "', argument " "3"" of type '" "double &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IJoint_setDamping" "', argument " "3"" of type '" "double &""'"); 
-  }
-  arg3 = reinterpret_cast< double * >(argp3);
-  result = (bool)(arg1)->setDamping(arg2,*arg3);
+  result = (bool)iDynTree_IJoint_isPrismaticJoint((iDynTree::IJoint const *)arg1);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_IJoint_setStaticFriction(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_IJoint_asRevoluteJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  size_t arg2 ;
-  double *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
   mxArray * _out;
-  bool result;
+  iDynTree::RevoluteJoint *result = 0 ;
   
-  if (!SWIG_check_num_args("IJoint_setStaticFriction",argc,3,3,0)) {
+  if (!SWIG_check_num_args("IJoint_asRevoluteJoint",argc,1,1,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_setStaticFriction" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_asRevoluteJoint" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IJoint_setStaticFriction" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_double,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "IJoint_setStaticFriction" "', argument " "3"" of type '" "double &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "IJoint_setStaticFriction" "', argument " "3"" of type '" "double &""'"); 
-  }
-  arg3 = reinterpret_cast< double * >(argp3);
-  result = (bool)(arg1)->setStaticFriction(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  result = (iDynTree::RevoluteJoint *)iDynTree_IJoint_asRevoluteJoint(arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RevoluteJoint, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_IJoint_getDamping(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_IJoint_asFixedJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  size_t arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  double result;
+  iDynTree::FixedJoint *result = 0 ;
   
-  if (!SWIG_check_num_args("IJoint_getDamping",argc,2,2,0)) {
+  if (!SWIG_check_num_args("IJoint_asFixedJoint",argc,1,1,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_getDamping" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_asFixedJoint" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IJoint_getDamping" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (double)((iDynTree::IJoint const *)arg1)->getDamping(arg2);
-  _out = SWIG_From_double(static_cast< double >(result));
+  result = (iDynTree::FixedJoint *)iDynTree_IJoint_asFixedJoint(arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_IJoint_getStaticFriction(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_IJoint_asPrismaticJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  size_t arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  double result;
+  iDynTree::PrismaticJoint *result = 0 ;
   
-  if (!SWIG_check_num_args("IJoint_getStaticFriction",argc,2,2,0)) {
+  if (!SWIG_check_num_args("IJoint_asPrismaticJoint",argc,1,1,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_getStaticFriction" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_asPrismaticJoint" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "IJoint_getStaticFriction" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (double)((iDynTree::IJoint const *)arg1)->getStaticFriction(arg2);
-  _out = SWIG_From_double(static_cast< double >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IJoint_isRevoluteJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("IJoint_isRevoluteJoint",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_isRevoluteJoint" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  result = (bool)iDynTree_IJoint_isRevoluteJoint((iDynTree::IJoint const *)arg1);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IJoint_isFixedJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("IJoint_isFixedJoint",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_isFixedJoint" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  result = (bool)iDynTree_IJoint_isFixedJoint((iDynTree::IJoint const *)arg1);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IJoint_isPrismaticJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("IJoint_isPrismaticJoint",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_isPrismaticJoint" "', argument " "1"" of type '" "iDynTree::IJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  result = (bool)iDynTree_IJoint_isPrismaticJoint((iDynTree::IJoint const *)arg1);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IJoint_asRevoluteJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::RevoluteJoint *result = 0 ;
-  
-  if (!SWIG_check_num_args("IJoint_asRevoluteJoint",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_asRevoluteJoint" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  result = (iDynTree::RevoluteJoint *)iDynTree_IJoint_asRevoluteJoint(arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__RevoluteJoint, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IJoint_asFixedJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::FixedJoint *result = 0 ;
-  
-  if (!SWIG_check_num_args("IJoint_asFixedJoint",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_asFixedJoint" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  result = (iDynTree::FixedJoint *)iDynTree_IJoint_asFixedJoint(arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_IJoint_asPrismaticJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::IJoint *arg1 = (iDynTree::IJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::PrismaticJoint *result = 0 ;
-  
-  if (!SWIG_check_num_args("IJoint_asPrismaticJoint",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__IJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IJoint_asPrismaticJoint" "', argument " "1"" of type '" "iDynTree::IJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::IJoint * >(argp1);
-  result = (iDynTree::PrismaticJoint *)iDynTree_IJoint_asPrismaticJoint(arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PrismaticJoint, 0 |  0 );
+  result = (iDynTree::PrismaticJoint *)iDynTree_IJoint_asPrismaticJoint(arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__PrismaticJoint, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
@@ -46746,15 +44461,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FixedJoint_setIndex" "', argument " "1"" of type '" "iDynTree::FixedJoint *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::FixedJoint * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FixedJoint_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FixedJoint_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::JointIndex * >(argp2);
@@ -47125,220 +44840,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_FixedJoint_getJointDynamicsType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::FixedJoint *arg1 = (iDynTree::FixedJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::JointDynamicsType result;
-  
-  if (!SWIG_check_num_args("FixedJoint_getJointDynamicsType",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FixedJoint_getJointDynamicsType" "', argument " "1"" of type '" "iDynTree::FixedJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::FixedJoint * >(argp1);
-  result = (iDynTree::JointDynamicsType)((iDynTree::FixedJoint const *)arg1)->getJointDynamicsType();
-  _out = SWIG_From_int(static_cast< int >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_FixedJoint_setJointDynamicsType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::FixedJoint *arg1 = (iDynTree::FixedJoint *) 0 ;
-  iDynTree::JointDynamicsType arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("FixedJoint_setJointDynamicsType",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FixedJoint_setJointDynamicsType" "', argument " "1"" of type '" "iDynTree::FixedJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::FixedJoint * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FixedJoint_setJointDynamicsType" "', argument " "2"" of type '" "iDynTree::JointDynamicsType""'");
-  } 
-  arg2 = static_cast< iDynTree::JointDynamicsType >(val2);
-  result = (bool)(arg1)->setJointDynamicsType(arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_FixedJoint_getDamping(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::FixedJoint *arg1 = (iDynTree::FixedJoint *) 0 ;
-  size_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  double result;
-  
-  if (!SWIG_check_num_args("FixedJoint_getDamping",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FixedJoint_getDamping" "', argument " "1"" of type '" "iDynTree::FixedJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::FixedJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FixedJoint_getDamping" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (double)((iDynTree::FixedJoint const *)arg1)->getDamping(arg2);
-  _out = SWIG_From_double(static_cast< double >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_FixedJoint_getStaticFriction(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::FixedJoint *arg1 = (iDynTree::FixedJoint *) 0 ;
-  size_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  double result;
-  
-  if (!SWIG_check_num_args("FixedJoint_getStaticFriction",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FixedJoint_getStaticFriction" "', argument " "1"" of type '" "iDynTree::FixedJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::FixedJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FixedJoint_getStaticFriction" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (double)((iDynTree::FixedJoint const *)arg1)->getStaticFriction(arg2);
-  _out = SWIG_From_double(static_cast< double >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_FixedJoint_setDamping(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::FixedJoint *arg1 = (iDynTree::FixedJoint *) 0 ;
-  size_t arg2 ;
-  double *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("FixedJoint_setDamping",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FixedJoint_setDamping" "', argument " "1"" of type '" "iDynTree::FixedJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::FixedJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FixedJoint_setDamping" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_double,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FixedJoint_setDamping" "', argument " "3"" of type '" "double &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FixedJoint_setDamping" "', argument " "3"" of type '" "double &""'"); 
-  }
-  arg3 = reinterpret_cast< double * >(argp3);
-  result = (bool)(arg1)->setDamping(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_FixedJoint_setStaticFriction(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::FixedJoint *arg1 = (iDynTree::FixedJoint *) 0 ;
-  size_t arg2 ;
-  double *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("FixedJoint_setStaticFriction",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__FixedJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FixedJoint_setStaticFriction" "', argument " "1"" of type '" "iDynTree::FixedJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::FixedJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FixedJoint_setStaticFriction" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_double,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "FixedJoint_setStaticFriction" "', argument " "3"" of type '" "double &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FixedJoint_setStaticFriction" "', argument " "3"" of type '" "double &""'"); 
-  }
-  arg3 = reinterpret_cast< double * >(argp3);
-  result = (bool)(arg1)->setStaticFriction(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_delete_MovableJointImpl1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::MovableJointImpl< 1,1 > *arg1 = (iDynTree::MovableJointImpl< 1,1 > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   
   int is_owned;
@@ -47423,15 +44932,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__MovableJointImplT_1_1_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MovableJointImpl1_setIndex" "', argument " "1"" of type '" "iDynTree::MovableJointImpl< 1,1 > *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::MovableJointImpl< 1,1 > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MovableJointImpl1_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MovableJointImpl1_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::JointIndex * >(argp2);
@@ -47666,15 +45175,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__MovableJointImplT_2_2_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MovableJointImpl2_setIndex" "', argument " "1"" of type '" "iDynTree::MovableJointImpl< 2,2 > *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::MovableJointImpl< 2,2 > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MovableJointImpl2_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MovableJointImpl2_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::JointIndex * >(argp2);
@@ -47909,15 +45418,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__MovableJointImplT_3_3_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MovableJointImpl3_setIndex" "', argument " "1"" of type '" "iDynTree::MovableJointImpl< 3,3 > *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::MovableJointImpl< 3,3 > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MovableJointImpl3_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MovableJointImpl3_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::JointIndex * >(argp2);
@@ -48152,15 +45661,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__MovableJointImplT_4_4_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MovableJointImpl4_setIndex" "', argument " "1"" of type '" "iDynTree::MovableJointImpl< 4,4 > *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::MovableJointImpl< 4,4 > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MovableJointImpl4_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MovableJointImpl4_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::JointIndex * >(argp2);
@@ -48395,15 +45904,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__MovableJointImplT_5_5_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MovableJointImpl5_setIndex" "', argument " "1"" of type '" "iDynTree::MovableJointImpl< 5,5 > *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::MovableJointImpl< 5,5 > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MovableJointImpl5_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MovableJointImpl5_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::JointIndex * >(argp2);
@@ -48638,15 +46147,15 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__MovableJointImplT_6_6_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MovableJointImpl6_setIndex" "', argument " "1"" of type '" "iDynTree::MovableJointImpl< 6,6 > *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::MovableJointImpl< 6,6 > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_ptrdiff_t,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__ptrdiff_t,  0 );
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MovableJointImpl6_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MovableJointImpl6_setIndex" "', argument " "2"" of type '" "iDynTree::JointIndex &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::JointIndex * >(argp2);
@@ -50520,220 +48029,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_RevoluteJoint_getJointDynamicsType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::RevoluteJoint *arg1 = (iDynTree::RevoluteJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::JointDynamicsType result;
-  
-  if (!SWIG_check_num_args("RevoluteJoint_getJointDynamicsType",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RevoluteJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RevoluteJoint_getJointDynamicsType" "', argument " "1"" of type '" "iDynTree::RevoluteJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::RevoluteJoint * >(argp1);
-  result = (iDynTree::JointDynamicsType)((iDynTree::RevoluteJoint const *)arg1)->getJointDynamicsType();
-  _out = SWIG_From_int(static_cast< int >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_RevoluteJoint_setJointDynamicsType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::RevoluteJoint *arg1 = (iDynTree::RevoluteJoint *) 0 ;
-  iDynTree::JointDynamicsType arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("RevoluteJoint_setJointDynamicsType",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RevoluteJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RevoluteJoint_setJointDynamicsType" "', argument " "1"" of type '" "iDynTree::RevoluteJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::RevoluteJoint * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RevoluteJoint_setJointDynamicsType" "', argument " "2"" of type '" "iDynTree::JointDynamicsType""'");
-  } 
-  arg2 = static_cast< iDynTree::JointDynamicsType >(val2);
-  result = (bool)(arg1)->setJointDynamicsType(arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_RevoluteJoint_getDamping(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::RevoluteJoint *arg1 = (iDynTree::RevoluteJoint *) 0 ;
-  size_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  double result;
-  
-  if (!SWIG_check_num_args("RevoluteJoint_getDamping",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RevoluteJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RevoluteJoint_getDamping" "', argument " "1"" of type '" "iDynTree::RevoluteJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::RevoluteJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RevoluteJoint_getDamping" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (double)((iDynTree::RevoluteJoint const *)arg1)->getDamping(arg2);
-  _out = SWIG_From_double(static_cast< double >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_RevoluteJoint_getStaticFriction(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::RevoluteJoint *arg1 = (iDynTree::RevoluteJoint *) 0 ;
-  size_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  double result;
-  
-  if (!SWIG_check_num_args("RevoluteJoint_getStaticFriction",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RevoluteJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RevoluteJoint_getStaticFriction" "', argument " "1"" of type '" "iDynTree::RevoluteJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::RevoluteJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RevoluteJoint_getStaticFriction" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (double)((iDynTree::RevoluteJoint const *)arg1)->getStaticFriction(arg2);
-  _out = SWIG_From_double(static_cast< double >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_RevoluteJoint_setDamping(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::RevoluteJoint *arg1 = (iDynTree::RevoluteJoint *) 0 ;
-  size_t arg2 ;
-  double *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("RevoluteJoint_setDamping",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RevoluteJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RevoluteJoint_setDamping" "', argument " "1"" of type '" "iDynTree::RevoluteJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::RevoluteJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RevoluteJoint_setDamping" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_double,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RevoluteJoint_setDamping" "', argument " "3"" of type '" "double &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RevoluteJoint_setDamping" "', argument " "3"" of type '" "double &""'"); 
-  }
-  arg3 = reinterpret_cast< double * >(argp3);
-  result = (bool)(arg1)->setDamping(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_RevoluteJoint_setStaticFriction(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::RevoluteJoint *arg1 = (iDynTree::RevoluteJoint *) 0 ;
-  size_t arg2 ;
-  double *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("RevoluteJoint_setStaticFriction",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__RevoluteJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RevoluteJoint_setStaticFriction" "', argument " "1"" of type '" "iDynTree::RevoluteJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::RevoluteJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RevoluteJoint_setStaticFriction" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_double,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RevoluteJoint_setStaticFriction" "', argument " "3"" of type '" "double &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RevoluteJoint_setStaticFriction" "', argument " "3"" of type '" "double &""'"); 
-  }
-  arg3 = reinterpret_cast< double * >(argp3);
-  result = (bool)(arg1)->setStaticFriction(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_new_PrismaticJoint__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
   iDynTree::PrismaticJoint *result = 0 ;
   
   if (!SWIG_check_num_args("new_PrismaticJoint",argc,0,0,0)) {
     SWIG_fail;
   }
@@ -52404,220 +49707,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_PrismaticJoint_getJointDynamicsType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::PrismaticJoint *arg1 = (iDynTree::PrismaticJoint *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::JointDynamicsType result;
-  
-  if (!SWIG_check_num_args("PrismaticJoint_getJointDynamicsType",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PrismaticJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PrismaticJoint_getJointDynamicsType" "', argument " "1"" of type '" "iDynTree::PrismaticJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::PrismaticJoint * >(argp1);
-  result = (iDynTree::JointDynamicsType)((iDynTree::PrismaticJoint const *)arg1)->getJointDynamicsType();
-  _out = SWIG_From_int(static_cast< int >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_PrismaticJoint_setJointDynamicsType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::PrismaticJoint *arg1 = (iDynTree::PrismaticJoint *) 0 ;
-  iDynTree::JointDynamicsType arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("PrismaticJoint_setJointDynamicsType",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PrismaticJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PrismaticJoint_setJointDynamicsType" "', argument " "1"" of type '" "iDynTree::PrismaticJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::PrismaticJoint * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PrismaticJoint_setJointDynamicsType" "', argument " "2"" of type '" "iDynTree::JointDynamicsType""'");
-  } 
-  arg2 = static_cast< iDynTree::JointDynamicsType >(val2);
-  result = (bool)(arg1)->setJointDynamicsType(arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_PrismaticJoint_getDamping(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::PrismaticJoint *arg1 = (iDynTree::PrismaticJoint *) 0 ;
-  size_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  double result;
-  
-  if (!SWIG_check_num_args("PrismaticJoint_getDamping",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PrismaticJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PrismaticJoint_getDamping" "', argument " "1"" of type '" "iDynTree::PrismaticJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::PrismaticJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PrismaticJoint_getDamping" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (double)((iDynTree::PrismaticJoint const *)arg1)->getDamping(arg2);
-  _out = SWIG_From_double(static_cast< double >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_PrismaticJoint_getStaticFriction(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::PrismaticJoint *arg1 = (iDynTree::PrismaticJoint *) 0 ;
-  size_t arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  double result;
-  
-  if (!SWIG_check_num_args("PrismaticJoint_getStaticFriction",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PrismaticJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PrismaticJoint_getStaticFriction" "', argument " "1"" of type '" "iDynTree::PrismaticJoint const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::PrismaticJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PrismaticJoint_getStaticFriction" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (double)((iDynTree::PrismaticJoint const *)arg1)->getStaticFriction(arg2);
-  _out = SWIG_From_double(static_cast< double >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_PrismaticJoint_setDamping(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::PrismaticJoint *arg1 = (iDynTree::PrismaticJoint *) 0 ;
-  size_t arg2 ;
-  double *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("PrismaticJoint_setDamping",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PrismaticJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PrismaticJoint_setDamping" "', argument " "1"" of type '" "iDynTree::PrismaticJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::PrismaticJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PrismaticJoint_setDamping" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_double,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "PrismaticJoint_setDamping" "', argument " "3"" of type '" "double &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PrismaticJoint_setDamping" "', argument " "3"" of type '" "double &""'"); 
-  }
-  arg3 = reinterpret_cast< double * >(argp3);
-  result = (bool)(arg1)->setDamping(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_PrismaticJoint_setStaticFriction(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::PrismaticJoint *arg1 = (iDynTree::PrismaticJoint *) 0 ;
-  size_t arg2 ;
-  double *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("PrismaticJoint_setStaticFriction",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__PrismaticJoint, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PrismaticJoint_setStaticFriction" "', argument " "1"" of type '" "iDynTree::PrismaticJoint *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::PrismaticJoint * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PrismaticJoint_setStaticFriction" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_double,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "PrismaticJoint_setStaticFriction" "', argument " "3"" of type '" "double &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PrismaticJoint_setStaticFriction" "', argument " "3"" of type '" "double &""'"); 
-  }
-  arg3 = reinterpret_cast< double * >(argp3);
-  result = (bool)(arg1)->setStaticFriction(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_new_Traversal(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
   iDynTree::Traversal *result = 0 ;
   
   if (!SWIG_check_num_args("new_Traversal",argc,0,0,0)) {
     SWIG_fail;
   }
@@ -54815,38 +51912,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ExternalMesh_getPackageDirs(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ExternalMesh *arg1 = (iDynTree::ExternalMesh *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< std::string,std::allocator< std::string > > *result = 0 ;
-  
-  if (!SWIG_check_num_args("ExternalMesh_getPackageDirs",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ExternalMesh, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExternalMesh_getPackageDirs" "', argument " "1"" of type '" "iDynTree::ExternalMesh const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ExternalMesh * >(argp1);
-  result = (std::vector< std::string,std::allocator< std::string > > *) &((iDynTree::ExternalMesh const *)arg1)->getPackageDirs();
-  _out = swig::from(static_cast< std::vector< std::string,std::allocator< std::string > > >(*result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_ExternalMesh_getFileLocationOnLocalFileSystem(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ExternalMesh *arg1 = (iDynTree::ExternalMesh *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   std::string result;
   
@@ -54901,52 +51974,14 @@
   return 0;
 fail:
   if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_ExternalMesh_setPackageDirs(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ExternalMesh *arg1 = (iDynTree::ExternalMesh *) 0 ;
-  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("ExternalMesh_setPackageDirs",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ExternalMesh, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExternalMesh_setPackageDirs" "', argument " "1"" of type '" "iDynTree::ExternalMesh *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ExternalMesh * >(argp1);
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res2 = swig::asptr(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExternalMesh_setPackageDirs" "', argument " "2"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExternalMesh_setPackageDirs" "', argument " "2"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg2 = ptr;
-  }
-  (arg1)->setPackageDirs((std::vector< std::string,std::allocator< std::string > > const &)*arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 1;
-}
-
-
 int _wrap_ExternalMesh_getScale(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ExternalMesh *arg1 = (iDynTree::ExternalMesh *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   iDynTree::Vector3 *result = 0 ;
   
@@ -55345,2262 +52380,14 @@
     "  Possible C/C++ prototypes are:\n"
     "    iDynTree::ModelSolidShapes::getLinkSolidShapes()\n"
     "    iDynTree::ModelSolidShapes::getLinkSolidShapes() const\n");
   return 1;
 }
 
 
-SWIGINTERN int _wrap_NR_OF_SENSOR_TYPES_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  resv[0] = SWIG_From_int(static_cast< int >(iDynTree::NR_OF_SENSOR_TYPES));
-  return 0;
-}
-
-
-int _wrap_isLinkSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorType arg1 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("isLinkSensor",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_int(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "isLinkSensor" "', argument " "1"" of type '" "iDynTree::SensorType""'");
-  } 
-  arg1 = static_cast< iDynTree::SensorType >(val1);
-  result = (bool)iDynTree::isLinkSensor(arg1);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_isJointSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorType arg1 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("isJointSensor",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_int(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "isJointSensor" "', argument " "1"" of type '" "iDynTree::SensorType""'");
-  } 
-  arg1 = static_cast< iDynTree::SensorType >(val1);
-  result = (bool)iDynTree::isJointSensor(arg1);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_getSensorTypeSize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorType arg1 ;
-  int val1 ;
-  int ecode1 = 0 ;
-  mxArray * _out;
-  std::size_t result;
-  
-  if (!SWIG_check_num_args("getSensorTypeSize",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  ecode1 = SWIG_AsVal_int(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "getSensorTypeSize" "', argument " "1"" of type '" "iDynTree::SensorType""'");
-  } 
-  arg1 = static_cast< iDynTree::SensorType >(val1);
-  result = iDynTree::getSensorTypeSize(arg1);
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_delete_Sensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  int is_owned;
-  if (!SWIG_check_num_args("delete_Sensor",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Sensor" "', argument " "1"" of type '" "iDynTree::Sensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
-  if (is_owned) {
-    delete arg1;
-  }
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Sensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::string result;
-  
-  if (!SWIG_check_num_args("Sensor_getName",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_getName" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
-  result = ((iDynTree::Sensor const *)arg1)->getName();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Sensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::SensorType result;
-  
-  if (!SWIG_check_num_args("Sensor_getSensorType",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_getSensorType" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
-  result = (iDynTree::SensorType)((iDynTree::Sensor const *)arg1)->getSensorType();
-  _out = SWIG_From_int(static_cast< int >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Sensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("Sensor_isValid",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_isValid" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
-  result = (bool)((iDynTree::Sensor const *)arg1)->isValid();
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Sensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
-  std::string *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("Sensor_setName",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_setName" "', argument " "1"" of type '" "iDynTree::Sensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Sensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
-  }
-  result = (bool)(arg1)->setName((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 1;
-}
-
-
-int _wrap_Sensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::Sensor *result = 0 ;
-  
-  if (!SWIG_check_num_args("Sensor_clone",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_clone" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
-  result = (iDynTree::Sensor *)((iDynTree::Sensor const *)arg1)->clone();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Sensor_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("Sensor_isConsistent",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_isConsistent" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Sensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)((iDynTree::Sensor const *)arg1)->isConsistent((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Sensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("Sensor_updateIndices",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_updateIndices" "', argument " "1"" of type '" "iDynTree::Sensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Sensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_delete_JointSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  int is_owned;
-  if (!SWIG_check_num_args("delete_JointSensor",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_JointSensor" "', argument " "1"" of type '" "iDynTree::JointSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
-  if (is_owned) {
-    delete arg1;
-  }
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_JointSensor_getParentJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::string result;
-  
-  if (!SWIG_check_num_args("JointSensor_getParentJoint",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_getParentJoint" "', argument " "1"" of type '" "iDynTree::JointSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
-  result = ((iDynTree::JointSensor const *)arg1)->getParentJoint();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_JointSensor_getParentJointIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::JointIndex result;
-  
-  if (!SWIG_check_num_args("JointSensor_getParentJointIndex",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_getParentJointIndex" "', argument " "1"" of type '" "iDynTree::JointSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
-  result = ((iDynTree::JointSensor const *)arg1)->getParentJointIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_JointSensor_setParentJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
-  std::string *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("JointSensor_setParentJoint",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_setParentJoint" "', argument " "1"" of type '" "iDynTree::JointSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "JointSensor_setParentJoint" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "JointSensor_setParentJoint" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
-  }
-  result = (bool)(arg1)->setParentJoint((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 1;
-}
-
-
-int _wrap_JointSensor_setParentJointIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
-  iDynTree::JointIndex *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  iDynTree::JointIndex temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("JointSensor_setParentJointIndex",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_setParentJointIndex" "', argument " "1"" of type '" "iDynTree::JointSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "JointSensor_setParentJointIndex" "', argument " "2"" of type '" "iDynTree::JointIndex""'");
-  } 
-  temp2 = static_cast< iDynTree::JointIndex >(val2);
-  arg2 = &temp2;
-  result = (bool)(arg1)->setParentJointIndex((iDynTree::JointIndex const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_JointSensor_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("JointSensor_isConsistent",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_isConsistent" "', argument " "1"" of type '" "iDynTree::JointSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "JointSensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "JointSensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)((iDynTree::JointSensor const *)arg1)->isConsistent((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_delete_LinkSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  int is_owned;
-  if (!SWIG_check_num_args("delete_LinkSensor",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LinkSensor" "', argument " "1"" of type '" "iDynTree::LinkSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
-  if (is_owned) {
-    delete arg1;
-  }
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_LinkSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::string result;
-  
-  if (!SWIG_check_num_args("LinkSensor_getParentLink",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::LinkSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
-  result = ((iDynTree::LinkSensor const *)arg1)->getParentLink();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_LinkSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::LinkIndex result;
-  
-  if (!SWIG_check_num_args("LinkSensor_getParentLinkIndex",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::LinkSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
-  result = ((iDynTree::LinkSensor const *)arg1)->getParentLinkIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_LinkSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::Transform result;
-  
-  if (!SWIG_check_num_args("LinkSensor_getLinkSensorTransform",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::LinkSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
-  result = ((iDynTree::LinkSensor const *)arg1)->getLinkSensorTransform();
-  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_LinkSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
-  std::string *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("LinkSensor_setParentLink",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::LinkSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinkSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinkSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
-  }
-  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 1;
-}
-
-
-int _wrap_LinkSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
-  iDynTree::LinkIndex *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  iDynTree::LinkIndex temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("LinkSensor_setParentLinkIndex",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::LinkSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinkSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  temp2 = static_cast< iDynTree::LinkIndex >(val2);
-  arg2 = &temp2;
-  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_LinkSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
-  iDynTree::Transform *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("LinkSensor_setLinkSensorTransform",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::LinkSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinkSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinkSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
-  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_LinkSensor_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("LinkSensor_isConsistent",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_isConsistent" "', argument " "1"" of type '" "iDynTree::LinkSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinkSensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinkSensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)((iDynTree::LinkSensor const *)arg1)->isConsistent((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_SensorsList__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  mxArray * _out;
-  iDynTree::SensorsList *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_SensorsList",argc,0,0,0)) {
-    SWIG_fail;
-  }
-  (void)argv;
-  result = (iDynTree::SensorsList *)new iDynTree::SensorsList();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsList, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_SensorsList__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = 0 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::SensorsList *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_SensorsList",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SensorsList,  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SensorsList" "', argument " "1"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SensorsList" "', argument " "1"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  result = (iDynTree::SensorsList *)new iDynTree::SensorsList((iDynTree::SensorsList const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsList, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_SensorsList(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_SensorsList__SWIG_0(resc,resv,argc,argv);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_SensorsList__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SensorsList'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::SensorsList::SensorsList()\n"
-    "    iDynTree::SensorsList::SensorsList(iDynTree::SensorsList const &)\n");
-  return 1;
-}
-
-
-int _wrap_delete_SensorsList(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  int is_owned;
-  if (!SWIG_check_num_args("delete_SensorsList",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SensorsList" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  if (is_owned) {
-    delete arg1;
-  }
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_addSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::Sensor *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  std::ptrdiff_t result;
-  
-  if (!SWIG_check_num_args("SensorsList_addSensor",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_addSensor" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Sensor,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SensorsList_addSensor" "', argument " "2"" of type '" "iDynTree::Sensor const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_addSensor" "', argument " "2"" of type '" "iDynTree::Sensor const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Sensor * >(argp2);
-  result = (arg1)->addSensor((iDynTree::Sensor const &)*arg2);
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_setSerialization(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  int res3 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsList_setSerialization",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_setSerialization" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_setSerialization" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res3 = swig::asptr(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_setSerialization" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_setSerialization" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  result = (bool)(arg1)->setSerialization((iDynTree::SensorType const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return 1;
-}
-
-
-int _wrap_SensorsList_getSerialization(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsList_getSerialization",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSerialization" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSerialization" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_getSerialization" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_getSerialization" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< std::string,std::allocator< std::string > > * >(argp3);
-  result = (bool)(arg1)->getSerialization((iDynTree::SensorType const &)*arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_getNrOfSensors(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  mxArray * _out;
-  std::size_t result;
-  
-  if (!SWIG_check_num_args("SensorsList_getNrOfSensors",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getNrOfSensors" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getNrOfSensors" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  result = ((iDynTree::SensorsList const *)arg1)->getNrOfSensors((iDynTree::SensorType const &)*arg2);
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_getSensorIndex__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::string *arg3 = 0 ;
-  std::ptrdiff_t *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  int res3 = SWIG_OLDOBJ ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsList_getSensorIndex",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSensorIndex" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSensorIndex" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  {
-    std::string *ptr = (std::string *)0;
-    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_getSensorIndex" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_getSensorIndex" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_ptrdiff_t,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsList_getSensorIndex" "', argument " "4"" of type '" "std::ptrdiff_t &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_getSensorIndex" "', argument " "4"" of type '" "std::ptrdiff_t &""'"); 
-  }
-  arg4 = reinterpret_cast< std::ptrdiff_t * >(argp4);
-  result = (bool)((iDynTree::SensorsList const *)arg1)->getSensorIndex((iDynTree::SensorType const &)*arg2,(std::string const &)*arg3,*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return 1;
-}
-
-
-int _wrap_SensorsList_getSensorIndex__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::string *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  int res3 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  std::ptrdiff_t result;
-  
-  if (!SWIG_check_num_args("SensorsList_getSensorIndex",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSensorIndex" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSensorIndex" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  {
-    std::string *ptr = (std::string *)0;
-    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_getSensorIndex" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_getSensorIndex" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  result = ((iDynTree::SensorsList const *)arg1)->getSensorIndex((iDynTree::SensorType const &)*arg2,(std::string const &)*arg3);
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return 1;
-}
-
-
-int _wrap_SensorsList_getSensorIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_SensorsList_getSensorIndex__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_ptrdiff_t, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_SensorsList_getSensorIndex__SWIG_0(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SensorsList_getSensorIndex'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::SensorsList::getSensorIndex(iDynTree::SensorType const &,std::string const &,std::ptrdiff_t &) const\n"
-    "    iDynTree::SensorsList::getSensorIndex(iDynTree::SensorType const &,std::string const &) const\n");
-  return 1;
-}
-
-
-int _wrap_SensorsList_getSizeOfAllSensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  size_t result;
-  
-  if (!SWIG_check_num_args("SensorsList_getSizeOfAllSensorsMeasurements",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSizeOfAllSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  result = ((iDynTree::SensorsList const *)arg1)->getSizeOfAllSensorsMeasurements();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_getSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::ptrdiff_t arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  iDynTree::Sensor *result = 0 ;
-  
-  if (!SWIG_check_num_args("SensorsList_getSensor",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSensor" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsList_getSensor" "', argument " "3"" of type '" "std::ptrdiff_t""'");
-  } 
-  arg3 = static_cast< std::ptrdiff_t >(val3);
-  result = (iDynTree::Sensor *)((iDynTree::SensorsList const *)arg1)->getSensor((iDynTree::SensorType const &)*arg2,arg3);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsList_isConsistent",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_isConsistent" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SensorsList_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)((iDynTree::SensorsList const *)arg1)->isConsistent((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_removeSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::string *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  int res3 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsList_removeSensor",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_removeSensor" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_removeSensor" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  {
-    std::string *ptr = (std::string *)0;
-    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_removeSensor" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_removeSensor" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  result = (bool)(arg1)->removeSensor((iDynTree::SensorType const &)*arg2,(std::string const &)*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  return 1;
-}
-
-
-int _wrap_SensorsList_removeSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::ptrdiff_t arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsList_removeSensor",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_removeSensor" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_removeSensor" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsList_removeSensor" "', argument " "3"" of type '" "std::ptrdiff_t""'");
-  } 
-  arg3 = static_cast< std::ptrdiff_t >(val3);
-  result = (bool)(arg1)->removeSensor((iDynTree::SensorType const &)*arg2,arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_removeSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          return _wrap_SensorsList_removeSensor__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_SensorsList_removeSensor__SWIG_0(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SensorsList_removeSensor'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::SensorsList::removeSensor(iDynTree::SensorType const &,std::string const &)\n"
-    "    iDynTree::SensorsList::removeSensor(iDynTree::SensorType const &,std::ptrdiff_t const)\n");
-  return 1;
-}
-
-
-int _wrap_SensorsList_removeAllSensorsOfType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsList_removeAllSensorsOfType",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_removeAllSensorsOfType" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_removeAllSensorsOfType" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  result = (bool)(arg1)->removeAllSensorsOfType((iDynTree::SensorType const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_getSixAxisForceTorqueSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  iDynTree::SixAxisForceTorqueSensor *result = 0 ;
-  
-  if (!SWIG_check_num_args("SensorsList_getSixAxisForceTorqueSensor",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSixAxisForceTorqueSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSixAxisForceTorqueSensor" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  result = (iDynTree::SixAxisForceTorqueSensor *)iDynTree_SensorsList_getSixAxisForceTorqueSensor((iDynTree::SensorsList const *)arg1,arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_getAccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  iDynTree::AccelerometerSensor *result = 0 ;
-  
-  if (!SWIG_check_num_args("SensorsList_getAccelerometerSensor",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getAccelerometerSensor" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  result = (iDynTree::AccelerometerSensor *)iDynTree_SensorsList_getAccelerometerSensor((iDynTree::SensorsList const *)arg1,arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_getGyroscopeSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  iDynTree::GyroscopeSensor *result = 0 ;
-  
-  if (!SWIG_check_num_args("SensorsList_getGyroscopeSensor",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getGyroscopeSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getGyroscopeSensor" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  result = (iDynTree::GyroscopeSensor *)iDynTree_SensorsList_getGyroscopeSensor((iDynTree::SensorsList const *)arg1,arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_getThreeAxisAngularAccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  iDynTree::ThreeAxisAngularAccelerometerSensor *result = 0 ;
-  
-  if (!SWIG_check_num_args("SensorsList_getThreeAxisAngularAccelerometerSensor",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getThreeAxisAngularAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getThreeAxisAngularAccelerometerSensor" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  result = (iDynTree::ThreeAxisAngularAccelerometerSensor *)iDynTree_SensorsList_getThreeAxisAngularAccelerometerSensor((iDynTree::SensorsList const *)arg1,arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsList_getThreeAxisForceTorqueContactSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
-  int arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 = 0 ;
-  mxArray * _out;
-  iDynTree::ThreeAxisForceTorqueContactSensor *result = 0 ;
-  
-  if (!SWIG_check_num_args("SensorsList_getThreeAxisForceTorqueContactSensor",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getThreeAxisForceTorqueContactSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  ecode2 = SWIG_AsVal_int(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getThreeAxisForceTorqueContactSensor" "', argument " "2"" of type '" "int""'");
-  } 
-  arg2 = static_cast< int >(val2);
-  result = (iDynTree::ThreeAxisForceTorqueContactSensor *)iDynTree_SensorsList_getThreeAxisForceTorqueContactSensor((iDynTree::SensorsList const *)arg1,arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_SensorsMeasurements__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  mxArray * _out;
-  iDynTree::SensorsMeasurements *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_SensorsMeasurements",argc,0,0,0)) {
-    SWIG_fail;
-  }
-  (void)argv;
-  result = (iDynTree::SensorsMeasurements *)new iDynTree::SensorsMeasurements();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsMeasurements, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_SensorsMeasurements__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsList *arg1 = 0 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::SensorsMeasurements *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_SensorsMeasurements",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SensorsList,  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
-  result = (iDynTree::SensorsMeasurements *)new iDynTree::SensorsMeasurements((iDynTree::SensorsList const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsMeasurements, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_SensorsMeasurements__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = 0 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::SensorsMeasurements *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_SensorsMeasurements",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SensorsMeasurements,  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  result = (iDynTree::SensorsMeasurements *)new iDynTree::SensorsMeasurements((iDynTree::SensorsMeasurements const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsMeasurements, 1 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_SensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_SensorsMeasurements__SWIG_0(resc,resv,argc,argv);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_SensorsMeasurements__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_SensorsMeasurements__SWIG_2(resc,resv,argc,argv);
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SensorsMeasurements'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::SensorsMeasurements::SensorsMeasurements()\n"
-    "    iDynTree::SensorsMeasurements::SensorsMeasurements(iDynTree::SensorsList const &)\n"
-    "    iDynTree::SensorsMeasurements::SensorsMeasurements(iDynTree::SensorsMeasurements const &)\n");
-  return 1;
-}
-
-
-int _wrap_delete_SensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  
-  int is_owned;
-  if (!SWIG_check_num_args("delete_SensorsMeasurements",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, SWIG_POINTER_DISOWN |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  if (is_owned) {
-    delete arg1;
-  }
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_setNrOfSensors(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::size_t arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_setNrOfSensors",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_setNrOfSensors" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_setNrOfSensors" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_setNrOfSensors" "', argument " "3"" of type '" "std::size_t""'");
-  } 
-  arg3 = static_cast< std::size_t >(val3);
-  result = (bool)(arg1)->setNrOfSensors((iDynTree::SensorType const &)*arg2,arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_getNrOfSensors(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  mxArray * _out;
-  std::size_t result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_getNrOfSensors",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_getNrOfSensors" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_getNrOfSensors" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  result = ((iDynTree::SensorsMeasurements const *)arg1)->getNrOfSensors((iDynTree::SensorType const &)*arg2);
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  iDynTree::SensorsList *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_resize",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_resize" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SensorsList,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SensorsMeasurements_resize" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_resize" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::SensorsList * >(argp2);
-  result = (bool)(arg1)->resize((iDynTree::SensorsList const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_toVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  iDynTree::VectorDynSize *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_toVector",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_toVector" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SensorsMeasurements_toVector" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_toVector" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::VectorDynSize * >(argp2);
-  result = (bool)((iDynTree::SensorsMeasurements const *)arg1)->toVector(*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_setMeasurement__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::ptrdiff_t *arg3 = 0 ;
-  iDynTree::Wrench *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  std::ptrdiff_t temp3 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_setMeasurement",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "3"" of type '" "std::ptrdiff_t""'");
-  } 
-  temp3 = static_cast< std::ptrdiff_t >(val3);
-  arg3 = &temp3;
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__Wrench,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "4"" of type '" "iDynTree::Wrench const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_setMeasurement" "', argument " "4"" of type '" "iDynTree::Wrench const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::Wrench * >(argp4);
-  result = (bool)(arg1)->setMeasurement((iDynTree::SensorType const &)*arg2,(std::ptrdiff_t const &)*arg3,(iDynTree::Wrench const &)*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_setMeasurement__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::ptrdiff_t *arg3 = 0 ;
-  iDynTree::Vector3 *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  std::ptrdiff_t temp3 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_setMeasurement",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "3"" of type '" "std::ptrdiff_t""'");
-  } 
-  temp3 = static_cast< std::ptrdiff_t >(val3);
-  arg3 = &temp3;
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "4"" of type '" "iDynTree::Vector3 const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_setMeasurement" "', argument " "4"" of type '" "iDynTree::Vector3 const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::Vector3 * >(argp4);
-  result = (bool)(arg1)->setMeasurement((iDynTree::SensorType const &)*arg2,(std::ptrdiff_t const &)*arg3,(iDynTree::Vector3 const &)*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_setMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__Wrench, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_SensorsMeasurements_setMeasurement__SWIG_0(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_SensorsMeasurements_setMeasurement__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SensorsMeasurements_setMeasurement'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::SensorsMeasurements::setMeasurement(iDynTree::SensorType const &,std::ptrdiff_t const &,iDynTree::Wrench const &)\n"
-    "    iDynTree::SensorsMeasurements::setMeasurement(iDynTree::SensorType const &,std::ptrdiff_t const &,iDynTree::Vector3 const &)\n");
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_getMeasurement__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::ptrdiff_t *arg3 = 0 ;
-  iDynTree::Wrench *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  std::ptrdiff_t temp3 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_getMeasurement",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "3"" of type '" "std::ptrdiff_t""'");
-  } 
-  temp3 = static_cast< std::ptrdiff_t >(val3);
-  arg3 = &temp3;
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__Wrench,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "4"" of type '" "iDynTree::Wrench &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_getMeasurement" "', argument " "4"" of type '" "iDynTree::Wrench &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::Wrench * >(argp4);
-  result = (bool)((iDynTree::SensorsMeasurements const *)arg1)->getMeasurement((iDynTree::SensorType const &)*arg2,(std::ptrdiff_t const &)*arg3,*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_getMeasurement__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  iDynTree::SensorType *arg2 = 0 ;
-  std::ptrdiff_t *arg3 = 0 ;
-  iDynTree::Vector3 *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int val2 ;
-  int ecode2 ;
-  iDynTree::SensorType temp2 ;
-  std::ptrdiff_t temp3 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_getMeasurement",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  ecode2 = SWIG_AsVal_int (argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
-  } else {
-    temp2 = static_cast< iDynTree::SensorType >(val2);
-    arg2 = &temp2;
-  }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "3"" of type '" "std::ptrdiff_t""'");
-  } 
-  temp3 = static_cast< std::ptrdiff_t >(val3);
-  arg3 = &temp3;
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "4"" of type '" "iDynTree::Vector3 &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_getMeasurement" "', argument " "4"" of type '" "iDynTree::Vector3 &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::Vector3 * >(argp4);
-  result = (bool)((iDynTree::SensorsMeasurements const *)arg1)->getMeasurement((iDynTree::SensorType const &)*arg2,(std::ptrdiff_t const &)*arg3,*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_getMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__Wrench, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_SensorsMeasurements_getMeasurement__SWIG_0(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_int(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        {
-          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_SensorsMeasurements_getMeasurement__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SensorsMeasurements_getMeasurement'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::SensorsMeasurements::getMeasurement(iDynTree::SensorType const &,std::ptrdiff_t const &,iDynTree::Wrench &) const\n"
-    "    iDynTree::SensorsMeasurements::getMeasurement(iDynTree::SensorType const &,std::ptrdiff_t const &,iDynTree::Vector3 &) const\n");
-  return 1;
-}
-
-
-int _wrap_SensorsMeasurements_getSizeOfAllSensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  size_t result;
-  
-  if (!SWIG_check_num_args("SensorsMeasurements_getSizeOfAllSensorsMeasurements",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_getSizeOfAllSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
-  result = ((iDynTree::SensorsMeasurements const *)arg1)->getSizeOfAllSensorsMeasurements();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_Neighbor_neighborLink_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Neighbor *arg1 = (iDynTree::Neighbor *) 0 ;
   iDynTree::LinkIndex arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   ptrdiff_t val2 ;
   int ecode2 = 0 ;
@@ -57888,76 +52675,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_Model_getPackageDirs(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = (iDynTree::Model *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< std::string,std::allocator< std::string > > *result = 0 ;
-  
-  if (!SWIG_check_num_args("Model_getPackageDirs",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Model, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getPackageDirs" "', argument " "1"" of type '" "iDynTree::Model const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  result = (std::vector< std::string,std::allocator< std::string > > *) &((iDynTree::Model const *)arg1)->getPackageDirs();
-  _out = swig::from(static_cast< std::vector< std::string,std::allocator< std::string > > >(*result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Model_setPackageDirs(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = (iDynTree::Model *) 0 ;
-  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("Model_setPackageDirs",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Model, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setPackageDirs" "', argument " "1"" of type '" "iDynTree::Model *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res2 = swig::asptr(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setPackageDirs" "', argument " "2"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setPackageDirs" "', argument " "2"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg2 = ptr;
-  }
-  (arg1)->setPackageDirs((std::vector< std::string,std::allocator< std::string > > const &)*arg2);
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  return 1;
-}
-
-
 int _wrap_Model_getLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Model *arg1 = (iDynTree::Model *) 0 ;
   iDynTree::LinkIndex arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   ptrdiff_t val2 ;
   int ecode2 = 0 ;
@@ -59766,90 +54491,14 @@
     "  Possible C/C++ prototypes are:\n"
     "    iDynTree::Model::collisionSolidShapes()\n"
     "    iDynTree::Model::collisionSolidShapes() const\n");
   return 1;
 }
 
 
-int _wrap_Model_sensors__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = (iDynTree::Model *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::SensorsList *result = 0 ;
-  
-  if (!SWIG_check_num_args("Model_sensors",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Model, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_sensors" "', argument " "1"" of type '" "iDynTree::Model *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  result = (iDynTree::SensorsList *) &(arg1)->sensors();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Model_sensors__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = (iDynTree::Model *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  iDynTree::SensorsList *result = 0 ;
-  
-  if (!SWIG_check_num_args("Model_sensors",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Model, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_sensors" "', argument " "1"" of type '" "iDynTree::Model const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  result = (iDynTree::SensorsList *) &((iDynTree::Model const *)arg1)->sensors();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_Model_sensors(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_Model_sensors__SWIG_0(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_Model_sensors__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'Model_sensors'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::Model::sensors()\n"
-    "    iDynTree::Model::sensors() const\n");
-  return 1;
-}
-
-
 int _wrap_Model_toString(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Model *arg1 = (iDynTree::Model *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
   std::string result;
   
@@ -59866,38 +54515,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_Model_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = (iDynTree::Model *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("Model_isValid",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Model, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isValid" "', argument " "1"" of type '" "iDynTree::Model const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  result = (bool)((iDynTree::Model const *)arg1)->isValid();
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_new_JointPosDoubleArray__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   std::size_t arg1 ;
   size_t val1 ;
   int ecode1 = 0 ;
   mxArray * _out;
   iDynTree::JointPosDoubleArray *result = 0 ;
   
@@ -64996,3203 +59621,4246 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SixAxisForceTorqueSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_SolidShapesVector_pop(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   mxArray * _out;
-  iDynTree::SixAxisForceTorqueSensor *result = 0 ;
+  std::vector< iDynTree::SolidShape * >::value_type result;
   
-  if (!SWIG_check_num_args("new_SixAxisForceTorqueSensor",argc,0,0,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_pop",argc,1,1,0)) {
     SWIG_fail;
   }
-  (void)argv;
-  result = (iDynTree::SixAxisForceTorqueSensor *)new iDynTree::SixAxisForceTorqueSensor();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 1 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_pop" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  try {
+    result = (std::vector< iDynTree::SolidShape * >::value_type)std_vector_Sl_iDynTree_SolidShape_Sm__Sg__pop(arg1);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SixAxisForceTorqueSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = 0 ;
-  void *argp1 ;
+int _wrap_SolidShapesVector_brace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::difference_type arg2 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  iDynTree::SixAxisForceTorqueSensor *result = 0 ;
+  std::vector< iDynTree::SolidShape * >::value_type result;
   
-  if (!SWIG_check_num_args("new_SixAxisForceTorqueSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_brace",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SixAxisForceTorqueSensor" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_brace" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SixAxisForceTorqueSensor" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const &""'"); 
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_brace" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::difference_type""'");
+  } 
+  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::difference_type >(val2);
+  try {
+    result = (std::vector< iDynTree::SolidShape * >::value_type)std_vector_Sl_iDynTree_SolidShape_Sm__Sg__brace(arg1,arg2);
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = (iDynTree::SixAxisForceTorqueSensor *)new iDynTree::SixAxisForceTorqueSensor((iDynTree::SixAxisForceTorqueSensor const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 1 |  0 );
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SixAxisForceTorqueSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_SixAxisForceTorqueSensor__SWIG_0(resc,resv,argc,argv);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_SixAxisForceTorqueSensor__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SixAxisForceTorqueSensor'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::SixAxisForceTorqueSensor::SixAxisForceTorqueSensor()\n"
-    "    iDynTree::SixAxisForceTorqueSensor::SixAxisForceTorqueSensor(iDynTree::SixAxisForceTorqueSensor const &)\n");
-  return 1;
-}
-
-
-int _wrap_delete_SixAxisForceTorqueSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_setbrace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::value_type arg2 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
+  std::vector< iDynTree::SolidShape * >::difference_type arg3 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
   mxArray * _out;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_SixAxisForceTorqueSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_setbrace",argc,3,3,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SixAxisForceTorqueSensor" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_setbrace" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  if (is_owned) {
-    delete arg1;
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolidShapesVector_setbrace" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
+  }
+  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp2);
+  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SolidShapesVector_setbrace" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::difference_type""'");
+  } 
+  arg3 = static_cast< std::vector< iDynTree::SolidShape * >::difference_type >(val3);
+  try {
+    std_vector_Sl_iDynTree_SolidShape_Sm__Sg__setbrace(arg1,arg2,arg3);
   }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  std::string *arg2 = 0 ;
+int _wrap_SolidShapesVector_append(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::value_type arg2 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setName",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_append",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_append" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolidShapesVector_append" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
   }
-  result = (bool)(arg1)->setName((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp2);
+  std_vector_Sl_iDynTree_SolidShape_Sm__Sg__append(arg1,arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_setFirstLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::LinkIndex arg2 ;
-  iDynTree::Transform *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
+int _wrap_new_SolidShapesVector__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  bool result;
+  std::vector< iDynTree::SolidShape * > *result = 0 ;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setFirstLinkSensorTransform",argc,3,3,0)) {
+  if (!SWIG_check_num_args("new_SolidShapesVector",argc,0,0,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setFirstLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_setFirstLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  arg2 = static_cast< iDynTree::LinkIndex >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Transform,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_setFirstLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setFirstLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::Transform * >(argp3);
-  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->setFirstLinkSensorTransform(arg2,(iDynTree::Transform const &)*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  (void)argv;
+  result = (std::vector< iDynTree::SolidShape * > *)new std::vector< iDynTree::SolidShape * >();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_setSecondLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::LinkIndex arg2 ;
-  iDynTree::Transform *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
+int _wrap_new_SolidShapesVector__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
+  std::vector< iDynTree::SolidShape * > *result = 0 ;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setSecondLinkSensorTransform",argc,3,3,0)) {
+  if (!SWIG_check_num_args("new_SolidShapesVector",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setSecondLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_setSecondLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  arg2 = static_cast< iDynTree::LinkIndex >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Transform,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_setSecondLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setSecondLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
+  {
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    res1 = swig::asptr(argv[0], &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const &""'"); 
+    }
+    arg1 = ptr;
   }
-  arg3 = reinterpret_cast< iDynTree::Transform * >(argp3);
-  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->setSecondLinkSensorTransform(arg2,(iDynTree::Transform const &)*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  result = (std::vector< iDynTree::SolidShape * > *)new std::vector< iDynTree::SolidShape * >((std::vector< iDynTree::SolidShape * > const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res1)) delete arg1;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res1)) delete arg1;
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getFirstLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_empty(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::LinkIndex result;
+  bool result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getFirstLinkIndex",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_empty",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getFirstLinkIndex" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_empty" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getFirstLinkIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = (bool)((std::vector< iDynTree::SolidShape * > const *)arg1)->empty();
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getSecondLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_size(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::LinkIndex result;
+  std::vector< iDynTree::SolidShape * >::size_type result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getSecondLinkIndex",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_size",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getSecondLinkIndex" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_size" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getSecondLinkIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = ((std::vector< iDynTree::SolidShape * > const *)arg1)->size();
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_setFirstLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  std::string *arg2 = 0 ;
+int _wrap_SolidShapesVector_swap(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * > *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setFirstLinkName",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_swap",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setFirstLinkName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_swap" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_setFirstLinkName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setFirstLinkName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolidShapesVector_swap" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * > &""'"); 
   }
-  result = (bool)(arg1)->setFirstLinkName((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SolidShapesVector_swap" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * > &""'"); 
+  }
+  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp2);
+  (arg1)->swap(*arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_setSecondLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  std::string *arg2 = 0 ;
+int _wrap_SolidShapesVector_begin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
+  std::vector< iDynTree::SolidShape * >::iterator result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setSecondLinkName",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_begin",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setSecondLinkName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_setSecondLinkName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setSecondLinkName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_begin" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  result = (bool)(arg1)->setSecondLinkName((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = (arg1)->begin();
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getFirstLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_end(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::string result;
+  std::vector< iDynTree::SolidShape * >::iterator result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getFirstLinkName",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_end",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getFirstLinkName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_end" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getFirstLinkName();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = (arg1)->end();
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getSecondLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_rbegin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::string result;
+  std::vector< iDynTree::SolidShape * >::reverse_iterator result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getSecondLinkName",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_rbegin",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getSecondLinkName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_rbegin" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getSecondLinkName();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = (arg1)->rbegin();
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::reverse_iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_setParentJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  std::string *arg2 = 0 ;
+int _wrap_SolidShapesVector_rend(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
+  std::vector< iDynTree::SolidShape * >::reverse_iterator result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setParentJoint",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_rend",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setParentJoint" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_setParentJoint" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setParentJoint" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_rend" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  result = (bool)(arg1)->setParentJoint((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = (arg1)->rend();
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::reverse_iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_setParentJointIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::JointIndex *arg2 = 0 ;
+int _wrap_SolidShapesVector_clear(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  iDynTree::JointIndex temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setParentJointIndex",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_clear",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setParentJointIndex" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_clear" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_setParentJointIndex" "', argument " "2"" of type '" "iDynTree::JointIndex""'");
-  } 
-  temp2 = static_cast< iDynTree::JointIndex >(val2);
-  arg2 = &temp2;
-  result = (bool)(arg1)->setParentJointIndex((iDynTree::JointIndex const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  (arg1)->clear();
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_setAppliedWrenchLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::LinkIndex arg2 ;
+int _wrap_SolidShapesVector_get_allocator(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  bool result;
+  SwigValueWrapper< std::allocator< iDynTree::SolidShape * > > result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setAppliedWrenchLink",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_get_allocator",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setAppliedWrenchLink" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_get_allocator" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_setAppliedWrenchLink" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  arg2 = static_cast< iDynTree::LinkIndex >(val2);
-  result = (bool)(arg1)->setAppliedWrenchLink(arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = ((std::vector< iDynTree::SolidShape * > const *)arg1)->get_allocator();
+  _out = SWIG_NewPointerObj((new std::vector< iDynTree::SolidShape * >::allocator_type(static_cast< const std::vector< iDynTree::SolidShape * >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_iDynTree__SolidShape_p_t, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
+int _wrap_new_SolidShapesVector__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * >::size_type arg1 ;
+  size_t val1 ;
+  int ecode1 = 0 ;
   mxArray * _out;
-  std::string result;
+  std::vector< iDynTree::SolidShape * > *result = 0 ;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getName",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_SolidShapesVector",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getName();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
+  } 
+  arg1 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val1);
+  result = (std::vector< iDynTree::SolidShape * > *)new std::vector< iDynTree::SolidShape * >(arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_pop_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::SensorType result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getSensorType",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_pop_back",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_pop_back" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = (iDynTree::SensorType)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getSensorType();
-  _out = SWIG_From_int(static_cast< int >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  (arg1)->pop_back();
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getParentJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_resize__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::size_type arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  std::string result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getParentJoint",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_resize",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getParentJoint" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_resize" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getParentJoint();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_resize" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val2);
+  (arg1)->resize(arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getParentJointIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_erase__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::iterator arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  swig::MatlabSwigIterator *iter2 = 0 ;
+  int res2 ;
   mxArray * _out;
-  iDynTree::JointIndex result;
+  std::vector< iDynTree::SolidShape * >::iterator result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getParentJointIndex",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_erase",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getParentJointIndex" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_erase" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getParentJointIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+    }
+  }
+  result = std_vector_Sl_iDynTree_SolidShape_Sm__Sg__erase__SWIG_0(arg1,arg2);
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_erase__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::iterator arg2 ;
+  std::vector< iDynTree::SolidShape * >::iterator arg3 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  swig::MatlabSwigIterator *iter2 = 0 ;
+  int res2 ;
+  swig::MatlabSwigIterator *iter3 = 0 ;
+  int res3 ;
   mxArray * _out;
-  bool result;
+  std::vector< iDynTree::SolidShape * >::iterator result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_isValid",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_erase",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_isValid" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_erase" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->isValid();
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+    }
+  }
+  res3 = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter3), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res3) || !iter3) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter3);
+    if (iter_t) {
+      arg3 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+    }
+  }
+  result = std_vector_Sl_iDynTree_SolidShape_Sm__Sg__erase__SWIG_1(arg1,arg2,arg3);
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
+int _wrap_SolidShapesVector_erase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 2) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::MatlabSwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
+      if (_v) {
+        return _wrap_SolidShapesVector_erase__SWIG_0(resc,resv,argc,argv);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::MatlabSwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
+      if (_v) {
+        swig::MatlabSwigIterator *iter = 0;
+        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
+        if (_v) {
+          return _wrap_SolidShapesVector_erase__SWIG_1(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SolidShapesVector_erase'."
+    "  Possible C/C++ prototypes are:\n"
+    "    std::vector< iDynTree::SolidShape * >::erase(std::vector< iDynTree::SolidShape * >::iterator)\n"
+    "    std::vector< iDynTree::SolidShape * >::erase(std::vector< iDynTree::SolidShape * >::iterator,std::vector< iDynTree::SolidShape * >::iterator)\n");
+  return 1;
+}
+
+
+int _wrap_new_SolidShapesVector__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * >::size_type arg1 ;
+  std::vector< iDynTree::SolidShape * >::value_type arg2 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
+  size_t val1 ;
+  int ecode1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::Sensor *result = 0 ;
+  std::vector< iDynTree::SolidShape * > *result = 0 ;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_clone",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_SolidShapesVector",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_clone" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
+  } 
+  arg1 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_SolidShapesVector" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = (iDynTree::Sensor *)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->clone();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp2);
+  result = (std::vector< iDynTree::SolidShape * > *)new std::vector< iDynTree::SolidShape * >(arg1,arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
+int _wrap_new_SolidShapesVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_SolidShapesVector__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    {
+      int res = SWIG_AsVal_size_t(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      return _wrap_new_SolidShapesVector__SWIG_2(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_SolidShapesVector__SWIG_1(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 2) {
+    int _v;
+    {
+      int res = SWIG_AsVal_size_t(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__SolidShape, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_new_SolidShapesVector__SWIG_3(resc,resv,argc,argv);
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SolidShapesVector'."
+    "  Possible C/C++ prototypes are:\n"
+    "    std::vector< iDynTree::SolidShape * >::vector()\n"
+    "    std::vector< iDynTree::SolidShape * >::vector(std::vector< iDynTree::SolidShape * > const &)\n"
+    "    std::vector< iDynTree::SolidShape * >::vector(std::vector< iDynTree::SolidShape * >::size_type)\n"
+    "    std::vector< iDynTree::SolidShape * >::vector(std::vector< iDynTree::SolidShape * >::size_type,std::vector< iDynTree::SolidShape * >::value_type)\n");
+  return 1;
+}
+
+
+int _wrap_SolidShapesVector_push_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::value_type arg2 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
+  void *argp2 = 0 ;
   int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_updateIndices",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_push_back",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_push_back" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolidShapesVector_push_back" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp2);
+  (arg1)->push_back(arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getAppliedWrenchLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+int _wrap_SolidShapesVector_front(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::LinkIndex result;
+  std::vector< iDynTree::SolidShape * >::value_type result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getAppliedWrenchLink",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_front",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getAppliedWrenchLink" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_front" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getAppliedWrenchLink();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = (std::vector< iDynTree::SolidShape * >::value_type)((std::vector< iDynTree::SolidShape * > const *)arg1)->front();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_isLinkAttachedToSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::LinkIndex arg2 ;
+int _wrap_SolidShapesVector_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  bool result;
+  std::vector< iDynTree::SolidShape * >::value_type result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_isLinkAttachedToSensor",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_back",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_isLinkAttachedToSensor" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_back" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_isLinkAttachedToSensor" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  arg2 = static_cast< iDynTree::LinkIndex >(val2);
-  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->isLinkAttachedToSensor(arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = (std::vector< iDynTree::SolidShape * >::value_type)((std::vector< iDynTree::SolidShape * > const *)arg1)->back();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::LinkIndex arg2 ;
-  iDynTree::Transform *arg3 = 0 ;
+int _wrap_SolidShapesVector_assign(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::size_type arg2 ;
+  std::vector< iDynTree::SolidShape * >::value_type arg3 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  ptrdiff_t val2 ;
+  size_t val2 ;
   int ecode2 = 0 ;
   void *argp3 = 0 ;
   int res3 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getLinkSensorTransform",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_assign",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_assign" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_getLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_assign" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
   } 
-  arg2 = static_cast< iDynTree::LinkIndex >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Transform,  0 );
+  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_getLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SolidShapesVector_assign" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::Transform * >(argp3);
-  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getLinkSensorTransform(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg3 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp3);
+  (arg1)->assign(arg2,arg3);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::LinkIndex arg2 ;
-  iDynTree::Wrench *arg3 = 0 ;
-  iDynTree::Wrench *arg4 = 0 ;
+int _wrap_SolidShapesVector_resize__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::size_type arg2 ;
+  std::vector< iDynTree::SolidShape * >::value_type arg3 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  ptrdiff_t val2 ;
+  size_t val2 ;
   int ecode2 = 0 ;
-  void *argp3 ;
+  void *argp3 = 0 ;
   int res3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getWrenchAppliedOnLink",argc,4,4,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_resize",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_resize" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_resize" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
   } 
-  arg2 = static_cast< iDynTree::LinkIndex >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Wrench,  0 );
+  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "3"" of type '" "iDynTree::Wrench const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "3"" of type '" "iDynTree::Wrench const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::Wrench * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__Wrench,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "4"" of type '" "iDynTree::Wrench &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "4"" of type '" "iDynTree::Wrench &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SolidShapesVector_resize" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::Wrench * >(argp4);
-  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getWrenchAppliedOnLink(arg2,(iDynTree::Wrench const &)*arg3,*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg3 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp3);
+  (arg1)->resize(arg2,arg3);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::LinkIndex arg2 ;
-  iDynTree::Matrix6x6 *arg3 = 0 ;
+int _wrap_SolidShapesVector_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 2) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_SolidShapesVector_resize__SWIG_0(resc,resv,argc,argv);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        void *vptr = 0;
+        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__SolidShape, 0);
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_SolidShapesVector_resize__SWIG_1(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SolidShapesVector_resize'."
+    "  Possible C/C++ prototypes are:\n"
+    "    std::vector< iDynTree::SolidShape * >::resize(std::vector< iDynTree::SolidShape * >::size_type)\n"
+    "    std::vector< iDynTree::SolidShape * >::resize(std::vector< iDynTree::SolidShape * >::size_type,std::vector< iDynTree::SolidShape * >::value_type)\n");
+  return 1;
+}
+
+
+int _wrap_SolidShapesVector_insert__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::iterator arg2 ;
+  std::vector< iDynTree::SolidShape * >::value_type arg3 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
+  swig::MatlabSwigIterator *iter2 = 0 ;
+  int res2 ;
   void *argp3 = 0 ;
   int res3 = 0 ;
   mxArray * _out;
-  bool result;
+  std::vector< iDynTree::SolidShape * >::iterator result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_insert",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_insert" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  arg2 = static_cast< iDynTree::LinkIndex >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__MatrixFixSizeT_6_6_t,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix" "', argument " "3"" of type '" "iDynTree::Matrix6x6 &""'"); 
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+    }
   }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix" "', argument " "3"" of type '" "iDynTree::Matrix6x6 &""'"); 
+  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::Matrix6x6 * >(argp3);
-  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getWrenchAppliedOnLinkMatrix(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg3 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp3);
+  result = std_vector_Sl_iDynTree_SolidShape_Sm__Sg__insert__SWIG_0(arg1,arg2,arg3);
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::LinkIndex arg2 ;
-  iDynTree::Matrix6x6 *arg3 = 0 ;
+int _wrap_SolidShapesVector_insert__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::iterator arg2 ;
+  std::vector< iDynTree::SolidShape * >::size_type arg3 ;
+  std::vector< iDynTree::SolidShape * >::value_type arg4 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
+  swig::MatlabSwigIterator *iter2 = 0 ;
+  int res2 ;
+  size_t val3 ;
+  int ecode3 = 0 ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_insert",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_insert" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  arg2 = static_cast< iDynTree::LinkIndex >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__MatrixFixSizeT_6_6_t,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix" "', argument " "3"" of type '" "iDynTree::Matrix6x6 &""'"); 
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+    }
   }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix" "', argument " "3"" of type '" "iDynTree::Matrix6x6 &""'"); 
+  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
+  } 
+  arg3 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SolidShapesVector_insert" "', argument " "4"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::Matrix6x6 * >(argp3);
-  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getWrenchAppliedOnLinkInverseMatrix(arg2,*arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg4 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp4);
+  std_vector_Sl_iDynTree_SolidShape_Sm__Sg__insert__SWIG_1(arg1,arg2,arg3,arg4);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_predictMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::LinkInternalWrenches *arg3 = 0 ;
+int _wrap_SolidShapesVector_insert(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::MatlabSwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
+      if (_v) {
+        void *vptr = 0;
+        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__SolidShape, 0);
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_SolidShapesVector_insert__SWIG_0(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  if (argc == 4) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::MatlabSwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
+      if (_v) {
+        {
+          int res = SWIG_AsVal_size_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__SolidShape, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_SolidShapesVector_insert__SWIG_1(resc,resv,argc,argv);
+          }
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SolidShapesVector_insert'."
+    "  Possible C/C++ prototypes are:\n"
+    "    std::vector< iDynTree::SolidShape * >::insert(std::vector< iDynTree::SolidShape * >::iterator,std::vector< iDynTree::SolidShape * >::value_type)\n"
+    "    std::vector< iDynTree::SolidShape * >::insert(std::vector< iDynTree::SolidShape * >::iterator,std::vector< iDynTree::SolidShape * >::size_type,std::vector< iDynTree::SolidShape * >::value_type)\n");
+  return 1;
+}
+
+
+int _wrap_SolidShapesVector_reserve(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  std::vector< iDynTree::SolidShape * >::size_type arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  iDynTree::Wrench result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_predictMeasurement",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_reserve",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "3"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "3"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_reserve" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp3);
-  result = (arg1)->predictMeasurement((iDynTree::Traversal const &)*arg2,(iDynTree::LinkInternalWrenches const &)*arg3);
-  _out = SWIG_NewPointerObj((new iDynTree::Wrench(static_cast< const iDynTree::Wrench& >(result))), SWIGTYPE_p_iDynTree__Wrench, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_reserve" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val2);
+  (arg1)->reserve(arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SixAxisForceTorqueSensor_toString(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
+int _wrap_SolidShapesVector_capacity(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
   mxArray * _out;
-  std::string result;
+  std::vector< iDynTree::SolidShape * >::size_type result;
   
-  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_toString",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SolidShapesVector_capacity",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_toString" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_toString" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_toString" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_capacity" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->toString((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  result = ((std::vector< iDynTree::SolidShape * > const *)arg1)->capacity();
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_AccelerometerSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_delete_SolidShapesVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   mxArray * _out;
-  iDynTree::AccelerometerSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("new_AccelerometerSensor",argc,0,0,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_SolidShapesVector",argc,1,1,0)) {
     SWIG_fail;
   }
-  (void)argv;
-  result = (iDynTree::AccelerometerSensor *)new iDynTree::AccelerometerSensor();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__AccelerometerSensor, 1 |  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
+  if (is_owned) {
+    delete arg1;
+  }
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_AccelerometerSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = 0 ;
-  void *argp1 ;
+int _wrap_LinksSolidShapesVector_pop(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::AccelerometerSensor *result = 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type result;
   
-  if (!SWIG_check_num_args("new_AccelerometerSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_pop",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__AccelerometerSensor,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AccelerometerSensor" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_pop" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_AccelerometerSensor" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const &""'"); 
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  try {
+    result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__pop(arg1);
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  result = (iDynTree::AccelerometerSensor *)new iDynTree::AccelerometerSensor((iDynTree::AccelerometerSensor const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__AccelerometerSensor, 1 |  0 );
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  }
+  
+  _out = swig::from(static_cast< std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_AccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_AccelerometerSensor__SWIG_0(resc,resv,argc,argv);
+int _wrap_LinksSolidShapesVector_brace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::difference_type arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type result;
+  
+  if (!SWIG_check_num_args("LinksSolidShapesVector_brace",argc,2,2,0)) {
+    SWIG_fail;
   }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__AccelerometerSensor, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_AccelerometerSensor__SWIG_1(resc,resv,argc,argv);
-    }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_brace" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_brace" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::difference_type""'");
+  } 
+  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::difference_type >(val2);
+  try {
+    result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__brace(arg1,arg2);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_AccelerometerSensor'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::AccelerometerSensor::AccelerometerSensor()\n"
-    "    iDynTree::AccelerometerSensor::AccelerometerSensor(iDynTree::AccelerometerSensor const &)\n");
+  _out = swig::from(static_cast< std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
   return 1;
 }
 
 
-int _wrap_delete_AccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_setbrace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type arg2 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::difference_type arg3 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
   mxArray * _out;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_AccelerometerSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_setbrace",argc,3,3,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AccelerometerSensor" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_setbrace" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  if (is_owned) {
-    delete arg1;
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  {
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    int res = swig::asptr(argv[1], &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "LinksSolidShapesVector_setbrace" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type""'"); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "LinksSolidShapesVector_setbrace" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::difference_type""'");
+  } 
+  arg3 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::difference_type >(val3);
+  try {
+    std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__setbrace(arg1,arg2,arg3);
+  }
+  catch(std::out_of_range &_e) {
+    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
   }
+  
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
-  std::string *arg2 = 0 ;
+int _wrap_LinksSolidShapesVector_append(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_setName",argc,2,2,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_append",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_setName" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_append" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
   {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    int res = swig::asptr(argv[1], &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "LinksSolidShapesVector_append" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type""'"); 
     }
-    arg2 = ptr;
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
   }
-  result = (bool)(arg1)->setName((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__append(arg1,arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
-  iDynTree::Transform *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
+int _wrap_new_LinksSolidShapesVector__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  bool result;
+  std::vector< std::vector< iDynTree::SolidShape * > > *result = 0 ;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_setLinkSensorTransform",argc,2,2,0)) {
+  if (!SWIG_check_num_args("new_LinksSolidShapesVector",argc,0,0,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
-  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  (void)argv;
+  result = (std::vector< std::vector< iDynTree::SolidShape * > > *)new std::vector< std::vector< iDynTree::SolidShape * > >();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
-  std::string *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
+int _wrap_new_LinksSolidShapesVector__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > *arg1 = 0 ;
+  int res1 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
+  std::vector< std::vector< iDynTree::SolidShape * > > *result = 0 ;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_setParentLink",argc,2,2,0)) {
+  if (!SWIG_check_num_args("new_LinksSolidShapesVector",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
   {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > > *ptr = (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > > *)0;
+    res1 = swig::asptr(argv[0], &ptr);
+    if (!SWIG_IsOK(res1)) {
+      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > const &""'"); 
     }
     if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > const &""'"); 
     }
-    arg2 = ptr;
+    arg1 = ptr;
   }
-  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  result = (std::vector< std::vector< iDynTree::SolidShape * > > *)new std::vector< std::vector< iDynTree::SolidShape * > >((std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
+  if (SWIG_IsNewObj(res1)) delete arg1;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
+  if (SWIG_IsNewObj(res1)) delete arg1;
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
-  iDynTree::LinkIndex *arg2 = 0 ;
+int _wrap_LinksSolidShapesVector_empty(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  iDynTree::LinkIndex temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_setParentLinkIndex",argc,2,2,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_empty",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_empty" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AccelerometerSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  temp2 = static_cast< iDynTree::LinkIndex >(val2);
-  arg2 = &temp2;
-  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = (bool)((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->empty();
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_size(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::string result;
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_getName",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_size",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getName" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_size" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  result = ((iDynTree::AccelerometerSensor const *)arg1)->getName();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = ((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->size();
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_swap(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::SensorType result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_getSensorType",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_swap",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_swap" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  result = (iDynTree::SensorType)((iDynTree::AccelerometerSensor const *)arg1)->getSensorType();
-  _out = SWIG_From_int(static_cast< int >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinksSolidShapesVector_swap" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_swap" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > &""'"); 
+  }
+  arg2 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > * >(argp2);
+  (arg1)->swap(*arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_begin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::string result;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_getParentLink",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_begin",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_begin" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  result = ((iDynTree::AccelerometerSensor const *)arg1)->getParentLink();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = (arg1)->begin();
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_end(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::LinkIndex result;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_getParentLinkIndex",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_end",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_end" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  result = ((iDynTree::AccelerometerSensor const *)arg1)->getParentLinkIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = (arg1)->end();
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_rbegin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::Transform result;
+  std::vector< std::vector< iDynTree::SolidShape * > >::reverse_iterator result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_getLinkSensorTransform",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_rbegin",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_rbegin" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  result = ((iDynTree::AccelerometerSensor const *)arg1)->getLinkSensorTransform();
-  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = (arg1)->rbegin();
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::reverse_iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_rend(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  bool result;
+  std::vector< std::vector< iDynTree::SolidShape * > >::reverse_iterator result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_isValid",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_rend",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_isValid" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_rend" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  result = (bool)((iDynTree::AccelerometerSensor const *)arg1)->isValid();
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = (arg1)->rend();
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::reverse_iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_clear(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::Sensor *result = 0 ;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_clone",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_clear",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_clone" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_clear" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  result = (iDynTree::Sensor *)((iDynTree::AccelerometerSensor const *)arg1)->clone();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  (arg1)->clear();
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
+int _wrap_LinksSolidShapesVector_get_allocator(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
   mxArray * _out;
-  bool result;
+  SwigValueWrapper< std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > > result;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_updateIndices",argc,2,2,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_get_allocator",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_get_allocator" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = ((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->get_allocator();
+  _out = SWIG_NewPointerObj((new std::vector< std::vector< iDynTree::SolidShape * > >::allocator_type(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_AccelerometerSensor_predictMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
-  iDynTree::SpatialAcc *arg2 = 0 ;
-  iDynTree::Twist *arg3 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
+int _wrap_new_LinksSolidShapesVector__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg1 ;
+  size_t val1 ;
+  int ecode1 = 0 ;
   mxArray * _out;
-  iDynTree::LinAcceleration result;
+  std::vector< std::vector< iDynTree::SolidShape * > > *result = 0 ;
   
-  if (!SWIG_check_num_args("AccelerometerSensor_predictMeasurement",argc,3,3,0)) {
+  if (!SWIG_check_num_args("new_LinksSolidShapesVector",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialAcc,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::SpatialAcc const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::SpatialAcc const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::SpatialAcc * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Twist,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "3"" of type '" "iDynTree::Twist const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "3"" of type '" "iDynTree::Twist const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::Twist * >(argp3);
-  result = (arg1)->predictMeasurement((iDynTree::SpatialAcc const &)*arg2,(iDynTree::Twist const &)*arg3);
-  _out = SWIG_NewPointerObj((new iDynTree::LinAcceleration(static_cast< const iDynTree::LinAcceleration& >(result))), SWIGTYPE_p_iDynTree__GeomVector3, SWIG_POINTER_OWN |  0 );
+  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
+  } 
+  arg1 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val1);
+  result = (std::vector< std::vector< iDynTree::SolidShape * > > *)new std::vector< std::vector< iDynTree::SolidShape * > >(arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_GyroscopeSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_LinksSolidShapesVector_pop_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   mxArray * _out;
-  iDynTree::GyroscopeSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("new_GyroscopeSensor",argc,0,0,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_pop_back",argc,1,1,0)) {
     SWIG_fail;
   }
-  (void)argv;
-  result = (iDynTree::GyroscopeSensor *)new iDynTree::GyroscopeSensor();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__GyroscopeSensor, 1 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_pop_back" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  (arg1)->pop_back();
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_GyroscopeSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = 0 ;
-  void *argp1 ;
+int _wrap_LinksSolidShapesVector_resize__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg2 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  iDynTree::GyroscopeSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("new_GyroscopeSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_resize",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__GyroscopeSensor,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GyroscopeSensor" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GyroscopeSensor" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_resize" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  result = (iDynTree::GyroscopeSensor *)new iDynTree::GyroscopeSensor((iDynTree::GyroscopeSensor const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__GyroscopeSensor, 1 |  0 );
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_resize" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val2);
+  (arg1)->resize(arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_GyroscopeSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_GyroscopeSensor__SWIG_0(resc,resv,argc,argv);
+int _wrap_LinksSolidShapesVector_erase__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  swig::MatlabSwigIterator *iter2 = 0 ;
+  int res2 ;
+  mxArray * _out;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
+  
+  if (!SWIG_check_num_args("LinksSolidShapesVector_erase",argc,2,2,0)) {
+    SWIG_fail;
   }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__GyroscopeSensor, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_GyroscopeSensor__SWIG_1(resc,resv,argc,argv);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_erase" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+  }
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
     }
   }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_GyroscopeSensor'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::GyroscopeSensor::GyroscopeSensor()\n"
-    "    iDynTree::GyroscopeSensor::GyroscopeSensor(iDynTree::GyroscopeSensor const &)\n");
+  result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__erase__SWIG_0(arg1,arg2);
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
   return 1;
 }
 
 
-int _wrap_delete_GyroscopeSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_erase__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg2 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg3 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  swig::MatlabSwigIterator *iter2 = 0 ;
+  int res2 ;
+  swig::MatlabSwigIterator *iter3 = 0 ;
+  int res3 ;
   mxArray * _out;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_GyroscopeSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_erase",argc,3,3,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GyroscopeSensor" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_erase" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  if (is_owned) {
-    delete arg1;
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+    }
   }
-  _out = (mxArray*)0;
+  res3 = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter3), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res3) || !iter3) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter3);
+    if (iter_t) {
+      arg3 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+    }
+  }
+  result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__erase__SWIG_1(arg1,arg2,arg3);
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
-  std::string *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
+int _wrap_LinksSolidShapesVector_erase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 2) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::MatlabSwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
+      if (_v) {
+        return _wrap_LinksSolidShapesVector_erase__SWIG_0(resc,resv,argc,argv);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::MatlabSwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
+      if (_v) {
+        swig::MatlabSwigIterator *iter = 0;
+        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
+        if (_v) {
+          return _wrap_LinksSolidShapesVector_erase__SWIG_1(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'LinksSolidShapesVector_erase'."
+    "  Possible C/C++ prototypes are:\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::erase(std::vector< std::vector< iDynTree::SolidShape * > >::iterator)\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::erase(std::vector< std::vector< iDynTree::SolidShape * > >::iterator,std::vector< std::vector< iDynTree::SolidShape * > >::iterator)\n");
+  return 1;
+}
+
+
+int _wrap_new_LinksSolidShapesVector__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg1 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg2 = 0 ;
+  size_t val1 ;
+  int ecode1 = 0 ;
   int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
+  std::vector< std::vector< iDynTree::SolidShape * > > *result = 0 ;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_setName",argc,2,2,0)) {
+  if (!SWIG_check_num_args("new_LinksSolidShapesVector",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_setName" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
+  } 
+  arg1 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val1);
   {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    res2 = swig::asptr(argv[1], &ptr);
     if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_LinksSolidShapesVector" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
     }
     if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LinksSolidShapesVector" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
     }
     arg2 = ptr;
   }
-  result = (bool)(arg1)->setName((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  result = (std::vector< std::vector< iDynTree::SolidShape * > > *)new std::vector< std::vector< iDynTree::SolidShape * > >(arg1,(std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)*arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
   if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
-  iDynTree::Transform *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("GyroscopeSensor_setLinkSensorTransform",argc,2,2,0)) {
-    SWIG_fail;
+int _wrap_new_LinksSolidShapesVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_LinksSolidShapesVector__SWIG_0(resc,resv,argc,argv);
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
+  if (argc == 1) {
+    int _v;
+    {
+      int res = SWIG_AsVal_size_t(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      return _wrap_new_LinksSolidShapesVector__SWIG_2(resc,resv,argc,argv);
+    }
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  if (argc == 1) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_LinksSolidShapesVector__SWIG_1(resc,resv,argc,argv);
+    }
   }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  if (argc == 2) {
+    int _v;
+    {
+      int res = SWIG_AsVal_size_t(argv[0], NULL);
+      _v = SWIG_CheckState(res);
+    }
+    if (_v) {
+      int res = swig::asptr(argv[1], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        return _wrap_new_LinksSolidShapesVector__SWIG_3(resc,resv,argc,argv);
+      }
+    }
   }
-  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
-  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_LinksSolidShapesVector'."
+    "  Possible C/C++ prototypes are:\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::vector()\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::vector(std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > const &)\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::vector(std::vector< std::vector< iDynTree::SolidShape * > >::size_type)\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::vector(std::vector< std::vector< iDynTree::SolidShape * > >::size_type,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)\n");
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
-  std::string *arg2 = 0 ;
+int _wrap_LinksSolidShapesVector_push_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_setParentLink",argc,2,2,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_push_back",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_push_back" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
   {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    res2 = swig::asptr(argv[1], &ptr);
     if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinksSolidShapesVector_push_back" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
     }
     if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_push_back" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
     }
     arg2 = ptr;
   }
-  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  (arg1)->push_back((std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)*arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
   if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
-  iDynTree::LinkIndex *arg2 = 0 ;
+int _wrap_LinksSolidShapesVector_front(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  iDynTree::LinkIndex temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  bool result;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *result = 0 ;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_setParentLinkIndex",argc,2,2,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_front",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_front" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GyroscopeSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  temp2 = static_cast< iDynTree::LinkIndex >(val2);
-  arg2 = &temp2;
-  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = (std::vector< std::vector< iDynTree::SolidShape * > >::value_type *) &((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->front();
+  _out = swig::from(static_cast< std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > >(*result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::string result;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *result = 0 ;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_getName",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_back",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getName" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_back" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  result = ((iDynTree::GyroscopeSensor const *)arg1)->getName();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = (std::vector< std::vector< iDynTree::SolidShape * > >::value_type *) &((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->back();
+  _out = swig::from(static_cast< std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > >(*result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_assign(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg2 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
-  iDynTree::SensorType result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_getSensorType",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_assign",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_assign" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  result = (iDynTree::SensorType)((iDynTree::GyroscopeSensor const *)arg1)->getSensorType();
-  _out = SWIG_From_int(static_cast< int >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_assign" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val2);
+  {
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    res3 = swig::asptr(argv[2], &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LinksSolidShapesVector_assign" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_assign" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  (arg1)->assign(arg2,(std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)*arg3);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res3)) delete arg3;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_resize__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg2 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
-  std::string result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_getParentLink",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_resize",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_resize" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  result = ((iDynTree::GyroscopeSensor const *)arg1)->getParentLink();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_resize" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val2);
+  {
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    res3 = swig::asptr(argv[2], &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LinksSolidShapesVector_resize" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_resize" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  (arg1)->resize(arg2,(std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)*arg3);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res3)) delete arg3;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 2) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        return _wrap_LinksSolidShapesVector_resize__SWIG_0(resc,resv,argc,argv);
+      }
+    }
+  }
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        int res = swig::asptr(argv[2], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_LinksSolidShapesVector_resize__SWIG_1(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'LinksSolidShapesVector_resize'."
+    "  Possible C/C++ prototypes are:\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::resize(std::vector< std::vector< iDynTree::SolidShape * > >::size_type)\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::resize(std::vector< std::vector< iDynTree::SolidShape * > >::size_type,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)\n");
+  return 1;
+}
+
+
+int _wrap_LinksSolidShapesVector_insert__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg2 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  swig::MatlabSwigIterator *iter2 = 0 ;
+  int res2 ;
+  int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
-  iDynTree::LinkIndex result;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_getParentLinkIndex",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_insert",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_insert" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  result = ((iDynTree::GyroscopeSensor const *)arg1)->getParentLinkIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+    }
+  }
+  {
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    res3 = swig::asptr(argv[2], &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LinksSolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__insert__SWIG_0(arg1,arg2,(std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > const &)*arg3);
+  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
+    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res3)) delete arg3;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_insert__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg2 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg3 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg4 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  swig::MatlabSwigIterator *iter2 = 0 ;
+  int res2 ;
+  size_t val3 ;
+  int ecode3 = 0 ;
+  int res4 = SWIG_OLDOBJ ;
   mxArray * _out;
-  iDynTree::Transform result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_getLinkSensorTransform",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_insert",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_insert" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  result = ((iDynTree::GyroscopeSensor const *)arg1)->getLinkSensorTransform();
-  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
+  if (!SWIG_IsOK(res2) || !iter2) {
+    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+  } else {
+    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter2);
+    if (iter_t) {
+      arg2 = iter_t->get_current();
+    } else {
+      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+    }
+  }
+  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "LinksSolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
+  } 
+  arg3 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val3);
+  {
+    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
+    res4 = swig::asptr(argv[3], &ptr);
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "LinksSolidShapesVector_insert" "', argument " "4"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_insert" "', argument " "4"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    }
+    arg4 = ptr;
+  }
+  std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__insert__SWIG_1(arg1,arg2,arg3,(std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > const &)*arg4);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res4)) delete arg4;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res4)) delete arg4;
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_insert(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 3) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::MatlabSwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
+      if (_v) {
+        int res = swig::asptr(argv[2], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_LinksSolidShapesVector_insert__SWIG_0(resc,resv,argc,argv);
+        }
+      }
+    }
+  }
+  if (argc == 4) {
+    int _v;
+    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      swig::MatlabSwigIterator *iter = 0;
+      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
+      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
+      if (_v) {
+        {
+          int res = SWIG_AsVal_size_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          int res = swig::asptr(argv[3], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_LinksSolidShapesVector_insert__SWIG_1(resc,resv,argc,argv);
+          }
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'LinksSolidShapesVector_insert'."
+    "  Possible C/C++ prototypes are:\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::insert(std::vector< std::vector< iDynTree::SolidShape * > >::iterator,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)\n"
+    "    std::vector< std::vector< iDynTree::SolidShape * > >::insert(std::vector< std::vector< iDynTree::SolidShape * > >::iterator,std::vector< std::vector< iDynTree::SolidShape * > >::size_type,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)\n");
+  return 1;
+}
+
+
+int _wrap_LinksSolidShapesVector_reserve(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_isValid",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_reserve",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_isValid" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_reserve" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  result = (bool)((iDynTree::GyroscopeSensor const *)arg1)->isValid();
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_reserve" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
+  } 
+  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val2);
+  (arg1)->reserve(arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+int _wrap_LinksSolidShapesVector_capacity(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::Sensor *result = 0 ;
+  std::vector< std::vector< iDynTree::SolidShape * > >::size_type result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_clone",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinksSolidShapesVector_capacity",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_clone" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_capacity" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  result = (iDynTree::Sensor *)((iDynTree::GyroscopeSensor const *)arg1)->clone();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  result = ((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->capacity();
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
+int _wrap_delete_LinksSolidShapesVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_updateIndices",argc,2,2,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_LinksSolidShapesVector",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
   }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_GyroscopeSensor_predictMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
-  iDynTree::Twist *arg2 = 0 ;
-  void *argp1 = 0 ;
+int _wrap_ForwardPositionKinematics__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::Transform *arg3 = 0 ;
+  iDynTree::VectorDynSize *arg4 = 0 ;
+  iDynTree::LinkPositions *arg5 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
   mxArray * _out;
-  iDynTree::AngVelocity result;
+  bool result;
   
-  if (!SWIG_check_num_args("GyroscopeSensor_predictMeasurement",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ForwardPositionKinematics",argc,5,5,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_predictMeasurement" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardPositionKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Twist,  0 );
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::Twist const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardPositionKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::Twist const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Twist * >(argp2);
-  result = (arg1)->predictMeasurement((iDynTree::Twist const &)*arg2);
-  _out = SWIG_NewPointerObj((new iDynTree::AngVelocity(static_cast< const iDynTree::AngVelocity& >(result))), SWIGTYPE_p_iDynTree__GeomVector3, SWIG_POINTER_OWN |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_new_ThreeAxisAngularAccelerometerSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  mxArray * _out;
-  iDynTree::ThreeAxisAngularAccelerometerSensor *result = 0 ;
-  
-  if (!SWIG_check_num_args("new_ThreeAxisAngularAccelerometerSensor",argc,0,0,0)) {
-    SWIG_fail;
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Transform,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardPositionKinematics" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
   }
-  (void)argv;
-  result = (iDynTree::ThreeAxisAngularAccelerometerSensor *)new iDynTree::ThreeAxisAngularAccelerometerSensor();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 1 |  0 );
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::Transform * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardPositionKinematics" "', argument " "4"" of type '" "iDynTree::VectorDynSize const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "4"" of type '" "iDynTree::VectorDynSize const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::VectorDynSize * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardPositionKinematics" "', argument " "5"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "5"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::LinkPositions * >(argp5);
+  result = (bool)iDynTree::ForwardPositionKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::Transform const &)*arg3,(iDynTree::VectorDynSize const &)*arg4,*arg5);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_ThreeAxisAngularAccelerometerSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = 0 ;
+int _wrap_ForwardPositionKinematics__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::FreeFloatingPos *arg3 = 0 ;
+  iDynTree::LinkPositions *arg4 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
   mxArray * _out;
-  iDynTree::ThreeAxisAngularAccelerometerSensor *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("new_ThreeAxisAngularAccelerometerSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ForwardPositionKinematics",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ThreeAxisAngularAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardPositionKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ThreeAxisAngularAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  result = (iDynTree::ThreeAxisAngularAccelerometerSensor *)new iDynTree::ThreeAxisAngularAccelerometerSensor((iDynTree::ThreeAxisAngularAccelerometerSensor const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 1 |  0 );
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardPositionKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardPositionKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardPositionKinematics" "', argument " "4"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "4"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::LinkPositions * >(argp4);
+  result = (bool)iDynTree::ForwardPositionKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,*arg4);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_ThreeAxisAngularAccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_ThreeAxisAngularAccelerometerSensor__SWIG_0(resc,resv,argc,argv);
+int _wrap_ForwardPositionKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 4) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        void *vptr = 0;
+        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingPos, 0);
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__LinkPositions, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_ForwardPositionKinematics__SWIG_1(resc,resv,argc,argv);
+          }
+        }
+      }
+    }
   }
-  if (argc == 1) {
+  if (argc == 5) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      return _wrap_new_ThreeAxisAngularAccelerometerSensor__SWIG_1(resc,resv,argc,argv);
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        void *vptr = 0;
+        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__Transform, 0);
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__VectorDynSize, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            void *vptr = 0;
+            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__LinkPositions, 0);
+            _v = SWIG_CheckState(res);
+            if (_v) {
+              return _wrap_ForwardPositionKinematics__SWIG_0(resc,resv,argc,argv);
+            }
+          }
+        }
+      }
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_ThreeAxisAngularAccelerometerSensor'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ForwardPositionKinematics'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ThreeAxisAngularAccelerometerSensor::ThreeAxisAngularAccelerometerSensor()\n"
-    "    iDynTree::ThreeAxisAngularAccelerometerSensor::ThreeAxisAngularAccelerometerSensor(iDynTree::ThreeAxisAngularAccelerometerSensor const &)\n");
+    "    iDynTree::ForwardPositionKinematics(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::Transform const &,iDynTree::VectorDynSize const &,iDynTree::LinkPositions &)\n"
+    "    iDynTree::ForwardPositionKinematics(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::FreeFloatingPos const &,iDynTree::LinkPositions &)\n");
   return 1;
 }
 
 
-int _wrap_delete_ThreeAxisAngularAccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_ForwardVelAccKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::FreeFloatingPos *arg3 = 0 ;
+  iDynTree::FreeFloatingVel *arg4 = 0 ;
+  iDynTree::FreeFloatingAcc *arg5 = 0 ;
+  iDynTree::LinkVelArray *arg6 = 0 ;
+  iDynTree::LinkAccArray *arg7 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 ;
+  int res5 = 0 ;
+  void *argp6 = 0 ;
+  int res6 = 0 ;
+  void *argp7 = 0 ;
+  int res7 = 0 ;
   mxArray * _out;
+  bool result;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_ThreeAxisAngularAccelerometerSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ForwardVelAccKinematics",argc,7,7,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ThreeAxisAngularAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardVelAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  if (is_owned) {
-    delete arg1;
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardVelAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardVelAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardVelAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardVelAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardVelAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray &""'"); 
+  }
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray &""'"); 
+  }
+  arg6 = reinterpret_cast< iDynTree::LinkVelArray * >(argp6);
+  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res7)) {
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ForwardVelAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  if (!argp7) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  arg7 = reinterpret_cast< iDynTree::LinkAccArray * >(argp7);
+  result = (bool)iDynTree::ForwardVelAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::FreeFloatingAcc const &)*arg5,*arg6,*arg7);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  std::string *arg2 = 0 ;
-  void *argp1 = 0 ;
+int _wrap_ForwardPosVelAccKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::FreeFloatingPos *arg3 = 0 ;
+  iDynTree::FreeFloatingVel *arg4 = 0 ;
+  iDynTree::FreeFloatingAcc *arg5 = 0 ;
+  iDynTree::LinkPositions *arg6 = 0 ;
+  iDynTree::LinkVelArray *arg7 = 0 ;
+  iDynTree::LinkAccArray *arg8 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 ;
+  int res5 = 0 ;
+  void *argp6 = 0 ;
+  int res6 = 0 ;
+  void *argp7 = 0 ;
+  int res7 = 0 ;
+  void *argp8 = 0 ;
+  int res8 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_setName",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ForwardPosVelAccKinematics",argc,8,8,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_setName" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardPosVelAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  result = (bool)(arg1)->setName((std::string const &)*arg2);
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardPosVelAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardPosVelAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardPosVelAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardPosVelAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardPosVelAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  arg6 = reinterpret_cast< iDynTree::LinkPositions * >(argp6);
+  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res7)) {
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ForwardPosVelAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkVelArray &""'"); 
+  }
+  if (!argp7) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkVelArray &""'"); 
+  }
+  arg7 = reinterpret_cast< iDynTree::LinkVelArray * >(argp7);
+  res8 = SWIG_ConvertPtr(argv[7], &argp8, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res8)) {
+    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "ForwardPosVelAccKinematics" "', argument " "8"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  if (!argp8) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "8"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  arg8 = reinterpret_cast< iDynTree::LinkAccArray * >(argp8);
+  result = (bool)iDynTree::ForwardPosVelAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::FreeFloatingAcc const &)*arg5,*arg6,*arg7,*arg8);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  iDynTree::Transform *arg2 = 0 ;
-  void *argp1 = 0 ;
+int _wrap_ForwardPosVelKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::FreeFloatingPos *arg3 = 0 ;
+  iDynTree::FreeFloatingVel *arg4 = 0 ;
+  iDynTree::LinkPositions *arg5 = 0 ;
+  iDynTree::LinkVelArray *arg6 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
+  void *argp6 = 0 ;
+  int res6 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ForwardPosVelKinematics",argc,6,6,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardPosVelKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardPosVelKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
-  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardPosVelKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardPosVelKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardPosVelKinematics" "', argument " "5"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "5"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::LinkPositions * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardPosVelKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray &""'"); 
+  }
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray &""'"); 
+  }
+  arg6 = reinterpret_cast< iDynTree::LinkVelArray * >(argp6);
+  result = (bool)iDynTree::ForwardPosVelKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,*arg5,*arg6);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  std::string *arg2 = 0 ;
-  void *argp1 = 0 ;
+int _wrap_ForwardAccKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::FreeFloatingPos *arg3 = 0 ;
+  iDynTree::FreeFloatingVel *arg4 = 0 ;
+  iDynTree::FreeFloatingAcc *arg5 = 0 ;
+  iDynTree::LinkVelArray *arg6 = 0 ;
+  iDynTree::LinkAccArray *arg7 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 ;
+  int res5 = 0 ;
+  void *argp6 ;
+  int res6 = 0 ;
+  void *argp7 = 0 ;
+  int res7 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_setParentLink",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ForwardAccKinematics",argc,7,7,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  arg6 = reinterpret_cast< iDynTree::LinkVelArray * >(argp6);
+  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res7)) {
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ForwardAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  if (!argp7) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  arg7 = reinterpret_cast< iDynTree::LinkAccArray * >(argp7);
+  result = (bool)iDynTree::ForwardAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::FreeFloatingAcc const &)*arg5,(iDynTree::LinkVelArray const &)*arg6,*arg7);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  iDynTree::LinkIndex *arg2 = 0 ;
-  void *argp1 = 0 ;
+int _wrap_ForwardBiasAccKinematics__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::FreeFloatingPos *arg3 = 0 ;
+  iDynTree::FreeFloatingVel *arg4 = 0 ;
+  iDynTree::SpatialAcc *arg5 = 0 ;
+  iDynTree::LinkVelArray *arg6 = 0 ;
+  iDynTree::LinkAccArray *arg7 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
-  iDynTree::LinkIndex temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 ;
+  int res5 = 0 ;
+  void *argp6 ;
+  int res6 = 0 ;
+  void *argp7 = 0 ;
+  int res7 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_setParentLinkIndex",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ForwardBiasAccKinematics",argc,7,7,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardBiasAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  temp2 = static_cast< iDynTree::LinkIndex >(val2);
-  arg2 = &temp2;
-  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardBiasAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardBiasAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardBiasAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__SpatialAcc,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardBiasAccKinematics" "', argument " "5"" of type '" "iDynTree::SpatialAcc const &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "5"" of type '" "iDynTree::SpatialAcc const &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::SpatialAcc * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardBiasAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  arg6 = reinterpret_cast< iDynTree::LinkVelArray * >(argp6);
+  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res7)) {
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ForwardBiasAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  if (!argp7) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  arg7 = reinterpret_cast< iDynTree::LinkAccArray * >(argp7);
+  result = (bool)iDynTree::ForwardBiasAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::SpatialAcc const &)*arg5,(iDynTree::LinkVelArray const &)*arg6,*arg7);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_ForwardBiasAccKinematics__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::FreeFloatingPos *arg3 = 0 ;
+  iDynTree::FreeFloatingVel *arg4 = 0 ;
+  iDynTree::LinkVelArray *arg5 = 0 ;
+  iDynTree::LinkAccArray *arg6 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 ;
+  int res5 = 0 ;
+  void *argp6 = 0 ;
+  int res6 = 0 ;
   mxArray * _out;
-  std::string result;
+  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getName",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ForwardBiasAccKinematics",argc,6,6,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getName" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardBiasAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getName();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardBiasAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardBiasAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardBiasAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardBiasAccKinematics" "', argument " "5"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "5"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::LinkVelArray * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardBiasAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  arg6 = reinterpret_cast< iDynTree::LinkAccArray * >(argp6);
+  result = (bool)iDynTree::ForwardBiasAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::LinkVelArray const &)*arg5,*arg6);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_ForwardBiasAccKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 6) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        void *vptr = 0;
+        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingPos, 0);
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingVel, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            void *vptr = 0;
+            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__LinkVelArray, 0);
+            _v = SWIG_CheckState(res);
+            if (_v) {
+              void *vptr = 0;
+              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_iDynTree__LinkAccArray, 0);
+              _v = SWIG_CheckState(res);
+              if (_v) {
+                return _wrap_ForwardBiasAccKinematics__SWIG_1(resc,resv,argc,argv);
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  if (argc == 7) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      void *vptr = 0;
+      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
+      _v = SWIG_CheckState(res);
+      if (_v) {
+        void *vptr = 0;
+        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingPos, 0);
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingVel, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            void *vptr = 0;
+            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__SpatialAcc, 0);
+            _v = SWIG_CheckState(res);
+            if (_v) {
+              void *vptr = 0;
+              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_iDynTree__LinkVelArray, 0);
+              _v = SWIG_CheckState(res);
+              if (_v) {
+                void *vptr = 0;
+                int res = SWIG_ConvertPtr(argv[6], &vptr, SWIGTYPE_p_iDynTree__LinkAccArray, 0);
+                _v = SWIG_CheckState(res);
+                if (_v) {
+                  return _wrap_ForwardBiasAccKinematics__SWIG_0(resc,resv,argc,argv);
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ForwardBiasAccKinematics'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::ForwardBiasAccKinematics(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::FreeFloatingPos const &,iDynTree::FreeFloatingVel const &,iDynTree::SpatialAcc const &,iDynTree::LinkVelArray const &,iDynTree::LinkAccArray &)\n"
+    "    iDynTree::ForwardBiasAccKinematics(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::FreeFloatingPos const &,iDynTree::FreeFloatingVel const &,iDynTree::LinkVelArray const &,iDynTree::LinkAccArray &)\n");
+  return 1;
+}
+
+
+int _wrap_ComputeLinearAndAngularMomentum(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::LinkPositions *arg2 = 0 ;
+  iDynTree::LinkVelArray *arg3 = 0 ;
+  iDynTree::SpatialMomentum *arg4 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
   mxArray * _out;
-  iDynTree::SensorType result;
+  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getSensorType",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ComputeLinearAndAngularMomentum",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ComputeLinearAndAngularMomentum" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  result = (iDynTree::SensorType)((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getSensorType();
-  _out = SWIG_From_int(static_cast< int >(result));
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentum" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ComputeLinearAndAngularMomentum" "', argument " "2"" of type '" "iDynTree::LinkPositions const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentum" "', argument " "2"" of type '" "iDynTree::LinkPositions const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::LinkPositions * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ComputeLinearAndAngularMomentum" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentum" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::LinkVelArray * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__SpatialMomentum,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ComputeLinearAndAngularMomentum" "', argument " "4"" of type '" "iDynTree::SpatialMomentum &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentum" "', argument " "4"" of type '" "iDynTree::SpatialMomentum &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::SpatialMomentum * >(argp4);
+  result = (bool)iDynTree::ComputeLinearAndAngularMomentum((iDynTree::Model const &)*arg1,(iDynTree::LinkPositions const &)*arg2,(iDynTree::LinkVelArray const &)*arg3,*arg4);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_ComputeLinearAndAngularMomentumDerivativeBias(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::LinkPositions *arg2 = 0 ;
+  iDynTree::LinkVelArray *arg3 = 0 ;
+  iDynTree::LinkAccArray *arg4 = 0 ;
+  iDynTree::Wrench *arg5 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
   mxArray * _out;
-  std::string result;
+  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getParentLink",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ComputeLinearAndAngularMomentumDerivativeBias",argc,5,5,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getParentLink();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "2"" of type '" "iDynTree::LinkPositions const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "2"" of type '" "iDynTree::LinkPositions const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::LinkPositions * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::LinkVelArray * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "4"" of type '" "iDynTree::LinkAccArray const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "4"" of type '" "iDynTree::LinkAccArray const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::LinkAccArray * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__Wrench,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "5"" of type '" "iDynTree::Wrench &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "5"" of type '" "iDynTree::Wrench &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::Wrench * >(argp5);
+  result = (bool)iDynTree::ComputeLinearAndAngularMomentumDerivativeBias((iDynTree::Model const &)*arg1,(iDynTree::LinkPositions const &)*arg2,(iDynTree::LinkVelArray const &)*arg3,(iDynTree::LinkAccArray const &)*arg4,*arg5);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_RNEADynamicPhase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::JointPosDoubleArray *arg3 = 0 ;
+  iDynTree::LinkVelArray *arg4 = 0 ;
+  iDynTree::LinkAccArray *arg5 = 0 ;
+  iDynTree::LinkNetExternalWrenches *arg6 = 0 ;
+  iDynTree::LinkInternalWrenches *arg7 = 0 ;
+  iDynTree::FreeFloatingGeneralizedTorques *arg8 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
+  void *argp5 ;
+  int res5 = 0 ;
+  void *argp6 ;
+  int res6 = 0 ;
+  void *argp7 = 0 ;
+  int res7 = 0 ;
+  void *argp8 = 0 ;
+  int res8 = 0 ;
   mxArray * _out;
-  iDynTree::LinkIndex result;
+  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getParentLinkIndex",argc,1,1,0)) {
+  if (!SWIG_check_num_args("RNEADynamicPhase",argc,8,8,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNEADynamicPhase" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getParentLinkIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RNEADynamicPhase" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__JointPosDoubleArray,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RNEADynamicPhase" "', argument " "3"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "3"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::JointPosDoubleArray * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "RNEADynamicPhase" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::LinkVelArray * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "RNEADynamicPhase" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::LinkAccArray * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "RNEADynamicPhase" "', argument " "6"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
+  }
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "6"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
+  }
+  arg6 = reinterpret_cast< iDynTree::LinkNetExternalWrenches * >(argp6);
+  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
+  if (!SWIG_IsOK(res7)) {
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "RNEADynamicPhase" "', argument " "7"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
+  }
+  if (!argp7) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "7"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
+  }
+  arg7 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp7);
+  res8 = SWIG_ConvertPtr(argv[7], &argp8, SWIGTYPE_p_iDynTree__FreeFloatingGeneralizedTorques,  0 );
+  if (!SWIG_IsOK(res8)) {
+    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "RNEADynamicPhase" "', argument " "8"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
+  }
+  if (!argp8) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "8"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
+  }
+  arg8 = reinterpret_cast< iDynTree::FreeFloatingGeneralizedTorques * >(argp8);
+  result = (bool)iDynTree::RNEADynamicPhase((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::JointPosDoubleArray const &)*arg3,(iDynTree::LinkVelArray const &)*arg4,(iDynTree::LinkAccArray const &)*arg5,(iDynTree::LinkWrenches const &)*arg6,*arg7,*arg8);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_CompositeRigidBodyAlgorithm(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  iDynTree::Traversal *arg2 = 0 ;
+  iDynTree::JointPosDoubleArray *arg3 = 0 ;
+  iDynTree::LinkCompositeRigidBodyInertias *arg4 = 0 ;
+  iDynTree::FreeFloatingMassMatrix *arg5 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
+  void *argp5 = 0 ;
+  int res5 = 0 ;
   mxArray * _out;
-  iDynTree::Transform result;
+  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform",argc,1,1,0)) {
+  if (!SWIG_check_num_args("CompositeRigidBodyAlgorithm",argc,5,5,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getLinkSensorTransform();
-  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__JointPosDoubleArray,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "3"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "3"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::JointPosDoubleArray * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkInertias,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "4"" of type '" "iDynTree::LinkCompositeRigidBodyInertias &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "4"" of type '" "iDynTree::LinkCompositeRigidBodyInertias &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::LinkCompositeRigidBodyInertias * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingMassMatrix,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "5"" of type '" "iDynTree::FreeFloatingMassMatrix &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "5"" of type '" "iDynTree::FreeFloatingMassMatrix &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::FreeFloatingMassMatrix * >(argp5);
+  result = (bool)iDynTree::CompositeRigidBodyAlgorithm((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::JointPosDoubleArray const &)*arg3,*arg4,*arg5);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
+int _wrap_new_ArticulatedBodyAlgorithmInternalBuffers__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  bool result;
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_isValid",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_ArticulatedBodyAlgorithmInternalBuffers",argc,0,0,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_isValid" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  result = (bool)((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->isValid();
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  (void)argv;
+  result = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *)new iDynTree::ArticulatedBodyAlgorithmInternalBuffers();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_new_ArticulatedBodyAlgorithmInternalBuffers__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::Sensor *result = 0 ;
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_clone",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_ArticulatedBodyAlgorithmInternalBuffers",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_clone" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ArticulatedBodyAlgorithmInternalBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  result = (iDynTree::Sensor *)((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->clone();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ArticulatedBodyAlgorithmInternalBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  result = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *)new iDynTree::ArticulatedBodyAlgorithmInternalBuffers((iDynTree::Model const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
+int _wrap_new_ArticulatedBodyAlgorithmInternalBuffers(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_ArticulatedBodyAlgorithmInternalBuffers__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_ArticulatedBodyAlgorithmInternalBuffers__SWIG_1(resc,resv,argc,argv);
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_ArticulatedBodyAlgorithmInternalBuffers'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::ArticulatedBodyAlgorithmInternalBuffers::ArticulatedBodyAlgorithmInternalBuffers()\n"
+    "    iDynTree::ArticulatedBodyAlgorithmInternalBuffers::ArticulatedBodyAlgorithmInternalBuffers(iDynTree::Model const &)\n");
+  return 1;
+}
+
+
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_updateIndices",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_resize",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_resize" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
   res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_resize" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithmInternalBuffers_resize" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  (arg1)->resize((iDynTree::Model const &)*arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisAngularAccelerometerSensor_predictMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
-  iDynTree::SpatialAcc *arg2 = 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
-  iDynTree::Vector3 result;
+  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_predictMeasurement",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_isConsistent",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_predictMeasurement" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_isConsistent" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialAcc,  0 );
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::SpatialAcc const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::SpatialAcc const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithmInternalBuffers_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::SpatialAcc * >(argp2);
-  result = (arg1)->predictMeasurement((iDynTree::SpatialAcc const &)*arg2);
-  _out = SWIG_NewPointerObj((new iDynTree::Vector3(static_cast< const iDynTree::Vector3& >(result))), SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t, SWIG_POINTER_OWN |  0 );
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)(arg1)->isConsistent((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_ThreeAxisForceTorqueContactSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_S_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::DOFSpatialMotionArray *arg2 = (iDynTree::DOFSpatialMotionArray *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::ThreeAxisForceTorqueContactSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("new_ThreeAxisForceTorqueContactSensor",argc,0,0,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_S_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  (void)argv;
-  result = (iDynTree::ThreeAxisForceTorqueContactSensor *)new iDynTree::ThreeAxisForceTorqueContactSensor();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 1 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_S_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__DOFSpatialMotionArray, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_S_set" "', argument " "2"" of type '" "iDynTree::DOFSpatialMotionArray *""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::DOFSpatialMotionArray * >(argp2);
+  if (arg1) (arg1)->S = *arg2;
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_ThreeAxisForceTorqueContactSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = 0 ;
-  void *argp1 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_S_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::ThreeAxisForceTorqueContactSensor *result = 0 ;
+  iDynTree::DOFSpatialMotionArray *result = 0 ;
   
-  if (!SWIG_check_num_args("new_ThreeAxisForceTorqueContactSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_S_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ThreeAxisForceTorqueContactSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ThreeAxisForceTorqueContactSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_S_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = (iDynTree::ThreeAxisForceTorqueContactSensor *)new iDynTree::ThreeAxisForceTorqueContactSensor((iDynTree::ThreeAxisForceTorqueContactSensor const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 1 |  0 );
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::DOFSpatialMotionArray *)& ((arg1)->S);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DOFSpatialMotionArray, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_ThreeAxisForceTorqueContactSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_ThreeAxisForceTorqueContactSensor__SWIG_0(resc,resv,argc,argv);
-  }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_ThreeAxisForceTorqueContactSensor__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_ThreeAxisForceTorqueContactSensor'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ThreeAxisForceTorqueContactSensor::ThreeAxisForceTorqueContactSensor()\n"
-    "    iDynTree::ThreeAxisForceTorqueContactSensor::ThreeAxisForceTorqueContactSensor(iDynTree::ThreeAxisForceTorqueContactSensor const &)\n");
-  return 1;
-}
-
-
-int _wrap_delete_ThreeAxisForceTorqueContactSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_U_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::DOFSpatialForceArray *arg2 = (iDynTree::DOFSpatialForceArray *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_ThreeAxisForceTorqueContactSensor",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_U_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ThreeAxisForceTorqueContactSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_U_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  if (is_owned) {
-    delete arg1;
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__DOFSpatialForceArray, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_U_set" "', argument " "2"" of type '" "iDynTree::DOFSpatialForceArray *""'"); 
   }
+  arg2 = reinterpret_cast< iDynTree::DOFSpatialForceArray * >(argp2);
+  if (arg1) (arg1)->U = *arg2;
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
-  std::string *arg2 = 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_U_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
+  iDynTree::DOFSpatialForceArray *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setName",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_U_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setName" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_U_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  result = (bool)(arg1)->setName((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::DOFSpatialForceArray *)& ((arg1)->U);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DOFSpatialForceArray, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
-  iDynTree::Transform *arg2 = 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_D_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::JointDOFsDoubleArray *arg2 = (iDynTree::JointDOFsDoubleArray *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
+  void *argp2 = 0 ;
   int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setLinkSensorTransform",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_D_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_D_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__JointDOFsDoubleArray, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_D_set" "', argument " "2"" of type '" "iDynTree::JointDOFsDoubleArray *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
-  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg2 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp2);
+  if (arg1) (arg1)->D = *arg2;
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
-  std::string *arg2 = 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_D_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  bool result;
+  iDynTree::JointDOFsDoubleArray *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setParentLink",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_D_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_D_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::JointDOFsDoubleArray *)& ((arg1)->D);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__JointDOFsDoubleArray, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
-  iDynTree::LinkIndex *arg2 = 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_u_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::JointDOFsDoubleArray *arg2 = (iDynTree::JointDOFsDoubleArray *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  iDynTree::LinkIndex temp2 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setParentLinkIndex",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_u_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_u_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ThreeAxisForceTorqueContactSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
-  } 
-  temp2 = static_cast< iDynTree::LinkIndex >(val2);
-  arg2 = &temp2;
-  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__JointDOFsDoubleArray, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_u_set" "', argument " "2"" of type '" "iDynTree::JointDOFsDoubleArray *""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp2);
+  if (arg1) (arg1)->u = *arg2;
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_u_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::string result;
+  iDynTree::JointDOFsDoubleArray *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getName",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_u_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getName" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_u_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getName();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::JointDOFsDoubleArray *)& ((arg1)->u);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__JointDOFsDoubleArray, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksVel_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::LinkVelArray *arg2 = (iDynTree::LinkVelArray *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::SensorType result;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getSensorType",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksVel_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksVel_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = (iDynTree::SensorType)((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getSensorType();
-  _out = SWIG_From_int(static_cast< int >(result));
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkVelArray, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksVel_set" "', argument " "2"" of type '" "iDynTree::LinkVelArray *""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::LinkVelArray * >(argp2);
+  if (arg1) (arg1)->linksVel = *arg2;
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksVel_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::string result;
+  iDynTree::LinkVelArray *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getParentLink",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksVel_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksVel_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getParentLink();
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::LinkVelArray *)& ((arg1)->linksVel);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkVelArray, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::LinkAccArray *arg2 = (iDynTree::LinkAccArray *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::LinkIndex result;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getParentLinkIndex",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getParentLinkIndex();
-  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkAccArray, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set" "', argument " "2"" of type '" "iDynTree::LinkAccArray *""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::LinkAccArray * >(argp2);
+  if (arg1) (arg1)->linksBiasAcceleration = *arg2;
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::Transform result;
+  iDynTree::LinkAccArray *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getLinkSensorTransform",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getLinkSensorTransform();
-  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::LinkAccArray *)& ((arg1)->linksBiasAcceleration);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkAccArray, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::LinkAccArray *arg2 = (iDynTree::LinkAccArray *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_isValid",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_isValid" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = (bool)((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->isValid();
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkAccArray, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set" "', argument " "2"" of type '" "iDynTree::LinkAccArray *""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::LinkAccArray * >(argp2);
+  if (arg1) (arg1)->linksAccelerations = *arg2;
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::Sensor *result = 0 ;
+  iDynTree::LinkAccArray *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_clone",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_clone" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = (iDynTree::Sensor *)((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->clone();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::LinkAccArray *)& ((arg1)->linksAccelerations);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkAccArray, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::LinkArticulatedBodyInertias *arg2 = (iDynTree::LinkArticulatedBodyInertias *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
+  void *argp2 = 0 ;
   int res2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_updateIndices",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkArticulatedBodyInertias, 0 |  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set" "', argument " "2"" of type '" "iDynTree::LinkArticulatedBodyInertias *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg2 = reinterpret_cast< iDynTree::LinkArticulatedBodyInertias * >(argp2);
+  if (arg1) (arg1)->linkABIs = *arg2;
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_setLoadCellLocations(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
-  std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > *arg2 = 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
+  iDynTree::LinkArticulatedBodyInertias *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setLoadCellLocations",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setLoadCellLocations" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_iDynTree__Position_std__allocatorT_iDynTree__Position_t_t,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_setLoadCellLocations" "', argument " "2"" of type '" "std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_setLoadCellLocations" "', argument " "2"" of type '" "std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg2 = reinterpret_cast< std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > * >(argp2);
-  (arg1)->setLoadCellLocations(*arg2);
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::LinkArticulatedBodyInertias *)& ((arg1)->linkABIs);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkArticulatedBodyInertias, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_getLoadCellLocations(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+  iDynTree::LinkWrenches *arg2 = (iDynTree::LinkWrenches *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  SwigValueWrapper< std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > > result;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getLoadCellLocations",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getLoadCellLocations" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getLoadCellLocations();
-  _out = SWIG_NewPointerObj((new std::vector< iDynTree::Position,std::allocator< iDynTree::Position > >(static_cast< const std::vector< iDynTree::Position,std::allocator< iDynTree::Position > >& >(result))), SWIGTYPE_p_std__vectorT_iDynTree__Position_std__allocatorT_iDynTree__Position_t_t, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkWrenches, 0 |  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set" "', argument " "2"" of type '" "iDynTree::LinkWrenches *""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::LinkWrenches * >(argp2);
+  if (arg1) (arg1)->linksBiasWrench = *arg2;
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
-  iDynTree::VectorDynSize *arg2 = 0 ;
+int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::Vector3 result;
+  iDynTree::LinkWrenches *result = 0 ;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::VectorDynSize * >(argp2);
-  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->computeThreeAxisForceTorqueFromLoadCellMeasurements(*arg2);
-  _out = SWIG_NewPointerObj((new iDynTree::Vector3(static_cast< const iDynTree::Vector3& >(result))), SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  result = (iDynTree::LinkWrenches *)& ((arg1)->linksBiasWrench);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkWrenches, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
-  iDynTree::VectorDynSize *arg2 = 0 ;
+int _wrap_delete_ArticulatedBodyAlgorithmInternalBuffers(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::Position result;
   
-  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements",argc,2,2,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_ArticulatedBodyAlgorithmInternalBuffers",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ArticulatedBodyAlgorithmInternalBuffers" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
   }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg2 = reinterpret_cast< iDynTree::VectorDynSize * >(argp2);
-  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->computeCenterOfPressureFromLoadCellMeasurements(*arg2);
-  _out = SWIG_NewPointerObj((new iDynTree::Position(static_cast< const iDynTree::Position& >(result))), SWIGTYPE_p_iDynTree__Position, SWIG_POINTER_OWN |  0 );
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_predictSensorsMeasurements__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_ArticulatedBodyAlgorithm(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Model *arg1 = 0 ;
   iDynTree::Traversal *arg2 = 0 ;
   iDynTree::FreeFloatingPos *arg3 = 0 ;
   iDynTree::FreeFloatingVel *arg4 = 0 ;
-  iDynTree::FreeFloatingAcc *arg5 = 0 ;
-  iDynTree::LinAcceleration *arg6 = 0 ;
-  iDynTree::LinkNetExternalWrenches *arg7 = 0 ;
+  iDynTree::LinkNetExternalWrenches *arg5 = 0 ;
+  iDynTree::JointDOFsDoubleArray *arg6 = 0 ;
+  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg7 = 0 ;
   iDynTree::FreeFloatingAcc *arg8 = 0 ;
-  iDynTree::LinkPositions *arg9 = 0 ;
-  iDynTree::LinkVelArray *arg10 = 0 ;
-  iDynTree::LinkAccArray *arg11 = 0 ;
-  iDynTree::LinkInternalWrenches *arg12 = 0 ;
-  iDynTree::FreeFloatingGeneralizedTorques *arg13 = 0 ;
-  iDynTree::SensorsMeasurements *arg14 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   void *argp3 ;
   int res3 = 0 ;
   void *argp4 ;
   int res4 = 0 ;
   void *argp5 ;
   int res5 = 0 ;
   void *argp6 ;
   int res6 = 0 ;
-  void *argp7 ;
+  void *argp7 = 0 ;
   int res7 = 0 ;
   void *argp8 = 0 ;
   int res8 = 0 ;
-  void *argp9 = 0 ;
-  int res9 = 0 ;
-  void *argp10 = 0 ;
-  int res10 = 0 ;
-  void *argp11 = 0 ;
-  int res11 = 0 ;
-  void *argp12 = 0 ;
-  int res12 = 0 ;
-  void *argp13 = 0 ;
-  int res13 = 0 ;
-  void *argp14 = 0 ;
-  int res14 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("predictSensorsMeasurements",argc,14,14,0)) {
+  if (!SWIG_check_num_args("ArticulatedBodyAlgorithm",argc,8,8,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "predictSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithm" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
   res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "predictSensorsMeasurements" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithm" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
   res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "predictSensorsMeasurements" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ArticulatedBodyAlgorithm" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
   }
   arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
   res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "predictSensorsMeasurements" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ArticulatedBodyAlgorithm" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
   }
   arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
   if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "predictSensorsMeasurements" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ArticulatedBodyAlgorithm" "', argument " "5"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
   }
   if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "5"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
   }
-  arg5 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__GeomVector3,  0 );
+  arg5 = reinterpret_cast< iDynTree::LinkNetExternalWrenches * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__JointDOFsDoubleArray,  0 );
   if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "predictSensorsMeasurements" "', argument " "6"" of type '" "iDynTree::LinAcceleration const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ArticulatedBodyAlgorithm" "', argument " "6"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
   if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "6"" of type '" "iDynTree::LinAcceleration const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "6"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
-  arg6 = reinterpret_cast< iDynTree::LinAcceleration * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
+  arg6 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp6);
+  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers,  0 );
   if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "predictSensorsMeasurements" "', argument " "7"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ArticulatedBodyAlgorithm" "', argument " "7"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers &""'"); 
   }
   if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "7"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "7"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers &""'"); 
   }
-  arg7 = reinterpret_cast< iDynTree::LinkNetExternalWrenches * >(argp7);
+  arg7 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp7);
   res8 = SWIG_ConvertPtr(argv[7], &argp8, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
   if (!SWIG_IsOK(res8)) {
-    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "predictSensorsMeasurements" "', argument " "8"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "ArticulatedBodyAlgorithm" "', argument " "8"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
   }
   if (!argp8) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "8"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "8"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
   }
   arg8 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp8);
-  res9 = SWIG_ConvertPtr(argv[8], &argp9, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
-  if (!SWIG_IsOK(res9)) {
-    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "predictSensorsMeasurements" "', argument " "9"" of type '" "iDynTree::LinkPositions &""'"); 
-  }
-  if (!argp9) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "9"" of type '" "iDynTree::LinkPositions &""'"); 
-  }
-  arg9 = reinterpret_cast< iDynTree::LinkPositions * >(argp9);
-  res10 = SWIG_ConvertPtr(argv[9], &argp10, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res10)) {
-    SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "predictSensorsMeasurements" "', argument " "10"" of type '" "iDynTree::LinkVelArray &""'"); 
-  }
-  if (!argp10) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "10"" of type '" "iDynTree::LinkVelArray &""'"); 
-  }
-  arg10 = reinterpret_cast< iDynTree::LinkVelArray * >(argp10);
-  res11 = SWIG_ConvertPtr(argv[10], &argp11, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res11)) {
-    SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "predictSensorsMeasurements" "', argument " "11"" of type '" "iDynTree::LinkAccArray &""'"); 
-  }
-  if (!argp11) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "11"" of type '" "iDynTree::LinkAccArray &""'"); 
-  }
-  arg11 = reinterpret_cast< iDynTree::LinkAccArray * >(argp11);
-  res12 = SWIG_ConvertPtr(argv[11], &argp12, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
-  if (!SWIG_IsOK(res12)) {
-    SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "predictSensorsMeasurements" "', argument " "12"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
-  }
-  if (!argp12) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "12"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
-  }
-  arg12 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp12);
-  res13 = SWIG_ConvertPtr(argv[12], &argp13, SWIGTYPE_p_iDynTree__FreeFloatingGeneralizedTorques,  0 );
-  if (!SWIG_IsOK(res13)) {
-    SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "predictSensorsMeasurements" "', argument " "13"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
-  }
-  if (!argp13) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "13"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
-  }
-  arg13 = reinterpret_cast< iDynTree::FreeFloatingGeneralizedTorques * >(argp13);
-  res14 = SWIG_ConvertPtr(argv[13], &argp14, SWIGTYPE_p_iDynTree__SensorsMeasurements,  0 );
-  if (!SWIG_IsOK(res14)) {
-    SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "predictSensorsMeasurements" "', argument " "14"" of type '" "iDynTree::SensorsMeasurements &""'"); 
-  }
-  if (!argp14) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "14"" of type '" "iDynTree::SensorsMeasurements &""'"); 
-  }
-  arg14 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp14);
-  result = (bool)iDynTree::predictSensorsMeasurements((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::FreeFloatingAcc const &)*arg5,(iDynTree::GeomVector3 const &)*arg6,(iDynTree::LinkWrenches const &)*arg7,*arg8,*arg9,*arg10,*arg11,*arg12,*arg13,*arg14);
+  result = (bool)iDynTree::ArticulatedBodyAlgorithm((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::LinkWrenches const &)*arg5,(iDynTree::JointDOFsDoubleArray const &)*arg6,*arg7,*arg8);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_predictSensorsMeasurementsFromRawBuffers__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_InverseDynamicsInertialParametersRegressor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Model *arg1 = 0 ;
   iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::LinkVelArray *arg3 = 0 ;
-  iDynTree::LinkAccArray *arg4 = 0 ;
-  iDynTree::LinkInternalWrenches *arg5 = 0 ;
-  iDynTree::SensorsMeasurements *arg6 = 0 ;
+  iDynTree::LinkPositions *arg3 = 0 ;
+  iDynTree::LinkVelArray *arg4 = 0 ;
+  iDynTree::LinkAccArray *arg5 = 0 ;
+  iDynTree::MatrixDynSize *arg6 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   void *argp3 ;
   int res3 = 0 ;
   void *argp4 ;
@@ -68200,6072 +63868,6779 @@
   void *argp5 ;
   int res5 = 0 ;
   void *argp6 = 0 ;
   int res6 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("predictSensorsMeasurementsFromRawBuffers",argc,6,6,0)) {
+  if (!SWIG_check_num_args("InverseDynamicsInertialParametersRegressor",argc,6,6,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
   res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "3"" of type '" "iDynTree::LinkPositions const &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "3"" of type '" "iDynTree::LinkPositions const &""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::LinkVelArray * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  arg3 = reinterpret_cast< iDynTree::LinkPositions * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "4"" of type '" "iDynTree::LinkAccArray const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "4"" of type '" "iDynTree::LinkAccArray const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::LinkAccArray * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
+  arg4 = reinterpret_cast< iDynTree::LinkVelArray * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
   if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "5"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
   }
   if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "5"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
   }
-  arg5 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__SensorsMeasurements,  0 );
+  arg5 = reinterpret_cast< iDynTree::LinkAccArray * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
   if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "6"" of type '" "iDynTree::SensorsMeasurements &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "6"" of type '" "iDynTree::MatrixDynSize &""'"); 
   }
   if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "6"" of type '" "iDynTree::SensorsMeasurements &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "6"" of type '" "iDynTree::MatrixDynSize &""'"); 
   }
-  arg6 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp6);
-  result = (bool)iDynTree::predictSensorsMeasurementsFromRawBuffers((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::LinkVelArray const &)*arg3,(iDynTree::LinkAccArray const &)*arg4,(iDynTree::LinkWrenches const &)*arg5,*arg6);
+  arg6 = reinterpret_cast< iDynTree::MatrixDynSize * >(argp6);
+  result = (bool)iDynTree::InverseDynamicsInertialParametersRegressor((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::LinkPositions const &)*arg3,(iDynTree::LinkVelArray const &)*arg4,(iDynTree::LinkAccArray const &)*arg5,*arg6);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_predictSensorsMeasurements__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::SensorsList *arg2 = 0 ;
-  iDynTree::Traversal *arg3 = 0 ;
-  iDynTree::FreeFloatingPos *arg4 = 0 ;
-  iDynTree::FreeFloatingVel *arg5 = 0 ;
-  iDynTree::FreeFloatingAcc *arg6 = 0 ;
-  iDynTree::LinAcceleration *arg7 = 0 ;
-  iDynTree::LinkNetExternalWrenches *arg8 = 0 ;
-  iDynTree::FreeFloatingAcc *arg9 = 0 ;
-  iDynTree::LinkPositions *arg10 = 0 ;
-  iDynTree::LinkVelArray *arg11 = 0 ;
-  iDynTree::LinkAccArray *arg12 = 0 ;
-  iDynTree::LinkInternalWrenches *arg13 = 0 ;
-  iDynTree::FreeFloatingGeneralizedTorques *arg14 = 0 ;
-  iDynTree::SensorsMeasurements *arg15 = 0 ;
-  void *argp1 ;
+int _wrap_DHLink_A_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 ;
-  int res6 = 0 ;
-  void *argp7 ;
-  int res7 = 0 ;
-  void *argp8 ;
-  int res8 = 0 ;
-  void *argp9 = 0 ;
-  int res9 = 0 ;
-  void *argp10 = 0 ;
-  int res10 = 0 ;
-  void *argp11 = 0 ;
-  int res11 = 0 ;
-  void *argp12 = 0 ;
-  int res12 = 0 ;
-  void *argp13 = 0 ;
-  int res13 = 0 ;
-  void *argp14 = 0 ;
-  int res14 = 0 ;
-  void *argp15 = 0 ;
-  int res15 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("predictSensorsMeasurements",argc,15,15,0)) {
+  if (!SWIG_check_num_args("DHLink_A_set",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "predictSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_A_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_A_set" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  if (arg1) (arg1)->A = arg2;
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_A_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  double result;
+  
+  if (!SWIG_check_num_args("DHLink_A_get",argc,1,1,0)) {
+    SWIG_fail;
   }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SensorsList,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "predictSensorsMeasurements" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_A_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  result = (double) ((arg1)->A);
+  _out = SWIG_From_double(static_cast< double >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_D_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHLink_D_set",argc,2,2,0)) {
+    SWIG_fail;
   }
-  arg2 = reinterpret_cast< iDynTree::SensorsList * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "predictSensorsMeasurements" "', argument " "3"" of type '" "iDynTree::Traversal const &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_D_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "3"" of type '" "iDynTree::Traversal const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_D_set" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  if (arg1) (arg1)->D = arg2;
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_D_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  double result;
+  
+  if (!SWIG_check_num_args("DHLink_D_get",argc,1,1,0)) {
+    SWIG_fail;
   }
-  arg3 = reinterpret_cast< iDynTree::Traversal * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "predictSensorsMeasurements" "', argument " "4"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_D_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "4"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  result = (double) ((arg1)->D);
+  _out = SWIG_From_double(static_cast< double >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_Alpha_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHLink_Alpha_set",argc,2,2,0)) {
+    SWIG_fail;
   }
-  arg4 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "predictSensorsMeasurements" "', argument " "5"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Alpha_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "5"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_Alpha_set" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  if (arg1) (arg1)->Alpha = arg2;
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_Alpha_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  double result;
+  
+  if (!SWIG_check_num_args("DHLink_Alpha_get",argc,1,1,0)) {
+    SWIG_fail;
   }
-  arg5 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "predictSensorsMeasurements" "', argument " "6"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Alpha_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "6"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  result = (double) ((arg1)->Alpha);
+  _out = SWIG_From_double(static_cast< double >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_Offset_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHLink_Offset_set",argc,2,2,0)) {
+    SWIG_fail;
   }
-  arg6 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__GeomVector3,  0 );
-  if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "predictSensorsMeasurements" "', argument " "7"" of type '" "iDynTree::LinAcceleration const &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Offset_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "7"" of type '" "iDynTree::LinAcceleration const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_Offset_set" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  if (arg1) (arg1)->Offset = arg2;
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_Offset_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  double result;
+  
+  if (!SWIG_check_num_args("DHLink_Offset_get",argc,1,1,0)) {
+    SWIG_fail;
   }
-  arg7 = reinterpret_cast< iDynTree::LinAcceleration * >(argp7);
-  res8 = SWIG_ConvertPtr(argv[7], &argp8, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
-  if (!SWIG_IsOK(res8)) {
-    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "predictSensorsMeasurements" "', argument " "8"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Offset_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp8) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "8"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  result = (double) ((arg1)->Offset);
+  _out = SWIG_From_double(static_cast< double >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_Min_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHLink_Min_set",argc,2,2,0)) {
+    SWIG_fail;
   }
-  arg8 = reinterpret_cast< iDynTree::LinkNetExternalWrenches * >(argp8);
-  res9 = SWIG_ConvertPtr(argv[8], &argp9, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
-  if (!SWIG_IsOK(res9)) {
-    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "predictSensorsMeasurements" "', argument " "9"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Min_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp9) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "9"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_Min_set" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  if (arg1) (arg1)->Min = arg2;
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_Min_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  double result;
+  
+  if (!SWIG_check_num_args("DHLink_Min_get",argc,1,1,0)) {
+    SWIG_fail;
   }
-  arg9 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp9);
-  res10 = SWIG_ConvertPtr(argv[9], &argp10, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
-  if (!SWIG_IsOK(res10)) {
-    SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "predictSensorsMeasurements" "', argument " "10"" of type '" "iDynTree::LinkPositions &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Min_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp10) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "10"" of type '" "iDynTree::LinkPositions &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  result = (double) ((arg1)->Min);
+  _out = SWIG_From_double(static_cast< double >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_Max_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  double arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHLink_Max_set",argc,2,2,0)) {
+    SWIG_fail;
   }
-  arg10 = reinterpret_cast< iDynTree::LinkPositions * >(argp10);
-  res11 = SWIG_ConvertPtr(argv[10], &argp11, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res11)) {
-    SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "predictSensorsMeasurements" "', argument " "11"" of type '" "iDynTree::LinkVelArray &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Max_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp11) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "11"" of type '" "iDynTree::LinkVelArray &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_Max_set" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  if (arg1) (arg1)->Max = arg2;
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHLink_Max_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  double result;
+  
+  if (!SWIG_check_num_args("DHLink_Max_get",argc,1,1,0)) {
+    SWIG_fail;
   }
-  arg11 = reinterpret_cast< iDynTree::LinkVelArray * >(argp11);
-  res12 = SWIG_ConvertPtr(argv[11], &argp12, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res12)) {
-    SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "predictSensorsMeasurements" "', argument " "12"" of type '" "iDynTree::LinkAccArray &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Max_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  if (!argp12) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "12"" of type '" "iDynTree::LinkAccArray &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  result = (double) ((arg1)->Max);
+  _out = SWIG_From_double(static_cast< double >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_DHLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::DHLink *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_DHLink",argc,0,0,0)) {
+    SWIG_fail;
   }
-  arg12 = reinterpret_cast< iDynTree::LinkAccArray * >(argp12);
-  res13 = SWIG_ConvertPtr(argv[12], &argp13, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
-  if (!SWIG_IsOK(res13)) {
-    SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "predictSensorsMeasurements" "', argument " "13"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
+  (void)argv;
+  result = (iDynTree::DHLink *)new iDynTree::DHLink();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DHLink, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_delete_DHLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  
+  int is_owned;
+  if (!SWIG_check_num_args("delete_DHLink",argc,1,1,0)) {
+    SWIG_fail;
   }
-  if (!argp13) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "13"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DHLink" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
   }
-  arg13 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp13);
-  res14 = SWIG_ConvertPtr(argv[13], &argp14, SWIGTYPE_p_iDynTree__FreeFloatingGeneralizedTorques,  0 );
-  if (!SWIG_IsOK(res14)) {
-    SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "predictSensorsMeasurements" "', argument " "14"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  if (!argp14) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "14"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_setNrOfDOFs(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  size_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHChain_setNrOfDOFs",argc,2,2,0)) {
+    SWIG_fail;
   }
-  arg14 = reinterpret_cast< iDynTree::FreeFloatingGeneralizedTorques * >(argp14);
-  res15 = SWIG_ConvertPtr(argv[14], &argp15, SWIGTYPE_p_iDynTree__SensorsMeasurements,  0 );
-  if (!SWIG_IsOK(res15)) {
-    SWIG_exception_fail(SWIG_ArgError(res15), "in method '" "predictSensorsMeasurements" "', argument " "15"" of type '" "iDynTree::SensorsMeasurements &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_setNrOfDOFs" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
   }
-  if (!argp15) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "15"" of type '" "iDynTree::SensorsMeasurements &""'"); 
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_setNrOfDOFs" "', argument " "2"" of type '" "size_t""'");
+  } 
+  arg2 = static_cast< size_t >(val2);
+  (arg1)->setNrOfDOFs(arg2);
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_getNrOfDOFs(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  size_t result;
+  
+  if (!SWIG_check_num_args("DHChain_getNrOfDOFs",argc,1,1,0)) {
+    SWIG_fail;
   }
-  arg15 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp15);
-  result = (bool)iDynTree::predictSensorsMeasurements((iDynTree::Model const &)*arg1,(iDynTree::SensorsList const &)*arg2,(iDynTree::Traversal const &)*arg3,(iDynTree::FreeFloatingPos const &)*arg4,(iDynTree::FreeFloatingVel const &)*arg5,(iDynTree::FreeFloatingAcc const &)*arg6,(iDynTree::GeomVector3 const &)*arg7,(iDynTree::LinkWrenches const &)*arg8,*arg9,*arg10,*arg11,*arg12,*arg13,*arg14,*arg15);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_getNrOfDOFs" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  result = ((iDynTree::DHChain const *)arg1)->getNrOfDOFs();
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_predictSensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 14) {
+int _wrap_DHChain_setH0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  iDynTree::Transform *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHChain_setH0",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_setH0" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DHChain_setH0" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_setH0" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
+  (arg1)->setH0((iDynTree::Transform const &)*arg2);
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_getH0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::Transform *result = 0 ;
+  
+  if (!SWIG_check_num_args("DHChain_getH0",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_getH0" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  result = (iDynTree::Transform *) &((iDynTree::DHChain const *)arg1)->getH0();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Transform, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_setHN(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  iDynTree::Transform *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHChain_setHN",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_setHN" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DHChain_setHN" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_setHN" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
+  (arg1)->setHN((iDynTree::Transform const &)*arg2);
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_getHN(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::Transform *result = 0 ;
+  
+  if (!SWIG_check_num_args("DHChain_getHN",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_getHN" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  result = (iDynTree::Transform *) &((iDynTree::DHChain const *)arg1)->getHN();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Transform, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_paren__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  size_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  iDynTree::DHLink *result = 0 ;
+  
+  if (!SWIG_check_num_args("DHChain_paren",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_paren" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_paren" "', argument " "2"" of type '" "size_t""'");
+  } 
+  arg2 = static_cast< size_t >(val2);
+  result = (iDynTree::DHLink *) &(arg1)->operator ()(arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_paren__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  size_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  iDynTree::DHLink *result = 0 ;
+  
+  if (!SWIG_check_num_args("DHChain_paren",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_paren" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_paren" "', argument " "2"" of type '" "size_t""'");
+  } 
+  arg2 = static_cast< size_t >(val2);
+  result = (iDynTree::DHLink *) &((iDynTree::DHChain const *)arg1)->operator ()(arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_paren(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 2) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__DHChain, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingPos, 0);
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
         _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingVel, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            void *vptr = 0;
-            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingAcc, 0);
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              void *vptr = 0;
-              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_iDynTree__GeomVector3, 0);
-              _v = SWIG_CheckState(res);
-              if (_v) {
-                void *vptr = 0;
-                int res = SWIG_ConvertPtr(argv[6], &vptr, SWIGTYPE_p_iDynTree__LinkWrenches, 0);
-                _v = SWIG_CheckState(res);
-                if (_v) {
-                  void *vptr = 0;
-                  int res = SWIG_ConvertPtr(argv[7], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingAcc, 0);
-                  _v = SWIG_CheckState(res);
-                  if (_v) {
-                    void *vptr = 0;
-                    int res = SWIG_ConvertPtr(argv[8], &vptr, SWIGTYPE_p_iDynTree__LinkPositions, 0);
-                    _v = SWIG_CheckState(res);
-                    if (_v) {
-                      void *vptr = 0;
-                      int res = SWIG_ConvertPtr(argv[9], &vptr, SWIGTYPE_p_iDynTree__LinkVelArray, 0);
-                      _v = SWIG_CheckState(res);
-                      if (_v) {
-                        void *vptr = 0;
-                        int res = SWIG_ConvertPtr(argv[10], &vptr, SWIGTYPE_p_iDynTree__LinkAccArray, 0);
-                        _v = SWIG_CheckState(res);
-                        if (_v) {
-                          void *vptr = 0;
-                          int res = SWIG_ConvertPtr(argv[11], &vptr, SWIGTYPE_p_iDynTree__LinkWrenches, 0);
-                          _v = SWIG_CheckState(res);
-                          if (_v) {
-                            void *vptr = 0;
-                            int res = SWIG_ConvertPtr(argv[12], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingGeneralizedTorques, 0);
-                            _v = SWIG_CheckState(res);
-                            if (_v) {
-                              void *vptr = 0;
-                              int res = SWIG_ConvertPtr(argv[13], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-                              _v = SWIG_CheckState(res);
-                              if (_v) {
-                                return _wrap_predictSensorsMeasurements__SWIG_0(resc,resv,argc,argv);
-                              }
-                            }
-                          }
-                        }
-                      }
-                    }
-                  }
-                }
-              }
-            }
-          }
-        }
+      }
+      if (_v) {
+        return _wrap_DHChain_paren__SWIG_0(resc,resv,argc,argv);
       }
     }
   }
-  if (argc == 15) {
+  if (argc == 2) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__DHChain, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
+      {
+        int res = SWIG_AsVal_size_t(argv[1], NULL);
         _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingPos, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            void *vptr = 0;
-            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingVel, 0);
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              void *vptr = 0;
-              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingAcc, 0);
-              _v = SWIG_CheckState(res);
-              if (_v) {
-                void *vptr = 0;
-                int res = SWIG_ConvertPtr(argv[6], &vptr, SWIGTYPE_p_iDynTree__GeomVector3, 0);
-                _v = SWIG_CheckState(res);
-                if (_v) {
-                  void *vptr = 0;
-                  int res = SWIG_ConvertPtr(argv[7], &vptr, SWIGTYPE_p_iDynTree__LinkWrenches, 0);
-                  _v = SWIG_CheckState(res);
-                  if (_v) {
-                    void *vptr = 0;
-                    int res = SWIG_ConvertPtr(argv[8], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingAcc, 0);
-                    _v = SWIG_CheckState(res);
-                    if (_v) {
-                      void *vptr = 0;
-                      int res = SWIG_ConvertPtr(argv[9], &vptr, SWIGTYPE_p_iDynTree__LinkPositions, 0);
-                      _v = SWIG_CheckState(res);
-                      if (_v) {
-                        void *vptr = 0;
-                        int res = SWIG_ConvertPtr(argv[10], &vptr, SWIGTYPE_p_iDynTree__LinkVelArray, 0);
-                        _v = SWIG_CheckState(res);
-                        if (_v) {
-                          void *vptr = 0;
-                          int res = SWIG_ConvertPtr(argv[11], &vptr, SWIGTYPE_p_iDynTree__LinkAccArray, 0);
-                          _v = SWIG_CheckState(res);
-                          if (_v) {
-                            void *vptr = 0;
-                            int res = SWIG_ConvertPtr(argv[12], &vptr, SWIGTYPE_p_iDynTree__LinkWrenches, 0);
-                            _v = SWIG_CheckState(res);
-                            if (_v) {
-                              void *vptr = 0;
-                              int res = SWIG_ConvertPtr(argv[13], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingGeneralizedTorques, 0);
-                              _v = SWIG_CheckState(res);
-                              if (_v) {
-                                void *vptr = 0;
-                                int res = SWIG_ConvertPtr(argv[14], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-                                _v = SWIG_CheckState(res);
-                                if (_v) {
-                                  return _wrap_predictSensorsMeasurements__SWIG_1(resc,resv,argc,argv);
-                                }
-                              }
-                            }
-                          }
-                        }
-                      }
-                    }
-                  }
-                }
-              }
-            }
-          }
-        }
+      }
+      if (_v) {
+        return _wrap_DHChain_paren__SWIG_1(resc,resv,argc,argv);
       }
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'predictSensorsMeasurements'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'DHChain_paren'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::predictSensorsMeasurements(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::FreeFloatingPos const &,iDynTree::FreeFloatingVel const &,iDynTree::FreeFloatingAcc const &,iDynTree::LinAcceleration const &,iDynTree::LinkNetExternalWrenches const &,iDynTree::FreeFloatingAcc &,iDynTree::LinkPositions &,iDynTree::LinkVelArray &,iDynTree::LinkAccArray &,iDynTree::LinkInternalWrenches &,iDynTree::FreeFloatingGeneralizedTorques &,iDynTree::SensorsMeasurements &)\n"
-    "    iDynTree::predictSensorsMeasurements(iDynTree::Model const &,iDynTree::SensorsList const &,iDynTree::Traversal const &,iDynTree::FreeFloatingPos const &,iDynTree::FreeFloatingVel const &,iDynTree::FreeFloatingAcc const &,iDynTree::LinAcceleration const &,iDynTree::LinkNetExternalWrenches const &,iDynTree::FreeFloatingAcc &,iDynTree::LinkPositions &,iDynTree::LinkVelArray &,iDynTree::LinkAccArray &,iDynTree::LinkInternalWrenches &,iDynTree::FreeFloatingGeneralizedTorques &,iDynTree::SensorsMeasurements &)\n");
+    "    iDynTree::DHChain::operator ()(size_t const)\n"
+    "    iDynTree::DHChain::operator ()(size_t const) const\n");
   return 1;
 }
 
 
-int _wrap_predictSensorsMeasurementsFromRawBuffers__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::SensorsList *arg2 = 0 ;
-  iDynTree::Traversal *arg3 = 0 ;
-  iDynTree::LinkVelArray *arg4 = 0 ;
-  iDynTree::LinkAccArray *arg5 = 0 ;
-  iDynTree::LinkInternalWrenches *arg6 = 0 ;
-  iDynTree::SensorsMeasurements *arg7 = 0 ;
-  void *argp1 ;
+int _wrap_DHChain_getDOFName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  size_t arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  std::string result;
+  
+  if (!SWIG_check_num_args("DHChain_getDOFName",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_getDOFName" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_getDOFName" "', argument " "2"" of type '" "size_t""'");
+  } 
+  arg2 = static_cast< size_t >(val2);
+  result = ((iDynTree::DHChain const *)arg1)->getDOFName(arg2);
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_setDOFName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  size_t arg2 ;
+  std::string *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  size_t val2 ;
+  int ecode2 = 0 ;
+  int res3 = SWIG_OLDOBJ ;
+  mxArray * _out;
+  
+  if (!SWIG_check_num_args("DHChain_setDOFName",argc,3,3,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_setDOFName" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_setDOFName" "', argument " "2"" of type '" "size_t""'");
+  } 
+  arg2 = static_cast< size_t >(val2);
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DHChain_setDOFName" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_setDOFName" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  (arg1)->setDOFName(arg2,(std::string const &)*arg3);
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return 0;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return 1;
+}
+
+
+int _wrap_DHChain_toModel(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("DHChain_toModel",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_toModel" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DHChain_toModel" "', argument " "2"" of type '" "iDynTree::Model &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_toModel" "', argument " "2"" of type '" "iDynTree::Model &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)((iDynTree::DHChain const *)arg1)->toModel(*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_DHChain_fromModel(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
+  std::string arg3 ;
+  std::string arg4 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("DHChain_fromModel",argc,4,4,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_fromModel" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DHChain_fromModel" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_fromModel" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(argv[2], &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DHChain_fromModel" "', argument " "3"" of type '" "std::string""'"); 
+    }
+    arg3 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(argv[3], &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DHChain_fromModel" "', argument " "4"" of type '" "std::string""'"); 
+    }
+    arg4 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
+  }
+  result = (bool)(arg1)->fromModel((iDynTree::Model const &)*arg2,arg3,arg4);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_DHChain(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::DHChain *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_DHChain",argc,0,0,0)) {
+    SWIG_fail;
+  }
+  (void)argv;
+  result = (iDynTree::DHChain *)new iDynTree::DHChain();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DHChain, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_delete_DHChain(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  
+  int is_owned;
+  if (!SWIG_check_num_args("delete_DHChain",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DHChain" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  if (is_owned) {
+    delete arg1;
+  }
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_TransformFromDHCraig1989(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  mxArray * _out;
+  iDynTree::Transform result;
+  
+  if (!SWIG_check_num_args("TransformFromDHCraig1989",argc,4,4,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "TransformFromDHCraig1989" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TransformFromDHCraig1989" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TransformFromDHCraig1989" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(argv[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TransformFromDHCraig1989" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  result = iDynTree::TransformFromDHCraig1989(arg1,arg2,arg3,arg4);
+  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_TransformFromDH(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  double arg1 ;
+  double arg2 ;
+  double arg3 ;
+  double arg4 ;
+  double val1 ;
+  int ecode1 = 0 ;
+  double val2 ;
+  int ecode2 = 0 ;
+  double val3 ;
+  int ecode3 = 0 ;
+  double val4 ;
+  int ecode4 = 0 ;
+  mxArray * _out;
+  iDynTree::Transform result;
+  
+  if (!SWIG_check_num_args("TransformFromDH",argc,4,4,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_double(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "TransformFromDH" "', argument " "1"" of type '" "double""'");
+  } 
+  arg1 = static_cast< double >(val1);
+  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TransformFromDH" "', argument " "2"" of type '" "double""'");
+  } 
+  arg2 = static_cast< double >(val2);
+  ecode3 = SWIG_AsVal_double(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TransformFromDH" "', argument " "3"" of type '" "double""'");
+  } 
+  arg3 = static_cast< double >(val3);
+  ecode4 = SWIG_AsVal_double(argv[3], &val4);
+  if (!SWIG_IsOK(ecode4)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TransformFromDH" "', argument " "4"" of type '" "double""'");
+  } 
+  arg4 = static_cast< double >(val4);
+  result = iDynTree::TransformFromDH(arg1,arg2,arg3,arg4);
+  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_ExtractDHChainFromModel__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  std::string arg2 ;
+  std::string arg3 ;
+  iDynTree::DHChain *arg4 = 0 ;
+  double arg5 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  void *argp4 = 0 ;
   int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 ;
-  int res6 = 0 ;
-  void *argp7 = 0 ;
-  int res7 = 0 ;
+  double val5 ;
+  int ecode5 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("predictSensorsMeasurementsFromRawBuffers",argc,7,7,0)) {
+  if (!SWIG_check_num_args("ExtractDHChainFromModel",argc,5,5,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtractDHChainFromModel" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtractDHChainFromModel" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SensorsList,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::SensorsList * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "3"" of type '" "iDynTree::Traversal const &""'"); 
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ExtractDHChainFromModel" "', argument " "2"" of type '" "std::string const""'"); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
   }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "3"" of type '" "iDynTree::Traversal const &""'"); 
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(argv[2], &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ExtractDHChainFromModel" "', argument " "3"" of type '" "std::string const""'"); 
+    }
+    arg3 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
   }
-  arg3 = reinterpret_cast< iDynTree::Traversal * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__DHChain,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtractDHChainFromModel" "', argument " "4"" of type '" "iDynTree::DHChain &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtractDHChainFromModel" "', argument " "4"" of type '" "iDynTree::DHChain &""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::LinkVelArray * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
+  arg4 = reinterpret_cast< iDynTree::DHChain * >(argp4);
+  ecode5 = SWIG_AsVal_double(argv[4], &val5);
+  if (!SWIG_IsOK(ecode5)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "ExtractDHChainFromModel" "', argument " "5"" of type '" "double""'");
+  } 
+  arg5 = static_cast< double >(val5);
+  result = (bool)iDynTree::ExtractDHChainFromModel((iDynTree::Model const &)*arg1,arg2,arg3,*arg4,arg5);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_ExtractDHChainFromModel__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Model *arg1 = 0 ;
+  std::string arg2 ;
+  std::string arg3 ;
+  iDynTree::DHChain *arg4 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("ExtractDHChainFromModel",argc,4,4,0)) {
+    SWIG_fail;
   }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtractDHChainFromModel" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg5 = reinterpret_cast< iDynTree::LinkAccArray * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "6"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtractDHChainFromModel" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "6"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ExtractDHChainFromModel" "', argument " "2"" of type '" "std::string const""'"); 
+    }
+    arg2 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
   }
-  arg6 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__SensorsMeasurements,  0 );
-  if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "7"" of type '" "iDynTree::SensorsMeasurements &""'"); 
+  {
+    std::string *ptr = (std::string *)0;
+    int res = SWIG_AsPtr_std_string(argv[2], &ptr);
+    if (!SWIG_IsOK(res) || !ptr) {
+      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ExtractDHChainFromModel" "', argument " "3"" of type '" "std::string const""'"); 
+    }
+    arg3 = *ptr;
+    if (SWIG_IsNewObj(res)) delete ptr;
   }
-  if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "7"" of type '" "iDynTree::SensorsMeasurements &""'"); 
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__DHChain,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtractDHChainFromModel" "', argument " "4"" of type '" "iDynTree::DHChain &""'"); 
   }
-  arg7 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp7);
-  result = (bool)iDynTree::predictSensorsMeasurementsFromRawBuffers((iDynTree::Model const &)*arg1,(iDynTree::SensorsList const &)*arg2,(iDynTree::Traversal const &)*arg3,(iDynTree::LinkVelArray const &)*arg4,(iDynTree::LinkAccArray const &)*arg5,(iDynTree::LinkWrenches const &)*arg6,*arg7);
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtractDHChainFromModel" "', argument " "4"" of type '" "iDynTree::DHChain &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::DHChain * >(argp4);
+  result = (bool)iDynTree::ExtractDHChainFromModel((iDynTree::Model const &)*arg1,arg2,arg3,*arg4);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_predictSensorsMeasurementsFromRawBuffers(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 6) {
+int _wrap_ExtractDHChainFromModel(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 4) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
       _v = SWIG_CheckState(res);
       if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__LinkVelArray, 0);
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
           void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__LinkAccArray, 0);
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__DHChain, 0);
           _v = SWIG_CheckState(res);
           if (_v) {
-            void *vptr = 0;
-            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__LinkWrenches, 0);
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              void *vptr = 0;
-              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-              _v = SWIG_CheckState(res);
-              if (_v) {
-                return _wrap_predictSensorsMeasurementsFromRawBuffers__SWIG_0(resc,resv,argc,argv);
-              }
-            }
+            return _wrap_ExtractDHChainFromModel__SWIG_1(resc,resv,argc,argv);
           }
         }
       }
     }
   }
-  if (argc == 7) {
+  if (argc == 5) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
+      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
       _v = SWIG_CheckState(res);
       if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
           void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__LinkVelArray, 0);
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__DHChain, 0);
           _v = SWIG_CheckState(res);
           if (_v) {
-            void *vptr = 0;
-            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__LinkAccArray, 0);
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              void *vptr = 0;
-              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_iDynTree__LinkWrenches, 0);
+            {
+              int res = SWIG_AsVal_double(argv[4], NULL);
               _v = SWIG_CheckState(res);
-              if (_v) {
-                void *vptr = 0;
-                int res = SWIG_ConvertPtr(argv[6], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
-                _v = SWIG_CheckState(res);
-                if (_v) {
-                  return _wrap_predictSensorsMeasurementsFromRawBuffers__SWIG_1(resc,resv,argc,argv);
-                }
-              }
+            }
+            if (_v) {
+              return _wrap_ExtractDHChainFromModel__SWIG_0(resc,resv,argc,argv);
             }
           }
         }
       }
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'predictSensorsMeasurementsFromRawBuffers'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ExtractDHChainFromModel'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::predictSensorsMeasurementsFromRawBuffers(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::LinkVelArray const &,iDynTree::LinkAccArray const &,iDynTree::LinkInternalWrenches const &,iDynTree::SensorsMeasurements &)\n"
-    "    iDynTree::predictSensorsMeasurementsFromRawBuffers(iDynTree::Model const &,iDynTree::SensorsList const &,iDynTree::Traversal const &,iDynTree::LinkVelArray const &,iDynTree::LinkAccArray const &,iDynTree::LinkInternalWrenches const &,iDynTree::SensorsMeasurements &)\n");
+    "    iDynTree::ExtractDHChainFromModel(iDynTree::Model const &,std::string const,std::string const,iDynTree::DHChain &,double)\n"
+    "    iDynTree::ExtractDHChainFromModel(iDynTree::Model const &,std::string const,std::string const,iDynTree::DHChain &)\n");
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_pop(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_CreateModelFromDHChain(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::DHChain *arg1 = 0 ;
+  iDynTree::Model *arg2 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::value_type result;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_pop",argc,1,1,0)) {
+  if (!SWIG_check_num_args("CreateModelFromDHChain",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__DHChain,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_pop" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateModelFromDHChain" "', argument " "1"" of type '" "iDynTree::DHChain const &""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  try {
-    result = (std::vector< iDynTree::SolidShape * >::value_type)std_vector_Sl_iDynTree_SolidShape_Sm__Sg__pop(arg1);
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CreateModelFromDHChain" "', argument " "1"" of type '" "iDynTree::DHChain const &""'"); 
   }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CreateModelFromDHChain" "', argument " "2"" of type '" "iDynTree::Model &""'"); 
   }
-  
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CreateModelFromDHChain" "', argument " "2"" of type '" "iDynTree::Model &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)iDynTree::CreateModelFromDHChain((iDynTree::DHChain const &)*arg1,*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_brace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::difference_type arg2 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  ptrdiff_t val2 ;
-  int ecode2 = 0 ;
+SWIGINTERN int _wrap_NR_OF_SENSOR_TYPES_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  resv[0] = SWIG_From_int(static_cast< int >(iDynTree::NR_OF_SENSOR_TYPES));
+  return 0;
+}
+
+
+int _wrap_isLinkSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorType arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::value_type result;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_brace",argc,2,2,0)) {
+  if (!SWIG_check_num_args("isLinkSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_brace" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_brace" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::difference_type""'");
+  ecode1 = SWIG_AsVal_int(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "isLinkSensor" "', argument " "1"" of type '" "iDynTree::SensorType""'");
   } 
-  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::difference_type >(val2);
-  try {
-    result = (std::vector< iDynTree::SolidShape * >::value_type)std_vector_Sl_iDynTree_SolidShape_Sm__Sg__brace(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  arg1 = static_cast< iDynTree::SensorType >(val1);
+  result = (bool)iDynTree::isLinkSensor(arg1);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_isJointSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorType arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("isJointSensor",argc,1,1,0)) {
+    SWIG_fail;
   }
+  ecode1 = SWIG_AsVal_int(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "isJointSensor" "', argument " "1"" of type '" "iDynTree::SensorType""'");
+  } 
+  arg1 = static_cast< iDynTree::SensorType >(val1);
+  result = (bool)iDynTree::isJointSensor(arg1);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_getSensorTypeSize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorType arg1 ;
+  int val1 ;
+  int ecode1 = 0 ;
+  mxArray * _out;
+  std::size_t result;
   
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  if (!SWIG_check_num_args("getSensorTypeSize",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  ecode1 = SWIG_AsVal_int(argv[0], &val1);
+  if (!SWIG_IsOK(ecode1)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "getSensorTypeSize" "', argument " "1"" of type '" "iDynTree::SensorType""'");
+  } 
+  arg1 = static_cast< iDynTree::SensorType >(val1);
+  result = iDynTree::getSensorTypeSize(arg1);
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_setbrace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::value_type arg2 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
-  std::vector< iDynTree::SolidShape * >::difference_type arg3 ;
+int _wrap_delete_Sensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
   mxArray * _out;
   
-  if (!SWIG_check_num_args("SolidShapesVector_setbrace",argc,3,3,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_Sensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_setbrace" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolidShapesVector_setbrace" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp2);
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SolidShapesVector_setbrace" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::difference_type""'");
-  } 
-  arg3 = static_cast< std::vector< iDynTree::SolidShape * >::difference_type >(val3);
-  try {
-    std_vector_Sl_iDynTree_SolidShape_Sm__Sg__setbrace(arg1,arg2,arg3);
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Sensor" "', argument " "1"" of type '" "iDynTree::Sensor *""'"); 
   }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_append(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::value_type arg2 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
+int _wrap_Sensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
+  std::string result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_append",argc,2,2,0)) {
+  if (!SWIG_check_num_args("Sensor_getName",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_append" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_getName" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolidShapesVector_append" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
+  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
+  result = ((iDynTree::Sensor const *)arg1)->getName();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_Sensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::SensorType result;
+  
+  if (!SWIG_check_num_args("Sensor_getSensorType",argc,1,1,0)) {
+    SWIG_fail;
   }
-  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp2);
-  std_vector_Sl_iDynTree_SolidShape_Sm__Sg__append(arg1,arg2);
-  _out = (mxArray*)0;
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_getSensorType" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
+  result = (iDynTree::SensorType)((iDynTree::Sensor const *)arg1)->getSensorType();
+  _out = SWIG_From_int(static_cast< int >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SolidShapesVector__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_Sensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * > *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("new_SolidShapesVector",argc,0,0,0)) {
+  if (!SWIG_check_num_args("Sensor_isValid",argc,1,1,0)) {
     SWIG_fail;
   }
-  (void)argv;
-  result = (std::vector< iDynTree::SolidShape * > *)new std::vector< iDynTree::SolidShape * >();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 1 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_isValid" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
+  result = (bool)((iDynTree::Sensor const *)arg1)->isValid();
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SolidShapesVector__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = 0 ;
-  int res1 = SWIG_OLDOBJ ;
+int _wrap_Sensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
+  std::string *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * > *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("new_SolidShapesVector",argc,1,1,0)) {
+  if (!SWIG_check_num_args("Sensor_setName",argc,2,2,0)) {
     SWIG_fail;
   }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_setName" "', argument " "1"" of type '" "iDynTree::Sensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
   {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    res1 = swig::asptr(argv[0], &ptr);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const &""'"); 
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Sensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
     }
     if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const &""'"); 
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
     }
-    arg1 = ptr;
+    arg2 = ptr;
   }
-  result = (std::vector< iDynTree::SolidShape * > *)new std::vector< iDynTree::SolidShape * >((std::vector< iDynTree::SolidShape * > const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 1 |  0 );
+  result = (bool)(arg1)->setName((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res1)) delete arg1;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_empty(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_Sensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  bool result;
+  iDynTree::Sensor *result = 0 ;
   
-  if (!SWIG_check_num_args("SolidShapesVector_empty",argc,1,1,0)) {
+  if (!SWIG_check_num_args("Sensor_clone",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_empty" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_clone" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = (bool)((std::vector< iDynTree::SolidShape * > const *)arg1)->empty();
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
+  result = (iDynTree::Sensor *)((iDynTree::Sensor const *)arg1)->clone();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_size(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_Sensor_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::size_type result;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_size",argc,1,1,0)) {
+  if (!SWIG_check_num_args("Sensor_isConsistent",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_size" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_isConsistent" "', argument " "1"" of type '" "iDynTree::Sensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = ((std::vector< iDynTree::SolidShape * > const *)arg1)->size();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
+  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Sensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)((iDynTree::Sensor const *)arg1)->isConsistent((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_swap(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * > *arg2 = 0 ;
+int _wrap_Sensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::Sensor *arg1 = (iDynTree::Sensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
+  void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_swap",argc,2,2,0)) {
+  if (!SWIG_check_num_args("Sensor_updateIndices",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_swap" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sensor_updateIndices" "', argument " "1"" of type '" "iDynTree::Sensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t,  0 );
+  arg1 = reinterpret_cast< iDynTree::Sensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolidShapesVector_swap" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * > &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Sensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SolidShapesVector_swap" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * > &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_delete_JointSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  
+  int is_owned;
+  if (!SWIG_check_num_args("delete_JointSensor",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_JointSensor" "', argument " "1"" of type '" "iDynTree::JointSensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp2);
-  (arg1)->swap(*arg2);
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_begin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_JointSensor_getParentJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::iterator result;
+  std::string result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_begin",argc,1,1,0)) {
+  if (!SWIG_check_num_args("JointSensor_getParentJoint",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_begin" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_getParentJoint" "', argument " "1"" of type '" "iDynTree::JointSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = (arg1)->begin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
+  result = ((iDynTree::JointSensor const *)arg1)->getParentJoint();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_end(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_JointSensor_getParentJointIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::iterator result;
+  iDynTree::JointIndex result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_end",argc,1,1,0)) {
+  if (!SWIG_check_num_args("JointSensor_getParentJointIndex",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_end" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_getParentJointIndex" "', argument " "1"" of type '" "iDynTree::JointSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = (arg1)->end();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
+  result = ((iDynTree::JointSensor const *)arg1)->getParentJointIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_rbegin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_JointSensor_setParentJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::reverse_iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_rbegin",argc,1,1,0)) {
+  if (!SWIG_check_num_args("JointSensor_setParentJoint",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_rbegin" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_setParentJoint" "', argument " "1"" of type '" "iDynTree::JointSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = (arg1)->rbegin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "JointSensor_setParentJoint" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "JointSensor_setParentJoint" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (bool)(arg1)->setParentJoint((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_rend(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_JointSensor_setParentJointIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
+  iDynTree::JointIndex *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  iDynTree::JointIndex temp2 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::reverse_iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_rend",argc,1,1,0)) {
+  if (!SWIG_check_num_args("JointSensor_setParentJointIndex",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_rend" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_setParentJointIndex" "', argument " "1"" of type '" "iDynTree::JointSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = (arg1)->rend();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "JointSensor_setParentJointIndex" "', argument " "2"" of type '" "iDynTree::JointIndex""'");
+  } 
+  temp2 = static_cast< iDynTree::JointIndex >(val2);
+  arg2 = &temp2;
+  result = (bool)(arg1)->setParentJointIndex((iDynTree::JointIndex const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_clear(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_JointSensor_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::JointSensor *arg1 = (iDynTree::JointSensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_clear",argc,1,1,0)) {
+  if (!SWIG_check_num_args("JointSensor_isConsistent",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__JointSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_clear" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "JointSensor_isConsistent" "', argument " "1"" of type '" "iDynTree::JointSensor const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::JointSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "JointSensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "JointSensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)((iDynTree::JointSensor const *)arg1)->isConsistent((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_delete_LinkSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  
+  int is_owned;
+  if (!SWIG_check_num_args("delete_LinkSensor",argc,1,1,0)) {
+    SWIG_fail;
+  }
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LinkSensor" "', argument " "1"" of type '" "iDynTree::LinkSensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  (arg1)->clear();
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_get_allocator(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_LinkSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  SwigValueWrapper< std::allocator< iDynTree::SolidShape * > > result;
+  std::string result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_get_allocator",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinkSensor_getParentLink",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_get_allocator" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::LinkSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = ((std::vector< iDynTree::SolidShape * > const *)arg1)->get_allocator();
-  _out = SWIG_NewPointerObj((new std::vector< iDynTree::SolidShape * >::allocator_type(static_cast< const std::vector< iDynTree::SolidShape * >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_iDynTree__SolidShape_p_t, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
+  result = ((iDynTree::LinkSensor const *)arg1)->getParentLink();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SolidShapesVector__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * >::size_type arg1 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
+int _wrap_LinkSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * > *result = 0 ;
+  iDynTree::LinkIndex result;
   
-  if (!SWIG_check_num_args("new_SolidShapesVector",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinkSensor_getParentLinkIndex",argc,1,1,0)) {
     SWIG_fail;
   }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val1);
-  result = (std::vector< iDynTree::SolidShape * > *)new std::vector< iDynTree::SolidShape * >(arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 1 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::LinkSensor const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
+  result = ((iDynTree::LinkSensor const *)arg1)->getParentLinkIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_pop_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_LinkSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
+  iDynTree::Transform result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_pop_back",argc,1,1,0)) {
+  if (!SWIG_check_num_args("LinkSensor_getLinkSensorTransform",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_pop_back" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::LinkSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  (arg1)->pop_back();
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
+  result = ((iDynTree::LinkSensor const *)arg1)->getLinkSensorTransform();
+  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_resize__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::size_type arg2 ;
+int _wrap_LinkSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
+  int res2 = SWIG_OLDOBJ ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("LinkSensor_setParentLink",argc,2,2,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::LinkSensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinkSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinkSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return 0;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return 1;
+}
+
+
+int _wrap_LinkSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
+  iDynTree::LinkIndex *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  iDynTree::LinkIndex temp2 ;
+  ptrdiff_t val2 ;
   int ecode2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_resize",argc,2,2,0)) {
+  if (!SWIG_check_num_args("LinkSensor_setParentLinkIndex",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_resize" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::LinkSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_resize" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinkSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
   } 
-  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val2);
-  (arg1)->resize(arg2);
-  _out = (mxArray*)0;
+  temp2 = static_cast< iDynTree::LinkIndex >(val2);
+  arg2 = &temp2;
+  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_erase__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::iterator arg2 ;
+int _wrap_LinkSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
+  iDynTree::Transform *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_erase",argc,2,2,0)) {
+  if (!SWIG_check_num_args("LinkSensor_setLinkSensorTransform",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_erase" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::LinkSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
-    }
+  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinkSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
   }
-  result = std_vector_Sl_iDynTree_SolidShape_Sm__Sg__erase__SWIG_0(arg1,arg2);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinkSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
+  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_erase__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::iterator arg2 ;
-  std::vector< iDynTree::SolidShape * >::iterator arg3 ;
+int _wrap_LinkSensor_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::LinkSensor *arg1 = (iDynTree::LinkSensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  swig::MatlabSwigIterator *iter3 = 0 ;
-  int res3 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_erase",argc,3,3,0)) {
+  if (!SWIG_check_num_args("LinkSensor_isConsistent",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__LinkSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_erase" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinkSensor_isConsistent" "', argument " "1"" of type '" "iDynTree::LinkSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
-    }
+  arg1 = reinterpret_cast< iDynTree::LinkSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinkSensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
-  res3 = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter3), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res3) || !iter3) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter3);
-    if (iter_t) {
-      arg3 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_erase" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
-    }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinkSensor_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
-  result = std_vector_Sl_iDynTree_SolidShape_Sm__Sg__erase__SWIG_1(arg1,arg2,arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)((iDynTree::LinkSensor const *)arg1)->isConsistent((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_erase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
-      if (_v) {
-        return _wrap_SolidShapesVector_erase__SWIG_0(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
-      if (_v) {
-        swig::MatlabSwigIterator *iter = 0;
-        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
-        if (_v) {
-          return _wrap_SolidShapesVector_erase__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
+int _wrap_new_SensorsList__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::SensorsList *result = 0 ;
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SolidShapesVector_erase'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::SolidShape * >::erase(std::vector< iDynTree::SolidShape * >::iterator)\n"
-    "    std::vector< iDynTree::SolidShape * >::erase(std::vector< iDynTree::SolidShape * >::iterator,std::vector< iDynTree::SolidShape * >::iterator)\n");
+  if (!SWIG_check_num_args("new_SensorsList",argc,0,0,0)) {
+    SWIG_fail;
+  }
+  (void)argv;
+  result = (iDynTree::SensorsList *)new iDynTree::SensorsList();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsList, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
   return 1;
 }
 
 
-int _wrap_new_SolidShapesVector__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * >::size_type arg1 ;
-  std::vector< iDynTree::SolidShape * >::value_type arg2 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
+int _wrap_new_SensorsList__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * > *result = 0 ;
+  iDynTree::SensorsList *result = 0 ;
   
-  if (!SWIG_check_num_args("new_SolidShapesVector",argc,2,2,0)) {
+  if (!SWIG_check_num_args("new_SensorsList",argc,1,1,0)) {
     SWIG_fail;
   }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_SolidShapesVector" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SensorsList,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SensorsList" "', argument " "1"" of type '" "iDynTree::SensorsList const &""'"); 
   }
-  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp2);
-  result = (std::vector< iDynTree::SolidShape * > *)new std::vector< iDynTree::SolidShape * >(arg1,arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 1 |  0 );
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SensorsList" "', argument " "1"" of type '" "iDynTree::SensorsList const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  result = (iDynTree::SensorsList *)new iDynTree::SensorsList((iDynTree::SensorsList const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsList, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_SolidShapesVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_SensorsList(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   if (argc == 0) {
-    return _wrap_new_SolidShapesVector__SWIG_0(resc,resv,argc,argv);
-  }
-  if (argc == 1) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      return _wrap_new_SolidShapesVector__SWIG_2(resc,resv,argc,argv);
-    }
+    return _wrap_new_SensorsList__SWIG_0(resc,resv,argc,argv);
   }
   if (argc == 1) {
     int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      return _wrap_new_SolidShapesVector__SWIG_1(resc,resv,argc,argv);
-    }
-  }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__SolidShape, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_new_SolidShapesVector__SWIG_3(resc,resv,argc,argv);
-      }
+      return _wrap_new_SensorsList__SWIG_1(resc,resv,argc,argv);
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SolidShapesVector'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SensorsList'."
     "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::SolidShape * >::vector()\n"
-    "    std::vector< iDynTree::SolidShape * >::vector(std::vector< iDynTree::SolidShape * > const &)\n"
-    "    std::vector< iDynTree::SolidShape * >::vector(std::vector< iDynTree::SolidShape * >::size_type)\n"
-    "    std::vector< iDynTree::SolidShape * >::vector(std::vector< iDynTree::SolidShape * >::size_type,std::vector< iDynTree::SolidShape * >::value_type)\n");
+    "    iDynTree::SensorsList::SensorsList()\n"
+    "    iDynTree::SensorsList::SensorsList(iDynTree::SensorsList const &)\n");
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_push_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::value_type arg2 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
+int _wrap_delete_SensorsList(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
   
-  if (!SWIG_check_num_args("SolidShapesVector_push_back",argc,2,2,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_SensorsList",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_push_back" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SensorsList" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SolidShapesVector_push_back" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg2 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp2);
-  (arg1)->push_back(arg2);
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_front(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_SensorsList_addSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::Sensor *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::value_type result;
+  std::ptrdiff_t result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_front",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsList_addSensor",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_front" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_addSensor" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = (std::vector< iDynTree::SolidShape * >::value_type)((std::vector< iDynTree::SolidShape * > const *)arg1)->front();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Sensor,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SensorsList_addSensor" "', argument " "2"" of type '" "iDynTree::Sensor const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_addSensor" "', argument " "2"" of type '" "iDynTree::Sensor const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Sensor * >(argp2);
+  result = (arg1)->addSensor((iDynTree::Sensor const &)*arg2);
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_SensorsList_setSerialization(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::value_type result;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_back",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsList_setSerialization",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_back" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_setSerialization" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = (std::vector< iDynTree::SolidShape * >::value_type)((std::vector< iDynTree::SolidShape * > const *)arg1)->back();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_setSerialization" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  {
+    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
+    res3 = swig::asptr(argv[2], &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_setSerialization" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_setSerialization" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  result = (bool)(arg1)->setSerialization((iDynTree::SensorType const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res3)) delete arg3;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_assign(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::size_type arg2 ;
-  std::vector< iDynTree::SolidShape * >::value_type arg3 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
+int _wrap_SensorsList_getSerialization(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
   void *argp3 = 0 ;
   int res3 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_assign",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SensorsList_getSerialization",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_assign" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSerialization" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_assign" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSerialization" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SolidShapesVector_assign" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_getSerialization" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > &""'"); 
   }
-  arg3 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp3);
-  (arg1)->assign(arg2,arg3);
-  _out = (mxArray*)0;
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_getSerialization" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > &""'"); 
+  }
+  arg3 = reinterpret_cast< std::vector< std::string,std::allocator< std::string > > * >(argp3);
+  result = (bool)(arg1)->getSerialization((iDynTree::SensorType const &)*arg2,*arg3);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_resize__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::size_type arg2 ;
-  std::vector< iDynTree::SolidShape * >::value_type arg3 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
+int _wrap_SensorsList_getNrOfSensors(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
   mxArray * _out;
+  std::size_t result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_resize",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SensorsList_getNrOfSensors",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_resize" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getNrOfSensors" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_resize" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SolidShapesVector_resize" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getNrOfSensors" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
   }
-  arg3 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp3);
-  (arg1)->resize(arg2,arg3);
-  _out = (mxArray*)0;
+  result = ((iDynTree::SensorsList const *)arg1)->getNrOfSensors((iDynTree::SensorType const &)*arg2);
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
+int _wrap_SensorsList_getSensorIndex__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::string *arg3 = 0 ;
+  std::ptrdiff_t *arg4 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  int res3 = SWIG_OLDOBJ ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("SensorsList_getSensorIndex",argc,4,4,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSensorIndex" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSensorIndex" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_getSensorIndex" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_getSensorIndex" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_std__ptrdiff_t,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsList_getSensorIndex" "', argument " "4"" of type '" "std::ptrdiff_t &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_getSensorIndex" "', argument " "4"" of type '" "std::ptrdiff_t &""'"); 
+  }
+  arg4 = reinterpret_cast< std::ptrdiff_t * >(argp4);
+  result = (bool)((iDynTree::SensorsList const *)arg1)->getSensorIndex((iDynTree::SensorType const &)*arg2,(std::string const &)*arg3,*arg4);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return 0;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return 1;
+}
+
+
+int _wrap_SensorsList_getSensorIndex__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::string *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  int res3 = SWIG_OLDOBJ ;
+  mxArray * _out;
+  std::ptrdiff_t result;
+  
+  if (!SWIG_check_num_args("SensorsList_getSensorIndex",argc,3,3,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSensorIndex" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSensorIndex" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_getSensorIndex" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_getSensorIndex" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    arg3 = ptr;
+  }
+  result = ((iDynTree::SensorsList const *)arg1)->getSensorIndex((iDynTree::SensorType const &)*arg2,(std::string const &)*arg3);
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return 0;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return 1;
+}
+
+
+int _wrap_SensorsList_getSensorIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 3) {
     int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
       {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        int res = SWIG_AsVal_int(argv[1], NULL);
         _v = SWIG_CheckState(res);
       }
       if (_v) {
-        return _wrap_SolidShapesVector_resize__SWIG_0(resc,resv,argc,argv);
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
+        _v = SWIG_CheckState(res);
+        if (_v) {
+          return _wrap_SensorsList_getSensorIndex__SWIG_1(resc,resv,argc,argv);
+        }
       }
     }
   }
-  if (argc == 3) {
+  if (argc == 4) {
     int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
       {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
+        int res = SWIG_AsVal_int(argv[1], NULL);
         _v = SWIG_CheckState(res);
       }
       if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__SolidShape, 0);
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
-          return _wrap_SolidShapesVector_resize__SWIG_1(resc,resv,argc,argv);
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_std__ptrdiff_t, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_SensorsList_getSensorIndex__SWIG_0(resc,resv,argc,argv);
+          }
         }
       }
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SolidShapesVector_resize'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SensorsList_getSensorIndex'."
     "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::SolidShape * >::resize(std::vector< iDynTree::SolidShape * >::size_type)\n"
-    "    std::vector< iDynTree::SolidShape * >::resize(std::vector< iDynTree::SolidShape * >::size_type,std::vector< iDynTree::SolidShape * >::value_type)\n");
+    "    iDynTree::SensorsList::getSensorIndex(iDynTree::SensorType const &,std::string const &,std::ptrdiff_t &) const\n"
+    "    iDynTree::SensorsList::getSensorIndex(iDynTree::SensorType const &,std::string const &) const\n");
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_insert__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::iterator arg2 ;
-  std::vector< iDynTree::SolidShape * >::value_type arg3 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
+int _wrap_SensorsList_getSizeOfAllSensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::iterator result;
+  size_t result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_insert",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SensorsList_getSizeOfAllSensorsMeasurements",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_insert" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSizeOfAllSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  result = ((iDynTree::SensorsList const *)arg1)->getSizeOfAllSensorsMeasurements();
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_SensorsList_getSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::ptrdiff_t arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  mxArray * _out;
+  iDynTree::Sensor *result = 0 ;
+  
+  if (!SWIG_check_num_args("SensorsList_getSensor",argc,3,3,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSensor" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
   } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
-    }
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
   }
-  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
+  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsList_getSensor" "', argument " "3"" of type '" "std::ptrdiff_t""'");
+  } 
+  arg3 = static_cast< std::ptrdiff_t >(val3);
+  result = (iDynTree::Sensor *)((iDynTree::SensorsList const *)arg1)->getSensor((iDynTree::SensorType const &)*arg2,arg3);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_SensorsList_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("SensorsList_isConsistent",argc,2,2,0)) {
+    SWIG_fail;
   }
-  arg3 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp3);
-  result = std_vector_Sl_iDynTree_SolidShape_Sm__Sg__insert__SWIG_0(arg1,arg2,arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< iDynTree::SolidShape * >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_isConsistent" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SensorsList_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)((iDynTree::SensorsList const *)arg1)->isConsistent((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_insert__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::iterator arg2 ;
-  std::vector< iDynTree::SolidShape * >::size_type arg3 ;
-  std::vector< iDynTree::SolidShape * >::value_type arg4 = (std::vector< iDynTree::SolidShape * >::value_type) 0 ;
+int _wrap_SensorsList_removeSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::string *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_insert",argc,4,4,0)) {
+  if (!SWIG_check_num_args("SensorsList_removeSensor",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_insert" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_removeSensor" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_removeSensor" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
   } else {
-    swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "SolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::iterator""'");
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  {
+    std::string *ptr = (std::string *)0;
+    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
+    if (!SWIG_IsOK(res3)) {
+      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SensorsList_removeSensor" "', argument " "3"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsList_removeSensor" "', argument " "3"" of type '" "std::string const &""'"); 
     }
+    arg3 = ptr;
   }
-  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
+  result = (bool)(arg1)->removeSensor((iDynTree::SensorType const &)*arg2,(std::string const &)*arg3);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return 0;
+fail:
+  if (SWIG_IsNewObj(res3)) delete arg3;
+  return 1;
+}
+
+
+int _wrap_SensorsList_removeSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::ptrdiff_t arg3 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("SensorsList_removeSensor",argc,3,3,0)) {
+    SWIG_fail;
+  }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_removeSensor" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_removeSensor" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
   if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsList_removeSensor" "', argument " "3"" of type '" "std::ptrdiff_t""'");
   } 
-  arg3 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_iDynTree__SolidShape, 0 |  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SolidShapesVector_insert" "', argument " "4"" of type '" "std::vector< iDynTree::SolidShape * >::value_type""'"); 
-  }
-  arg4 = reinterpret_cast< std::vector< iDynTree::SolidShape * >::value_type >(argp4);
-  std_vector_Sl_iDynTree_SolidShape_Sm__Sg__insert__SWIG_1(arg1,arg2,arg3,arg4);
-  _out = (mxArray*)0;
+  arg3 = static_cast< std::ptrdiff_t >(val3);
+  result = (bool)(arg1)->removeSensor((iDynTree::SensorType const &)*arg2,arg3);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_insert(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_SensorsList_removeSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   if (argc == 3) {
     int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__SolidShape, 0);
+      {
+        int res = SWIG_AsVal_int(argv[1], NULL);
         _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
         if (_v) {
-          return _wrap_SolidShapesVector_insert__SWIG_0(resc,resv,argc,argv);
+          return _wrap_SensorsList_removeSensor__SWIG_1(resc,resv,argc,argv);
         }
       }
     }
   }
-  if (argc == 4) {
+  if (argc == 3) {
     int _v;
-    int res = swig::asptr(argv[0], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< iDynTree::SolidShape * >::iterator > *>(iter) != 0));
+      {
+        int res = SWIG_AsVal_int(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
       if (_v) {
-        {
-          int res = SWIG_AsVal_size_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
+        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
+        _v = SWIG_CheckState(res);
         if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__SolidShape, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_SolidShapesVector_insert__SWIG_1(resc,resv,argc,argv);
-          }
+          return _wrap_SensorsList_removeSensor__SWIG_0(resc,resv,argc,argv);
         }
       }
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SolidShapesVector_insert'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SensorsList_removeSensor'."
     "  Possible C/C++ prototypes are:\n"
-    "    std::vector< iDynTree::SolidShape * >::insert(std::vector< iDynTree::SolidShape * >::iterator,std::vector< iDynTree::SolidShape * >::value_type)\n"
-    "    std::vector< iDynTree::SolidShape * >::insert(std::vector< iDynTree::SolidShape * >::iterator,std::vector< iDynTree::SolidShape * >::size_type,std::vector< iDynTree::SolidShape * >::value_type)\n");
+    "    iDynTree::SensorsList::removeSensor(iDynTree::SensorType const &,std::string const &)\n"
+    "    iDynTree::SensorsList::removeSensor(iDynTree::SensorType const &,std::ptrdiff_t const)\n");
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_reserve(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
-  std::vector< iDynTree::SolidShape * >::size_type arg2 ;
+int _wrap_SensorsList_removeAllSensorsOfType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("SolidShapesVector_reserve",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SensorsList_removeAllSensorsOfType",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_reserve" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_removeAllSensorsOfType" "', argument " "1"" of type '" "iDynTree::SensorsList *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SolidShapesVector_reserve" "', argument " "2"" of type '" "std::vector< iDynTree::SolidShape * >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< iDynTree::SolidShape * >::size_type >(val2);
-  (arg1)->reserve(arg2);
-  _out = (mxArray*)0;
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_removeAllSensorsOfType" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  result = (bool)(arg1)->removeAllSensorsOfType((iDynTree::SensorType const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_SolidShapesVector_capacity(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_SensorsList_getSixAxisForceTorqueSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  std::vector< iDynTree::SolidShape * >::size_type result;
+  iDynTree::SixAxisForceTorqueSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("SolidShapesVector_capacity",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsList_getSixAxisForceTorqueSensor",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SolidShapesVector_capacity" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getSixAxisForceTorqueSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  result = ((std::vector< iDynTree::SolidShape * > const *)arg1)->capacity();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getSixAxisForceTorqueSensor" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  result = (iDynTree::SixAxisForceTorqueSensor *)iDynTree_SensorsList_getSixAxisForceTorqueSensor((iDynTree::SensorsList const *)arg1,arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_delete_SolidShapesVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< iDynTree::SolidShape * > *arg1 = (std::vector< iDynTree::SolidShape * > *) 0 ;
+int _wrap_SensorsList_getAccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
+  iDynTree::AccelerometerSensor *result = 0 ;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_SolidShapesVector",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsList_getAccelerometerSensor",argc,2,2,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SolidShapesVector" "', argument " "1"" of type '" "std::vector< iDynTree::SolidShape * > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< iDynTree::SolidShape * > * >(argp1);
-  if (is_owned) {
-    delete arg1;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
   }
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getAccelerometerSensor" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  result = (iDynTree::AccelerometerSensor *)iDynTree_SensorsList_getAccelerometerSensor((iDynTree::SensorsList const *)arg1,arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_pop(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsList_getGyroscopeSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type result;
+  iDynTree::GyroscopeSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_pop",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsList_getGyroscopeSensor",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_pop" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  try {
-    result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__pop(arg1);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getGyroscopeSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
   }
-  
-  _out = swig::from(static_cast< std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > >(result));
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getGyroscopeSensor" "', argument " "2"" of type '" "int""'");
+  } 
+  arg2 = static_cast< int >(val2);
+  result = (iDynTree::GyroscopeSensor *)iDynTree_SensorsList_getGyroscopeSensor((iDynTree::SensorsList const *)arg1,arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_brace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::difference_type arg2 ;
+int _wrap_SensorsList_getThreeAxisAngularAccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  ptrdiff_t val2 ;
+  int val2 ;
   int ecode2 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type result;
+  iDynTree::ThreeAxisAngularAccelerometerSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_brace",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SensorsList_getThreeAxisAngularAccelerometerSensor",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_brace" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getThreeAxisAngularAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_brace" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::difference_type""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getThreeAxisAngularAccelerometerSensor" "', argument " "2"" of type '" "int""'");
   } 
-  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::difference_type >(val2);
-  try {
-    result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__brace(arg1,arg2);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
-  
-  _out = swig::from(static_cast< std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > >(result));
+  arg2 = static_cast< int >(val2);
+  result = (iDynTree::ThreeAxisAngularAccelerometerSensor *)iDynTree_SensorsList_getThreeAxisAngularAccelerometerSensor((iDynTree::SensorsList const *)arg1,arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_setbrace(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type arg2 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::difference_type arg3 ;
+int _wrap_SensorsList_getThreeAxisForceTorqueContactSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = (iDynTree::SensorsList *) 0 ;
+  int arg2 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  ptrdiff_t val3 ;
-  int ecode3 = 0 ;
+  int val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
+  iDynTree::ThreeAxisForceTorqueContactSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_setbrace",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SensorsList_getThreeAxisForceTorqueContactSensor",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsList, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_setbrace" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
-  }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    int res = swig::asptr(argv[1], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "LinksSolidShapesVector_setbrace" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsList_getThreeAxisForceTorqueContactSensor" "', argument " "1"" of type '" "iDynTree::SensorsList const *""'"); 
   }
-  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "LinksSolidShapesVector_setbrace" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::difference_type""'");
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  ecode2 = SWIG_AsVal_int(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsList_getThreeAxisForceTorqueContactSensor" "', argument " "2"" of type '" "int""'");
   } 
-  arg3 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::difference_type >(val3);
-  try {
-    std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__setbrace(arg1,arg2,arg3);
-  }
-  catch(std::out_of_range &_e) {
-    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
-  }
+  arg2 = static_cast< int >(val2);
+  result = (iDynTree::ThreeAxisForceTorqueContactSensor *)iDynTree_SensorsList_getThreeAxisForceTorqueContactSensor((iDynTree::SensorsList const *)arg1,arg2);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_SensorsMeasurements__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::SensorsMeasurements *result = 0 ;
   
-  _out = (mxArray*)0;
+  if (!SWIG_check_num_args("new_SensorsMeasurements",argc,0,0,0)) {
+    SWIG_fail;
+  }
+  (void)argv;
+  result = (iDynTree::SensorsMeasurements *)new iDynTree::SensorsMeasurements();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsMeasurements, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_append(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type arg2 ;
-  void *argp1 = 0 ;
+int _wrap_new_SensorsMeasurements__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsList *arg1 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
+  iDynTree::SensorsMeasurements *result = 0 ;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_append",argc,2,2,0)) {
+  if (!SWIG_check_num_args("new_SensorsMeasurements",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SensorsList,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_append" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsList const &""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    int res = swig::asptr(argv[1], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "LinksSolidShapesVector_append" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsList const &""'"); 
   }
-  std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__append(arg1,arg2);
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::SensorsList * >(argp1);
+  result = (iDynTree::SensorsMeasurements *)new iDynTree::SensorsMeasurements((iDynTree::SensorsList const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsMeasurements, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_LinksSolidShapesVector__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_SensorsMeasurements__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = 0 ;
+  void *argp1 ;
+  int res1 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > > *result = 0 ;
+  iDynTree::SensorsMeasurements *result = 0 ;
   
-  if (!SWIG_check_num_args("new_LinksSolidShapesVector",argc,0,0,0)) {
+  if (!SWIG_check_num_args("new_SensorsMeasurements",argc,1,1,0)) {
     SWIG_fail;
   }
-  (void)argv;
-  result = (std::vector< std::vector< iDynTree::SolidShape * > > *)new std::vector< std::vector< iDynTree::SolidShape * > >();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 1 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SensorsMeasurements,  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const &""'"); 
+  }
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  result = (iDynTree::SensorsMeasurements *)new iDynTree::SensorsMeasurements((iDynTree::SensorsMeasurements const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SensorsMeasurements, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_LinksSolidShapesVector__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > *arg1 = 0 ;
-  int res1 = SWIG_OLDOBJ ;
+int _wrap_new_SensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_SensorsMeasurements__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_SensorsMeasurements__SWIG_1(resc,resv,argc,argv);
+    }
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_SensorsMeasurements__SWIG_2(resc,resv,argc,argv);
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SensorsMeasurements'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::SensorsMeasurements::SensorsMeasurements()\n"
+    "    iDynTree::SensorsMeasurements::SensorsMeasurements(iDynTree::SensorsList const &)\n"
+    "    iDynTree::SensorsMeasurements::SensorsMeasurements(iDynTree::SensorsMeasurements const &)\n");
+  return 1;
+}
+
+
+int _wrap_delete_SensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > > *result = 0 ;
   
-  if (!SWIG_check_num_args("new_LinksSolidShapesVector",argc,1,1,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_SensorsMeasurements",argc,1,1,0)) {
     SWIG_fail;
   }
-  {
-    std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > > *ptr = (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > > *)0;
-    res1 = swig::asptr(argv[0], &ptr);
-    if (!SWIG_IsOK(res1)) {
-      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > const &""'"); 
-    }
-    arg1 = ptr;
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
   }
-  result = (std::vector< std::vector< iDynTree::SolidShape * > > *)new std::vector< std::vector< iDynTree::SolidShape * > >((std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 1 |  0 );
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  if (is_owned) {
+    delete arg1;
+  }
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res1)) delete arg1;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res1)) delete arg1;
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_empty(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsMeasurements_setNrOfSensors(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::size_t arg3 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  size_t val3 ;
+  int ecode3 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_empty",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_setNrOfSensors",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_empty" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_setNrOfSensors" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = (bool)((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->empty();
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_setNrOfSensors" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_setNrOfSensors" "', argument " "3"" of type '" "std::size_t""'");
+  } 
+  arg3 = static_cast< std::size_t >(val3);
+  result = (bool)(arg1)->setNrOfSensors((iDynTree::SensorType const &)*arg2,arg3);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_size(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsMeasurements_getNrOfSensors(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type result;
+  std::size_t result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_size",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_getNrOfSensors",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_size" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_getNrOfSensors" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = ((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->size();
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_getNrOfSensors" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  result = ((iDynTree::SensorsMeasurements const *)arg1)->getNrOfSensors((iDynTree::SensorType const &)*arg2);
   _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_swap(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > *arg2 = 0 ;
+int _wrap_SensorsMeasurements_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  iDynTree::SensorsList *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
+  void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_swap",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_resize",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_swap" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_resize" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t,  0 );
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SensorsList,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinksSolidShapesVector_swap" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SensorsMeasurements_resize" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_swap" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_resize" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
   }
-  arg2 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > * >(argp2);
-  (arg1)->swap(*arg2);
-  _out = (mxArray*)0;
+  arg2 = reinterpret_cast< iDynTree::SensorsList * >(argp2);
+  result = (bool)(arg1)->resize((iDynTree::SensorsList const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_begin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsMeasurements_toVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  iDynTree::VectorDynSize *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_begin",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_toVector",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_begin" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_toVector" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = (arg1)->begin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SensorsMeasurements_toVector" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_toVector" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::VectorDynSize * >(argp2);
+  result = (bool)((iDynTree::SensorsMeasurements const *)arg1)->toVector(*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_end(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsMeasurements_setMeasurement__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::ptrdiff_t *arg3 = 0 ;
+  iDynTree::Wrench *arg4 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  std::ptrdiff_t temp3 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_end",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_setMeasurement",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_end" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = (arg1)->end();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "3"" of type '" "std::ptrdiff_t""'");
+  } 
+  temp3 = static_cast< std::ptrdiff_t >(val3);
+  arg3 = &temp3;
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__Wrench,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "4"" of type '" "iDynTree::Wrench const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_setMeasurement" "', argument " "4"" of type '" "iDynTree::Wrench const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::Wrench * >(argp4);
+  result = (bool)(arg1)->setMeasurement((iDynTree::SensorType const &)*arg2,(std::ptrdiff_t const &)*arg3,(iDynTree::Wrench const &)*arg4);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_rbegin(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsMeasurements_setMeasurement__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::ptrdiff_t *arg3 = 0 ;
+  iDynTree::Vector3 *arg4 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  std::ptrdiff_t temp3 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::reverse_iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_rbegin",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_setMeasurement",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_rbegin" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = (arg1)->rbegin();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "3"" of type '" "std::ptrdiff_t""'");
+  } 
+  temp3 = static_cast< std::ptrdiff_t >(val3);
+  arg3 = &temp3;
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsMeasurements_setMeasurement" "', argument " "4"" of type '" "iDynTree::Vector3 const &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_setMeasurement" "', argument " "4"" of type '" "iDynTree::Vector3 const &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::Vector3 * >(argp4);
+  result = (bool)(arg1)->setMeasurement((iDynTree::SensorType const &)*arg2,(std::ptrdiff_t const &)*arg3,(iDynTree::Vector3 const &)*arg4);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_rend(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsMeasurements_setMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 4) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_int(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__Wrench, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_SensorsMeasurements_setMeasurement__SWIG_0(resc,resv,argc,argv);
+          }
+        }
+      }
+    }
+  }
+  if (argc == 4) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_int(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_SensorsMeasurements_setMeasurement__SWIG_1(resc,resv,argc,argv);
+          }
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SensorsMeasurements_setMeasurement'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::SensorsMeasurements::setMeasurement(iDynTree::SensorType const &,std::ptrdiff_t const &,iDynTree::Wrench const &)\n"
+    "    iDynTree::SensorsMeasurements::setMeasurement(iDynTree::SensorType const &,std::ptrdiff_t const &,iDynTree::Vector3 const &)\n");
+  return 1;
+}
+
+
+int _wrap_SensorsMeasurements_getMeasurement__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::ptrdiff_t *arg3 = 0 ;
+  iDynTree::Wrench *arg4 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  std::ptrdiff_t temp3 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::reverse_iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_rend",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_getMeasurement",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_rend" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = (arg1)->rend();
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::reverse_iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "3"" of type '" "std::ptrdiff_t""'");
+  } 
+  temp3 = static_cast< std::ptrdiff_t >(val3);
+  arg3 = &temp3;
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__Wrench,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "4"" of type '" "iDynTree::Wrench &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_getMeasurement" "', argument " "4"" of type '" "iDynTree::Wrench &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::Wrench * >(argp4);
+  result = (bool)((iDynTree::SensorsMeasurements const *)arg1)->getMeasurement((iDynTree::SensorType const &)*arg2,(std::ptrdiff_t const &)*arg3,*arg4);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_clear(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsMeasurements_getMeasurement__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
+  iDynTree::SensorType *arg2 = 0 ;
+  std::ptrdiff_t *arg3 = 0 ;
+  iDynTree::Vector3 *arg4 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int val2 ;
+  int ecode2 ;
+  iDynTree::SensorType temp2 ;
+  std::ptrdiff_t temp3 ;
+  ptrdiff_t val3 ;
+  int ecode3 = 0 ;
+  void *argp4 = 0 ;
+  int res4 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_clear",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_getMeasurement",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_clear" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  (arg1)->clear();
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  ecode2 = SWIG_AsVal_int (argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "2"" of type '" "iDynTree::SensorType const &""'");
+  } else {
+    temp2 = static_cast< iDynTree::SensorType >(val2);
+    arg2 = &temp2;
+  }
+  ecode3 = SWIG_AsVal_ptrdiff_t(argv[2], &val3);
+  if (!SWIG_IsOK(ecode3)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "3"" of type '" "std::ptrdiff_t""'");
+  } 
+  temp3 = static_cast< std::ptrdiff_t >(val3);
+  arg3 = &temp3;
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t,  0 );
+  if (!SWIG_IsOK(res4)) {
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SensorsMeasurements_getMeasurement" "', argument " "4"" of type '" "iDynTree::Vector3 &""'"); 
+  }
+  if (!argp4) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SensorsMeasurements_getMeasurement" "', argument " "4"" of type '" "iDynTree::Vector3 &""'"); 
+  }
+  arg4 = reinterpret_cast< iDynTree::Vector3 * >(argp4);
+  result = (bool)((iDynTree::SensorsMeasurements const *)arg1)->getMeasurement((iDynTree::SensorType const &)*arg2,(std::ptrdiff_t const &)*arg3,*arg4);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_get_allocator(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SensorsMeasurements_getMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 4) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_int(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__Wrench, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_SensorsMeasurements_getMeasurement__SWIG_0(resc,resv,argc,argv);
+          }
+        }
+      }
+    }
+  }
+  if (argc == 4) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SensorsMeasurements, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      {
+        int res = SWIG_AsVal_int(argv[1], NULL);
+        _v = SWIG_CheckState(res);
+      }
+      if (_v) {
+        {
+          int res = SWIG_AsVal_ptrdiff_t(argv[2], NULL);
+          _v = SWIG_CheckState(res);
+        }
+        if (_v) {
+          void *vptr = 0;
+          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t, 0);
+          _v = SWIG_CheckState(res);
+          if (_v) {
+            return _wrap_SensorsMeasurements_getMeasurement__SWIG_1(resc,resv,argc,argv);
+          }
+        }
+      }
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'SensorsMeasurements_getMeasurement'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::SensorsMeasurements::getMeasurement(iDynTree::SensorType const &,std::ptrdiff_t const &,iDynTree::Wrench &) const\n"
+    "    iDynTree::SensorsMeasurements::getMeasurement(iDynTree::SensorType const &,std::ptrdiff_t const &,iDynTree::Vector3 &) const\n");
+  return 1;
+}
+
+
+int _wrap_SensorsMeasurements_getSizeOfAllSensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SensorsMeasurements *arg1 = (iDynTree::SensorsMeasurements *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  SwigValueWrapper< std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > > result;
+  size_t result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_get_allocator",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SensorsMeasurements_getSizeOfAllSensorsMeasurements",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SensorsMeasurements, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_get_allocator" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SensorsMeasurements_getSizeOfAllSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::SensorsMeasurements const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = ((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->get_allocator();
-  _out = SWIG_NewPointerObj((new std::vector< std::vector< iDynTree::SolidShape * > >::allocator_type(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::allocator_type& >(result))), SWIGTYPE_p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t, SWIG_POINTER_OWN |  0 );
+  arg1 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp1);
+  result = ((iDynTree::SensorsMeasurements const *)arg1)->getSizeOfAllSensorsMeasurements();
+  _out = SWIG_From_size_t(static_cast< size_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_LinksSolidShapesVector__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg1 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
+int _wrap_new_SixAxisForceTorqueSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > > *result = 0 ;
+  iDynTree::SixAxisForceTorqueSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("new_LinksSolidShapesVector",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_SixAxisForceTorqueSensor",argc,0,0,0)) {
     SWIG_fail;
   }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val1);
-  result = (std::vector< std::vector< iDynTree::SolidShape * > > *)new std::vector< std::vector< iDynTree::SolidShape * > >(arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 1 |  0 );
+  (void)argv;
+  result = (iDynTree::SixAxisForceTorqueSensor *)new iDynTree::SixAxisForceTorqueSensor();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_pop_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_new_SixAxisForceTorqueSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
+  iDynTree::SixAxisForceTorqueSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_pop_back",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_SixAxisForceTorqueSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_pop_back" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SixAxisForceTorqueSensor" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const &""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  (arg1)->pop_back();
-  _out = (mxArray*)0;
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SixAxisForceTorqueSensor" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = (iDynTree::SixAxisForceTorqueSensor *)new iDynTree::SixAxisForceTorqueSensor((iDynTree::SixAxisForceTorqueSensor const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_resize__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg2 ;
+int _wrap_new_SixAxisForceTorqueSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_SixAxisForceTorqueSensor__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_SixAxisForceTorqueSensor__SWIG_1(resc,resv,argc,argv);
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_SixAxisForceTorqueSensor'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::SixAxisForceTorqueSensor::SixAxisForceTorqueSensor()\n"
+    "    iDynTree::SixAxisForceTorqueSensor::SixAxisForceTorqueSensor(iDynTree::SixAxisForceTorqueSensor const &)\n");
+  return 1;
+}
+
+
+int _wrap_delete_SixAxisForceTorqueSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_resize",argc,2,2,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_SixAxisForceTorqueSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_resize" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SixAxisForceTorqueSensor" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_resize" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val2);
-  (arg1)->resize(arg2);
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_erase__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg2 ;
+int _wrap_SixAxisForceTorqueSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_erase",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setName",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_erase" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
     }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
   }
-  result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__erase__SWIG_0(arg1,arg2);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  result = (bool)(arg1)->setName((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_erase__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg2 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg3 ;
+int _wrap_SixAxisForceTorqueSensor_setFirstLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::LinkIndex arg2 ;
+  iDynTree::Transform *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  swig::MatlabSwigIterator *iter3 = 0 ;
-  int res3 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_erase",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setFirstLinkSensorTransform",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_erase" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setFirstLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-    }
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_setFirstLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  arg2 = static_cast< iDynTree::LinkIndex >(val2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Transform,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_setFirstLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
   }
-  res3 = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter3), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res3) || !iter3) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter3);
-    if (iter_t) {
-      arg3 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_erase" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-    }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setFirstLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
   }
-  result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__erase__SWIG_1(arg1,arg2,arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg3 = reinterpret_cast< iDynTree::Transform * >(argp3);
+  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->setFirstLinkSensorTransform(arg2,(iDynTree::Transform const &)*arg3);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_erase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
-      if (_v) {
-        return _wrap_LinksSolidShapesVector_erase__SWIG_0(resc,resv,argc,argv);
-      }
-    }
+int _wrap_SixAxisForceTorqueSensor_setSecondLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::LinkIndex arg2 ;
+  iDynTree::Transform *arg3 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setSecondLinkSensorTransform",argc,3,3,0)) {
+    SWIG_fail;
   }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
-      if (_v) {
-        swig::MatlabSwigIterator *iter = 0;
-        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
-        if (_v) {
-          return _wrap_LinksSolidShapesVector_erase__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setSecondLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'LinksSolidShapesVector_erase'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::erase(std::vector< std::vector< iDynTree::SolidShape * > >::iterator)\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::erase(std::vector< std::vector< iDynTree::SolidShape * > >::iterator,std::vector< std::vector< iDynTree::SolidShape * > >::iterator)\n");
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_setSecondLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  arg2 = static_cast< iDynTree::LinkIndex >(val2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Transform,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_setSecondLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setSecondLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::Transform * >(argp3);
+  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->setSecondLinkSensorTransform(arg2,(iDynTree::Transform const &)*arg3);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
   return 1;
 }
 
 
-int _wrap_new_LinksSolidShapesVector__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg1 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg2 = 0 ;
-  size_t val1 ;
-  int ecode1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
+int _wrap_SixAxisForceTorqueSensor_getFirstLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > > *result = 0 ;
+  iDynTree::LinkIndex result;
   
-  if (!SWIG_check_num_args("new_LinksSolidShapesVector",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getFirstLinkIndex",argc,1,1,0)) {
     SWIG_fail;
   }
-  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
-  } 
-  arg1 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val1);
-  {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    res2 = swig::asptr(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_LinksSolidShapesVector" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LinksSolidShapesVector" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
-    }
-    arg2 = ptr;
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getFirstLinkIndex" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  result = (std::vector< std::vector< iDynTree::SolidShape * > > *)new std::vector< std::vector< iDynTree::SolidShape * > >(arg1,(std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)*arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 1 |  0 );
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getFirstLinkIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_new_LinksSolidShapesVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_LinksSolidShapesVector__SWIG_0(resc,resv,argc,argv);
+int _wrap_SixAxisForceTorqueSensor_getSecondLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::LinkIndex result;
+  
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getSecondLinkIndex",argc,1,1,0)) {
+    SWIG_fail;
   }
-  if (argc == 1) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
-    }
-    if (_v) {
-      return _wrap_new_LinksSolidShapesVector__SWIG_2(resc,resv,argc,argv);
-    }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getSecondLinkIndex" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  if (argc == 1) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_LinksSolidShapesVector__SWIG_1(resc,resv,argc,argv);
-    }
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getSecondLinkIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_SixAxisForceTorqueSensor_setFirstLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  std::string *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setFirstLinkName",argc,2,2,0)) {
+    SWIG_fail;
   }
-  if (argc == 2) {
-    int _v;
-    {
-      int res = SWIG_AsVal_size_t(argv[0], NULL);
-      _v = SWIG_CheckState(res);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setFirstLinkName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_setFirstLinkName" "', argument " "2"" of type '" "std::string const &""'"); 
     }
-    if (_v) {
-      int res = swig::asptr(argv[1], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_new_LinksSolidShapesVector__SWIG_3(resc,resv,argc,argv);
-      }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setFirstLinkName" "', argument " "2"" of type '" "std::string const &""'"); 
     }
+    arg2 = ptr;
   }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_LinksSolidShapesVector'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::vector()\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::vector(std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > const &)\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::vector(std::vector< std::vector< iDynTree::SolidShape * > >::size_type)\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::vector(std::vector< std::vector< iDynTree::SolidShape * > >::size_type,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)\n");
+  result = (bool)(arg1)->setFirstLinkName((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
+  return 0;
+fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_push_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg2 = 0 ;
+int _wrap_SixAxisForceTorqueSensor_setSecondLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_push_back",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setSecondLinkName",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_push_back" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setSecondLinkName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
   {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    res2 = swig::asptr(argv[1], &ptr);
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
     if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LinksSolidShapesVector_push_back" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_setSecondLinkName" "', argument " "2"" of type '" "std::string const &""'"); 
     }
     if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_push_back" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setSecondLinkName" "', argument " "2"" of type '" "std::string const &""'"); 
     }
     arg2 = ptr;
   }
-  (arg1)->push_back((std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)*arg2);
-  _out = (mxArray*)0;
+  result = (bool)(arg1)->setSecondLinkName((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
   if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_front(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SixAxisForceTorqueSensor_getFirstLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *result = 0 ;
+  std::string result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_front",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getFirstLinkName",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_front" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getFirstLinkName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = (std::vector< std::vector< iDynTree::SolidShape * > >::value_type *) &((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->front();
-  _out = swig::from(static_cast< std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > >(*result));
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getFirstLinkName();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_back(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SixAxisForceTorqueSensor_getSecondLinkName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *result = 0 ;
+  std::string result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_back",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getSecondLinkName",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_back" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getSecondLinkName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = (std::vector< std::vector< iDynTree::SolidShape * > >::value_type *) &((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->back();
-  _out = swig::from(static_cast< std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > >(*result));
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getSecondLinkName();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_assign(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg2 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg3 = 0 ;
+int _wrap_SixAxisForceTorqueSensor_setParentJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  int res3 = SWIG_OLDOBJ ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_assign",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setParentJoint",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_assign" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setParentJoint" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_assign" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val2);
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
   {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    res3 = swig::asptr(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LinksSolidShapesVector_assign" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_setParentJoint" "', argument " "2"" of type '" "std::string const &""'"); 
     }
     if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_assign" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_setParentJoint" "', argument " "2"" of type '" "std::string const &""'"); 
     }
-    arg3 = ptr;
+    arg2 = ptr;
   }
-  (arg1)->assign(arg2,(std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)*arg3);
-  _out = (mxArray*)0;
+  result = (bool)(arg1)->setParentJoint((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_resize__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg2 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg3 = 0 ;
+int _wrap_SixAxisForceTorqueSensor_setParentJointIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::JointIndex *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
+  iDynTree::JointIndex temp2 ;
+  ptrdiff_t val2 ;
   int ecode2 = 0 ;
-  int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_resize",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setParentJointIndex",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_resize" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setParentJointIndex" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_resize" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_setParentJointIndex" "', argument " "2"" of type '" "iDynTree::JointIndex""'");
   } 
-  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val2);
-  {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    res3 = swig::asptr(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LinksSolidShapesVector_resize" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_resize" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  (arg1)->resize(arg2,(std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)*arg3);
-  _out = (mxArray*)0;
+  temp2 = static_cast< iDynTree::JointIndex >(val2);
+  arg2 = &temp2;
+  result = (bool)(arg1)->setParentJointIndex((iDynTree::JointIndex const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_LinksSolidShapesVector_resize__SWIG_0(resc,resv,argc,argv);
-      }
-    }
+int _wrap_SixAxisForceTorqueSensor_setAppliedWrenchLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::LinkIndex arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_setAppliedWrenchLink",argc,2,2,0)) {
+    SWIG_fail;
   }
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_LinksSolidShapesVector_resize__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_setAppliedWrenchLink" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
   }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'LinksSolidShapesVector_resize'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::resize(std::vector< std::vector< iDynTree::SolidShape * > >::size_type)\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::resize(std::vector< std::vector< iDynTree::SolidShape * > >::size_type,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)\n");
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_setAppliedWrenchLink" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  arg2 = static_cast< iDynTree::LinkIndex >(val2);
+  result = (bool)(arg1)->setAppliedWrenchLink(arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_insert__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg2 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg3 = 0 ;
+int _wrap_SixAxisForceTorqueSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator result;
+  std::string result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_insert",argc,3,3,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getName",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_insert" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getName" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-    }
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getName();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_SixAxisForceTorqueSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::SensorType result;
+  
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getSensorType",argc,1,1,0)) {
+    SWIG_fail;
   }
-  {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    res3 = swig::asptr(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "LinksSolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
-    }
-    arg3 = ptr;
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  result = std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__insert__SWIG_0(arg1,arg2,(std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > const &)*arg3);
-  _out = SWIG_NewPointerObj(swig::make_output_iterator(static_cast< const std::vector< std::vector< iDynTree::SolidShape * > >::iterator & >(result)),
-    swig::MatlabSwigIterator::descriptor(),SWIG_POINTER_OWN);
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = (iDynTree::SensorType)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getSensorType();
+  _out = SWIG_From_int(static_cast< int >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_insert__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::iterator arg2 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg3 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::value_type *arg4 = 0 ;
+int _wrap_SixAxisForceTorqueSensor_getParentJoint(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  swig::MatlabSwigIterator *iter2 = 0 ;
-  int res2 ;
-  size_t val3 ;
-  int ecode3 = 0 ;
-  int res4 = SWIG_OLDOBJ ;
   mxArray * _out;
+  std::string result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_insert",argc,4,4,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getParentJoint",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_insert" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getParentJoint" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter2), swig::MatlabSwigIterator::descriptor(), 0);
-  if (!SWIG_IsOK(res2) || !iter2) {
-    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-  } else {
-    swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *iter_t = dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter2);
-    if (iter_t) {
-      arg2 = iter_t->get_current();
-    } else {
-      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "LinksSolidShapesVector_insert" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::iterator""'");
-    }
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getParentJoint();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_SixAxisForceTorqueSensor_getParentJointIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::JointIndex result;
+  
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getParentJointIndex",argc,1,1,0)) {
+    SWIG_fail;
   }
-  ecode3 = SWIG_AsVal_size_t(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "LinksSolidShapesVector_insert" "', argument " "3"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
-  } 
-  arg3 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val3);
-  {
-    std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *ptr = (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > > *)0;
-    res4 = swig::asptr(argv[3], &ptr);
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "LinksSolidShapesVector_insert" "', argument " "4"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "LinksSolidShapesVector_insert" "', argument " "4"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &""'"); 
-    }
-    arg4 = ptr;
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getParentJointIndex" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  std_vector_Sl_std_vector_Sl_iDynTree_SolidShape_Sm__Sg__Sg__insert__SWIG_1(arg1,arg2,arg3,(std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > const &)*arg4);
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getParentJointIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res4)) delete arg4;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res4)) delete arg4;
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_insert(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 3) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_LinksSolidShapesVector_insert__SWIG_0(resc,resv,argc,argv);
-        }
-      }
-    }
+int _wrap_SixAxisForceTorqueSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_isValid",argc,1,1,0)) {
+    SWIG_fail;
   }
-  if (argc == 4) {
-    int _v;
-    int res = swig::asptr(argv[0], (std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > >**)(0));
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      swig::MatlabSwigIterator *iter = 0;
-      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::MatlabSwigIterator::descriptor(), 0);
-      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::MatlabSwigIterator_T<std::vector< std::vector< iDynTree::SolidShape * > >::iterator > *>(iter) != 0));
-      if (_v) {
-        {
-          int res = SWIG_AsVal_size_t(argv[2], NULL);
-          _v = SWIG_CheckState(res);
-        }
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector< iDynTree::SolidShape*,std::allocator< iDynTree::SolidShape * > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_LinksSolidShapesVector_insert__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_isValid" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'LinksSolidShapesVector_insert'."
-    "  Possible C/C++ prototypes are:\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::insert(std::vector< std::vector< iDynTree::SolidShape * > >::iterator,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)\n"
-    "    std::vector< std::vector< iDynTree::SolidShape * > >::insert(std::vector< std::vector< iDynTree::SolidShape * > >::iterator,std::vector< std::vector< iDynTree::SolidShape * > >::size_type,std::vector< std::vector< iDynTree::SolidShape * > >::value_type const &)\n");
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->isValid();
+  _out = SWIG_From_bool(static_cast< bool >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_reserve(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type arg2 ;
+int _wrap_SixAxisForceTorqueSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
+  iDynTree::Sensor *result = 0 ;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_reserve",argc,2,2,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_clone",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_reserve" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_clone" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "LinksSolidShapesVector_reserve" "', argument " "2"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > >::size_type""'");
-  } 
-  arg2 = static_cast< std::vector< std::vector< iDynTree::SolidShape * > >::size_type >(val2);
-  (arg1)->reserve(arg2);
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = (iDynTree::Sensor *)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->clone();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_LinksSolidShapesVector_capacity(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SixAxisForceTorqueSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
-  std::vector< std::vector< iDynTree::SolidShape * > >::size_type result;
+  bool result;
   
-  if (!SWIG_check_num_args("LinksSolidShapesVector_capacity",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_updateIndices",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LinksSolidShapesVector_capacity" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  result = ((std::vector< std::vector< iDynTree::SolidShape * > > const *)arg1)->capacity();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_delete_LinksSolidShapesVector(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  std::vector< std::vector< iDynTree::SolidShape * > > *arg1 = (std::vector< std::vector< iDynTree::SolidShape * > > *) 0 ;
+int _wrap_SixAxisForceTorqueSensor_getAppliedWrenchLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
+  iDynTree::LinkIndex result;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_LinksSolidShapesVector",argc,1,1,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getAppliedWrenchLink",argc,1,1,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LinksSolidShapesVector" "', argument " "1"" of type '" "std::vector< std::vector< iDynTree::SolidShape * > > *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getAppliedWrenchLink" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< std::vector< std::vector< iDynTree::SolidShape * > > * >(argp1);
-  if (is_owned) {
-    delete arg1;
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getAppliedWrenchLink();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_SixAxisForceTorqueSensor_isLinkAttachedToSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::LinkIndex arg2 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_isLinkAttachedToSensor",argc,2,2,0)) {
+    SWIG_fail;
   }
-  _out = (mxArray*)0;
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_isLinkAttachedToSensor" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_isLinkAttachedToSensor" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  arg2 = static_cast< iDynTree::LinkIndex >(val2);
+  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->isLinkAttachedToSensor(arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardPositionKinematics__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
+int _wrap_SixAxisForceTorqueSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::LinkIndex arg2 ;
   iDynTree::Transform *arg3 = 0 ;
-  iDynTree::VectorDynSize *arg4 = 0 ;
-  iDynTree::LinkPositions *arg5 = 0 ;
-  void *argp1 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  void *argp3 = 0 ;
   int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 = 0 ;
-  int res5 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ForwardPositionKinematics",argc,5,5,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getLinkSensorTransform",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardPositionKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardPositionKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_getLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  arg2 = static_cast< iDynTree::LinkIndex >(val2);
   res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Transform,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardPositionKinematics" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_getLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "3"" of type '" "iDynTree::Transform const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getLinkSensorTransform" "', argument " "3"" of type '" "iDynTree::Transform &""'"); 
   }
   arg3 = reinterpret_cast< iDynTree::Transform * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardPositionKinematics" "', argument " "4"" of type '" "iDynTree::VectorDynSize const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "4"" of type '" "iDynTree::VectorDynSize const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::VectorDynSize * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardPositionKinematics" "', argument " "5"" of type '" "iDynTree::LinkPositions &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "5"" of type '" "iDynTree::LinkPositions &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::LinkPositions * >(argp5);
-  result = (bool)iDynTree::ForwardPositionKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::Transform const &)*arg3,(iDynTree::VectorDynSize const &)*arg4,*arg5);
+  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getLinkSensorTransform(arg2,*arg3);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardPositionKinematics__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::FreeFloatingPos *arg3 = 0 ;
-  iDynTree::LinkPositions *arg4 = 0 ;
-  void *argp1 ;
+int _wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::LinkIndex arg2 ;
+  iDynTree::Wrench *arg3 = 0 ;
+  iDynTree::Wrench *arg4 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
   void *argp3 ;
   int res3 = 0 ;
   void *argp4 = 0 ;
   int res4 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ForwardPositionKinematics",argc,4,4,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getWrenchAppliedOnLink",argc,4,4,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardPositionKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardPositionKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  arg2 = static_cast< iDynTree::LinkIndex >(val2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Wrench,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardPositionKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "3"" of type '" "iDynTree::Wrench const &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "3"" of type '" "iDynTree::Wrench const &""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
+  arg3 = reinterpret_cast< iDynTree::Wrench * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__Wrench,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardPositionKinematics" "', argument " "4"" of type '" "iDynTree::LinkPositions &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "4"" of type '" "iDynTree::Wrench &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPositionKinematics" "', argument " "4"" of type '" "iDynTree::LinkPositions &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLink" "', argument " "4"" of type '" "iDynTree::Wrench &""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::LinkPositions * >(argp4);
-  result = (bool)iDynTree::ForwardPositionKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,*arg4);
+  arg4 = reinterpret_cast< iDynTree::Wrench * >(argp4);
+  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getWrenchAppliedOnLink(arg2,(iDynTree::Wrench const &)*arg3,*arg4);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardPositionKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingPos, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__LinkPositions, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_ForwardPositionKinematics__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  if (argc == 5) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__Transform, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__VectorDynSize, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            void *vptr = 0;
-            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__LinkPositions, 0);
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              return _wrap_ForwardPositionKinematics__SWIG_0(resc,resv,argc,argv);
-            }
-          }
-        }
-      }
-    }
-  }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ForwardPositionKinematics'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ForwardPositionKinematics(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::Transform const &,iDynTree::VectorDynSize const &,iDynTree::LinkPositions &)\n"
-    "    iDynTree::ForwardPositionKinematics(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::FreeFloatingPos const &,iDynTree::LinkPositions &)\n");
-  return 1;
-}
-
-
-int _wrap_ForwardVelAccKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::FreeFloatingPos *arg3 = 0 ;
-  iDynTree::FreeFloatingVel *arg4 = 0 ;
-  iDynTree::FreeFloatingAcc *arg5 = 0 ;
-  iDynTree::LinkVelArray *arg6 = 0 ;
-  iDynTree::LinkAccArray *arg7 = 0 ;
-  void *argp1 ;
+int _wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::LinkIndex arg2 ;
+  iDynTree::Matrix6x6 *arg3 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  void *argp3 = 0 ;
   int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 = 0 ;
-  int res6 = 0 ;
-  void *argp7 = 0 ;
-  int res7 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ForwardVelAccKinematics",argc,7,7,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardVelAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardVelAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  arg2 = static_cast< iDynTree::LinkIndex >(val2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__MatrixFixSizeT_6_6_t,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardVelAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix" "', argument " "3"" of type '" "iDynTree::Matrix6x6 &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardVelAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardVelAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardVelAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray &""'"); 
-  }
-  arg6 = reinterpret_cast< iDynTree::LinkVelArray * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ForwardVelAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
-  }
-  if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardVelAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix" "', argument " "3"" of type '" "iDynTree::Matrix6x6 &""'"); 
   }
-  arg7 = reinterpret_cast< iDynTree::LinkAccArray * >(argp7);
-  result = (bool)iDynTree::ForwardVelAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::FreeFloatingAcc const &)*arg5,*arg6,*arg7);
+  arg3 = reinterpret_cast< iDynTree::Matrix6x6 * >(argp3);
+  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getWrenchAppliedOnLinkMatrix(arg2,*arg3);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardPosVelAccKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::FreeFloatingPos *arg3 = 0 ;
-  iDynTree::FreeFloatingVel *arg4 = 0 ;
-  iDynTree::FreeFloatingAcc *arg5 = 0 ;
-  iDynTree::LinkPositions *arg6 = 0 ;
-  iDynTree::LinkVelArray *arg7 = 0 ;
-  iDynTree::LinkAccArray *arg8 = 0 ;
-  void *argp1 ;
+int _wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::LinkIndex arg2 ;
+  iDynTree::Matrix6x6 *arg3 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
+  void *argp3 = 0 ;
   int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 = 0 ;
-  int res6 = 0 ;
-  void *argp7 = 0 ;
-  int res7 = 0 ;
-  void *argp8 = 0 ;
-  int res8 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ForwardPosVelAccKinematics",argc,8,8,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardPosVelAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardPosVelAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  arg2 = static_cast< iDynTree::LinkIndex >(val2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__MatrixFixSizeT_6_6_t,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardPosVelAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix" "', argument " "3"" of type '" "iDynTree::Matrix6x6 &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardPosVelAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardPosVelAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardPosVelAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkPositions &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkPositions &""'"); 
-  }
-  arg6 = reinterpret_cast< iDynTree::LinkPositions * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ForwardPosVelAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkVelArray &""'"); 
-  }
-  if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkVelArray &""'"); 
-  }
-  arg7 = reinterpret_cast< iDynTree::LinkVelArray * >(argp7);
-  res8 = SWIG_ConvertPtr(argv[7], &argp8, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res8)) {
-    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "ForwardPosVelAccKinematics" "', argument " "8"" of type '" "iDynTree::LinkAccArray &""'"); 
-  }
-  if (!argp8) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelAccKinematics" "', argument " "8"" of type '" "iDynTree::LinkAccArray &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix" "', argument " "3"" of type '" "iDynTree::Matrix6x6 &""'"); 
   }
-  arg8 = reinterpret_cast< iDynTree::LinkAccArray * >(argp8);
-  result = (bool)iDynTree::ForwardPosVelAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::FreeFloatingAcc const &)*arg5,*arg6,*arg7,*arg8);
+  arg3 = reinterpret_cast< iDynTree::Matrix6x6 * >(argp3);
+  result = (bool)((iDynTree::SixAxisForceTorqueSensor const *)arg1)->getWrenchAppliedOnLinkInverseMatrix(arg2,*arg3);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardPosVelKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
+int _wrap_SixAxisForceTorqueSensor_predictMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
   iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::FreeFloatingPos *arg3 = 0 ;
-  iDynTree::FreeFloatingVel *arg4 = 0 ;
-  iDynTree::LinkPositions *arg5 = 0 ;
-  iDynTree::LinkVelArray *arg6 = 0 ;
-  void *argp1 ;
+  iDynTree::LinkInternalWrenches *arg3 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   void *argp3 ;
   int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 = 0 ;
-  int res5 = 0 ;
-  void *argp6 = 0 ;
-  int res6 = 0 ;
   mxArray * _out;
-  bool result;
+  iDynTree::Wrench result;
   
-  if (!SWIG_check_num_args("ForwardPosVelKinematics",argc,6,6,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_predictMeasurement",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardPosVelKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
   res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardPosVelKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardPosVelKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "3"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardPosVelKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardPosVelKinematics" "', argument " "5"" of type '" "iDynTree::LinkPositions &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "5"" of type '" "iDynTree::LinkPositions &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::LinkPositions * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardPosVelKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardPosVelKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_predictMeasurement" "', argument " "3"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
   }
-  arg6 = reinterpret_cast< iDynTree::LinkVelArray * >(argp6);
-  result = (bool)iDynTree::ForwardPosVelKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,*arg5,*arg6);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg3 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp3);
+  result = (arg1)->predictMeasurement((iDynTree::Traversal const &)*arg2,(iDynTree::LinkInternalWrenches const &)*arg3);
+  _out = SWIG_NewPointerObj((new iDynTree::Wrench(static_cast< const iDynTree::Wrench& >(result))), SWIGTYPE_p_iDynTree__Wrench, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardAccKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::FreeFloatingPos *arg3 = 0 ;
-  iDynTree::FreeFloatingVel *arg4 = 0 ;
-  iDynTree::FreeFloatingAcc *arg5 = 0 ;
-  iDynTree::LinkVelArray *arg6 = 0 ;
-  iDynTree::LinkAccArray *arg7 = 0 ;
-  void *argp1 ;
+int _wrap_SixAxisForceTorqueSensor_toString(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::SixAxisForceTorqueSensor *arg1 = (iDynTree::SixAxisForceTorqueSensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 ;
-  int res6 = 0 ;
-  void *argp7 = 0 ;
-  int res7 = 0 ;
   mxArray * _out;
-  bool result;
+  std::string result;
   
-  if (!SWIG_check_num_args("ForwardAccKinematics",argc,7,7,0)) {
+  if (!SWIG_check_num_args("SixAxisForceTorqueSensor_toString",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__SixAxisForceTorqueSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SixAxisForceTorqueSensor_toString" "', argument " "1"" of type '" "iDynTree::SixAxisForceTorqueSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  arg1 = reinterpret_cast< iDynTree::SixAxisForceTorqueSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SixAxisForceTorqueSensor_toString" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "5"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  arg6 = reinterpret_cast< iDynTree::LinkVelArray * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ForwardAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
-  }
-  if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SixAxisForceTorqueSensor_toString" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
-  arg7 = reinterpret_cast< iDynTree::LinkAccArray * >(argp7);
-  result = (bool)iDynTree::ForwardAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::FreeFloatingAcc const &)*arg5,(iDynTree::LinkVelArray const &)*arg6,*arg7);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = ((iDynTree::SixAxisForceTorqueSensor const *)arg1)->toString((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardBiasAccKinematics__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::FreeFloatingPos *arg3 = 0 ;
-  iDynTree::FreeFloatingVel *arg4 = 0 ;
-  iDynTree::SpatialAcc *arg5 = 0 ;
-  iDynTree::LinkVelArray *arg6 = 0 ;
-  iDynTree::LinkAccArray *arg7 = 0 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 ;
-  int res6 = 0 ;
-  void *argp7 = 0 ;
-  int res7 = 0 ;
+int _wrap_new_AccelerometerSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  bool result;
+  iDynTree::AccelerometerSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("ForwardBiasAccKinematics",argc,7,7,0)) {
+  if (!SWIG_check_num_args("new_AccelerometerSensor",argc,0,0,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardBiasAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardBiasAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardBiasAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardBiasAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__SpatialAcc,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardBiasAccKinematics" "', argument " "5"" of type '" "iDynTree::SpatialAcc const &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "5"" of type '" "iDynTree::SpatialAcc const &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::SpatialAcc * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardBiasAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  arg6 = reinterpret_cast< iDynTree::LinkVelArray * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ForwardBiasAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
-  }
-  if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "7"" of type '" "iDynTree::LinkAccArray &""'"); 
-  }
-  arg7 = reinterpret_cast< iDynTree::LinkAccArray * >(argp7);
-  result = (bool)iDynTree::ForwardBiasAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::SpatialAcc const &)*arg5,(iDynTree::LinkVelArray const &)*arg6,*arg7);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  (void)argv;
+  result = (iDynTree::AccelerometerSensor *)new iDynTree::AccelerometerSensor();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__AccelerometerSensor, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardBiasAccKinematics__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::FreeFloatingPos *arg3 = 0 ;
-  iDynTree::FreeFloatingVel *arg4 = 0 ;
-  iDynTree::LinkVelArray *arg5 = 0 ;
-  iDynTree::LinkAccArray *arg6 = 0 ;
+int _wrap_new_AccelerometerSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 = 0 ;
-  int res6 = 0 ;
   mxArray * _out;
-  bool result;
+  iDynTree::AccelerometerSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("ForwardBiasAccKinematics",argc,6,6,0)) {
+  if (!SWIG_check_num_args("new_AccelerometerSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__AccelerometerSensor,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ForwardBiasAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AccelerometerSensor" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ForwardBiasAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ForwardBiasAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ForwardBiasAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ForwardBiasAccKinematics" "', argument " "5"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "5"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::LinkVelArray * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ForwardBiasAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkAccArray &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ForwardBiasAccKinematics" "', argument " "6"" of type '" "iDynTree::LinkAccArray &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_AccelerometerSensor" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const &""'"); 
   }
-  arg6 = reinterpret_cast< iDynTree::LinkAccArray * >(argp6);
-  result = (bool)iDynTree::ForwardBiasAccKinematics((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::LinkVelArray const &)*arg5,*arg6);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  result = (iDynTree::AccelerometerSensor *)new iDynTree::AccelerometerSensor((iDynTree::AccelerometerSensor const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__AccelerometerSensor, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ForwardBiasAccKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 6) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingPos, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingVel, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            void *vptr = 0;
-            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__LinkVelArray, 0);
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              void *vptr = 0;
-              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_iDynTree__LinkAccArray, 0);
-              _v = SWIG_CheckState(res);
-              if (_v) {
-                return _wrap_ForwardBiasAccKinematics__SWIG_1(resc,resv,argc,argv);
-              }
-            }
-          }
-        }
-      }
-    }
+int _wrap_new_AccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_AccelerometerSensor__SWIG_0(resc,resv,argc,argv);
   }
-  if (argc == 7) {
+  if (argc == 1) {
     int _v;
     void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__AccelerometerSensor, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Traversal, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingPos, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__FreeFloatingVel, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            void *vptr = 0;
-            int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_iDynTree__SpatialAcc, 0);
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              void *vptr = 0;
-              int res = SWIG_ConvertPtr(argv[5], &vptr, SWIGTYPE_p_iDynTree__LinkVelArray, 0);
-              _v = SWIG_CheckState(res);
-              if (_v) {
-                void *vptr = 0;
-                int res = SWIG_ConvertPtr(argv[6], &vptr, SWIGTYPE_p_iDynTree__LinkAccArray, 0);
-                _v = SWIG_CheckState(res);
-                if (_v) {
-                  return _wrap_ForwardBiasAccKinematics__SWIG_0(resc,resv,argc,argv);
-                }
-              }
-            }
-          }
-        }
-      }
+      return _wrap_new_AccelerometerSensor__SWIG_1(resc,resv,argc,argv);
     }
   }
   
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ForwardBiasAccKinematics'."
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_AccelerometerSensor'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ForwardBiasAccKinematics(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::FreeFloatingPos const &,iDynTree::FreeFloatingVel const &,iDynTree::SpatialAcc const &,iDynTree::LinkVelArray const &,iDynTree::LinkAccArray &)\n"
-    "    iDynTree::ForwardBiasAccKinematics(iDynTree::Model const &,iDynTree::Traversal const &,iDynTree::FreeFloatingPos const &,iDynTree::FreeFloatingVel const &,iDynTree::LinkVelArray const &,iDynTree::LinkAccArray &)\n");
+    "    iDynTree::AccelerometerSensor::AccelerometerSensor()\n"
+    "    iDynTree::AccelerometerSensor::AccelerometerSensor(iDynTree::AccelerometerSensor const &)\n");
   return 1;
 }
 
 
-int _wrap_ComputeLinearAndAngularMomentum(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::LinkPositions *arg2 = 0 ;
-  iDynTree::LinkVelArray *arg3 = 0 ;
-  iDynTree::SpatialMomentum *arg4 = 0 ;
-  void *argp1 ;
+int _wrap_delete_AccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
   mxArray * _out;
-  bool result;
   
-  if (!SWIG_check_num_args("ComputeLinearAndAngularMomentum",argc,4,4,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_AccelerometerSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ComputeLinearAndAngularMomentum" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentum" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ComputeLinearAndAngularMomentum" "', argument " "2"" of type '" "iDynTree::LinkPositions const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentum" "', argument " "2"" of type '" "iDynTree::LinkPositions const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::LinkPositions * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ComputeLinearAndAngularMomentum" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentum" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::LinkVelArray * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__SpatialMomentum,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ComputeLinearAndAngularMomentum" "', argument " "4"" of type '" "iDynTree::SpatialMomentum &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AccelerometerSensor" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
   }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentum" "', argument " "4"" of type '" "iDynTree::SpatialMomentum &""'"); 
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg4 = reinterpret_cast< iDynTree::SpatialMomentum * >(argp4);
-  result = (bool)iDynTree::ComputeLinearAndAngularMomentum((iDynTree::Model const &)*arg1,(iDynTree::LinkPositions const &)*arg2,(iDynTree::LinkVelArray const &)*arg3,*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ComputeLinearAndAngularMomentumDerivativeBias(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::LinkPositions *arg2 = 0 ;
-  iDynTree::LinkVelArray *arg3 = 0 ;
-  iDynTree::LinkAccArray *arg4 = 0 ;
-  iDynTree::Wrench *arg5 = 0 ;
-  void *argp1 ;
+int _wrap_AccelerometerSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  std::string *arg2 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 = 0 ;
-  int res5 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ComputeLinearAndAngularMomentumDerivativeBias",argc,5,5,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_setName",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "2"" of type '" "iDynTree::LinkPositions const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "2"" of type '" "iDynTree::LinkPositions const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::LinkPositions * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "3"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::LinkVelArray * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "4"" of type '" "iDynTree::LinkAccArray const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "4"" of type '" "iDynTree::LinkAccArray const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::LinkAccArray * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__Wrench,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "5"" of type '" "iDynTree::Wrench &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_setName" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
   }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ComputeLinearAndAngularMomentumDerivativeBias" "', argument " "5"" of type '" "iDynTree::Wrench &""'"); 
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
   }
-  arg5 = reinterpret_cast< iDynTree::Wrench * >(argp5);
-  result = (bool)iDynTree::ComputeLinearAndAngularMomentumDerivativeBias((iDynTree::Model const &)*arg1,(iDynTree::LinkPositions const &)*arg2,(iDynTree::LinkVelArray const &)*arg3,(iDynTree::LinkAccArray const &)*arg4,*arg5);
+  result = (bool)(arg1)->setName((std::string const &)*arg2);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_RNEADynamicPhase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::JointPosDoubleArray *arg3 = 0 ;
-  iDynTree::LinkVelArray *arg4 = 0 ;
-  iDynTree::LinkAccArray *arg5 = 0 ;
-  iDynTree::LinkNetExternalWrenches *arg6 = 0 ;
-  iDynTree::LinkInternalWrenches *arg7 = 0 ;
-  iDynTree::FreeFloatingGeneralizedTorques *arg8 = 0 ;
-  void *argp1 ;
+int _wrap_AccelerometerSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  iDynTree::Transform *arg2 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 ;
-  int res6 = 0 ;
-  void *argp7 = 0 ;
-  int res7 = 0 ;
-  void *argp8 = 0 ;
-  int res8 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("RNEADynamicPhase",argc,8,8,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_setLinkSensorTransform",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RNEADynamicPhase" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RNEADynamicPhase" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__JointPosDoubleArray,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "RNEADynamicPhase" "', argument " "3"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "3"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::JointPosDoubleArray * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "RNEADynamicPhase" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::LinkVelArray * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "RNEADynamicPhase" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::LinkAccArray * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "RNEADynamicPhase" "', argument " "6"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "6"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
-  }
-  arg6 = reinterpret_cast< iDynTree::LinkNetExternalWrenches * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
-  if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "RNEADynamicPhase" "', argument " "7"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
-  }
-  if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "7"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
-  }
-  arg7 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp7);
-  res8 = SWIG_ConvertPtr(argv[7], &argp8, SWIGTYPE_p_iDynTree__FreeFloatingGeneralizedTorques,  0 );
-  if (!SWIG_IsOK(res8)) {
-    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "RNEADynamicPhase" "', argument " "8"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
-  }
-  if (!argp8) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RNEADynamicPhase" "', argument " "8"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
   }
-  arg8 = reinterpret_cast< iDynTree::FreeFloatingGeneralizedTorques * >(argp8);
-  result = (bool)iDynTree::RNEADynamicPhase((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::JointPosDoubleArray const &)*arg3,(iDynTree::LinkVelArray const &)*arg4,(iDynTree::LinkAccArray const &)*arg5,(iDynTree::LinkWrenches const &)*arg6,*arg7,*arg8);
+  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
+  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_CompositeRigidBodyAlgorithm(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::JointPosDoubleArray *arg3 = 0 ;
-  iDynTree::LinkCompositeRigidBodyInertias *arg4 = 0 ;
-  iDynTree::FreeFloatingMassMatrix *arg5 = 0 ;
-  void *argp1 ;
+int _wrap_AccelerometerSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  std::string *arg2 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
-  void *argp5 = 0 ;
-  int res5 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("CompositeRigidBodyAlgorithm",argc,5,5,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_setParentLink",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__JointPosDoubleArray,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "3"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "3"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::JointPosDoubleArray * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkInertias,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "4"" of type '" "iDynTree::LinkCompositeRigidBodyInertias &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "4"" of type '" "iDynTree::LinkCompositeRigidBodyInertias &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::LinkCompositeRigidBodyInertias * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingMassMatrix,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "CompositeRigidBodyAlgorithm" "', argument " "5"" of type '" "iDynTree::FreeFloatingMassMatrix &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
   }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompositeRigidBodyAlgorithm" "', argument " "5"" of type '" "iDynTree::FreeFloatingMassMatrix &""'"); 
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
   }
-  arg5 = reinterpret_cast< iDynTree::FreeFloatingMassMatrix * >(argp5);
-  result = (bool)iDynTree::CompositeRigidBodyAlgorithm((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::JointPosDoubleArray const &)*arg3,*arg4,*arg5);
+  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_new_ArticulatedBodyAlgorithmInternalBuffers__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_AccelerometerSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  iDynTree::LinkIndex *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  iDynTree::LinkIndex temp2 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("new_ArticulatedBodyAlgorithmInternalBuffers",argc,0,0,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_setParentLinkIndex",argc,2,2,0)) {
     SWIG_fail;
   }
-  (void)argv;
-  result = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *)new iDynTree::ArticulatedBodyAlgorithmInternalBuffers();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 1 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "AccelerometerSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  temp2 = static_cast< iDynTree::LinkIndex >(val2);
+  arg2 = &temp2;
+  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_ArticulatedBodyAlgorithmInternalBuffers__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  void *argp1 ;
+int _wrap_AccelerometerSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *result = 0 ;
+  std::string result;
   
-  if (!SWIG_check_num_args("new_ArticulatedBodyAlgorithmInternalBuffers",argc,1,1,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_getName",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ArticulatedBodyAlgorithmInternalBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ArticulatedBodyAlgorithmInternalBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getName" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  result = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *)new iDynTree::ArticulatedBodyAlgorithmInternalBuffers((iDynTree::Model const &)*arg1);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 1 |  0 );
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  result = ((iDynTree::AccelerometerSensor const *)arg1)->getName();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_ArticulatedBodyAlgorithmInternalBuffers(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 0) {
-    return _wrap_new_ArticulatedBodyAlgorithmInternalBuffers__SWIG_0(resc,resv,argc,argv);
+int _wrap_AccelerometerSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::SensorType result;
+  
+  if (!SWIG_check_num_args("AccelerometerSensor_getSensorType",argc,1,1,0)) {
+    SWIG_fail;
   }
-  if (argc == 1) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      return _wrap_new_ArticulatedBodyAlgorithmInternalBuffers__SWIG_1(resc,resv,argc,argv);
-    }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
   }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_ArticulatedBodyAlgorithmInternalBuffers'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ArticulatedBodyAlgorithmInternalBuffers::ArticulatedBodyAlgorithmInternalBuffers()\n"
-    "    iDynTree::ArticulatedBodyAlgorithmInternalBuffers::ArticulatedBodyAlgorithmInternalBuffers(iDynTree::Model const &)\n");
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  result = (iDynTree::SensorType)((iDynTree::AccelerometerSensor const *)arg1)->getSensorType();
+  _out = SWIG_From_int(static_cast< int >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_resize(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
+int _wrap_AccelerometerSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
   mxArray * _out;
+  std::string result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_resize",argc,2,2,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_getParentLink",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_resize" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_resize" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithmInternalBuffers_resize" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  (arg1)->resize((iDynTree::Model const &)*arg2);
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  result = ((iDynTree::AccelerometerSensor const *)arg1)->getParentLink();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_isConsistent(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
+int _wrap_AccelerometerSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
   mxArray * _out;
-  bool result;
+  iDynTree::LinkIndex result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_isConsistent",argc,2,2,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_getParentLinkIndex",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_isConsistent" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithmInternalBuffers_isConsistent" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->isConsistent((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  result = ((iDynTree::AccelerometerSensor const *)arg1)->getParentLinkIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_S_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::DOFSpatialMotionArray *arg2 = (iDynTree::DOFSpatialMotionArray *) 0 ;
+int _wrap_AccelerometerSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
+  iDynTree::Transform result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_S_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_getLinkSensorTransform",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_S_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__DOFSpatialMotionArray, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_S_set" "', argument " "2"" of type '" "iDynTree::DOFSpatialMotionArray *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::DOFSpatialMotionArray * >(argp2);
-  if (arg1) (arg1)->S = *arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  result = ((iDynTree::AccelerometerSensor const *)arg1)->getLinkSensorTransform();
+  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_S_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_AccelerometerSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::DOFSpatialMotionArray *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_S_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_isValid",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_S_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_isValid" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::DOFSpatialMotionArray *)& ((arg1)->S);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DOFSpatialMotionArray, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  result = (bool)((iDynTree::AccelerometerSensor const *)arg1)->isValid();
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_U_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::DOFSpatialForceArray *arg2 = (iDynTree::DOFSpatialForceArray *) 0 ;
+int _wrap_AccelerometerSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
+  iDynTree::Sensor *result = 0 ;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_U_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_clone",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_U_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__DOFSpatialForceArray, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_U_set" "', argument " "2"" of type '" "iDynTree::DOFSpatialForceArray *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_clone" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::DOFSpatialForceArray * >(argp2);
-  if (arg1) (arg1)->U = *arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  result = (iDynTree::Sensor *)((iDynTree::AccelerometerSensor const *)arg1)->clone();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_U_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_AccelerometerSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::DOFSpatialForceArray *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_U_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_updateIndices",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_U_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::DOFSpatialForceArray *)& ((arg1)->U);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DOFSpatialForceArray, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_D_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::JointDOFsDoubleArray *arg2 = (iDynTree::JointDOFsDoubleArray *) 0 ;
+int _wrap_AccelerometerSensor_predictMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::AccelerometerSensor *arg1 = (iDynTree::AccelerometerSensor *) 0 ;
+  iDynTree::SpatialAcc *arg2 = 0 ;
+  iDynTree::Twist *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
+  void *argp2 ;
   int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
   mxArray * _out;
+  iDynTree::LinAcceleration result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_D_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("AccelerometerSensor_predictMeasurement",argc,3,3,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__AccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_D_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "1"" of type '" "iDynTree::AccelerometerSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__JointDOFsDoubleArray, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::AccelerometerSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialAcc,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_D_set" "', argument " "2"" of type '" "iDynTree::JointDOFsDoubleArray *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::SpatialAcc const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp2);
-  if (arg1) (arg1)->D = *arg2;
-  _out = (mxArray*)0;
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::SpatialAcc const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::SpatialAcc * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Twist,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "3"" of type '" "iDynTree::Twist const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AccelerometerSensor_predictMeasurement" "', argument " "3"" of type '" "iDynTree::Twist const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::Twist * >(argp3);
+  result = (arg1)->predictMeasurement((iDynTree::SpatialAcc const &)*arg2,(iDynTree::Twist const &)*arg3);
+  _out = SWIG_NewPointerObj((new iDynTree::LinAcceleration(static_cast< const iDynTree::LinAcceleration& >(result))), SWIGTYPE_p_iDynTree__GeomVector3, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_D_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_new_GyroscopeSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::GyroscopeSensor *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_GyroscopeSensor",argc,0,0,0)) {
+    SWIG_fail;
+  }
+  (void)argv;
+  result = (iDynTree::GyroscopeSensor *)new iDynTree::GyroscopeSensor();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__GyroscopeSensor, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_GyroscopeSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::JointDOFsDoubleArray *result = 0 ;
+  iDynTree::GyroscopeSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_D_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_GyroscopeSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__GyroscopeSensor,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_D_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GyroscopeSensor" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::JointDOFsDoubleArray *)& ((arg1)->D);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__JointDOFsDoubleArray, 0 |  0 );
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GyroscopeSensor" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const &""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  result = (iDynTree::GyroscopeSensor *)new iDynTree::GyroscopeSensor((iDynTree::GyroscopeSensor const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__GyroscopeSensor, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_u_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::JointDOFsDoubleArray *arg2 = (iDynTree::JointDOFsDoubleArray *) 0 ;
+int _wrap_new_GyroscopeSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_GyroscopeSensor__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__GyroscopeSensor, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_GyroscopeSensor__SWIG_1(resc,resv,argc,argv);
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_GyroscopeSensor'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::GyroscopeSensor::GyroscopeSensor()\n"
+    "    iDynTree::GyroscopeSensor::GyroscopeSensor(iDynTree::GyroscopeSensor const &)\n");
+  return 1;
+}
+
+
+int _wrap_delete_GyroscopeSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_u_set",argc,2,2,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_GyroscopeSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_u_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GyroscopeSensor" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__JointDOFsDoubleArray, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_u_set" "', argument " "2"" of type '" "iDynTree::JointDOFsDoubleArray *""'"); 
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg2 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp2);
-  if (arg1) (arg1)->u = *arg2;
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_u_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_GyroscopeSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  iDynTree::JointDOFsDoubleArray *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_u_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_setName",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_u_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_setName" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::JointDOFsDoubleArray *)& ((arg1)->u);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__JointDOFsDoubleArray, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (bool)(arg1)->setName((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksVel_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::LinkVelArray *arg2 = (iDynTree::LinkVelArray *) 0 ;
+int _wrap_GyroscopeSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+  iDynTree::Transform *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
+  void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksVel_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_setLinkSensorTransform",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksVel_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkVelArray, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksVel_set" "', argument " "2"" of type '" "iDynTree::LinkVelArray *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::LinkVelArray * >(argp2);
-  if (arg1) (arg1)->linksVel = *arg2;
-  _out = (mxArray*)0;
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
+  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksVel_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_GyroscopeSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  iDynTree::LinkVelArray *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksVel_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_setParentLink",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksVel_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::LinkVelArray *)& ((arg1)->linksVel);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkVelArray, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::LinkAccArray *arg2 = (iDynTree::LinkAccArray *) 0 ;
+int _wrap_GyroscopeSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+  iDynTree::LinkIndex *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
+  iDynTree::LinkIndex temp2 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_setParentLinkIndex",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkAccArray, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set" "', argument " "2"" of type '" "iDynTree::LinkAccArray *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::LinkAccArray * >(argp2);
-  if (arg1) (arg1)->linksBiasAcceleration = *arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "GyroscopeSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  temp2 = static_cast< iDynTree::LinkIndex >(val2);
+  arg2 = &temp2;
+  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_GyroscopeSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::LinkAccArray *result = 0 ;
+  std::string result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_getName",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getName" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::LinkAccArray *)& ((arg1)->linksBiasAcceleration);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkAccArray, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  result = ((iDynTree::GyroscopeSensor const *)arg1)->getName();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::LinkAccArray *arg2 = (iDynTree::LinkAccArray *) 0 ;
+int _wrap_GyroscopeSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
+  iDynTree::SensorType result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_getSensorType",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkAccArray, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set" "', argument " "2"" of type '" "iDynTree::LinkAccArray *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::LinkAccArray * >(argp2);
-  if (arg1) (arg1)->linksAccelerations = *arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  result = (iDynTree::SensorType)((iDynTree::GyroscopeSensor const *)arg1)->getSensorType();
+  _out = SWIG_From_int(static_cast< int >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_GyroscopeSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::LinkAccArray *result = 0 ;
+  std::string result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_getParentLink",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::LinkAccArray *)& ((arg1)->linksAccelerations);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkAccArray, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  result = ((iDynTree::GyroscopeSensor const *)arg1)->getParentLink();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::LinkArticulatedBodyInertias *arg2 = (iDynTree::LinkArticulatedBodyInertias *) 0 ;
+int _wrap_GyroscopeSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
+  iDynTree::LinkIndex result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_getParentLinkIndex",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkArticulatedBodyInertias, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set" "', argument " "2"" of type '" "iDynTree::LinkArticulatedBodyInertias *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::LinkArticulatedBodyInertias * >(argp2);
-  if (arg1) (arg1)->linkABIs = *arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  result = ((iDynTree::GyroscopeSensor const *)arg1)->getParentLinkIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_GyroscopeSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::LinkArticulatedBodyInertias *result = 0 ;
+  iDynTree::Transform result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_getLinkSensorTransform",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::LinkArticulatedBodyInertias *)& ((arg1)->linkABIs);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkArticulatedBodyInertias, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  result = ((iDynTree::GyroscopeSensor const *)arg1)->getLinkSensorTransform();
+  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
-  iDynTree::LinkWrenches *arg2 = (iDynTree::LinkWrenches *) 0 ;
+int _wrap_GyroscopeSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_isValid",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_iDynTree__LinkWrenches, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set" "', argument " "2"" of type '" "iDynTree::LinkWrenches *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_isValid" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::LinkWrenches * >(argp2);
-  if (arg1) (arg1)->linksBiasWrench = *arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  result = (bool)((iDynTree::GyroscopeSensor const *)arg1)->isValid();
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_GyroscopeSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::LinkWrenches *result = 0 ;
+  iDynTree::Sensor *result = 0 ;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_clone",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_clone" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  result = (iDynTree::LinkWrenches *)& ((arg1)->linksBiasWrench);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__LinkWrenches, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  result = (iDynTree::Sensor *)((iDynTree::GyroscopeSensor const *)arg1)->clone();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_delete_ArticulatedBodyAlgorithmInternalBuffers(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg1 = (iDynTree::ArticulatedBodyAlgorithmInternalBuffers *) 0 ;
+int _wrap_GyroscopeSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_ArticulatedBodyAlgorithmInternalBuffers",argc,1,1,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_updateIndices",argc,2,2,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ArticulatedBodyAlgorithmInternalBuffers" "', argument " "1"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp1);
-  if (is_owned) {
-    delete arg1;
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
-  _out = (mxArray*)0;
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ArticulatedBodyAlgorithm(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::FreeFloatingPos *arg3 = 0 ;
-  iDynTree::FreeFloatingVel *arg4 = 0 ;
-  iDynTree::LinkNetExternalWrenches *arg5 = 0 ;
-  iDynTree::JointDOFsDoubleArray *arg6 = 0 ;
-  iDynTree::ArticulatedBodyAlgorithmInternalBuffers *arg7 = 0 ;
-  iDynTree::FreeFloatingAcc *arg8 = 0 ;
-  void *argp1 ;
+int _wrap_GyroscopeSensor_predictMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::GyroscopeSensor *arg1 = (iDynTree::GyroscopeSensor *) 0 ;
+  iDynTree::Twist *arg2 = 0 ;
+  void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 ;
-  int res6 = 0 ;
-  void *argp7 = 0 ;
-  int res7 = 0 ;
-  void *argp8 = 0 ;
-  int res8 = 0 ;
   mxArray * _out;
-  bool result;
+  iDynTree::AngVelocity result;
   
-  if (!SWIG_check_num_args("ArticulatedBodyAlgorithm",argc,8,8,0)) {
+  if (!SWIG_check_num_args("GyroscopeSensor_predictMeasurement",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__GyroscopeSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ArticulatedBodyAlgorithm" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GyroscopeSensor_predictMeasurement" "', argument " "1"" of type '" "iDynTree::GyroscopeSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  arg1 = reinterpret_cast< iDynTree::GyroscopeSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Twist,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ArticulatedBodyAlgorithm" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GyroscopeSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::Twist const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ArticulatedBodyAlgorithm" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "3"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ArticulatedBodyAlgorithm" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "4"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ArticulatedBodyAlgorithm" "', argument " "5"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "5"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
-  }
-  arg5 = reinterpret_cast< iDynTree::LinkNetExternalWrenches * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__JointDOFsDoubleArray,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ArticulatedBodyAlgorithm" "', argument " "6"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "6"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
-  }
-  arg6 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp6);
-  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__ArticulatedBodyAlgorithmInternalBuffers,  0 );
-  if (!SWIG_IsOK(res7)) {
-    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ArticulatedBodyAlgorithm" "', argument " "7"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers &""'"); 
-  }
-  if (!argp7) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "7"" of type '" "iDynTree::ArticulatedBodyAlgorithmInternalBuffers &""'"); 
-  }
-  arg7 = reinterpret_cast< iDynTree::ArticulatedBodyAlgorithmInternalBuffers * >(argp7);
-  res8 = SWIG_ConvertPtr(argv[7], &argp8, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
-  if (!SWIG_IsOK(res8)) {
-    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "ArticulatedBodyAlgorithm" "', argument " "8"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GyroscopeSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::Twist const &""'"); 
   }
-  if (!argp8) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ArticulatedBodyAlgorithm" "', argument " "8"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
+  arg2 = reinterpret_cast< iDynTree::Twist * >(argp2);
+  result = (arg1)->predictMeasurement((iDynTree::Twist const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::AngVelocity(static_cast< const iDynTree::AngVelocity& >(result))), SWIGTYPE_p_iDynTree__GeomVector3, SWIG_POINTER_OWN |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_ThreeAxisAngularAccelerometerSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  mxArray * _out;
+  iDynTree::ThreeAxisAngularAccelerometerSensor *result = 0 ;
+  
+  if (!SWIG_check_num_args("new_ThreeAxisAngularAccelerometerSensor",argc,0,0,0)) {
+    SWIG_fail;
   }
-  arg8 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp8);
-  result = (bool)iDynTree::ArticulatedBodyAlgorithm((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::FreeFloatingPos const &)*arg3,(iDynTree::FreeFloatingVel const &)*arg4,(iDynTree::LinkWrenches const &)*arg5,(iDynTree::JointDOFsDoubleArray const &)*arg6,*arg7,*arg8);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  (void)argv;
+  result = (iDynTree::ThreeAxisAngularAccelerometerSensor *)new iDynTree::ThreeAxisAngularAccelerometerSensor();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_InverseDynamicsInertialParametersRegressor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::Model *arg1 = 0 ;
-  iDynTree::Traversal *arg2 = 0 ;
-  iDynTree::LinkPositions *arg3 = 0 ;
-  iDynTree::LinkVelArray *arg4 = 0 ;
-  iDynTree::LinkAccArray *arg5 = 0 ;
-  iDynTree::MatrixDynSize *arg6 = 0 ;
+int _wrap_new_ThreeAxisAngularAccelerometerSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
-  void *argp5 ;
-  int res5 = 0 ;
-  void *argp6 = 0 ;
-  int res6 = 0 ;
   mxArray * _out;
-  bool result;
+  iDynTree::ThreeAxisAngularAccelerometerSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("InverseDynamicsInertialParametersRegressor",argc,6,6,0)) {
+  if (!SWIG_check_num_args("new_ThreeAxisAngularAccelerometerSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ThreeAxisAngularAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Traversal,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "2"" of type '" "iDynTree::Traversal const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ThreeAxisAngularAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Traversal * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "3"" of type '" "iDynTree::LinkPositions const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  result = (iDynTree::ThreeAxisAngularAccelerometerSensor *)new iDynTree::ThreeAxisAngularAccelerometerSensor((iDynTree::ThreeAxisAngularAccelerometerSensor const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 1 |  0 );
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_new_ThreeAxisAngularAccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_ThreeAxisAngularAccelerometerSensor__SWIG_0(resc,resv,argc,argv);
   }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "3"" of type '" "iDynTree::LinkPositions const &""'"); 
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_ThreeAxisAngularAccelerometerSensor__SWIG_1(resc,resv,argc,argv);
+    }
   }
-  arg3 = reinterpret_cast< iDynTree::LinkPositions * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_ThreeAxisAngularAccelerometerSensor'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::ThreeAxisAngularAccelerometerSensor::ThreeAxisAngularAccelerometerSensor()\n"
+    "    iDynTree::ThreeAxisAngularAccelerometerSensor::ThreeAxisAngularAccelerometerSensor(iDynTree::ThreeAxisAngularAccelerometerSensor const &)\n");
+  return 1;
+}
+
+
+int _wrap_delete_ThreeAxisAngularAccelerometerSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  
+  int is_owned;
+  if (!SWIG_check_num_args("delete_ThreeAxisAngularAccelerometerSensor",argc,1,1,0)) {
+    SWIG_fail;
   }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, SWIG_POINTER_DISOWN |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ThreeAxisAngularAccelerometerSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::LinkVelArray * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
+  _out = (mxArray*)0;
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
+  return 1;
+}
+
+
+int _wrap_ThreeAxisAngularAccelerometerSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
+  std::string *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
+  mxArray * _out;
+  bool result;
+  
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_setName",argc,2,2,0)) {
+    SWIG_fail;
   }
-  arg5 = reinterpret_cast< iDynTree::LinkAccArray * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__MatrixDynSize,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "6"" of type '" "iDynTree::MatrixDynSize &""'"); 
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_setName" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
   }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InverseDynamicsInertialParametersRegressor" "', argument " "6"" of type '" "iDynTree::MatrixDynSize &""'"); 
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
   }
-  arg6 = reinterpret_cast< iDynTree::MatrixDynSize * >(argp6);
-  result = (bool)iDynTree::InverseDynamicsInertialParametersRegressor((iDynTree::Model const &)*arg1,(iDynTree::Traversal const &)*arg2,(iDynTree::LinkPositions const &)*arg3,(iDynTree::LinkVelArray const &)*arg4,(iDynTree::LinkAccArray const &)*arg5,*arg6);
+  result = (bool)(arg1)->setName((std::string const &)*arg2);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_DHLink_A_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
-  double arg2 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
+  iDynTree::Transform *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("DHLink_A_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_A_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  ecode2 = SWIG_AsVal_double(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_A_set" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  if (arg1) (arg1)->A = arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
+  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_A_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  double result;
+  bool result;
   
-  if (!SWIG_check_num_args("DHLink_A_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_setParentLink",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_A_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  result = (double) ((arg1)->A);
-  _out = SWIG_From_double(static_cast< double >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_DHLink_D_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
-  double arg2 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
+  iDynTree::LinkIndex *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  double val2 ;
+  iDynTree::LinkIndex temp2 ;
+  ptrdiff_t val2 ;
   int ecode2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("DHLink_D_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_setParentLinkIndex",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_D_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  ecode2 = SWIG_AsVal_double(argv[1], &val2);
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
   if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_D_set" "', argument " "2"" of type '" "double""'");
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ThreeAxisAngularAccelerometerSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
   } 
-  arg2 = static_cast< double >(val2);
-  if (arg1) (arg1)->D = arg2;
-  _out = (mxArray*)0;
+  temp2 = static_cast< iDynTree::LinkIndex >(val2);
+  arg2 = &temp2;
+  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_D_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  double result;
+  std::string result;
   
-  if (!SWIG_check_num_args("DHLink_D_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getName",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_D_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getName" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  result = (double) ((arg1)->D);
-  _out = SWIG_From_double(static_cast< double >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getName();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_Alpha_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
-  double arg2 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
+  iDynTree::SensorType result;
   
-  if (!SWIG_check_num_args("DHLink_Alpha_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getSensorType",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Alpha_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  ecode2 = SWIG_AsVal_double(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_Alpha_set" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  if (arg1) (arg1)->Alpha = arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  result = (iDynTree::SensorType)((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getSensorType();
+  _out = SWIG_From_int(static_cast< int >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_Alpha_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  double result;
+  std::string result;
   
-  if (!SWIG_check_num_args("DHLink_Alpha_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getParentLink",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Alpha_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  result = (double) ((arg1)->Alpha);
-  _out = SWIG_From_double(static_cast< double >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getParentLink();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_Offset_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
-  double arg2 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
+  iDynTree::LinkIndex result;
   
-  if (!SWIG_check_num_args("DHLink_Offset_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getParentLinkIndex",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Offset_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  ecode2 = SWIG_AsVal_double(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_Offset_set" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  if (arg1) (arg1)->Offset = arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getParentLinkIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_Offset_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  double result;
+  iDynTree::Transform result;
   
-  if (!SWIG_check_num_args("DHLink_Offset_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Offset_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  result = (double) ((arg1)->Offset);
-  _out = SWIG_From_double(static_cast< double >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->getLinkSensorTransform();
+  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_Min_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
-  double arg2 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("DHLink_Min_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_isValid",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Min_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_isValid" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  ecode2 = SWIG_AsVal_double(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_Min_set" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  if (arg1) (arg1)->Min = arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  result = (bool)((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->isValid();
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_Min_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  double result;
+  iDynTree::Sensor *result = 0 ;
   
-  if (!SWIG_check_num_args("DHLink_Min_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_clone",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Min_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_clone" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  result = (double) ((arg1)->Min);
-  _out = SWIG_From_double(static_cast< double >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  result = (iDynTree::Sensor *)((iDynTree::ThreeAxisAngularAccelerometerSensor const *)arg1)->clone();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_Max_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
-  double arg2 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
+  iDynTree::Model *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("DHLink_Max_set",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_updateIndices",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Max_set" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  ecode2 = SWIG_AsVal_double(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHLink_Max_set" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  if (arg1) (arg1)->Max = arg2;
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHLink_Max_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
+int _wrap_ThreeAxisAngularAccelerometerSensor_predictMeasurement(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisAngularAccelerometerSensor *arg1 = (iDynTree::ThreeAxisAngularAccelerometerSensor *) 0 ;
+  iDynTree::SpatialAcc *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
   mxArray * _out;
-  double result;
+  iDynTree::Vector3 result;
   
-  if (!SWIG_check_num_args("DHLink_Max_get",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisAngularAccelerometerSensor_predictMeasurement",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisAngularAccelerometerSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHLink_Max_get" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisAngularAccelerometerSensor_predictMeasurement" "', argument " "1"" of type '" "iDynTree::ThreeAxisAngularAccelerometerSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  result = (double) ((arg1)->Max);
-  _out = SWIG_From_double(static_cast< double >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisAngularAccelerometerSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SpatialAcc,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisAngularAccelerometerSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::SpatialAcc const &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisAngularAccelerometerSensor_predictMeasurement" "', argument " "2"" of type '" "iDynTree::SpatialAcc const &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::SpatialAcc * >(argp2);
+  result = (arg1)->predictMeasurement((iDynTree::SpatialAcc const &)*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::Vector3(static_cast< const iDynTree::Vector3& >(result))), SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_DHLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_new_ThreeAxisForceTorqueContactSensor__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
-  iDynTree::DHLink *result = 0 ;
+  iDynTree::ThreeAxisForceTorqueContactSensor *result = 0 ;
   
-  if (!SWIG_check_num_args("new_DHLink",argc,0,0,0)) {
+  if (!SWIG_check_num_args("new_ThreeAxisForceTorqueContactSensor",argc,0,0,0)) {
     SWIG_fail;
   }
   (void)argv;
-  result = (iDynTree::DHLink *)new iDynTree::DHLink();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DHLink, 1 |  0 );
+  result = (iDynTree::ThreeAxisForceTorqueContactSensor *)new iDynTree::ThreeAxisForceTorqueContactSensor();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_delete_DHLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHLink *arg1 = (iDynTree::DHLink *) 0 ;
-  void *argp1 = 0 ;
+int _wrap_new_ThreeAxisForceTorqueContactSensor__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = 0 ;
+  void *argp1 ;
   int res1 = 0 ;
   mxArray * _out;
+  iDynTree::ThreeAxisForceTorqueContactSensor *result = 0 ;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_DHLink",argc,1,1,0)) {
+  if (!SWIG_check_num_args("new_ThreeAxisForceTorqueContactSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHLink, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DHLink" "', argument " "1"" of type '" "iDynTree::DHLink *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ThreeAxisForceTorqueContactSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHLink * >(argp1);
-  if (is_owned) {
-    delete arg1;
+  if (!argp1) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ThreeAxisForceTorqueContactSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const &""'"); 
   }
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = (iDynTree::ThreeAxisForceTorqueContactSensor *)new iDynTree::ThreeAxisForceTorqueContactSensor((iDynTree::ThreeAxisForceTorqueContactSensor const &)*arg1);
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 1 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_setNrOfDOFs(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
-  size_t arg2 ;
+int _wrap_new_ThreeAxisForceTorqueContactSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  if (argc == 0) {
+    return _wrap_new_ThreeAxisForceTorqueContactSensor__SWIG_0(resc,resv,argc,argv);
+  }
+  if (argc == 1) {
+    int _v;
+    void *vptr = 0;
+    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0);
+    _v = SWIG_CheckState(res);
+    if (_v) {
+      return _wrap_new_ThreeAxisForceTorqueContactSensor__SWIG_1(resc,resv,argc,argv);
+    }
+  }
+  
+  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'new_ThreeAxisForceTorqueContactSensor'."
+    "  Possible C/C++ prototypes are:\n"
+    "    iDynTree::ThreeAxisForceTorqueContactSensor::ThreeAxisForceTorqueContactSensor()\n"
+    "    iDynTree::ThreeAxisForceTorqueContactSensor::ThreeAxisForceTorqueContactSensor(iDynTree::ThreeAxisForceTorqueContactSensor const &)\n");
+  return 1;
+}
+
+
+int _wrap_delete_ThreeAxisForceTorqueContactSensor(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
   
-  if (!SWIG_check_num_args("DHChain_setNrOfDOFs",argc,2,2,0)) {
+  int is_owned;
+  if (!SWIG_check_num_args("delete_ThreeAxisForceTorqueContactSensor",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  is_owned = SWIG_Matlab_isOwned(argv[0]);
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, SWIG_POINTER_DISOWN |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_setNrOfDOFs" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ThreeAxisForceTorqueContactSensor" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  if (is_owned) {
+    delete arg1;
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_setNrOfDOFs" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  (arg1)->setNrOfDOFs(arg2);
   _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_getNrOfDOFs(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_setName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  size_t result;
+  bool result;
   
-  if (!SWIG_check_num_args("DHChain_getNrOfDOFs",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setName",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_getNrOfDOFs" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setName" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  result = ((iDynTree::DHChain const *)arg1)->getNrOfDOFs();
-  _out = SWIG_From_size_t(static_cast< size_t >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_setName" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (bool)(arg1)->setName((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_DHChain_setH0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_setLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   iDynTree::Transform *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("DHChain_setH0",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setLinkSensorTransform",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_setH0" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
   res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DHChain_setH0" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_setH0" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_setLinkSensorTransform" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
-  (arg1)->setH0((iDynTree::Transform const &)*arg2);
-  _out = (mxArray*)0;
+  result = (bool)(arg1)->setLinkSensorTransform((iDynTree::Transform const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_getH0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_setParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+  std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
+  int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
-  iDynTree::Transform *result = 0 ;
+  bool result;
   
-  if (!SWIG_check_num_args("DHChain_getH0",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setParentLink",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_getH0" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setParentLink" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  result = (iDynTree::Transform *) &((iDynTree::DHChain const *)arg1)->getH0();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Transform, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  {
+    std::string *ptr = (std::string *)0;
+    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
+    if (!SWIG_IsOK(res2)) {
+      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    if (!ptr) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_setParentLink" "', argument " "2"" of type '" "std::string const &""'"); 
+    }
+    arg2 = ptr;
+  }
+  result = (bool)(arg1)->setParentLink((std::string const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 0;
 fail:
+  if (SWIG_IsNewObj(res2)) delete arg2;
   return 1;
 }
 
 
-int _wrap_DHChain_setHN(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
-  iDynTree::Transform *arg2 = 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_setParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+  iDynTree::LinkIndex *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
+  iDynTree::LinkIndex temp2 ;
+  ptrdiff_t val2 ;
+  int ecode2 = 0 ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("DHChain_setHN",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setParentLinkIndex",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_setHN" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Transform,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DHChain_setHN" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_setHN" "', argument " "2"" of type '" "iDynTree::Transform const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setParentLinkIndex" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Transform * >(argp2);
-  (arg1)->setHN((iDynTree::Transform const &)*arg2);
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  ecode2 = SWIG_AsVal_ptrdiff_t(argv[1], &val2);
+  if (!SWIG_IsOK(ecode2)) {
+    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ThreeAxisForceTorqueContactSensor_setParentLinkIndex" "', argument " "2"" of type '" "iDynTree::LinkIndex""'");
+  } 
+  temp2 = static_cast< iDynTree::LinkIndex >(val2);
+  arg2 = &temp2;
+  result = (bool)(arg1)->setParentLinkIndex((iDynTree::LinkIndex const &)*arg2);
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_getHN(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_getName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
-  iDynTree::Transform *result = 0 ;
+  std::string result;
   
-  if (!SWIG_check_num_args("DHChain_getHN",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getName",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_getHN" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getName" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  result = (iDynTree::Transform *) &((iDynTree::DHChain const *)arg1)->getHN();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Transform, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getName();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_paren__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
-  size_t arg2 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_getSensorType(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  iDynTree::DHLink *result = 0 ;
+  iDynTree::SensorType result;
   
-  if (!SWIG_check_num_args("DHChain_paren",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getSensorType",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_paren" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getSensorType" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_paren" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (iDynTree::DHLink *) &(arg1)->operator ()(arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = (iDynTree::SensorType)((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getSensorType();
+  _out = SWIG_From_int(static_cast< int >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_paren__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
-  size_t arg2 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_getParentLink(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  iDynTree::DHLink *result = 0 ;
+  std::string result;
   
-  if (!SWIG_check_num_args("DHChain_paren",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getParentLink",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_paren" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getParentLink" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_paren" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = (iDynTree::DHLink *) &((iDynTree::DHChain const *)arg1)->operator ()(arg2);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DHLink, 0 |  0 );
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getParentLink();
+  _out = SWIG_From_std_string(static_cast< std::string >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_paren(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__DHChain, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_DHChain_paren__SWIG_0(resc,resv,argc,argv);
-      }
-    }
+int _wrap_ThreeAxisForceTorqueContactSensor_getParentLinkIndex(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  mxArray * _out;
+  iDynTree::LinkIndex result;
+  
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getParentLinkIndex",argc,1,1,0)) {
+    SWIG_fail;
   }
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__DHChain, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      {
-        int res = SWIG_AsVal_size_t(argv[1], NULL);
-        _v = SWIG_CheckState(res);
-      }
-      if (_v) {
-        return _wrap_DHChain_paren__SWIG_1(resc,resv,argc,argv);
-      }
-    }
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getParentLinkIndex" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
   }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'DHChain_paren'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::DHChain::operator ()(size_t const)\n"
-    "    iDynTree::DHChain::operator ()(size_t const) const\n");
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getParentLinkIndex();
+  _out = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
+  if (_out) --resc, *resv++ = _out;
+  return 0;
+fail:
   return 1;
 }
 
 
-int _wrap_DHChain_getDOFName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
-  size_t arg2 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_getLinkSensorTransform(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
   mxArray * _out;
-  std::string result;
+  iDynTree::Transform result;
   
-  if (!SWIG_check_num_args("DHChain_getDOFName",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getLinkSensorTransform",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_getDOFName" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getLinkSensorTransform" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_getDOFName" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  result = ((iDynTree::DHChain const *)arg1)->getDOFName(arg2);
-  _out = SWIG_From_std_string(static_cast< std::string >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getLinkSensorTransform();
+  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_setDOFName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
-  size_t arg2 ;
-  std::string *arg3 = 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_isValid(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  size_t val2 ;
-  int ecode2 = 0 ;
-  int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
+  bool result;
   
-  if (!SWIG_check_num_args("DHChain_setDOFName",argc,3,3,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_isValid",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_setDOFName" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  ecode2 = SWIG_AsVal_size_t(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DHChain_setDOFName" "', argument " "2"" of type '" "size_t""'");
-  } 
-  arg2 = static_cast< size_t >(val2);
-  {
-    std::string *ptr = (std::string *)0;
-    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DHChain_setDOFName" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_setDOFName" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    arg3 = ptr;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_isValid" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
   }
-  (arg1)->setDOFName(arg2,(std::string const &)*arg3);
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = (bool)((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->isValid();
+  _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
   return 0;
 fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_DHChain_toModel(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_clone(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
   mxArray * _out;
-  bool result;
+  iDynTree::Sensor *result = 0 ;
   
-  if (!SWIG_check_num_args("DHChain_toModel",argc,2,2,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_clone",argc,1,1,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_toModel" "', argument " "1"" of type '" "iDynTree::DHChain const *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DHChain_toModel" "', argument " "2"" of type '" "iDynTree::Model &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_toModel" "', argument " "2"" of type '" "iDynTree::Model &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_clone" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)((iDynTree::DHChain const *)arg1)->toModel(*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = (iDynTree::Sensor *)((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->clone();
+  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__Sensor, 0 |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_DHChain_fromModel(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_updateIndices(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   iDynTree::Model *arg2 = 0 ;
-  std::string arg3 ;
-  std::string arg4 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("DHChain_fromModel",argc,4,4,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_updateIndices",argc,2,2,0)) {
     SWIG_fail;
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, 0 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DHChain_fromModel" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_updateIndices" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
   res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DHChain_fromModel" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DHChain_fromModel" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_updateIndices" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DHChain_fromModel" "', argument " "3"" of type '" "std::string""'"); 
-    }
-    arg3 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[3], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "DHChain_fromModel" "', argument " "4"" of type '" "std::string""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  result = (bool)(arg1)->fromModel((iDynTree::Model const &)*arg2,arg3,arg4);
+  result = (bool)(arg1)->updateIndices((iDynTree::Model const &)*arg2);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_new_DHChain(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_ThreeAxisForceTorqueContactSensor_setLoadCellLocations(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+  std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::DHChain *result = 0 ;
   
-  if (!SWIG_check_num_args("new_DHChain",argc,0,0,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_setLoadCellLocations",argc,2,2,0)) {
     SWIG_fail;
   }
-  (void)argv;
-  result = (iDynTree::DHChain *)new iDynTree::DHChain();
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_iDynTree__DHChain, 1 |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_setLoadCellLocations" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_iDynTree__Position_std__allocatorT_iDynTree__Position_t_t,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_setLoadCellLocations" "', argument " "2"" of type '" "std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_setLoadCellLocations" "', argument " "2"" of type '" "std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > &""'"); 
+  }
+  arg2 = reinterpret_cast< std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > * >(argp2);
+  (arg1)->setLoadCellLocations(*arg2);
+  _out = (mxArray*)0;
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_delete_DHChain(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = (iDynTree::DHChain *) 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_getLoadCellLocations(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   mxArray * _out;
+  SwigValueWrapper< std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > > result;
   
-  int is_owned;
-  if (!SWIG_check_num_args("delete_DHChain",argc,1,1,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_getLoadCellLocations",argc,1,1,0)) {
     SWIG_fail;
   }
-  is_owned = SWIG_Matlab_isOwned(argv[0]);
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__DHChain, SWIG_POINTER_DISOWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DHChain" "', argument " "1"" of type '" "iDynTree::DHChain *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  if (is_owned) {
-    delete arg1;
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_getLoadCellLocations" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
   }
-  _out = (mxArray*)0;
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->getLoadCellLocations();
+  _out = SWIG_NewPointerObj((new std::vector< iDynTree::Position,std::allocator< iDynTree::Position > >(static_cast< const std::vector< iDynTree::Position,std::allocator< iDynTree::Position > >& >(result))), SWIGTYPE_p_std__vectorT_iDynTree__Position_std__allocatorT_iDynTree__Position_t_t, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_TransformFromDHCraig1989(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  double arg1 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+  iDynTree::VectorDynSize *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::Transform result;
+  iDynTree::Vector3 result;
   
-  if (!SWIG_check_num_args("TransformFromDHCraig1989",argc,4,4,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements",argc,2,2,0)) {
     SWIG_fail;
   }
-  ecode1 = SWIG_AsVal_double(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "TransformFromDHCraig1989" "', argument " "1"" of type '" "double""'");
-  } 
-  arg1 = static_cast< double >(val1);
-  ecode2 = SWIG_AsVal_double(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TransformFromDHCraig1989" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TransformFromDHCraig1989" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(argv[3], &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TransformFromDHCraig1989" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  result = iDynTree::TransformFromDHCraig1989(arg1,arg2,arg3,arg4);
-  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::VectorDynSize * >(argp2);
+  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->computeThreeAxisForceTorqueFromLoadCellMeasurements(*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::Vector3(static_cast< const iDynTree::Vector3& >(result))), SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_TransformFromDH(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  double arg1 ;
-  double arg2 ;
-  double arg3 ;
-  double arg4 ;
-  double val1 ;
-  int ecode1 = 0 ;
-  double val2 ;
-  int ecode2 = 0 ;
-  double val3 ;
-  int ecode3 = 0 ;
-  double val4 ;
-  int ecode4 = 0 ;
+int _wrap_ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+  iDynTree::ThreeAxisForceTorqueContactSensor *arg1 = (iDynTree::ThreeAxisForceTorqueContactSensor *) 0 ;
+  iDynTree::VectorDynSize *arg2 = 0 ;
+  void *argp1 = 0 ;
+  int res1 = 0 ;
+  void *argp2 = 0 ;
+  int res2 = 0 ;
   mxArray * _out;
-  iDynTree::Transform result;
+  iDynTree::Position result;
   
-  if (!SWIG_check_num_args("TransformFromDH",argc,4,4,0)) {
+  if (!SWIG_check_num_args("ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements",argc,2,2,0)) {
     SWIG_fail;
   }
-  ecode1 = SWIG_AsVal_double(argv[0], &val1);
-  if (!SWIG_IsOK(ecode1)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "TransformFromDH" "', argument " "1"" of type '" "double""'");
-  } 
-  arg1 = static_cast< double >(val1);
-  ecode2 = SWIG_AsVal_double(argv[1], &val2);
-  if (!SWIG_IsOK(ecode2)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TransformFromDH" "', argument " "2"" of type '" "double""'");
-  } 
-  arg2 = static_cast< double >(val2);
-  ecode3 = SWIG_AsVal_double(argv[2], &val3);
-  if (!SWIG_IsOK(ecode3)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TransformFromDH" "', argument " "3"" of type '" "double""'");
-  } 
-  arg3 = static_cast< double >(val3);
-  ecode4 = SWIG_AsVal_double(argv[3], &val4);
-  if (!SWIG_IsOK(ecode4)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TransformFromDH" "', argument " "4"" of type '" "double""'");
-  } 
-  arg4 = static_cast< double >(val4);
-  result = iDynTree::TransformFromDH(arg1,arg2,arg3,arg4);
-  _out = SWIG_NewPointerObj((new iDynTree::Transform(static_cast< const iDynTree::Transform& >(result))), SWIGTYPE_p_iDynTree__Transform, SWIG_POINTER_OWN |  0 );
+  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ThreeAxisForceTorqueContactSensor, 0 |  0 );
+  if (!SWIG_IsOK(res1)) {
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements" "', argument " "1"" of type '" "iDynTree::ThreeAxisForceTorqueContactSensor const *""'"); 
+  }
+  arg1 = reinterpret_cast< iDynTree::ThreeAxisForceTorqueContactSensor * >(argp1);
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+  }
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements" "', argument " "2"" of type '" "iDynTree::VectorDynSize &""'"); 
+  }
+  arg2 = reinterpret_cast< iDynTree::VectorDynSize * >(argp2);
+  result = ((iDynTree::ThreeAxisForceTorqueContactSensor const *)arg1)->computeCenterOfPressureFromLoadCellMeasurements(*arg2);
+  _out = SWIG_NewPointerObj((new iDynTree::Position(static_cast< const iDynTree::Position& >(result))), SWIGTYPE_p_iDynTree__Position, SWIG_POINTER_OWN |  0 );
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ExtractDHChainFromModel__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_predictSensorsMeasurements(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Model *arg1 = 0 ;
-  std::string arg2 ;
-  std::string arg3 ;
-  iDynTree::DHChain *arg4 = 0 ;
-  double arg5 ;
+  iDynTree::SensorsList *arg2 = 0 ;
+  iDynTree::Traversal *arg3 = 0 ;
+  iDynTree::FreeFloatingPos *arg4 = 0 ;
+  iDynTree::FreeFloatingVel *arg5 = 0 ;
+  iDynTree::FreeFloatingAcc *arg6 = 0 ;
+  iDynTree::LinAcceleration *arg7 = 0 ;
+  iDynTree::LinkNetExternalWrenches *arg8 = 0 ;
+  iDynTree::FreeFloatingAcc *arg9 = 0 ;
+  iDynTree::LinkPositions *arg10 = 0 ;
+  iDynTree::LinkVelArray *arg11 = 0 ;
+  iDynTree::LinkAccArray *arg12 = 0 ;
+  iDynTree::LinkInternalWrenches *arg13 = 0 ;
+  iDynTree::FreeFloatingGeneralizedTorques *arg14 = 0 ;
+  iDynTree::SensorsMeasurements *arg15 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
-  void *argp4 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
   int res4 = 0 ;
-  double val5 ;
-  int ecode5 = 0 ;
+  void *argp5 ;
+  int res5 = 0 ;
+  void *argp6 ;
+  int res6 = 0 ;
+  void *argp7 ;
+  int res7 = 0 ;
+  void *argp8 ;
+  int res8 = 0 ;
+  void *argp9 = 0 ;
+  int res9 = 0 ;
+  void *argp10 = 0 ;
+  int res10 = 0 ;
+  void *argp11 = 0 ;
+  int res11 = 0 ;
+  void *argp12 = 0 ;
+  int res12 = 0 ;
+  void *argp13 = 0 ;
+  int res13 = 0 ;
+  void *argp14 = 0 ;
+  int res14 = 0 ;
+  void *argp15 = 0 ;
+  int res15 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ExtractDHChainFromModel",argc,5,5,0)) {
+  if (!SWIG_check_num_args("predictSensorsMeasurements",argc,15,15,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtractDHChainFromModel" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "predictSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtractDHChainFromModel" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ExtractDHChainFromModel" "', argument " "2"" of type '" "std::string const""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SensorsList,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "predictSensorsMeasurements" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
   }
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ExtractDHChainFromModel" "', argument " "3"" of type '" "std::string const""'"); 
-    }
-    arg3 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
   }
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__DHChain,  0 );
+  arg2 = reinterpret_cast< iDynTree::SensorsList * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "predictSensorsMeasurements" "', argument " "3"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "3"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::Traversal * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__FreeFloatingPos,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtractDHChainFromModel" "', argument " "4"" of type '" "iDynTree::DHChain &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "predictSensorsMeasurements" "', argument " "4"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtractDHChainFromModel" "', argument " "4"" of type '" "iDynTree::DHChain &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "4"" of type '" "iDynTree::FreeFloatingPos const &""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::DHChain * >(argp4);
-  ecode5 = SWIG_AsVal_double(argv[4], &val5);
-  if (!SWIG_IsOK(ecode5)) {
-    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "ExtractDHChainFromModel" "', argument " "5"" of type '" "double""'");
-  } 
-  arg5 = static_cast< double >(val5);
-  result = (bool)iDynTree::ExtractDHChainFromModel((iDynTree::Model const &)*arg1,arg2,arg3,*arg4,arg5);
+  arg4 = reinterpret_cast< iDynTree::FreeFloatingPos * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__FreeFloatingVel,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "predictSensorsMeasurements" "', argument " "5"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "5"" of type '" "iDynTree::FreeFloatingVel const &""'"); 
+  }
+  arg5 = reinterpret_cast< iDynTree::FreeFloatingVel * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "predictSensorsMeasurements" "', argument " "6"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  }
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "6"" of type '" "iDynTree::FreeFloatingAcc const &""'"); 
+  }
+  arg6 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp6);
+  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__GeomVector3,  0 );
+  if (!SWIG_IsOK(res7)) {
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "predictSensorsMeasurements" "', argument " "7"" of type '" "iDynTree::LinAcceleration const &""'"); 
+  }
+  if (!argp7) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "7"" of type '" "iDynTree::LinAcceleration const &""'"); 
+  }
+  arg7 = reinterpret_cast< iDynTree::LinAcceleration * >(argp7);
+  res8 = SWIG_ConvertPtr(argv[7], &argp8, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
+  if (!SWIG_IsOK(res8)) {
+    SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "predictSensorsMeasurements" "', argument " "8"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
+  }
+  if (!argp8) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "8"" of type '" "iDynTree::LinkNetExternalWrenches const &""'"); 
+  }
+  arg8 = reinterpret_cast< iDynTree::LinkNetExternalWrenches * >(argp8);
+  res9 = SWIG_ConvertPtr(argv[8], &argp9, SWIGTYPE_p_iDynTree__FreeFloatingAcc,  0 );
+  if (!SWIG_IsOK(res9)) {
+    SWIG_exception_fail(SWIG_ArgError(res9), "in method '" "predictSensorsMeasurements" "', argument " "9"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
+  }
+  if (!argp9) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "9"" of type '" "iDynTree::FreeFloatingAcc &""'"); 
+  }
+  arg9 = reinterpret_cast< iDynTree::FreeFloatingAcc * >(argp9);
+  res10 = SWIG_ConvertPtr(argv[9], &argp10, SWIGTYPE_p_iDynTree__LinkPositions,  0 );
+  if (!SWIG_IsOK(res10)) {
+    SWIG_exception_fail(SWIG_ArgError(res10), "in method '" "predictSensorsMeasurements" "', argument " "10"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  if (!argp10) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "10"" of type '" "iDynTree::LinkPositions &""'"); 
+  }
+  arg10 = reinterpret_cast< iDynTree::LinkPositions * >(argp10);
+  res11 = SWIG_ConvertPtr(argv[10], &argp11, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
+  if (!SWIG_IsOK(res11)) {
+    SWIG_exception_fail(SWIG_ArgError(res11), "in method '" "predictSensorsMeasurements" "', argument " "11"" of type '" "iDynTree::LinkVelArray &""'"); 
+  }
+  if (!argp11) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "11"" of type '" "iDynTree::LinkVelArray &""'"); 
+  }
+  arg11 = reinterpret_cast< iDynTree::LinkVelArray * >(argp11);
+  res12 = SWIG_ConvertPtr(argv[11], &argp12, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res12)) {
+    SWIG_exception_fail(SWIG_ArgError(res12), "in method '" "predictSensorsMeasurements" "', argument " "12"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  if (!argp12) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "12"" of type '" "iDynTree::LinkAccArray &""'"); 
+  }
+  arg12 = reinterpret_cast< iDynTree::LinkAccArray * >(argp12);
+  res13 = SWIG_ConvertPtr(argv[12], &argp13, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
+  if (!SWIG_IsOK(res13)) {
+    SWIG_exception_fail(SWIG_ArgError(res13), "in method '" "predictSensorsMeasurements" "', argument " "13"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
+  }
+  if (!argp13) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "13"" of type '" "iDynTree::LinkInternalWrenches &""'"); 
+  }
+  arg13 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp13);
+  res14 = SWIG_ConvertPtr(argv[13], &argp14, SWIGTYPE_p_iDynTree__FreeFloatingGeneralizedTorques,  0 );
+  if (!SWIG_IsOK(res14)) {
+    SWIG_exception_fail(SWIG_ArgError(res14), "in method '" "predictSensorsMeasurements" "', argument " "14"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
+  }
+  if (!argp14) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "14"" of type '" "iDynTree::FreeFloatingGeneralizedTorques &""'"); 
+  }
+  arg14 = reinterpret_cast< iDynTree::FreeFloatingGeneralizedTorques * >(argp14);
+  res15 = SWIG_ConvertPtr(argv[14], &argp15, SWIGTYPE_p_iDynTree__SensorsMeasurements,  0 );
+  if (!SWIG_IsOK(res15)) {
+    SWIG_exception_fail(SWIG_ArgError(res15), "in method '" "predictSensorsMeasurements" "', argument " "15"" of type '" "iDynTree::SensorsMeasurements &""'"); 
+  }
+  if (!argp15) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurements" "', argument " "15"" of type '" "iDynTree::SensorsMeasurements &""'"); 
+  }
+  arg15 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp15);
+  result = (bool)iDynTree::predictSensorsMeasurements((iDynTree::Model const &)*arg1,(iDynTree::SensorsList const &)*arg2,(iDynTree::Traversal const &)*arg3,(iDynTree::FreeFloatingPos const &)*arg4,(iDynTree::FreeFloatingVel const &)*arg5,(iDynTree::FreeFloatingAcc const &)*arg6,(iDynTree::GeomVector3 const &)*arg7,(iDynTree::LinkWrenches const &)*arg8,*arg9,*arg10,*arg11,*arg12,*arg13,*arg14,*arg15);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ExtractDHChainFromModel__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_predictSensorsMeasurementsFromRawBuffers(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::Model *arg1 = 0 ;
-  std::string arg2 ;
-  std::string arg3 ;
-  iDynTree::DHChain *arg4 = 0 ;
+  iDynTree::SensorsList *arg2 = 0 ;
+  iDynTree::Traversal *arg3 = 0 ;
+  iDynTree::LinkVelArray *arg4 = 0 ;
+  iDynTree::LinkAccArray *arg5 = 0 ;
+  iDynTree::LinkInternalWrenches *arg6 = 0 ;
+  iDynTree::SensorsMeasurements *arg7 = 0 ;
   void *argp1 ;
   int res1 = 0 ;
-  void *argp4 = 0 ;
+  void *argp2 ;
+  int res2 = 0 ;
+  void *argp3 ;
+  int res3 = 0 ;
+  void *argp4 ;
   int res4 = 0 ;
+  void *argp5 ;
+  int res5 = 0 ;
+  void *argp6 ;
+  int res6 = 0 ;
+  void *argp7 = 0 ;
+  int res7 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ExtractDHChainFromModel",argc,4,4,0)) {
+  if (!SWIG_check_num_args("predictSensorsMeasurementsFromRawBuffers",argc,7,7,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__Model,  0 );
   if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtractDHChainFromModel" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtractDHChainFromModel" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "1"" of type '" "iDynTree::Model const &""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::Model * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ExtractDHChainFromModel" "', argument " "2"" of type '" "std::string const""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__SensorsList,  0 );
+  if (!SWIG_IsOK(res2)) {
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
   }
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ExtractDHChainFromModel" "', argument " "3"" of type '" "std::string const""'"); 
-    }
-    arg3 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
+  if (!argp2) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "2"" of type '" "iDynTree::SensorsList const &""'"); 
   }
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__DHChain,  0 );
+  arg2 = reinterpret_cast< iDynTree::SensorsList * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__Traversal,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "3"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "3"" of type '" "iDynTree::Traversal const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::Traversal * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__LinkVelArray,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtractDHChainFromModel" "', argument " "4"" of type '" "iDynTree::DHChain &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtractDHChainFromModel" "', argument " "4"" of type '" "iDynTree::DHChain &""'"); 
-  }
-  arg4 = reinterpret_cast< iDynTree::DHChain * >(argp4);
-  result = (bool)iDynTree::ExtractDHChainFromModel((iDynTree::Model const &)*arg1,arg2,arg3,*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_ExtractDHChainFromModel(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__DHChain, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_ExtractDHChainFromModel__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "4"" of type '" "iDynTree::LinkVelArray const &""'"); 
   }
-  if (argc == 5) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          void *vptr = 0;
-          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__DHChain, 0);
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            {
-              int res = SWIG_AsVal_double(argv[4], NULL);
-              _v = SWIG_CheckState(res);
-            }
-            if (_v) {
-              return _wrap_ExtractDHChainFromModel__SWIG_0(resc,resv,argc,argv);
-            }
-          }
-        }
-      }
-    }
+  arg4 = reinterpret_cast< iDynTree::LinkVelArray * >(argp4);
+  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_iDynTree__LinkAccArray,  0 );
+  if (!SWIG_IsOK(res5)) {
+    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
   }
-  
-  SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ExtractDHChainFromModel'."
-    "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ExtractDHChainFromModel(iDynTree::Model const &,std::string const,std::string const,iDynTree::DHChain &,double)\n"
-    "    iDynTree::ExtractDHChainFromModel(iDynTree::Model const &,std::string const,std::string const,iDynTree::DHChain &)\n");
-  return 1;
-}
-
-
-int _wrap_CreateModelFromDHChain(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::DHChain *arg1 = 0 ;
-  iDynTree::Model *arg2 = 0 ;
-  void *argp1 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("CreateModelFromDHChain",argc,2,2,0)) {
-    SWIG_fail;
+  if (!argp5) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "5"" of type '" "iDynTree::LinkAccArray const &""'"); 
   }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_iDynTree__DHChain,  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CreateModelFromDHChain" "', argument " "1"" of type '" "iDynTree::DHChain const &""'"); 
+  arg5 = reinterpret_cast< iDynTree::LinkAccArray * >(argp5);
+  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__LinkWrenches,  0 );
+  if (!SWIG_IsOK(res6)) {
+    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "6"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
   }
-  if (!argp1) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CreateModelFromDHChain" "', argument " "1"" of type '" "iDynTree::DHChain const &""'"); 
+  if (!argp6) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "6"" of type '" "iDynTree::LinkInternalWrenches const &""'"); 
   }
-  arg1 = reinterpret_cast< iDynTree::DHChain * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CreateModelFromDHChain" "', argument " "2"" of type '" "iDynTree::Model &""'"); 
+  arg6 = reinterpret_cast< iDynTree::LinkInternalWrenches * >(argp6);
+  res7 = SWIG_ConvertPtr(argv[6], &argp7, SWIGTYPE_p_iDynTree__SensorsMeasurements,  0 );
+  if (!SWIG_IsOK(res7)) {
+    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "7"" of type '" "iDynTree::SensorsMeasurements &""'"); 
   }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CreateModelFromDHChain" "', argument " "2"" of type '" "iDynTree::Model &""'"); 
+  if (!argp7) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "predictSensorsMeasurementsFromRawBuffers" "', argument " "7"" of type '" "iDynTree::SensorsMeasurements &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)iDynTree::CreateModelFromDHChain((iDynTree::DHChain const &)*arg1,*arg2);
+  arg7 = reinterpret_cast< iDynTree::SensorsMeasurements * >(argp7);
+  result = (bool)iDynTree::predictSensorsMeasurementsFromRawBuffers((iDynTree::Model const &)*arg1,(iDynTree::SensorsList const &)*arg2,(iDynTree::Traversal const &)*arg3,(iDynTree::LinkVelArray const &)*arg4,(iDynTree::LinkAccArray const &)*arg5,(iDynTree::LinkWrenches const &)*arg6,*arg7);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
@@ -74617,83 +70992,14 @@
 }
 
 
 int _wrap_ModelLoader_loadModelFromString__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
   std::string *arg2 = 0 ;
   std::string *arg3 = 0 ;
-  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
-  int res3 = SWIG_OLDOBJ ;
-  int res4 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("ModelLoader_loadModelFromString",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelLoader, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelLoader_loadModelFromString" "', argument " "1"" of type '" "iDynTree::ModelLoader *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ModelLoader * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelLoader_loadModelFromString" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadModelFromString" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
-  }
-  {
-    std::string *ptr = (std::string *)0;
-    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ModelLoader_loadModelFromString" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadModelFromString" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res4 = swig::asptr(argv[3], &ptr);
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ModelLoader_loadModelFromString" "', argument " "4"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadModelFromString" "', argument " "4"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg4 = ptr;
-  }
-  result = (bool)(arg1)->loadModelFromString((std::string const &)*arg2,(std::string const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return 1;
-}
-
-
-int _wrap_ModelLoader_loadModelFromString__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
-  std::string *arg2 = 0 ;
-  std::string *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 = SWIG_OLDOBJ ;
   int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
   bool result;
   
@@ -74736,15 +71042,15 @@
 fail:
   if (SWIG_IsNewObj(res2)) delete arg2;
   if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_ModelLoader_loadModelFromString__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_ModelLoader_loadModelFromString__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
   std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
   bool result;
@@ -74785,15 +71091,15 @@
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelLoader, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
       int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
       _v = SWIG_CheckState(res);
       if (_v) {
-        return _wrap_ModelLoader_loadModelFromString__SWIG_2(resc,resv,argc,argv);
+        return _wrap_ModelLoader_loadModelFromString__SWIG_1(resc,resv,argc,argv);
       }
     }
   }
   if (argc == 3) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelLoader, 0);
@@ -74801,123 +71107,32 @@
     if (_v) {
       int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
       _v = SWIG_CheckState(res);
       if (_v) {
         int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
-          return _wrap_ModelLoader_loadModelFromString__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelLoader, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector< std::string,std::allocator< std::string > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_ModelLoader_loadModelFromString__SWIG_0(resc,resv,argc,argv);
-          }
+          return _wrap_ModelLoader_loadModelFromString__SWIG_0(resc,resv,argc,argv);
         }
       }
     }
   }
   
   SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ModelLoader_loadModelFromString'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ModelLoader::loadModelFromString(std::string const &,std::string const &,std::vector< std::string,std::allocator< std::string > > const &)\n"
     "    iDynTree::ModelLoader::loadModelFromString(std::string const &,std::string const &)\n"
     "    iDynTree::ModelLoader::loadModelFromString(std::string const &)\n");
   return 1;
 }
 
 
 int _wrap_ModelLoader_loadModelFromFile__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
   std::string *arg2 = 0 ;
   std::string *arg3 = 0 ;
-  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res2 = SWIG_OLDOBJ ;
-  int res3 = SWIG_OLDOBJ ;
-  int res4 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("ModelLoader_loadModelFromFile",argc,4,4,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelLoader, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelLoader_loadModelFromFile" "', argument " "1"" of type '" "iDynTree::ModelLoader *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ModelLoader * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    res2 = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res2)) {
-      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelLoader_loadModelFromFile" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadModelFromFile" "', argument " "2"" of type '" "std::string const &""'"); 
-    }
-    arg2 = ptr;
-  }
-  {
-    std::string *ptr = (std::string *)0;
-    res3 = SWIG_AsPtr_std_string(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ModelLoader_loadModelFromFile" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadModelFromFile" "', argument " "3"" of type '" "std::string const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res4 = swig::asptr(argv[3], &ptr);
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ModelLoader_loadModelFromFile" "', argument " "4"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadModelFromFile" "', argument " "4"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg4 = ptr;
-  }
-  result = (bool)(arg1)->loadModelFromFile((std::string const &)*arg2,(std::string const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res2)) delete arg2;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  if (SWIG_IsNewObj(res4)) delete arg4;
-  return 1;
-}
-
-
-int _wrap_ModelLoader_loadModelFromFile__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
-  std::string *arg2 = 0 ;
-  std::string *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 = SWIG_OLDOBJ ;
   int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
   bool result;
   
@@ -74960,15 +71175,15 @@
 fail:
   if (SWIG_IsNewObj(res2)) delete arg2;
   if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_ModelLoader_loadModelFromFile__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_ModelLoader_loadModelFromFile__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
   std::string *arg2 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res2 = SWIG_OLDOBJ ;
   mxArray * _out;
   bool result;
@@ -75009,15 +71224,15 @@
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelLoader, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
       int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
       _v = SWIG_CheckState(res);
       if (_v) {
-        return _wrap_ModelLoader_loadModelFromFile__SWIG_2(resc,resv,argc,argv);
+        return _wrap_ModelLoader_loadModelFromFile__SWIG_1(resc,resv,argc,argv);
       }
     }
   }
   if (argc == 3) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelLoader, 0);
@@ -75025,44 +71240,22 @@
     if (_v) {
       int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
       _v = SWIG_CheckState(res);
       if (_v) {
         int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
-          return _wrap_ModelLoader_loadModelFromFile__SWIG_1(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
-  if (argc == 4) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelLoader, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          int res = swig::asptr(argv[3], (std::vector< std::string,std::allocator< std::string > >**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            return _wrap_ModelLoader_loadModelFromFile__SWIG_0(resc,resv,argc,argv);
-          }
+          return _wrap_ModelLoader_loadModelFromFile__SWIG_0(resc,resv,argc,argv);
         }
       }
     }
   }
   
   SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ModelLoader_loadModelFromFile'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ModelLoader::loadModelFromFile(std::string const &,std::string const &,std::vector< std::string,std::allocator< std::string > > const &)\n"
     "    iDynTree::ModelLoader::loadModelFromFile(std::string const &,std::string const &)\n"
     "    iDynTree::ModelLoader::loadModelFromFile(std::string const &)\n");
   return 1;
 }
 
 
 int _wrap_ModelLoader_loadReducedModelFromFullModel__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
@@ -75226,88 +71419,14 @@
 
 
 int _wrap_ModelLoader_loadReducedModelFromString__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
   std::string arg2 ;
   std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
   std::string arg4 ;
-  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res3 = SWIG_OLDOBJ ;
-  int res5 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("ModelLoader_loadReducedModelFromString",argc,5,5,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelLoader, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelLoader_loadReducedModelFromString" "', argument " "1"" of type '" "iDynTree::ModelLoader *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ModelLoader * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelLoader_loadReducedModelFromString" "', argument " "2"" of type '" "std::string const""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res3 = swig::asptr(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ModelLoader_loadReducedModelFromString" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadReducedModelFromString" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[3], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelLoader_loadReducedModelFromString" "', argument " "4"" of type '" "std::string const""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res5 = swig::asptr(argv[4], &ptr);
-    if (!SWIG_IsOK(res5)) {
-      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ModelLoader_loadReducedModelFromString" "', argument " "5"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadReducedModelFromString" "', argument " "5"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg5 = ptr;
-  }
-  result = (bool)(arg1)->loadReducedModelFromString(arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  if (SWIG_IsNewObj(res5)) delete arg5;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  if (SWIG_IsNewObj(res5)) delete arg5;
-  return 1;
-}
-
-
-int _wrap_ModelLoader_loadReducedModelFromString__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
-  std::string arg2 ;
-  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
-  std::string arg4 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
   bool result;
   
   if (!SWIG_check_num_args("ModelLoader_loadReducedModelFromString",argc,4,4,0)) {
@@ -75354,15 +71473,15 @@
   return 0;
 fail:
   if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_ModelLoader_loadReducedModelFromString__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_ModelLoader_loadReducedModelFromString__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
   std::string arg2 ;
   std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
@@ -75416,15 +71535,15 @@
     if (_v) {
       int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
       _v = SWIG_CheckState(res);
       if (_v) {
         int res = swig::asptr(argv[2], (std::vector< std::string,std::allocator< std::string > >**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
-          return _wrap_ModelLoader_loadReducedModelFromString__SWIG_2(resc,resv,argc,argv);
+          return _wrap_ModelLoader_loadReducedModelFromString__SWIG_1(resc,resv,argc,argv);
         }
       }
     }
   }
   if (argc == 4) {
     int _v;
     void *vptr = 0;
@@ -75436,134 +71555,34 @@
       if (_v) {
         int res = swig::asptr(argv[2], (std::vector< std::string,std::allocator< std::string > >**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
           int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
           _v = SWIG_CheckState(res);
           if (_v) {
-            return _wrap_ModelLoader_loadReducedModelFromString__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  if (argc == 5) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelLoader, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector< std::string,std::allocator< std::string > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            int res = swig::asptr(argv[4], (std::vector< std::string,std::allocator< std::string > >**)(0));
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              return _wrap_ModelLoader_loadReducedModelFromString__SWIG_0(resc,resv,argc,argv);
-            }
+            return _wrap_ModelLoader_loadReducedModelFromString__SWIG_0(resc,resv,argc,argv);
           }
         }
       }
     }
   }
   
   SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ModelLoader_loadReducedModelFromString'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ModelLoader::loadReducedModelFromString(std::string const,std::vector< std::string,std::allocator< std::string > > const &,std::string const,std::vector< std::string,std::allocator< std::string > > const &)\n"
     "    iDynTree::ModelLoader::loadReducedModelFromString(std::string const,std::vector< std::string,std::allocator< std::string > > const &,std::string const)\n"
     "    iDynTree::ModelLoader::loadReducedModelFromString(std::string const,std::vector< std::string,std::allocator< std::string > > const &)\n");
   return 1;
 }
 
 
 int _wrap_ModelLoader_loadReducedModelFromFile__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
   std::string arg2 ;
   std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
   std::string arg4 ;
-  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  int res3 = SWIG_OLDOBJ ;
-  int res5 = SWIG_OLDOBJ ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("ModelLoader_loadReducedModelFromFile",argc,5,5,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelLoader, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelLoader_loadReducedModelFromFile" "', argument " "1"" of type '" "iDynTree::ModelLoader *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ModelLoader * >(argp1);
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[1], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelLoader_loadReducedModelFromFile" "', argument " "2"" of type '" "std::string const""'"); 
-    }
-    arg2 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res3 = swig::asptr(argv[2], &ptr);
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ModelLoader_loadReducedModelFromFile" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadReducedModelFromFile" "', argument " "3"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg3 = ptr;
-  }
-  {
-    std::string *ptr = (std::string *)0;
-    int res = SWIG_AsPtr_std_string(argv[3], &ptr);
-    if (!SWIG_IsOK(res) || !ptr) {
-      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ModelLoader_loadReducedModelFromFile" "', argument " "4"" of type '" "std::string const""'"); 
-    }
-    arg4 = *ptr;
-    if (SWIG_IsNewObj(res)) delete ptr;
-  }
-  {
-    std::vector< std::string,std::allocator< std::string > > *ptr = (std::vector< std::string,std::allocator< std::string > > *)0;
-    res5 = swig::asptr(argv[4], &ptr);
-    if (!SWIG_IsOK(res5)) {
-      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ModelLoader_loadReducedModelFromFile" "', argument " "5"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    if (!ptr) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelLoader_loadReducedModelFromFile" "', argument " "5"" of type '" "std::vector< std::string,std::allocator< std::string > > const &""'"); 
-    }
-    arg5 = ptr;
-  }
-  result = (bool)(arg1)->loadReducedModelFromFile(arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  if (SWIG_IsNewObj(res5)) delete arg5;
-  return 0;
-fail:
-  if (SWIG_IsNewObj(res3)) delete arg3;
-  if (SWIG_IsNewObj(res5)) delete arg5;
-  return 1;
-}
-
-
-int _wrap_ModelLoader_loadReducedModelFromFile__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
-  std::string arg2 ;
-  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
-  std::string arg4 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
   bool result;
   
   if (!SWIG_check_num_args("ModelLoader_loadReducedModelFromFile",argc,4,4,0)) {
@@ -75610,15 +71629,15 @@
   return 0;
 fail:
   if (SWIG_IsNewObj(res3)) delete arg3;
   return 1;
 }
 
 
-int _wrap_ModelLoader_loadReducedModelFromFile__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_ModelLoader_loadReducedModelFromFile__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelLoader *arg1 = (iDynTree::ModelLoader *) 0 ;
   std::string arg2 ;
   std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   int res3 = SWIG_OLDOBJ ;
   mxArray * _out;
@@ -75672,15 +71691,15 @@
     if (_v) {
       int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
       _v = SWIG_CheckState(res);
       if (_v) {
         int res = swig::asptr(argv[2], (std::vector< std::string,std::allocator< std::string > >**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
-          return _wrap_ModelLoader_loadReducedModelFromFile__SWIG_2(resc,resv,argc,argv);
+          return _wrap_ModelLoader_loadReducedModelFromFile__SWIG_1(resc,resv,argc,argv);
         }
       }
     }
   }
   if (argc == 4) {
     int _v;
     void *vptr = 0;
@@ -75692,49 +71711,23 @@
       if (_v) {
         int res = swig::asptr(argv[2], (std::vector< std::string,std::allocator< std::string > >**)(0));
         _v = SWIG_CheckState(res);
         if (_v) {
           int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
           _v = SWIG_CheckState(res);
           if (_v) {
-            return _wrap_ModelLoader_loadReducedModelFromFile__SWIG_1(resc,resv,argc,argv);
-          }
-        }
-      }
-    }
-  }
-  if (argc == 5) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelLoader, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0));
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        int res = swig::asptr(argv[2], (std::vector< std::string,std::allocator< std::string > >**)(0));
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          int res = SWIG_AsPtr_std_string(argv[3], (std::string**)(0));
-          _v = SWIG_CheckState(res);
-          if (_v) {
-            int res = swig::asptr(argv[4], (std::vector< std::string,std::allocator< std::string > >**)(0));
-            _v = SWIG_CheckState(res);
-            if (_v) {
-              return _wrap_ModelLoader_loadReducedModelFromFile__SWIG_0(resc,resv,argc,argv);
-            }
+            return _wrap_ModelLoader_loadReducedModelFromFile__SWIG_0(resc,resv,argc,argv);
           }
         }
       }
     }
   }
   
   SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ModelLoader_loadReducedModelFromFile'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ModelLoader::loadReducedModelFromFile(std::string const,std::vector< std::string,std::allocator< std::string > > const &,std::string const,std::vector< std::string,std::allocator< std::string > > const &)\n"
     "    iDynTree::ModelLoader::loadReducedModelFromFile(std::string const,std::vector< std::string,std::allocator< std::string > > const &,std::string const)\n"
     "    iDynTree::ModelLoader::loadReducedModelFromFile(std::string const,std::vector< std::string,std::allocator< std::string > > const &)\n");
   return 1;
 }
 
 
 int _wrap_ModelLoader_model(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
@@ -75984,69 +71977,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ModelExporterOptions_xmlBlobs_set(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ModelExporterOptions *arg1 = (iDynTree::ModelExporterOptions *) 0 ;
-  std::vector< std::string,std::allocator< std::string > > *arg2 = (std::vector< std::string,std::allocator< std::string > > *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 = 0 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  
-  if (!SWIG_check_num_args("ModelExporterOptions_xmlBlobs_set",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelExporterOptions, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelExporterOptions_xmlBlobs_set" "', argument " "1"" of type '" "iDynTree::ModelExporterOptions *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ModelExporterOptions * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelExporterOptions_xmlBlobs_set" "', argument " "2"" of type '" "std::vector< std::string,std::allocator< std::string > > *""'"); 
-  }
-  arg2 = reinterpret_cast< std::vector< std::string,std::allocator< std::string > > * >(argp2);
-  if (arg1) (arg1)->xmlBlobs = *arg2;
-  _out = (mxArray*)0;
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_ModelExporterOptions_xmlBlobs_get(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ModelExporterOptions *arg1 = (iDynTree::ModelExporterOptions *) 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  mxArray * _out;
-  std::vector< std::string,std::allocator< std::string > > *result = 0 ;
-  
-  if (!SWIG_check_num_args("ModelExporterOptions_xmlBlobs_get",argc,1,1,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelExporterOptions, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelExporterOptions_xmlBlobs_get" "', argument " "1"" of type '" "iDynTree::ModelExporterOptions *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ModelExporterOptions * >(argp1);
-  result = (std::vector< std::string,std::allocator< std::string > > *)& ((arg1)->xmlBlobs);
-  _out = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_new_ModelExporterOptions(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   mxArray * _out;
   iDynTree::ModelExporterOptions *result = 0 ;
   
   if (!SWIG_check_num_args("new_ModelExporterOptions",argc,0,0,0)) {
     SWIG_fail;
   }
@@ -76188,25 +72126,28 @@
   return 1;
 }
 
 
 int _wrap_ModelExporter_init__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelExporter *arg1 = (iDynTree::ModelExporter *) 0 ;
   iDynTree::Model *arg2 = 0 ;
-  iDynTree::ModelExporterOptions arg3 ;
+  iDynTree::SensorsList *arg3 = 0 ;
+  iDynTree::ModelExporterOptions arg4 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   void *argp3 ;
   int res3 = 0 ;
+  void *argp4 ;
+  int res4 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ModelExporter_init",argc,3,3,0)) {
+  if (!SWIG_check_num_args("ModelExporter_init",argc,4,4,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelExporter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelExporter_init" "', argument " "1"" of type '" "iDynTree::ModelExporter *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::ModelExporter * >(argp1);
@@ -76214,86 +72155,56 @@
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelExporter_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__SensorsList,  0 );
+  if (!SWIG_IsOK(res3)) {
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ModelExporter_init" "', argument " "3"" of type '" "iDynTree::SensorsList const &""'"); 
+  }
+  if (!argp3) {
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "3"" of type '" "iDynTree::SensorsList const &""'"); 
+  }
+  arg3 = reinterpret_cast< iDynTree::SensorsList * >(argp3);
   {
-    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__ModelExporterOptions,  0 );
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ModelExporter_init" "', argument " "3"" of type '" "iDynTree::ModelExporterOptions const""'"); 
+    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__ModelExporterOptions,  0 );
+    if (!SWIG_IsOK(res4)) {
+      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ModelExporter_init" "', argument " "4"" of type '" "iDynTree::ModelExporterOptions const""'"); 
     }  
-    if (!argp3) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "3"" of type '" "iDynTree::ModelExporterOptions const""'");
+    if (!argp4) {
+      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "4"" of type '" "iDynTree::ModelExporterOptions const""'");
     } else {
-      arg3 = *(reinterpret_cast< iDynTree::ModelExporterOptions * >(argp3));
+      arg4 = *(reinterpret_cast< iDynTree::ModelExporterOptions * >(argp4));
     }
   }
-  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2,arg3);
+  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2,(iDynTree::SensorsList const &)*arg3,arg4);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
 int _wrap_ModelExporter_init__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelExporter *arg1 = (iDynTree::ModelExporter *) 0 ;
   iDynTree::Model *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("ModelExporter_init",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelExporter, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelExporter_init" "', argument " "1"" of type '" "iDynTree::ModelExporter *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ModelExporter * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelExporter_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_ModelExporter_init__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ModelExporter *arg1 = (iDynTree::ModelExporter *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
   iDynTree::SensorsList *arg3 = 0 ;
-  iDynTree::ModelExporterOptions arg4 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   void *argp3 ;
   int res3 = 0 ;
-  void *argp4 ;
-  int res4 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ModelExporter_init",argc,4,4,0)) {
+  if (!SWIG_check_num_args("ModelExporter_init",argc,3,3,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelExporter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelExporter_init" "', argument " "1"" of type '" "iDynTree::ModelExporter *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::ModelExporter * >(argp1);
@@ -76309,48 +72220,34 @@
   if (!SWIG_IsOK(res3)) {
     SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ModelExporter_init" "', argument " "3"" of type '" "iDynTree::SensorsList const &""'"); 
   }
   if (!argp3) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "3"" of type '" "iDynTree::SensorsList const &""'"); 
   }
   arg3 = reinterpret_cast< iDynTree::SensorsList * >(argp3);
-  {
-    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__ModelExporterOptions,  0 );
-    if (!SWIG_IsOK(res4)) {
-      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ModelExporter_init" "', argument " "4"" of type '" "iDynTree::ModelExporterOptions const""'"); 
-    }  
-    if (!argp4) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "4"" of type '" "iDynTree::ModelExporterOptions const""'");
-    } else {
-      arg4 = *(reinterpret_cast< iDynTree::ModelExporterOptions * >(argp4));
-    }
-  }
-  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2,(iDynTree::SensorsList const &)*arg3,arg4);
+  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2,(iDynTree::SensorsList const &)*arg3);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ModelExporter_init__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_ModelExporter_init__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelExporter *arg1 = (iDynTree::ModelExporter *) 0 ;
   iDynTree::Model *arg2 = 0 ;
-  iDynTree::SensorsList *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
   mxArray * _out;
   bool result;
   
-  if (!SWIG_check_num_args("ModelExporter_init",argc,3,3,0)) {
+  if (!SWIG_check_num_args("ModelExporter_init",argc,2,2,0)) {
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ModelExporter, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelExporter_init" "', argument " "1"" of type '" "iDynTree::ModelExporter *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::ModelExporter * >(argp1);
@@ -76358,23 +72255,15 @@
   if (!SWIG_IsOK(res2)) {
     SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelExporter_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   if (!argp2) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
   }
   arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__SensorsList,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ModelExporter_init" "', argument " "3"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelExporter_init" "', argument " "3"" of type '" "iDynTree::SensorsList const &""'"); 
-  }
-  arg3 = reinterpret_cast< iDynTree::SensorsList * >(argp3);
-  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2,(iDynTree::SensorsList const &)*arg3);
+  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
@@ -76386,34 +72275,15 @@
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelExporter, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
       void *vptr = 0;
       int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
       _v = SWIG_CheckState(res);
       if (_v) {
-        return _wrap_ModelExporter_init__SWIG_1(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelExporter, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__ModelExporterOptions, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_ModelExporter_init__SWIG_0(resc,resv,argc,argv);
-        }
+        return _wrap_ModelExporter_init__SWIG_2(resc,resv,argc,argv);
       }
     }
   }
   if (argc == 3) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__ModelExporter, 0);
@@ -76423,15 +72293,15 @@
       int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
       _v = SWIG_CheckState(res);
       if (_v) {
         void *vptr = 0;
         int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
         _v = SWIG_CheckState(res);
         if (_v) {
-          return _wrap_ModelExporter_init__SWIG_3(resc,resv,argc,argv);
+          return _wrap_ModelExporter_init__SWIG_1(resc,resv,argc,argv);
         }
       }
     }
   }
   if (argc == 4) {
     int _v;
     void *vptr = 0;
@@ -76446,27 +72316,26 @@
         int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
         _v = SWIG_CheckState(res);
         if (_v) {
           void *vptr = 0;
           int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__ModelExporterOptions, 0);
           _v = SWIG_CheckState(res);
           if (_v) {
-            return _wrap_ModelExporter_init__SWIG_2(resc,resv,argc,argv);
+            return _wrap_ModelExporter_init__SWIG_0(resc,resv,argc,argv);
           }
         }
       }
     }
   }
   
   SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'ModelExporter_init'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::ModelExporter::init(iDynTree::Model const &,iDynTree::ModelExporterOptions const)\n"
-    "    iDynTree::ModelExporter::init(iDynTree::Model const &)\n"
     "    iDynTree::ModelExporter::init(iDynTree::Model const &,iDynTree::SensorsList const &,iDynTree::ModelExporterOptions const)\n"
-    "    iDynTree::ModelExporter::init(iDynTree::Model const &,iDynTree::SensorsList const &)\n");
+    "    iDynTree::ModelExporter::init(iDynTree::Model const &,iDynTree::SensorsList const &)\n"
+    "    iDynTree::ModelExporter::init(iDynTree::Model const &)\n");
   return 1;
 }
 
 
 int _wrap_ModelExporter_model(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ModelExporter *arg1 = (iDynTree::ModelExporter *) 0 ;
   void *argp1 = 0 ;
@@ -80165,49 +76034,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ExtWrenchesAndJointTorquesEstimator_setModel(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ExtWrenchesAndJointTorquesEstimator *arg1 = (iDynTree::ExtWrenchesAndJointTorquesEstimator *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("ExtWrenchesAndJointTorquesEstimator_setModel",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ExtWrenchesAndJointTorquesEstimator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtWrenchesAndJointTorquesEstimator_setModel" "', argument " "1"" of type '" "iDynTree::ExtWrenchesAndJointTorquesEstimator *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ExtWrenchesAndJointTorquesEstimator * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExtWrenchesAndJointTorquesEstimator_setModel" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_setModel" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->setModel((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_ExtWrenchesAndJointTorquesEstimator_setModelAndSensors(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ExtWrenchesAndJointTorquesEstimator *arg1 = (iDynTree::ExtWrenchesAndJointTorquesEstimator *) 0 ;
   iDynTree::Model *arg2 = 0 ;
   iDynTree::SensorsList *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
@@ -80594,17 +76428,17 @@
 fail:
   return 1;
 }
 
 
 int _wrap_ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ExtWrenchesAndJointTorquesEstimator *arg1 = (iDynTree::ExtWrenchesAndJointTorquesEstimator *) 0 ;
-  iDynTree::VectorDynSize *arg2 = 0 ;
-  iDynTree::VectorDynSize *arg3 = 0 ;
-  iDynTree::VectorDynSize *arg4 = 0 ;
+  iDynTree::JointPosDoubleArray *arg2 = 0 ;
+  iDynTree::JointDOFsDoubleArray *arg3 = 0 ;
+  iDynTree::JointDOFsDoubleArray *arg4 = 0 ;
   iDynTree::FrameIndex *arg5 = 0 ;
   iDynTree::Vector3 *arg6 = 0 ;
   iDynTree::Vector3 *arg7 = 0 ;
   iDynTree::Vector3 *arg8 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
@@ -80629,38 +76463,38 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ExtWrenchesAndJointTorquesEstimator, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "1"" of type '" "iDynTree::ExtWrenchesAndJointTorquesEstimator *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::ExtWrenchesAndJointTorquesEstimator * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__JointPosDoubleArray,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "2"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "2"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "2"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "2"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::VectorDynSize * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  arg2 = reinterpret_cast< iDynTree::JointPosDoubleArray * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__JointDOFsDoubleArray,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "3"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "3"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "3"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "3"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::VectorDynSize * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  arg3 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__JointDOFsDoubleArray,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "4"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "4"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "4"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "4"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::VectorDynSize * >(argp4);
+  arg4 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp4);
   ecode5 = SWIG_AsVal_ptrdiff_t(argv[4], &val5);
   if (!SWIG_IsOK(ecode5)) {
     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "5"" of type '" "iDynTree::FrameIndex""'");
   } 
   temp5 = static_cast< iDynTree::FrameIndex >(val5);
   arg5 = &temp5;
   res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t,  0 );
@@ -80683,28 +76517,28 @@
   if (!SWIG_IsOK(res8)) {
     SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "8"" of type '" "iDynTree::Vector3 const &""'"); 
   }
   if (!argp8) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase" "', argument " "8"" of type '" "iDynTree::Vector3 const &""'"); 
   }
   arg8 = reinterpret_cast< iDynTree::Vector3 * >(argp8);
-  result = (bool)(arg1)->updateKinematicsFromFloatingBase((iDynTree::VectorDynSize const &)*arg2,(iDynTree::VectorDynSize const &)*arg3,(iDynTree::VectorDynSize const &)*arg4,(iDynTree::FrameIndex const &)*arg5,(iDynTree::Vector3 const &)*arg6,(iDynTree::Vector3 const &)*arg7,(iDynTree::Vector3 const &)*arg8);
+  result = (bool)(arg1)->updateKinematicsFromFloatingBase((iDynTree::JointPosDoubleArray const &)*arg2,(iDynTree::JointDOFsDoubleArray const &)*arg3,(iDynTree::JointDOFsDoubleArray const &)*arg4,(iDynTree::FrameIndex const &)*arg5,(iDynTree::Vector3 const &)*arg6,(iDynTree::Vector3 const &)*arg7,(iDynTree::Vector3 const &)*arg8);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
 int _wrap_ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ExtWrenchesAndJointTorquesEstimator *arg1 = (iDynTree::ExtWrenchesAndJointTorquesEstimator *) 0 ;
-  iDynTree::VectorDynSize *arg2 = 0 ;
-  iDynTree::VectorDynSize *arg3 = 0 ;
-  iDynTree::VectorDynSize *arg4 = 0 ;
+  iDynTree::JointPosDoubleArray *arg2 = 0 ;
+  iDynTree::JointDOFsDoubleArray *arg3 = 0 ;
+  iDynTree::JointDOFsDoubleArray *arg4 = 0 ;
   iDynTree::FrameIndex *arg5 = 0 ;
   iDynTree::Vector3 *arg6 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   void *argp3 ;
@@ -80723,53 +76557,53 @@
     SWIG_fail;
   }
   res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ExtWrenchesAndJointTorquesEstimator, 0 |  0 );
   if (!SWIG_IsOK(res1)) {
     SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "1"" of type '" "iDynTree::ExtWrenchesAndJointTorquesEstimator *""'"); 
   }
   arg1 = reinterpret_cast< iDynTree::ExtWrenchesAndJointTorquesEstimator * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__JointPosDoubleArray,  0 );
   if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "2"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "2"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
   }
   if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "2"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "2"" of type '" "iDynTree::JointPosDoubleArray const &""'"); 
   }
-  arg2 = reinterpret_cast< iDynTree::VectorDynSize * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  arg2 = reinterpret_cast< iDynTree::JointPosDoubleArray * >(argp2);
+  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__JointDOFsDoubleArray,  0 );
   if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "3"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "3"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
   if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "3"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "3"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
-  arg3 = reinterpret_cast< iDynTree::VectorDynSize * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__VectorDynSize,  0 );
+  arg3 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp3);
+  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_iDynTree__JointDOFsDoubleArray,  0 );
   if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "4"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "4"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
   if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "4"" of type '" "iDynTree::VectorDynSize const &""'"); 
+    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "4"" of type '" "iDynTree::JointDOFsDoubleArray const &""'"); 
   }
-  arg4 = reinterpret_cast< iDynTree::VectorDynSize * >(argp4);
+  arg4 = reinterpret_cast< iDynTree::JointDOFsDoubleArray * >(argp4);
   ecode5 = SWIG_AsVal_ptrdiff_t(argv[4], &val5);
   if (!SWIG_IsOK(ecode5)) {
     SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "5"" of type '" "iDynTree::FrameIndex""'");
   } 
   temp5 = static_cast< iDynTree::FrameIndex >(val5);
   arg5 = &temp5;
   res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_iDynTree__VectorFixSizeT_3_t,  0 );
   if (!SWIG_IsOK(res6)) {
     SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "6"" of type '" "iDynTree::Vector3 const &""'"); 
   }
   if (!argp6) {
     SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase" "', argument " "6"" of type '" "iDynTree::Vector3 const &""'"); 
   }
   arg6 = reinterpret_cast< iDynTree::Vector3 * >(argp6);
-  result = (bool)(arg1)->updateKinematicsFromFixedBase((iDynTree::VectorDynSize const &)*arg2,(iDynTree::VectorDynSize const &)*arg3,(iDynTree::VectorDynSize const &)*arg4,(iDynTree::FrameIndex const &)*arg5,(iDynTree::Vector3 const &)*arg6);
+  result = (bool)(arg1)->updateKinematicsFromFixedBase((iDynTree::JointPosDoubleArray const &)*arg2,(iDynTree::JointDOFsDoubleArray const &)*arg3,(iDynTree::JointDOFsDoubleArray const &)*arg4,(iDynTree::FrameIndex const &)*arg5,(iDynTree::Vector3 const &)*arg6);
   _out = SWIG_From_bool(static_cast< bool >(result));
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
@@ -80838,93 +76672,14 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::ExtWrenchesAndJointTorquesEstimator *arg1 = (iDynTree::ExtWrenchesAndJointTorquesEstimator *) 0 ;
-  iDynTree::LinkUnknownWrenchContacts *arg2 = 0 ;
-  std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > > *arg3 = 0 ;
-  std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > > *arg4 = 0 ;
-  std::vector< std::ptrdiff_t,std::allocator< std::ptrdiff_t > > *arg5 = 0 ;
-  std::vector< iDynTree::LinkIndex,std::allocator< iDynTree::LinkIndex > > *arg6 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 = 0 ;
-  int res3 = 0 ;
-  void *argp4 = 0 ;
-  int res4 = 0 ;
-  void *argp5 = 0 ;
-  int res5 = 0 ;
-  void *argp6 = 0 ;
-  int res6 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics",argc,6,6,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__ExtWrenchesAndJointTorquesEstimator, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "1"" of type '" "iDynTree::ExtWrenchesAndJointTorquesEstimator *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::ExtWrenchesAndJointTorquesEstimator * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__LinkUnknownWrenchContacts,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "2"" of type '" "iDynTree::LinkUnknownWrenchContacts const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "2"" of type '" "iDynTree::LinkUnknownWrenchContacts const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::LinkUnknownWrenchContacts * >(argp2);
-  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t,  0 );
-  if (!SWIG_IsOK(res3)) {
-    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > > &""'"); 
-  }
-  if (!argp3) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "3"" of type '" "std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > > &""'"); 
-  }
-  arg3 = reinterpret_cast< std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > > * >(argp3);
-  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t,  0 );
-  if (!SWIG_IsOK(res4)) {
-    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "4"" of type '" "std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > > &""'"); 
-  }
-  if (!argp4) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "4"" of type '" "std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > > &""'"); 
-  }
-  arg4 = reinterpret_cast< std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > > * >(argp4);
-  res5 = SWIG_ConvertPtr(argv[4], &argp5, SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t,  0 );
-  if (!SWIG_IsOK(res5)) {
-    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "5"" of type '" "std::vector< std::ptrdiff_t,std::allocator< std::ptrdiff_t > > &""'"); 
-  }
-  if (!argp5) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "5"" of type '" "std::vector< std::ptrdiff_t,std::allocator< std::ptrdiff_t > > &""'"); 
-  }
-  arg5 = reinterpret_cast< std::vector< std::ptrdiff_t,std::allocator< std::ptrdiff_t > > * >(argp5);
-  res6 = SWIG_ConvertPtr(argv[5], &argp6, SWIGTYPE_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t,  0 );
-  if (!SWIG_IsOK(res6)) {
-    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "6"" of type '" "std::vector< iDynTree::LinkIndex,std::allocator< iDynTree::LinkIndex > > &""'"); 
-  }
-  if (!argp6) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics" "', argument " "6"" of type '" "std::vector< iDynTree::LinkIndex,std::allocator< iDynTree::LinkIndex > > &""'"); 
-  }
-  arg6 = reinterpret_cast< std::vector< iDynTree::LinkIndex,std::allocator< iDynTree::LinkIndex > > * >(argp6);
-  result = (bool)(arg1)->computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics((iDynTree::LinkUnknownWrenchContacts const &)*arg2,*arg3,*arg4,*arg5,*arg6);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
 int _wrap_ExtWrenchesAndJointTorquesEstimator_estimateExtWrenchesAndJointTorques(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::ExtWrenchesAndJointTorquesEstimator *arg1 = (iDynTree::ExtWrenchesAndJointTorquesEstimator *) 0 ;
   iDynTree::LinkUnknownWrenchContacts *arg2 = 0 ;
   iDynTree::SensorsMeasurements *arg3 = 0 ;
   iDynTree::LinkContactWrenches *arg4 = 0 ;
   iDynTree::JointDOFsDoubleArray *arg5 = 0 ;
   void *argp1 = 0 ;
@@ -83469,98 +79224,14 @@
   return 1;
 }
 
 
 int _wrap_BerdyHelper_init__SWIG_0(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::BerdyHelper *arg1 = (iDynTree::BerdyHelper *) 0 ;
   iDynTree::Model *arg2 = 0 ;
-  iDynTree::BerdyOptions arg3 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  void *argp3 ;
-  int res3 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("BerdyHelper_init",argc,3,3,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__BerdyHelper, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BerdyHelper_init" "', argument " "1"" of type '" "iDynTree::BerdyHelper *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::BerdyHelper * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BerdyHelper_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BerdyHelper_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  {
-    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_iDynTree__BerdyOptions,  0 );
-    if (!SWIG_IsOK(res3)) {
-      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "BerdyHelper_init" "', argument " "3"" of type '" "iDynTree::BerdyOptions const""'"); 
-    }  
-    if (!argp3) {
-      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BerdyHelper_init" "', argument " "3"" of type '" "iDynTree::BerdyOptions const""'");
-    } else {
-      arg3 = *(reinterpret_cast< iDynTree::BerdyOptions * >(argp3));
-    }
-  }
-  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2,arg3);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_BerdyHelper_init__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::BerdyHelper *arg1 = (iDynTree::BerdyHelper *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
-  void *argp1 = 0 ;
-  int res1 = 0 ;
-  void *argp2 ;
-  int res2 = 0 ;
-  mxArray * _out;
-  bool result;
-  
-  if (!SWIG_check_num_args("BerdyHelper_init",argc,2,2,0)) {
-    SWIG_fail;
-  }
-  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_iDynTree__BerdyHelper, 0 |  0 );
-  if (!SWIG_IsOK(res1)) {
-    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BerdyHelper_init" "', argument " "1"" of type '" "iDynTree::BerdyHelper *""'"); 
-  }
-  arg1 = reinterpret_cast< iDynTree::BerdyHelper * >(argp1);
-  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_iDynTree__Model,  0 );
-  if (!SWIG_IsOK(res2)) {
-    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BerdyHelper_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  if (!argp2) {
-    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BerdyHelper_init" "', argument " "2"" of type '" "iDynTree::Model const &""'"); 
-  }
-  arg2 = reinterpret_cast< iDynTree::Model * >(argp2);
-  result = (bool)(arg1)->init((iDynTree::Model const &)*arg2);
-  _out = SWIG_From_bool(static_cast< bool >(result));
-  if (_out) --resc, *resv++ = _out;
-  return 0;
-fail:
-  return 1;
-}
-
-
-int _wrap_BerdyHelper_init__SWIG_2(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  iDynTree::BerdyHelper *arg1 = (iDynTree::BerdyHelper *) 0 ;
-  iDynTree::Model *arg2 = 0 ;
   iDynTree::SensorsList *arg3 = 0 ;
   iDynTree::BerdyOptions arg4 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
   void *argp3 ;
@@ -83610,15 +79281,15 @@
   if (_out) --resc, *resv++ = _out;
   return 0;
 fail:
   return 1;
 }
 
 
-int _wrap_BerdyHelper_init__SWIG_3(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
+int _wrap_BerdyHelper_init__SWIG_1(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   iDynTree::BerdyHelper *arg1 = (iDynTree::BerdyHelper *) 0 ;
   iDynTree::Model *arg2 = 0 ;
   iDynTree::SensorsList *arg3 = 0 ;
   void *argp1 = 0 ;
   int res1 = 0 ;
   void *argp2 ;
   int res2 = 0 ;
@@ -83657,62 +79328,29 @@
   return 0;
 fail:
   return 1;
 }
 
 
 int _wrap_BerdyHelper_init(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
-  if (argc == 2) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__BerdyHelper, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        return _wrap_BerdyHelper_init__SWIG_1(resc,resv,argc,argv);
-      }
-    }
-  }
-  if (argc == 3) {
-    int _v;
-    void *vptr = 0;
-    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__BerdyHelper, 0);
-    _v = SWIG_CheckState(res);
-    if (_v) {
-      void *vptr = 0;
-      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
-      _v = SWIG_CheckState(res);
-      if (_v) {
-        void *vptr = 0;
-        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__BerdyOptions, 0);
-        _v = SWIG_CheckState(res);
-        if (_v) {
-          return _wrap_BerdyHelper_init__SWIG_0(resc,resv,argc,argv);
-        }
-      }
-    }
-  }
   if (argc == 3) {
     int _v;
     void *vptr = 0;
     int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_iDynTree__BerdyHelper, 0);
     _v = SWIG_CheckState(res);
     if (_v) {
       void *vptr = 0;
       int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_iDynTree__Model, 0);
       _v = SWIG_CheckState(res);
       if (_v) {
         void *vptr = 0;
         int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
         _v = SWIG_CheckState(res);
         if (_v) {
-          return _wrap_BerdyHelper_init__SWIG_3(resc,resv,argc,argv);
+          return _wrap_BerdyHelper_init__SWIG_1(resc,resv,argc,argv);
         }
       }
     }
   }
   if (argc == 4) {
     int _v;
     void *vptr = 0;
@@ -83727,25 +79365,23 @@
         int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_iDynTree__SensorsList, 0);
         _v = SWIG_CheckState(res);
         if (_v) {
           void *vptr = 0;
           int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_iDynTree__BerdyOptions, 0);
           _v = SWIG_CheckState(res);
           if (_v) {
-            return _wrap_BerdyHelper_init__SWIG_2(resc,resv,argc,argv);
+            return _wrap_BerdyHelper_init__SWIG_0(resc,resv,argc,argv);
           }
         }
       }
     }
   }
   
   SWIG_Error(SWIG_RuntimeError, "No matching function for overload function 'BerdyHelper_init'."
     "  Possible C/C++ prototypes are:\n"
-    "    iDynTree::BerdyHelper::init(iDynTree::Model const &,iDynTree::BerdyOptions const)\n"
-    "    iDynTree::BerdyHelper::init(iDynTree::Model const &)\n"
     "    iDynTree::BerdyHelper::init(iDynTree::Model const &,iDynTree::SensorsList const &,iDynTree::BerdyOptions const)\n"
     "    iDynTree::BerdyHelper::init(iDynTree::Model const &,iDynTree::SensorsList const &)\n");
   return 1;
 }
 
 
 int _wrap_BerdyHelper_getOptions(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
@@ -113724,53 +109360,65 @@
 }
 static void *_p_iDynTree__AttitudeMahonyFilterTo_p_iDynTree__IAttitudeEstimator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::IAttitudeEstimator *)  ((iDynTree::AttitudeMahonyFilter *) x));
 }
 static void *_p_iDynTree__AttitudeQuaternionEKFTo_p_iDynTree__IAttitudeEstimator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::IAttitudeEstimator *)  ((iDynTree::AttitudeQuaternionEKF *) x));
 }
+static void *_p_iDynTree__RotationTo_p_iDynTree__RotationRaw(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::RotationRaw *)  ((iDynTree::Rotation *) x));
+}
+static void *_p_iDynTree__PositionTo_p_iDynTree__PositionRaw(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::PositionRaw *)  ((iDynTree::Position *) x));
+}
 static void *_p_iDynTree__RevoluteJointTo_p_iDynTree__MovableJointImplT_1_1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::MovableJointImpl< 1,1 > *)  ((iDynTree::RevoluteJoint *) x));
 }
 static void *_p_iDynTree__PrismaticJointTo_p_iDynTree__MovableJointImplT_1_1_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::MovableJointImpl< 1,1 > *)  ((iDynTree::PrismaticJoint *) x));
 }
 static void *_p_iDynTree__PositionTo_p_iDynTree__VectorFixSizeT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((iDynTree::VectorFixSize< 3 > *)  ((iDynTree::Position *) x));
+    return (void *)((iDynTree::VectorFixSize< 3 > *) (iDynTree::PositionRaw *) ((iDynTree::Position *) x));
+}
+static void *_p_iDynTree__PositionRawTo_p_iDynTree__VectorFixSizeT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::VectorFixSize< 3 > *)  ((iDynTree::PositionRaw *) x));
 }
 static void *_p_iDynTree__GeomVector3To_p_iDynTree__VectorFixSizeT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::VectorFixSize< 3 > *)  ((iDynTree::GeomVector3 *) x));
 }
 static void *_p_iDynTree__DirectionTo_p_iDynTree__VectorFixSizeT_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::VectorFixSize< 3 > *)  ((iDynTree::Direction *) x));
 }
-static void *_p_iDynTree__JointPosDoubleArrayTo_p_iDynTree__VectorDynSize(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((iDynTree::VectorDynSize *)  ((iDynTree::JointPosDoubleArray *) x));
-}
-static void *_p_iDynTree__JointDOFsDoubleArrayTo_p_iDynTree__VectorDynSize(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((iDynTree::VectorDynSize *)  ((iDynTree::JointDOFsDoubleArray *) x));
-}
 static void *_p_iDynTree__FrameFreeFloatingJacobianTo_p_iDynTree__MatrixDynSize(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::MatrixDynSize *)  ((iDynTree::FrameFreeFloatingJacobian *) x));
 }
 static void *_p_iDynTree__MomentumFreeFloatingJacobianTo_p_iDynTree__MatrixDynSize(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::MatrixDynSize *)  ((iDynTree::MomentumFreeFloatingJacobian *) x));
 }
 static void *_p_iDynTree__FreeFloatingMassMatrixTo_p_iDynTree__MatrixDynSize(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::MatrixDynSize *)  ((iDynTree::FreeFloatingMassMatrix *) x));
 }
+static void *_p_iDynTree__JointPosDoubleArrayTo_p_iDynTree__VectorDynSize(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::VectorDynSize *)  ((iDynTree::JointPosDoubleArray *) x));
+}
+static void *_p_iDynTree__JointDOFsDoubleArrayTo_p_iDynTree__VectorDynSize(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::VectorDynSize *)  ((iDynTree::JointDOFsDoubleArray *) x));
+}
 static void *_p_iDynTree__WrenchTo_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SpatialVector< iDynTree::SpatialForceVector > *) (iDynTree::SpatialForceVector *) ((iDynTree::Wrench *) x));
 }
 static void *_p_iDynTree__SpatialForceVectorTo_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SpatialVector< iDynTree::SpatialForceVector > *)  ((iDynTree::SpatialForceVector *) x));
 }
 static void *_p_iDynTree__SpatialMomentumTo_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SpatialVector< iDynTree::SpatialForceVector > *) (iDynTree::SpatialForceVector *) ((iDynTree::SpatialMomentum *) x));
 }
+static void *_p_iDynTree__SixAxisForceTorqueSensorTo_p_iDynTree__JointSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::JointSensor *)  ((iDynTree::SixAxisForceTorqueSensor *) x));
+}
 static void *_p_iDynTree__JointSensorTo_p_iDynTree__Sensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::Sensor *)  ((iDynTree::JointSensor *) x));
 }
 static void *_p_iDynTree__AccelerometerSensorTo_p_iDynTree__Sensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::Sensor *) (iDynTree::LinkSensor *) ((iDynTree::AccelerometerSensor *) x));
 }
 static void *_p_iDynTree__ThreeAxisAngularAccelerometerSensorTo_p_iDynTree__Sensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
@@ -113784,29 +109432,29 @@
 }
 static void *_p_iDynTree__SixAxisForceTorqueSensorTo_p_iDynTree__Sensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::Sensor *) (iDynTree::JointSensor *) ((iDynTree::SixAxisForceTorqueSensor *) x));
 }
 static void *_p_iDynTree__GyroscopeSensorTo_p_iDynTree__Sensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::Sensor *) (iDynTree::LinkSensor *) ((iDynTree::GyroscopeSensor *) x));
 }
-static void *_p_iDynTree__SixAxisForceTorqueSensorTo_p_iDynTree__JointSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((iDynTree::JointSensor *)  ((iDynTree::SixAxisForceTorqueSensor *) x));
-}
 static void *_p_iDynTree__BoxTo_p_iDynTree__SolidShape(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SolidShape *)  ((iDynTree::Box *) x));
 }
 static void *_p_iDynTree__ExternalMeshTo_p_iDynTree__SolidShape(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SolidShape *)  ((iDynTree::ExternalMesh *) x));
 }
 static void *_p_iDynTree__SphereTo_p_iDynTree__SolidShape(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SolidShape *)  ((iDynTree::Sphere *) x));
 }
 static void *_p_iDynTree__CylinderTo_p_iDynTree__SolidShape(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SolidShape *)  ((iDynTree::Cylinder *) x));
 }
+static void *_p_iDynTree__SpatialInertiaTo_p_iDynTree__SpatialInertiaRaw(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::SpatialInertiaRaw *)  ((iDynTree::SpatialInertia *) x));
+}
 static void *_p_iDynTree__AccelerometerSensorTo_p_iDynTree__LinkSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::LinkSensor *)  ((iDynTree::AccelerometerSensor *) x));
 }
 static void *_p_iDynTree__ThreeAxisAngularAccelerometerSensorTo_p_iDynTree__LinkSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::LinkSensor *)  ((iDynTree::ThreeAxisAngularAccelerometerSensor *) x));
 }
 static void *_p_iDynTree__ThreeAxisForceTorqueContactSensorTo_p_iDynTree__LinkSensor(void *x, int *SWIGUNUSEDPARM(newmemory)) {
@@ -113823,19 +109471,22 @@
 }
 static void *_p_iDynTree__WrenchTo_p_iDynTree__SpatialForceVector(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SpatialForceVector *)  ((iDynTree::Wrench *) x));
 }
 static void *_p_iDynTree__SpatialMomentumTo_p_iDynTree__SpatialForceVector(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::SpatialForceVector *)  ((iDynTree::SpatialMomentum *) x));
 }
-static void *_p_iDynTree__RotationalInertiaTo_p_iDynTree__MatrixFixSizeT_3_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((iDynTree::MatrixFixSize< 3,3 > *)  ((iDynTree::RotationalInertia *) x));
+static void *_p_iDynTree__RotationalInertiaRawTo_p_iDynTree__MatrixFixSizeT_3_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::MatrixFixSize< 3,3 > *)  ((iDynTree::RotationalInertiaRaw *) x));
+}
+static void *_p_iDynTree__RotationRawTo_p_iDynTree__MatrixFixSizeT_3_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
+    return (void *)((iDynTree::MatrixFixSize< 3,3 > *)  ((iDynTree::RotationRaw *) x));
 }
 static void *_p_iDynTree__RotationTo_p_iDynTree__MatrixFixSizeT_3_3_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
-    return (void *)((iDynTree::MatrixFixSize< 3,3 > *)  ((iDynTree::Rotation *) x));
+    return (void *)((iDynTree::MatrixFixSize< 3,3 > *) (iDynTree::RotationRaw *) ((iDynTree::Rotation *) x));
 }
 static void *_p_iDynTree__MovableJointImplT_1_1_tTo_p_iDynTree__IJoint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::IJoint *)  ((iDynTree::MovableJointImpl< 1,1 > *) x));
 }
 static void *_p_iDynTree__RevoluteJointTo_p_iDynTree__IJoint(void *x, int *SWIGUNUSEDPARM(newmemory)) {
     return (void *)((iDynTree::IJoint *) (iDynTree::MovableJointImpl< 1,1 > *) ((iDynTree::RevoluteJoint *) x));
 }
@@ -113950,15 +109601,15 @@
 static swig_type_info _swigt__p_iDynTree__LinkInertias = {"_p_iDynTree__LinkInertias", "iDynTree::LinkInertias *|iDynTree::LinkCompositeRigidBodyInertias *", 0, 0, (void*)"iDynTree.LinkInertias", 0};
 static swig_type_info _swigt__p_iDynTree__LinkPositions = {"_p_iDynTree__LinkPositions", "iDynTree::LinkPositions *", 0, 0, (void*)"iDynTree.LinkPositions", 0};
 static swig_type_info _swigt__p_iDynTree__LinkSensor = {"_p_iDynTree__LinkSensor", "iDynTree::LinkSensor *", 0, 0, (void*)"iDynTree.LinkSensor", 0};
 static swig_type_info _swigt__p_iDynTree__LinkUnknownWrenchContacts = {"_p_iDynTree__LinkUnknownWrenchContacts", "iDynTree::LinkUnknownWrenchContacts *", 0, 0, (void*)"iDynTree.LinkUnknownWrenchContacts", 0};
 static swig_type_info _swigt__p_iDynTree__LinkVelArray = {"_p_iDynTree__LinkVelArray", "iDynTree::LinkVelArray *", 0, 0, (void*)"iDynTree.LinkVelArray", 0};
 static swig_type_info _swigt__p_iDynTree__LinkWrenches = {"_p_iDynTree__LinkWrenches", "iDynTree::LinkWrenches *|iDynTree::LinkNetExternalWrenches *|iDynTree::LinkInternalWrenches *|iDynTree::LinkNetTotalWrenchesWithoutGravity *", 0, 0, (void*)"iDynTree.LinkWrenches", 0};
 static swig_type_info _swigt__p_iDynTree__Material = {"_p_iDynTree__Material", "iDynTree::Material *", 0, 0, (void*)"iDynTree.Material", 0};
-static swig_type_info _swigt__p_iDynTree__MatrixDynSize = {"_p_iDynTree__MatrixDynSize", "iDynTree::MatrixDynSize *|std::vector< iDynTree::MatrixDynSize >::value_type *", 0, 0, (void*)"iDynTree.MatrixDynSize", 0};
+static swig_type_info _swigt__p_iDynTree__MatrixDynSize = {"_p_iDynTree__MatrixDynSize", "iDynTree::MatrixDynSize *", 0, 0, (void*)"iDynTree.MatrixDynSize", 0};
 static swig_type_info _swigt__p_iDynTree__MatrixFixSizeT_10_16_t = {"_p_iDynTree__MatrixFixSizeT_10_16_t", "iDynTree::MatrixFixSize< 10,16 > *|iDynTree::Matrix10x16 *", 0, 0, (void*)"iDynTree.Matrix10x16", 0};
 static swig_type_info _swigt__p_iDynTree__MatrixFixSizeT_1_6_t = {"_p_iDynTree__MatrixFixSizeT_1_6_t", "iDynTree::Matrix1x6 *|iDynTree::MatrixFixSize< 1,6 > *", 0, 0, (void*)"iDynTree.Matrix1x6", 0};
 static swig_type_info _swigt__p_iDynTree__MatrixFixSizeT_2_3_t = {"_p_iDynTree__MatrixFixSizeT_2_3_t", "iDynTree::MatrixFixSize< 2,3 > *|iDynTree::Matrix2x3 *", 0, 0, (void*)"iDynTree.Matrix2x3", 0};
 static swig_type_info _swigt__p_iDynTree__MatrixFixSizeT_3_3_t = {"_p_iDynTree__MatrixFixSizeT_3_3_t", "iDynTree::Matrix3x3 *|iDynTree::MatrixFixSize< 3,3 > *", 0, 0, (void*)"iDynTree.Matrix3x3", 0};
 static swig_type_info _swigt__p_iDynTree__MatrixFixSizeT_3_4_t = {"_p_iDynTree__MatrixFixSizeT_3_4_t", "iDynTree::MatrixFixSize< 3,4 > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__MatrixFixSizeT_4_3_t = {"_p_iDynTree__MatrixFixSizeT_4_3_t", "iDynTree::MatrixFixSize< 4,3 > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__MatrixFixSizeT_4_4_t = {"_p_iDynTree__MatrixFixSizeT_4_4_t", "std::vector< iDynTree::MatrixFixSize< 4,4 > >::value_type *|iDynTree::MatrixFixSize< 4,4 > *|iDynTree::Matrix4x4 *", 0, 0, (void*)"iDynTree.Matrix4x4", 0};
@@ -113981,33 +109632,36 @@
 static swig_type_info _swigt__p_iDynTree__MovableJointImplT_4_4_t = {"_p_iDynTree__MovableJointImplT_4_4_t", "iDynTree::MovableJointImpl4 *|iDynTree::MovableJointImpl< 4,4 > *", 0, 0, (void*)"iDynTree.MovableJointImpl4", 0};
 static swig_type_info _swigt__p_iDynTree__MovableJointImplT_5_5_t = {"_p_iDynTree__MovableJointImplT_5_5_t", "iDynTree::MovableJointImpl< 5,5 > *|iDynTree::MovableJointImpl5 *", 0, 0, (void*)"iDynTree.MovableJointImpl5", 0};
 static swig_type_info _swigt__p_iDynTree__MovableJointImplT_6_6_t = {"_p_iDynTree__MovableJointImplT_6_6_t", "iDynTree::MovableJointImpl< 6,6 > *|iDynTree::MovableJointImpl6 *", 0, 0, (void*)"iDynTree.MovableJointImpl6", 0};
 static swig_type_info _swigt__p_iDynTree__Neighbor = {"_p_iDynTree__Neighbor", "iDynTree::Neighbor *", 0, 0, (void*)"iDynTree.Neighbor", 0};
 static swig_type_info _swigt__p_iDynTree__PixelViz = {"_p_iDynTree__PixelViz", "iDynTree::PixelViz *", 0, 0, (void*)"iDynTree.PixelViz", 0};
 static swig_type_info _swigt__p_iDynTree__Polygon = {"_p_iDynTree__Polygon", "iDynTree::Polygon *", 0, 0, (void*)"iDynTree.Polygon", 0};
 static swig_type_info _swigt__p_iDynTree__Polygon2D = {"_p_iDynTree__Polygon2D", "iDynTree::Polygon2D *", 0, 0, (void*)"iDynTree.Polygon2D", 0};
-static swig_type_info _swigt__p_iDynTree__Position = {"_p_iDynTree__Position", "iDynTree::PositionRaw *|iDynTree::Position *", 0, 0, (void*)"iDynTree.Position", 0};
+static swig_type_info _swigt__p_iDynTree__Position = {"_p_iDynTree__Position", "iDynTree::Position *", 0, 0, (void*)"iDynTree.Position", 0};
+static swig_type_info _swigt__p_iDynTree__PositionRaw = {"_p_iDynTree__PositionRaw", "iDynTree::PositionRaw *", 0, 0, (void*)"iDynTree.PositionRaw", 0};
 static swig_type_info _swigt__p_iDynTree__PrismaticJoint = {"_p_iDynTree__PrismaticJoint", "iDynTree::PrismaticJoint *", 0, 0, (void*)"iDynTree.PrismaticJoint", 0};
 static swig_type_info _swigt__p_iDynTree__RevoluteJoint = {"_p_iDynTree__RevoluteJoint", "iDynTree::RevoluteJoint *", 0, 0, (void*)"iDynTree.RevoluteJoint", 0};
 static swig_type_info _swigt__p_iDynTree__RigidBodyInertiaNonLinearParametrization = {"_p_iDynTree__RigidBodyInertiaNonLinearParametrization", "iDynTree::RigidBodyInertiaNonLinearParametrization *", 0, 0, (void*)"iDynTree.RigidBodyInertiaNonLinearParametrization", 0};
-static swig_type_info _swigt__p_iDynTree__Rotation = {"_p_iDynTree__Rotation", "iDynTree::RotationRaw *|iDynTree::Rotation *", 0, 0, (void*)"iDynTree.Rotation", 0};
-static swig_type_info _swigt__p_iDynTree__RotationalInertia = {"_p_iDynTree__RotationalInertia", "iDynTree::RotationalInertiaRaw *|iDynTree::RotationalInertia *", 0, 0, (void*)"iDynTree.RotationalInertia", 0};
+static swig_type_info _swigt__p_iDynTree__Rotation = {"_p_iDynTree__Rotation", "iDynTree::Rotation *", 0, 0, (void*)"iDynTree.Rotation", 0};
+static swig_type_info _swigt__p_iDynTree__RotationRaw = {"_p_iDynTree__RotationRaw", "iDynTree::RotationRaw *", 0, 0, (void*)"iDynTree.RotationRaw", 0};
+static swig_type_info _swigt__p_iDynTree__RotationalInertiaRaw = {"_p_iDynTree__RotationalInertiaRaw", "iDynTree::RotationalInertiaRaw *", 0, 0, (void*)"iDynTree.RotationalInertiaRaw", 0};
 static swig_type_info _swigt__p_iDynTree__Sensor = {"_p_iDynTree__Sensor", "iDynTree::Sensor *", 0, 0, (void*)"iDynTree.Sensor", 0};
 static swig_type_info _swigt__p_iDynTree__SensorsList = {"_p_iDynTree__SensorsList", "iDynTree::SensorsList *", 0, 0, (void*)"iDynTree.SensorsList", 0};
 static swig_type_info _swigt__p_iDynTree__SensorsMeasurements = {"_p_iDynTree__SensorsMeasurements", "iDynTree::SensorsMeasurements *", 0, 0, (void*)"iDynTree.SensorsMeasurements", 0};
 static swig_type_info _swigt__p_iDynTree__SimpleLeggedOdometry = {"_p_iDynTree__SimpleLeggedOdometry", "iDynTree::SimpleLeggedOdometry *", 0, 0, (void*)"iDynTree.SimpleLeggedOdometry", 0};
 static swig_type_info _swigt__p_iDynTree__SixAxisForceTorqueSensor = {"_p_iDynTree__SixAxisForceTorqueSensor", "iDynTree::SixAxisForceTorqueSensor *", 0, 0, (void*)"iDynTree.SixAxisForceTorqueSensor", 0};
 static swig_type_info _swigt__p_iDynTree__SolidShape = {"_p_iDynTree__SolidShape", "std::vector< iDynTree::SolidShape * >::value_type|iDynTree::SolidShape *", 0, 0, (void*)"iDynTree.SolidShape", 0};
 static swig_type_info _swigt__p_iDynTree__SpanT_double__1_t = {"_p_iDynTree__SpanT_double__1_t", "iDynTree::Span< iDynTree::Span< double,-1 >::element_type,-1 > *|iDynTree::Span< double,-1 > *", 0, 0, (void*)"iDynTree.DynamicSpan", 0};
 static swig_type_info _swigt__p_iDynTree__SpanT_double_const__1_t = {"_p_iDynTree__SpanT_double_const__1_t", "iDynTree::Span< double const,-1 > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__SparseMatrixT_iDynTree__ColumnMajor_t = {"_p_iDynTree__SparseMatrixT_iDynTree__ColumnMajor_t", "iDynTree::SparseMatrix< iDynTree::ColumnMajor > *", 0, 0, (void*)"iDynTree.SparseMatrixColMajor", 0};
 static swig_type_info _swigt__p_iDynTree__SparseMatrixT_iDynTree__RowMajor_t = {"_p_iDynTree__SparseMatrixT_iDynTree__RowMajor_t", "iDynTree::SparseMatrix< iDynTree::RowMajor > *", 0, 0, (void*)"iDynTree.SparseMatrixRowMajor", 0};
 static swig_type_info _swigt__p_iDynTree__SpatialAcc = {"_p_iDynTree__SpatialAcc", "iDynTree::SpatialAcc *", 0, 0, (void*)"iDynTree.SpatialAcc", 0};
 static swig_type_info _swigt__p_iDynTree__SpatialForceVector = {"_p_iDynTree__SpatialForceVector", "iDynTree::SpatialVector< iDynTree::SpatialMotionVector >::DualVectorT *|iDynTree::SpatialForceVector *", 0, 0, (void*)"iDynTree.SpatialForceVector", 0};
 static swig_type_info _swigt__p_iDynTree__SpatialInertia = {"_p_iDynTree__SpatialInertia", "iDynTree::SpatialInertia *", 0, 0, (void*)"iDynTree.SpatialInertia", 0};
+static swig_type_info _swigt__p_iDynTree__SpatialInertiaRaw = {"_p_iDynTree__SpatialInertiaRaw", "iDynTree::SpatialInertiaRaw *", 0, 0, (void*)"iDynTree.SpatialInertiaRaw", 0};
 static swig_type_info _swigt__p_iDynTree__SpatialMomentum = {"_p_iDynTree__SpatialMomentum", "iDynTree::SpatialMomentum *", 0, 0, (void*)"iDynTree.SpatialMomentum", 0};
 static swig_type_info _swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__AngularVector3Type = {"_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__AngularVector3Type", "iDynTree::SpatialForceVector::AngularVector3T *|iDynTree::SpatialMotionForceVectorT_traits< iDynTree::SpatialForceVector >::AngularVector3Type *|iDynTree::SpatialVector< iDynTree::SpatialForceVector >::AngularVector3T *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__LinearVector3Type = {"_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__LinearVector3Type", "iDynTree::SpatialForceVector::LinearVector3T *|iDynTree::SpatialMotionForceVectorT_traits< iDynTree::SpatialForceVector >::LinearVector3Type *|iDynTree::SpatialVector< iDynTree::SpatialForceVector >::LinearVector3T *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__AngularVector3Type = {"_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__AngularVector3Type", "iDynTree::SpatialMotionForceVectorT_traits< iDynTree::SpatialMotionVector >::AngularVector3Type *|iDynTree::SpatialVector< iDynTree::SpatialMotionVector >::AngularVector3T *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__LinearVector3Type = {"_p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__LinearVector3Type", "iDynTree::SpatialMotionForceVectorT_traits< iDynTree::SpatialMotionVector >::LinearVector3Type *|iDynTree::SpatialVector< iDynTree::SpatialMotionVector >::LinearVector3T *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__SpatialMotionVector = {"_p_iDynTree__SpatialMotionVector", "iDynTree::SpatialVector< iDynTree::SpatialForceVector >::DualVectorT *|iDynTree::SpatialMotionVector *", 0, 0, (void*)"iDynTree.SpatialMotionVector", 0};
 static swig_type_info _swigt__p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t = {"_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t", "iDynTree::SpatialVector< iDynTree::SpatialForceVector > *", 0, 0, (void*)"iDynTree.SpatialForceVectorBase", 0};
@@ -114018,15 +109672,15 @@
 static swig_type_info _swigt__p_iDynTree__ThreeAxisForceTorqueContactSensor = {"_p_iDynTree__ThreeAxisForceTorqueContactSensor", "iDynTree::ThreeAxisForceTorqueContactSensor *", 0, 0, (void*)"iDynTree.ThreeAxisForceTorqueContactSensor", 0};
 static swig_type_info _swigt__p_iDynTree__Transform = {"_p_iDynTree__Transform", "iDynTree::Transform *", 0, 0, (void*)"iDynTree.Transform", 0};
 static swig_type_info _swigt__p_iDynTree__TransformDerivative = {"_p_iDynTree__TransformDerivative", "iDynTree::TransformDerivative *", 0, 0, (void*)"iDynTree.TransformDerivative", 0};
 static swig_type_info _swigt__p_iDynTree__Traversal = {"_p_iDynTree__Traversal", "iDynTree::Traversal *", 0, 0, (void*)"iDynTree.Traversal", 0};
 static swig_type_info _swigt__p_iDynTree__Triplets = {"_p_iDynTree__Triplets", "iDynTree::Triplets *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__Twist = {"_p_iDynTree__Twist", "iDynTree::Twist *", 0, 0, (void*)"iDynTree.Twist", 0};
 static swig_type_info _swigt__p_iDynTree__UnknownWrenchContact = {"_p_iDynTree__UnknownWrenchContact", "iDynTree::UnknownWrenchContact *", 0, 0, (void*)"iDynTree.UnknownWrenchContact", 0};
-static swig_type_info _swigt__p_iDynTree__VectorDynSize = {"_p_iDynTree__VectorDynSize", "iDynTree::VectorDynSize *|std::vector< iDynTree::VectorDynSize >::value_type *", 0, 0, (void*)"iDynTree.VectorDynSize", 0};
+static swig_type_info _swigt__p_iDynTree__VectorDynSize = {"_p_iDynTree__VectorDynSize", "iDynTree::VectorDynSize *", 0, 0, (void*)"iDynTree.VectorDynSize", 0};
 static swig_type_info _swigt__p_iDynTree__VectorFixSizeT_10_t = {"_p_iDynTree__VectorFixSizeT_10_t", "iDynTree::VectorFixSize< 10 > *|iDynTree::Vector10 *", 0, 0, (void*)"iDynTree.Vector10", 0};
 static swig_type_info _swigt__p_iDynTree__VectorFixSizeT_16_t = {"_p_iDynTree__VectorFixSizeT_16_t", "iDynTree::Vector16 *|iDynTree::VectorFixSize< 16 > *", 0, 0, (void*)"iDynTree.Vector16", 0};
 static swig_type_info _swigt__p_iDynTree__VectorFixSizeT_2_t = {"_p_iDynTree__VectorFixSizeT_2_t", "iDynTree::Vector2 *|iDynTree::VectorFixSize< 2 > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__VectorFixSizeT_3_t = {"_p_iDynTree__VectorFixSizeT_3_t", "iDynTree::MagnetometerMeasurements *|iDynTree::GyroscopeMeasurements *|iDynTree::LinearAccelerometerMeasurements *|iDynTree::Vector3 *|iDynTree::RPY *|iDynTree::VectorFixSize< 3 > *", 0, 0, (void*)"iDynTree.Vector3", 0};
 static swig_type_info _swigt__p_iDynTree__VectorFixSizeT_4_t = {"_p_iDynTree__VectorFixSizeT_4_t", "iDynTree::VectorFixSize< 4 > *|iDynTree::Vector4 *|iDynTree::UnitQuaternion *", 0, 0, (void*)"iDynTree.Vector4", 0};
 static swig_type_info _swigt__p_iDynTree__VectorFixSizeT_6_t = {"_p_iDynTree__VectorFixSizeT_6_t", "iDynTree::Vector6 *|iDynTree::VectorFixSize< 6 > *", 0, 0, (void*)"iDynTree.Vector6", 0};
 static swig_type_info _swigt__p_iDynTree__Visualizer = {"_p_iDynTree__Visualizer", "iDynTree::Visualizer *", 0, 0, (void*)"iDynTree.Visualizer", 0};
@@ -114034,47 +109688,44 @@
 static swig_type_info _swigt__p_iDynTree__Wrench = {"_p_iDynTree__Wrench", "iDynTree::Wrench *", 0, 0, (void*)"iDynTree.Wrench", 0};
 static swig_type_info _swigt__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t = {"_p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t", "iDynTree::Span< double,-1 >::iterator *|iDynTree::details::span_iterator< iDynTree::Span< double,-1 >,false > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t = {"_p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t", "iDynTree::Span< double,-1 >::const_iterator *|iDynTree::details::span_iterator< iDynTree::Span< double,-1 >,true > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iDynTree__estimateExternalWrenchesBuffers = {"_p_iDynTree__estimateExternalWrenchesBuffers", "iDynTree::estimateExternalWrenchesBuffers *", 0, 0, (void*)"iDynTree.estimateExternalWrenchesBuffers", 0};
 static swig_type_info _swigt__p_index_type = {"_p_index_type", "index_type *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_iterator = {"_p_iterator", "iterator *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_pointer = {"_p_pointer", "pointer *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_ptrdiff_t = {"_p_ptrdiff_t", "::ptrdiff_t *|std::ptrdiff_t *|iDynTree::LinkIndex *|iDynTree::FrameIndex *|iDynTree::TraversalIndex *|iDynTree::JointIndex *|iDynTree::DOFIndex *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_reference = {"_p_reference", "reference *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_reverse_iterator = {"_p_reverse_iterator", "reverse_iterator *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__allocatorT_iDynTree__BerdyDynamicVariable_t = {"_p_std__allocatorT_iDynTree__BerdyDynamicVariable_t", "std::vector< iDynTree::BerdyDynamicVariable >::allocator_type *|std::allocator< iDynTree::BerdyDynamicVariable > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__allocatorT_iDynTree__BerdySensor_t = {"_p_std__allocatorT_iDynTree__BerdySensor_t", "std::allocator< iDynTree::BerdySensor > *|std::vector< iDynTree::BerdySensor >::allocator_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__allocatorT_iDynTree__MatrixDynSize_t = {"_p_std__allocatorT_iDynTree__MatrixDynSize_t", "std::vector< iDynTree::MatrixDynSize >::allocator_type *|std::allocator< iDynTree::MatrixDynSize > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t = {"_p_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t", "std::vector< iDynTree::MatrixFixSize< 4,4 > >::allocator_type *|std::allocator< iDynTree::MatrixFixSize< 4,4 > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__allocatorT_iDynTree__SolidShape_p_t = {"_p_std__allocatorT_iDynTree__SolidShape_p_t", "std::allocator< iDynTree::SolidShape * > *|std::vector< iDynTree::SolidShape * >::allocator_type *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__allocatorT_iDynTree__VectorDynSize_t = {"_p_std__allocatorT_iDynTree__VectorDynSize_t", "std::vector< iDynTree::VectorDynSize >::allocator_type *|std::allocator< iDynTree::VectorDynSize > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__allocatorT_int_t = {"_p_std__allocatorT_int_t", "std::vector< int >::allocator_type *|std::allocator< int > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__allocatorT_std__ptrdiff_t_t = {"_p_std__allocatorT_std__ptrdiff_t_t", "std::vector< ::ptrdiff_t >::allocator_type *|std::allocator< ::ptrdiff_t > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__allocatorT_std__string_t = {"_p_std__allocatorT_std__string_t", "std::vector< std::string >::allocator_type *|std::allocator< std::string > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t = {"_p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t", "std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > *|std::vector< std::vector< iDynTree::SolidShape * > >::allocator_type *", 0, 0, (void*)0, 0};
+static swig_type_info _swigt__p_std__ptrdiff_t = {"_p_std__ptrdiff_t", "std::ptrdiff_t *|iDynTree::LinkIndex *|iDynTree::FrameIndex *|iDynTree::TraversalIndex *|iDynTree::JointIndex *|iDynTree::DOFIndex *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t_t = {"_p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t_t", "iDynTree::Span< double,-1 >::reverse_iterator *|std::reverse_iterator< iDynTree::details::span_iterator< iDynTree::Span< double,-1 >,false > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t_t = {"_p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t_t", "std::reverse_iterator< iDynTree::details::span_iterator< iDynTree::Span< double,-1 >,true > > *|iDynTree::Span< double,-1 >::const_reverse_iterator *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__size_t = {"_p_std__size_t", "std::size_t *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__BerdyDynamicVariable_std__allocatorT_iDynTree__BerdyDynamicVariable_t_t = {"_p_std__vectorT_iDynTree__BerdyDynamicVariable_std__allocatorT_iDynTree__BerdyDynamicVariable_t_t", "std::vector< iDynTree::BerdyDynamicVariable,std::allocator< iDynTree::BerdyDynamicVariable > > *|std::vector< iDynTree::BerdyDynamicVariable > *", 0, 0, (void*)"iDynTree.BerdyDynamicVariables", 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__BerdySensor_std__allocatorT_iDynTree__BerdySensor_t_t = {"_p_std__vectorT_iDynTree__BerdySensor_std__allocatorT_iDynTree__BerdySensor_t_t", "std::vector< iDynTree::BerdySensor > *|std::vector< iDynTree::BerdySensor,std::allocator< iDynTree::BerdySensor > > *", 0, 0, (void*)"iDynTree.BerdySensors", 0};
-static swig_type_info _swigt__p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t = {"_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t", "std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > > *|std::vector< iDynTree::MatrixDynSize > *", 0, 0, (void*)"iDynTree.MatrixDynSizeVector", 0};
+static swig_type_info _swigt__p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t = {"_p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t", "std::vector< iDynTree::MatrixDynSize,std::allocator< iDynTree::MatrixDynSize > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__MatrixFixSizeT_4_4_t_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t_t = {"_p_std__vectorT_iDynTree__MatrixFixSizeT_4_4_t_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t_t", "std::vector< iDynTree::MatrixFixSize< 4,4 > > *|std::vector< iDynTree::Matrix4x4 > *|std::vector< iDynTree::MatrixFixSize< 4,4 >,std::allocator< iDynTree::MatrixFixSize< 4,4 > > > *|std::vector< iDynTree::Matrix4x4,std::allocator< iDynTree::Matrix4x4 > > *", 0, 0, (void*)"iDynTree.Matrix4x4Vector", 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__PixelViz_std__allocatorT_iDynTree__PixelViz_t_t = {"_p_std__vectorT_iDynTree__PixelViz_std__allocatorT_iDynTree__PixelViz_t_t", "std::vector< iDynTree::PixelViz,std::allocator< iDynTree::PixelViz > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__Polygon_std__allocatorT_iDynTree__Polygon_t_t = {"_p_std__vectorT_iDynTree__Polygon_std__allocatorT_iDynTree__Polygon_t_t", "std::vector< iDynTree::Polygon,std::allocator< iDynTree::Polygon > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__Position_std__allocatorT_iDynTree__Position_t_t = {"_p_std__vectorT_iDynTree__Position_std__allocatorT_iDynTree__Position_t_t", "std::vector< iDynTree::Position,std::allocator< iDynTree::Position > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t = {"_p_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t", "std::vector< iDynTree::SolidShape * > *|std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > *", 0, 0, (void*)"iDynTree.SolidShapesVector", 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__Transform_std__allocatorT_iDynTree__Transform_t_t = {"_p_std__vectorT_iDynTree__Transform_std__allocatorT_iDynTree__Transform_t_t", "std::vector< iDynTree::Transform,std::allocator< iDynTree::Transform > > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t = {"_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t", "std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > > *|std::vector< iDynTree::VectorDynSize > *", 0, 0, (void*)"iDynTree.VectorDynSizeVector", 0};
+static swig_type_info _swigt__p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t = {"_p_std__vectorT_iDynTree__VectorDynSize_std__allocatorT_iDynTree__VectorDynSize_t_t", "std::vector< iDynTree::VectorDynSize,std::allocator< iDynTree::VectorDynSize > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__VectorFixSizeT_2_t_std__allocatorT_iDynTree__VectorFixSizeT_2_t_t_t = {"_p_std__vectorT_iDynTree__VectorFixSizeT_2_t_std__allocatorT_iDynTree__VectorFixSizeT_2_t_t_t", "std::vector< iDynTree::Vector2,std::allocator< iDynTree::Vector2 > > *|std::vector< iDynTree::VectorFixSize< 2 >,std::allocator< iDynTree::VectorFixSize< 2 > > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_iDynTree__VectorFixSizeT_6_t_std__allocatorT_iDynTree__VectorFixSizeT_6_t_t_t = {"_p_std__vectorT_iDynTree__VectorFixSizeT_6_t_std__allocatorT_iDynTree__VectorFixSizeT_6_t_t_t", "std::vector< iDynTree::Vector6,std::allocator< iDynTree::Vector6 > > *|std::vector< iDynTree::VectorFixSize< 6 >,std::allocator< iDynTree::VectorFixSize< 6 > > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_int_std__allocatorT_int_t_t = {"_p_std__vectorT_int_std__allocatorT_int_t_t", "std::vector< int,std::allocator< int > > *|std::vector< int > *", 0, 0, (void*)"iDynTree.IntVector", 0};
 static swig_type_info _swigt__p_std__vectorT_std__pairT_double_double_t_std__allocatorT_std__pairT_double_double_t_t_t = {"_p_std__vectorT_std__pairT_double_double_t_std__allocatorT_std__pairT_double_double_t_t_t", "std::vector< std::pair< double,double >,std::allocator< std::pair< double,double > > > *", 0, 0, (void*)0, 0};
-static swig_type_info _swigt__p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t = {"_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t", "std::vector< ::ptrdiff_t,std::allocator< ::ptrdiff_t > > *|std::vector< ::ptrdiff_t > *|std::vector< std::ptrdiff_t > *|std::vector< std::ptrdiff_t,std::allocator< std::ptrdiff_t > > *|std::vector< iDynTree::LinkIndex,std::allocator< iDynTree::LinkIndex > > *|std::vector< iDynTree::FrameIndex,std::allocator< iDynTree::FrameIndex > > *", 0, 0, (void*)"iDynTree.IndexVector", 0};
+static swig_type_info _swigt__p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t = {"_p_std__vectorT_std__ptrdiff_t_std__allocatorT_std__ptrdiff_t_t_t", "std::vector< std::ptrdiff_t,std::allocator< std::ptrdiff_t > > *|std::vector< iDynTree::FrameIndex,std::allocator< iDynTree::FrameIndex > > *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t = {"_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", "std::vector< std::string,std::allocator< std::string > > *|std::vector< std::string > *", 0, 0, (void*)"iDynTree.StringVector", 0};
 static swig_type_info _swigt__p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t = {"_p_std__vectorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t_t", "std::vector< std::vector< iDynTree::SolidShape * > > *|std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > >,std::allocator< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > > *|std::vector< std::vector< iDynTree::SolidShape *,std::allocator< iDynTree::SolidShape * > > > *", 0, 0, (void*)"iDynTree.LinksSolidShapesVector", 0};
 static swig_type_info _swigt__p_swig__MatlabSwigIterator = {"_p_swig__MatlabSwigIterator", "swig::MatlabSwigIterator *", 0, 0, (void*)"iDynTree.MatlabSwigIterator", 0};
 static swig_type_info _swigt__p_typed_iterator = {"_p_typed_iterator", "typed_iterator *", 0, 0, (void*)0, 0};
 static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
 
 static swig_type_info *swig_type_initial[] = {
@@ -114188,32 +109839,35 @@
   &_swigt__p_iDynTree__MovableJointImplT_5_5_t,
   &_swigt__p_iDynTree__MovableJointImplT_6_6_t,
   &_swigt__p_iDynTree__Neighbor,
   &_swigt__p_iDynTree__PixelViz,
   &_swigt__p_iDynTree__Polygon,
   &_swigt__p_iDynTree__Polygon2D,
   &_swigt__p_iDynTree__Position,
+  &_swigt__p_iDynTree__PositionRaw,
   &_swigt__p_iDynTree__PrismaticJoint,
   &_swigt__p_iDynTree__RevoluteJoint,
   &_swigt__p_iDynTree__RigidBodyInertiaNonLinearParametrization,
   &_swigt__p_iDynTree__Rotation,
-  &_swigt__p_iDynTree__RotationalInertia,
+  &_swigt__p_iDynTree__RotationRaw,
+  &_swigt__p_iDynTree__RotationalInertiaRaw,
   &_swigt__p_iDynTree__Sensor,
   &_swigt__p_iDynTree__SensorsList,
   &_swigt__p_iDynTree__SensorsMeasurements,
   &_swigt__p_iDynTree__SimpleLeggedOdometry,
   &_swigt__p_iDynTree__SixAxisForceTorqueSensor,
   &_swigt__p_iDynTree__SolidShape,
   &_swigt__p_iDynTree__SpanT_double__1_t,
   &_swigt__p_iDynTree__SpanT_double_const__1_t,
   &_swigt__p_iDynTree__SparseMatrixT_iDynTree__ColumnMajor_t,
   &_swigt__p_iDynTree__SparseMatrixT_iDynTree__RowMajor_t,
   &_swigt__p_iDynTree__SpatialAcc,
   &_swigt__p_iDynTree__SpatialForceVector,
   &_swigt__p_iDynTree__SpatialInertia,
+  &_swigt__p_iDynTree__SpatialInertiaRaw,
   &_swigt__p_iDynTree__SpatialMomentum,
   &_swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__AngularVector3Type,
   &_swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__LinearVector3Type,
   &_swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__AngularVector3Type,
   &_swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__LinearVector3Type,
   &_swigt__p_iDynTree__SpatialMotionVector,
   &_swigt__p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t,
@@ -114240,28 +109894,25 @@
   &_swigt__p_iDynTree__Wrench,
   &_swigt__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t,
   &_swigt__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t,
   &_swigt__p_iDynTree__estimateExternalWrenchesBuffers,
   &_swigt__p_index_type,
   &_swigt__p_iterator,
   &_swigt__p_pointer,
-  &_swigt__p_ptrdiff_t,
   &_swigt__p_reference,
   &_swigt__p_reverse_iterator,
   &_swigt__p_size_type,
   &_swigt__p_std__allocatorT_iDynTree__BerdyDynamicVariable_t,
   &_swigt__p_std__allocatorT_iDynTree__BerdySensor_t,
-  &_swigt__p_std__allocatorT_iDynTree__MatrixDynSize_t,
   &_swigt__p_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t,
   &_swigt__p_std__allocatorT_iDynTree__SolidShape_p_t,
-  &_swigt__p_std__allocatorT_iDynTree__VectorDynSize_t,
   &_swigt__p_std__allocatorT_int_t,
-  &_swigt__p_std__allocatorT_std__ptrdiff_t_t,
   &_swigt__p_std__allocatorT_std__string_t,
   &_swigt__p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t,
+  &_swigt__p_std__ptrdiff_t,
   &_swigt__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t_t,
   &_swigt__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t_t,
   &_swigt__p_std__size_t,
   &_swigt__p_std__string,
   &_swigt__p_std__vectorT_iDynTree__BerdyDynamicVariable_std__allocatorT_iDynTree__BerdyDynamicVariable_t_t,
   &_swigt__p_std__vectorT_iDynTree__BerdySensor_std__allocatorT_iDynTree__BerdySensor_t_t,
   &_swigt__p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t,
@@ -114366,15 +110017,15 @@
 static swig_cast_info _swigc__p_iDynTree__LinkVelArray[] = {  {&_swigt__p_iDynTree__LinkVelArray, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__LinkWrenches[] = {  {&_swigt__p_iDynTree__LinkWrenches, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Material[] = {  {&_swigt__p_iDynTree__Material, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixDynSize[] = {  {&_swigt__p_iDynTree__MatrixDynSize, 0, 0, 0},  {&_swigt__p_iDynTree__FrameFreeFloatingJacobian, _p_iDynTree__FrameFreeFloatingJacobianTo_p_iDynTree__MatrixDynSize, 0, 0},  {&_swigt__p_iDynTree__MomentumFreeFloatingJacobian, _p_iDynTree__MomentumFreeFloatingJacobianTo_p_iDynTree__MatrixDynSize, 0, 0},  {&_swigt__p_iDynTree__FreeFloatingMassMatrix, _p_iDynTree__FreeFloatingMassMatrixTo_p_iDynTree__MatrixDynSize, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_10_16_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_10_16_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_1_6_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_1_6_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_2_3_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_2_3_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_3_3_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_3_3_t, 0, 0, 0},  {&_swigt__p_iDynTree__RotationalInertia, _p_iDynTree__RotationalInertiaTo_p_iDynTree__MatrixFixSizeT_3_3_t, 0, 0},  {&_swigt__p_iDynTree__Rotation, _p_iDynTree__RotationTo_p_iDynTree__MatrixFixSizeT_3_3_t, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_3_3_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_3_3_t, 0, 0, 0},  {&_swigt__p_iDynTree__RotationalInertiaRaw, _p_iDynTree__RotationalInertiaRawTo_p_iDynTree__MatrixFixSizeT_3_3_t, 0, 0},  {&_swigt__p_iDynTree__RotationRaw, _p_iDynTree__RotationRawTo_p_iDynTree__MatrixFixSizeT_3_3_t, 0, 0},  {&_swigt__p_iDynTree__Rotation, _p_iDynTree__RotationTo_p_iDynTree__MatrixFixSizeT_3_3_t, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_3_4_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_3_4_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_4_3_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_4_3_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_4_4_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_4_4_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_6_10_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_6_10_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_6_1_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_6_1_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixFixSizeT_6_6_t[] = {  {&_swigt__p_iDynTree__MatrixFixSizeT_6_6_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MatrixViewT_double_const_t[] = {  {&_swigt__p_iDynTree__MatrixViewT_double_const_t, 0, 0, 0},{0, 0, 0, 0}};
@@ -114394,32 +110045,35 @@
 static swig_cast_info _swigc__p_iDynTree__MovableJointImplT_5_5_t[] = {  {&_swigt__p_iDynTree__MovableJointImplT_5_5_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__MovableJointImplT_6_6_t[] = {  {&_swigt__p_iDynTree__MovableJointImplT_6_6_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Neighbor[] = {  {&_swigt__p_iDynTree__Neighbor, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__PixelViz[] = {  {&_swigt__p_iDynTree__PixelViz, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Polygon[] = {  {&_swigt__p_iDynTree__Polygon, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Polygon2D[] = {  {&_swigt__p_iDynTree__Polygon2D, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Position[] = {  {&_swigt__p_iDynTree__Position, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_iDynTree__PositionRaw[] = {  {&_swigt__p_iDynTree__Position, _p_iDynTree__PositionTo_p_iDynTree__PositionRaw, 0, 0},  {&_swigt__p_iDynTree__PositionRaw, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__PrismaticJoint[] = {  {&_swigt__p_iDynTree__PrismaticJoint, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__RevoluteJoint[] = {  {&_swigt__p_iDynTree__RevoluteJoint, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__RigidBodyInertiaNonLinearParametrization[] = {  {&_swigt__p_iDynTree__RigidBodyInertiaNonLinearParametrization, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Rotation[] = {  {&_swigt__p_iDynTree__Rotation, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_iDynTree__RotationalInertia[] = {  {&_swigt__p_iDynTree__RotationalInertia, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_iDynTree__RotationRaw[] = {  {&_swigt__p_iDynTree__RotationRaw, 0, 0, 0},  {&_swigt__p_iDynTree__Rotation, _p_iDynTree__RotationTo_p_iDynTree__RotationRaw, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_iDynTree__RotationalInertiaRaw[] = {  {&_swigt__p_iDynTree__RotationalInertiaRaw, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Sensor[] = {  {&_swigt__p_iDynTree__JointSensor, _p_iDynTree__JointSensorTo_p_iDynTree__Sensor, 0, 0},  {&_swigt__p_iDynTree__AccelerometerSensor, _p_iDynTree__AccelerometerSensorTo_p_iDynTree__Sensor, 0, 0},  {&_swigt__p_iDynTree__ThreeAxisAngularAccelerometerSensor, _p_iDynTree__ThreeAxisAngularAccelerometerSensorTo_p_iDynTree__Sensor, 0, 0},  {&_swigt__p_iDynTree__ThreeAxisForceTorqueContactSensor, _p_iDynTree__ThreeAxisForceTorqueContactSensorTo_p_iDynTree__Sensor, 0, 0},  {&_swigt__p_iDynTree__Sensor, 0, 0, 0},  {&_swigt__p_iDynTree__SixAxisForceTorqueSensor, _p_iDynTree__SixAxisForceTorqueSensorTo_p_iDynTree__Sensor, 0, 0},  {&_swigt__p_iDynTree__LinkSensor, _p_iDynTree__LinkSensorTo_p_iDynTree__Sensor, 0, 0},  {&_swigt__p_iDynTree__GyroscopeSensor, _p_iDynTree__GyroscopeSensorTo_p_iDynTree__Sensor, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SensorsList[] = {  {&_swigt__p_iDynTree__SensorsList, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SensorsMeasurements[] = {  {&_swigt__p_iDynTree__SensorsMeasurements, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SimpleLeggedOdometry[] = {  {&_swigt__p_iDynTree__SimpleLeggedOdometry, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SixAxisForceTorqueSensor[] = {  {&_swigt__p_iDynTree__SixAxisForceTorqueSensor, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SolidShape[] = {  {&_swigt__p_iDynTree__SolidShape, 0, 0, 0},  {&_swigt__p_iDynTree__ExternalMesh, _p_iDynTree__ExternalMeshTo_p_iDynTree__SolidShape, 0, 0},  {&_swigt__p_iDynTree__Box, _p_iDynTree__BoxTo_p_iDynTree__SolidShape, 0, 0},  {&_swigt__p_iDynTree__Cylinder, _p_iDynTree__CylinderTo_p_iDynTree__SolidShape, 0, 0},  {&_swigt__p_iDynTree__Sphere, _p_iDynTree__SphereTo_p_iDynTree__SolidShape, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpanT_double__1_t[] = {  {&_swigt__p_iDynTree__SpanT_double__1_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpanT_double_const__1_t[] = {  {&_swigt__p_iDynTree__SpanT_double_const__1_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SparseMatrixT_iDynTree__ColumnMajor_t[] = {  {&_swigt__p_iDynTree__SparseMatrixT_iDynTree__ColumnMajor_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SparseMatrixT_iDynTree__RowMajor_t[] = {  {&_swigt__p_iDynTree__SparseMatrixT_iDynTree__RowMajor_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialAcc[] = {  {&_swigt__p_iDynTree__SpatialAcc, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialForceVector[] = {  {&_swigt__p_iDynTree__SpatialForceVector, 0, 0, 0},  {&_swigt__p_iDynTree__Wrench, _p_iDynTree__WrenchTo_p_iDynTree__SpatialForceVector, 0, 0},  {&_swigt__p_iDynTree__SpatialMomentum, _p_iDynTree__SpatialMomentumTo_p_iDynTree__SpatialForceVector, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialInertia[] = {  {&_swigt__p_iDynTree__SpatialInertia, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_iDynTree__SpatialInertiaRaw[] = {  {&_swigt__p_iDynTree__SpatialInertia, _p_iDynTree__SpatialInertiaTo_p_iDynTree__SpatialInertiaRaw, 0, 0},  {&_swigt__p_iDynTree__SpatialInertiaRaw, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialMomentum[] = {  {&_swigt__p_iDynTree__SpatialMomentum, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__AngularVector3Type[] = {  {&_swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__AngularVector3Type, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__LinearVector3Type[] = {  {&_swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__LinearVector3Type, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__AngularVector3Type[] = {  {&_swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__AngularVector3Type, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__LinearVector3Type[] = {  {&_swigt__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__LinearVector3Type, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialMotionVector[] = {  {&_swigt__p_iDynTree__SpatialMotionVector, 0, 0, 0},  {&_swigt__p_iDynTree__Twist, _p_iDynTree__TwistTo_p_iDynTree__SpatialMotionVector, 0, 0},  {&_swigt__p_iDynTree__SpatialAcc, _p_iDynTree__SpatialAccTo_p_iDynTree__SpatialMotionVector, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t[] = {  {&_swigt__p_iDynTree__Wrench, _p_iDynTree__WrenchTo_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t, 0, 0},  {&_swigt__p_iDynTree__SpatialForceVector, _p_iDynTree__SpatialForceVectorTo_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t, 0, 0},  {&_swigt__p_iDynTree__SpatialMomentum, _p_iDynTree__SpatialMomentumTo_p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t, 0, 0},  {&_swigt__p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t, 0, 0, 0},{0, 0, 0, 0}};
@@ -114434,40 +110088,37 @@
 static swig_cast_info _swigc__p_iDynTree__Triplets[] = {  {&_swigt__p_iDynTree__Triplets, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Twist[] = {  {&_swigt__p_iDynTree__Twist, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__UnknownWrenchContact[] = {  {&_swigt__p_iDynTree__UnknownWrenchContact, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__VectorDynSize[] = {  {&_swigt__p_iDynTree__VectorDynSize, 0, 0, 0},  {&_swigt__p_iDynTree__JointPosDoubleArray, _p_iDynTree__JointPosDoubleArrayTo_p_iDynTree__VectorDynSize, 0, 0},  {&_swigt__p_iDynTree__JointDOFsDoubleArray, _p_iDynTree__JointDOFsDoubleArrayTo_p_iDynTree__VectorDynSize, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__VectorFixSizeT_10_t[] = {  {&_swigt__p_iDynTree__VectorFixSizeT_10_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__VectorFixSizeT_16_t[] = {  {&_swigt__p_iDynTree__VectorFixSizeT_16_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__VectorFixSizeT_2_t[] = {  {&_swigt__p_iDynTree__VectorFixSizeT_2_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_iDynTree__VectorFixSizeT_3_t[] = {  {&_swigt__p_iDynTree__Position, _p_iDynTree__PositionTo_p_iDynTree__VectorFixSizeT_3_t, 0, 0},  {&_swigt__p_iDynTree__VectorFixSizeT_3_t, 0, 0, 0},  {&_swigt__p_iDynTree__GeomVector3, _p_iDynTree__GeomVector3To_p_iDynTree__VectorFixSizeT_3_t, 0, 0},  {&_swigt__p_iDynTree__Direction, _p_iDynTree__DirectionTo_p_iDynTree__VectorFixSizeT_3_t, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_iDynTree__VectorFixSizeT_3_t[] = {  {&_swigt__p_iDynTree__Position, _p_iDynTree__PositionTo_p_iDynTree__VectorFixSizeT_3_t, 0, 0},  {&_swigt__p_iDynTree__VectorFixSizeT_3_t, 0, 0, 0},  {&_swigt__p_iDynTree__PositionRaw, _p_iDynTree__PositionRawTo_p_iDynTree__VectorFixSizeT_3_t, 0, 0},  {&_swigt__p_iDynTree__GeomVector3, _p_iDynTree__GeomVector3To_p_iDynTree__VectorFixSizeT_3_t, 0, 0},  {&_swigt__p_iDynTree__Direction, _p_iDynTree__DirectionTo_p_iDynTree__VectorFixSizeT_3_t, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__VectorFixSizeT_4_t[] = {  {&_swigt__p_iDynTree__VectorFixSizeT_4_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__VectorFixSizeT_6_t[] = {  {&_swigt__p_iDynTree__ClassicalAcc, _p_iDynTree__ClassicalAccTo_p_iDynTree__VectorFixSizeT_6_t, 0, 0},  {&_swigt__p_iDynTree__VectorFixSizeT_6_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Visualizer[] = {  {&_swigt__p_iDynTree__Visualizer, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__VisualizerOptions[] = {  {&_swigt__p_iDynTree__VisualizerOptions, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__Wrench[] = {  {&_swigt__p_iDynTree__Wrench, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t[] = {  {&_swigt__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t[] = {  {&_swigt__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iDynTree__estimateExternalWrenchesBuffers[] = {  {&_swigt__p_iDynTree__estimateExternalWrenchesBuffers, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_index_type[] = {  {&_swigt__p_index_type, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_iterator[] = {  {&_swigt__p_iterator, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_pointer[] = {  {&_swigt__p_pointer, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_ptrdiff_t[] = {  {&_swigt__p_ptrdiff_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_reference[] = {  {&_swigt__p_reference, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_reverse_iterator[] = {  {&_swigt__p_reverse_iterator, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__allocatorT_iDynTree__BerdyDynamicVariable_t[] = {  {&_swigt__p_std__allocatorT_iDynTree__BerdyDynamicVariable_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__allocatorT_iDynTree__BerdySensor_t[] = {  {&_swigt__p_std__allocatorT_iDynTree__BerdySensor_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__allocatorT_iDynTree__MatrixDynSize_t[] = {  {&_swigt__p_std__allocatorT_iDynTree__MatrixDynSize_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t[] = {  {&_swigt__p_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__allocatorT_iDynTree__SolidShape_p_t[] = {  {&_swigt__p_std__allocatorT_iDynTree__SolidShape_p_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__allocatorT_iDynTree__VectorDynSize_t[] = {  {&_swigt__p_std__allocatorT_iDynTree__VectorDynSize_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__allocatorT_int_t[] = {  {&_swigt__p_std__allocatorT_int_t, 0, 0, 0},{0, 0, 0, 0}};
-static swig_cast_info _swigc__p_std__allocatorT_std__ptrdiff_t_t[] = {  {&_swigt__p_std__allocatorT_std__ptrdiff_t_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__allocatorT_std__string_t[] = {  {&_swigt__p_std__allocatorT_std__string_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t[] = {  {&_swigt__p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
+static swig_cast_info _swigc__p_std__ptrdiff_t[] = {  {&_swigt__p_std__ptrdiff_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t_t[] = {  {&_swigt__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t_t[] = {  {&_swigt__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__size_t[] = {  {&_swigt__p_std__size_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__vectorT_iDynTree__BerdyDynamicVariable_std__allocatorT_iDynTree__BerdyDynamicVariable_t_t[] = {  {&_swigt__p_std__vectorT_iDynTree__BerdyDynamicVariable_std__allocatorT_iDynTree__BerdyDynamicVariable_t_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__vectorT_iDynTree__BerdySensor_std__allocatorT_iDynTree__BerdySensor_t_t[] = {  {&_swigt__p_std__vectorT_iDynTree__BerdySensor_std__allocatorT_iDynTree__BerdySensor_t_t, 0, 0, 0},{0, 0, 0, 0}};
 static swig_cast_info _swigc__p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t[] = {  {&_swigt__p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t, 0, 0, 0},{0, 0, 0, 0}};
@@ -114600,32 +110251,35 @@
   _swigc__p_iDynTree__MovableJointImplT_5_5_t,
   _swigc__p_iDynTree__MovableJointImplT_6_6_t,
   _swigc__p_iDynTree__Neighbor,
   _swigc__p_iDynTree__PixelViz,
   _swigc__p_iDynTree__Polygon,
   _swigc__p_iDynTree__Polygon2D,
   _swigc__p_iDynTree__Position,
+  _swigc__p_iDynTree__PositionRaw,
   _swigc__p_iDynTree__PrismaticJoint,
   _swigc__p_iDynTree__RevoluteJoint,
   _swigc__p_iDynTree__RigidBodyInertiaNonLinearParametrization,
   _swigc__p_iDynTree__Rotation,
-  _swigc__p_iDynTree__RotationalInertia,
+  _swigc__p_iDynTree__RotationRaw,
+  _swigc__p_iDynTree__RotationalInertiaRaw,
   _swigc__p_iDynTree__Sensor,
   _swigc__p_iDynTree__SensorsList,
   _swigc__p_iDynTree__SensorsMeasurements,
   _swigc__p_iDynTree__SimpleLeggedOdometry,
   _swigc__p_iDynTree__SixAxisForceTorqueSensor,
   _swigc__p_iDynTree__SolidShape,
   _swigc__p_iDynTree__SpanT_double__1_t,
   _swigc__p_iDynTree__SpanT_double_const__1_t,
   _swigc__p_iDynTree__SparseMatrixT_iDynTree__ColumnMajor_t,
   _swigc__p_iDynTree__SparseMatrixT_iDynTree__RowMajor_t,
   _swigc__p_iDynTree__SpatialAcc,
   _swigc__p_iDynTree__SpatialForceVector,
   _swigc__p_iDynTree__SpatialInertia,
+  _swigc__p_iDynTree__SpatialInertiaRaw,
   _swigc__p_iDynTree__SpatialMomentum,
   _swigc__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__AngularVector3Type,
   _swigc__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialForceVector_t__LinearVector3Type,
   _swigc__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__AngularVector3Type,
   _swigc__p_iDynTree__SpatialMotionForceVectorT_traitsT_iDynTree__SpatialMotionVector_t__LinearVector3Type,
   _swigc__p_iDynTree__SpatialMotionVector,
   _swigc__p_iDynTree__SpatialVectorT_iDynTree__SpatialForceVector_t,
@@ -114652,28 +110306,25 @@
   _swigc__p_iDynTree__Wrench,
   _swigc__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t,
   _swigc__p_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t,
   _swigc__p_iDynTree__estimateExternalWrenchesBuffers,
   _swigc__p_index_type,
   _swigc__p_iterator,
   _swigc__p_pointer,
-  _swigc__p_ptrdiff_t,
   _swigc__p_reference,
   _swigc__p_reverse_iterator,
   _swigc__p_size_type,
   _swigc__p_std__allocatorT_iDynTree__BerdyDynamicVariable_t,
   _swigc__p_std__allocatorT_iDynTree__BerdySensor_t,
-  _swigc__p_std__allocatorT_iDynTree__MatrixDynSize_t,
   _swigc__p_std__allocatorT_iDynTree__MatrixFixSizeT_4_4_t_t,
   _swigc__p_std__allocatorT_iDynTree__SolidShape_p_t,
-  _swigc__p_std__allocatorT_iDynTree__VectorDynSize_t,
   _swigc__p_std__allocatorT_int_t,
-  _swigc__p_std__allocatorT_std__ptrdiff_t_t,
   _swigc__p_std__allocatorT_std__string_t,
   _swigc__p_std__allocatorT_std__vectorT_iDynTree__SolidShape_p_std__allocatorT_iDynTree__SolidShape_p_t_t_t,
+  _swigc__p_std__ptrdiff_t,
   _swigc__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_false_t_t,
   _swigc__p_std__reverse_iteratorT_iDynTree__details__span_iteratorT_iDynTree__SpanT_double__1_t_true_t_t,
   _swigc__p_std__size_t,
   _swigc__p_std__string,
   _swigc__p_std__vectorT_iDynTree__BerdyDynamicVariable_std__allocatorT_iDynTree__BerdyDynamicVariable_t_t,
   _swigc__p_std__vectorT_iDynTree__BerdySensor_std__allocatorT_iDynTree__BerdySensor_t_t,
   _swigc__p_std__vectorT_iDynTree__MatrixDynSize_std__allocatorT_iDynTree__MatrixDynSize_t_t,
@@ -114950,56 +110601,54 @@
 }
 
 
 SWIGINTERN const char* SwigConstantName(int con_id) {
   switch (con_id) {
   case 0: return "RowMajor";
   case 1: return "ColumnMajor";
-  case 2: return "NoJointDynamics";
-  case 3: return "URDFJointDynamics";
-  case 4: return "SIX_AXIS_FORCE_TORQUE";
-  case 5: return "ACCELEROMETER";
-  case 6: return "GYROSCOPE";
-  case 7: return "THREE_AXIS_ANGULAR_ACCELEROMETER";
-  case 8: return "THREE_AXIS_FORCE_TORQUE_CONTACT";
-  case 9: return "INERTIAL_FIXED_REPRESENTATION";
-  case 10: return "BODY_FIXED_REPRESENTATION";
-  case 11: return "MIXED_REPRESENTATION";
-  case 12: return "FULL_WRENCH";
-  case 13: return "PURE_FORCE";
-  case 14: return "PURE_FORCE_WITH_KNOWN_DIRECTION";
-  case 15: return "NO_UNKNOWNS";
-  case 16: return "ORIGINAL_BERDY_FIXED_BASE";
-  case 17: return "BERDY_FLOATING_BASE";
-  case 18: return "BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES";
-  case 19: return "LINK_BODY_PROPER_ACCELERATION";
-  case 20: return "NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV";
-  case 21: return "JOINT_WRENCH";
-  case 22: return "DOF_TORQUE";
-  case 23: return "NET_EXT_WRENCH";
-  case 24: return "DOF_ACCELERATION";
-  case 25: return "LINK_BODY_PROPER_CLASSICAL_ACCELERATION";
-  case 26: return "SIX_AXIS_FORCE_TORQUE_SENSOR";
-  case 27: return "ACCELEROMETER_SENSOR";
-  case 28: return "GYROSCOPE_SENSOR";
-  case 29: return "THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR";
-  case 30: return "THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR";
-  case 31: return "DOF_ACCELERATION_SENSOR";
-  case 32: return "DOF_TORQUE_SENSOR";
-  case 33: return "NET_EXT_WRENCH_SENSOR";
-  case 34: return "JOINT_WRENCH_SENSOR";
-  case 35: return "RCM_SENSOR";
-  case 36: return "POINT_LIGHT";
-  case 37: return "DIRECTIONAL_LIGHT";
-  case 38: return "InverseKinematicsRotationParametrizationQuaternion";
-  case 39: return "InverseKinematicsRotationParametrizationRollPitchYaw";
-  case 40: return "InverseKinematicsTreatTargetAsConstraintNone";
-  case 41: return "InverseKinematicsTreatTargetAsConstraintPositionOnly";
-  case 42: return "InverseKinematicsTreatTargetAsConstraintRotationOnly";
-  case 43: return "InverseKinematicsTreatTargetAsConstraintFull";
+  case 2: return "INERTIAL_FIXED_REPRESENTATION";
+  case 3: return "BODY_FIXED_REPRESENTATION";
+  case 4: return "MIXED_REPRESENTATION";
+  case 5: return "SIX_AXIS_FORCE_TORQUE";
+  case 6: return "ACCELEROMETER";
+  case 7: return "GYROSCOPE";
+  case 8: return "THREE_AXIS_ANGULAR_ACCELEROMETER";
+  case 9: return "THREE_AXIS_FORCE_TORQUE_CONTACT";
+  case 10: return "FULL_WRENCH";
+  case 11: return "PURE_FORCE";
+  case 12: return "PURE_FORCE_WITH_KNOWN_DIRECTION";
+  case 13: return "NO_UNKNOWNS";
+  case 14: return "ORIGINAL_BERDY_FIXED_BASE";
+  case 15: return "BERDY_FLOATING_BASE";
+  case 16: return "BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES";
+  case 17: return "LINK_BODY_PROPER_ACCELERATION";
+  case 18: return "NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV";
+  case 19: return "JOINT_WRENCH";
+  case 20: return "DOF_TORQUE";
+  case 21: return "NET_EXT_WRENCH";
+  case 22: return "DOF_ACCELERATION";
+  case 23: return "LINK_BODY_PROPER_CLASSICAL_ACCELERATION";
+  case 24: return "SIX_AXIS_FORCE_TORQUE_SENSOR";
+  case 25: return "ACCELEROMETER_SENSOR";
+  case 26: return "GYROSCOPE_SENSOR";
+  case 27: return "THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR";
+  case 28: return "THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR";
+  case 29: return "DOF_ACCELERATION_SENSOR";
+  case 30: return "DOF_TORQUE_SENSOR";
+  case 31: return "NET_EXT_WRENCH_SENSOR";
+  case 32: return "JOINT_WRENCH_SENSOR";
+  case 33: return "RCM_SENSOR";
+  case 34: return "POINT_LIGHT";
+  case 35: return "DIRECTIONAL_LIGHT";
+  case 36: return "InverseKinematicsRotationParametrizationQuaternion";
+  case 37: return "InverseKinematicsRotationParametrizationRollPitchYaw";
+  case 38: return "InverseKinematicsTreatTargetAsConstraintNone";
+  case 39: return "InverseKinematicsTreatTargetAsConstraintPositionOnly";
+  case 40: return "InverseKinematicsTreatTargetAsConstraintRotationOnly";
+  case 41: return "InverseKinematicsTreatTargetAsConstraintFull";
   default: return 0;
   }
 }
 
 SWIGINTERN int swigConstantName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   if (argc!=1 || !mxIsDouble(*argv) || mxGetNumberOfElements(*argv)!=1) {
     SWIG_Error(SWIG_RuntimeError, "This mex file should only be called from inside the .m files generated by SWIG. The input should be the constant ID.");
@@ -115024,56 +110673,54 @@
     SWIG_Error(SWIG_RuntimeError, "This function should only be called from inside the .m files generated by SWIG. First input should be the constant ID .");
     return 1;
   }
   int con_id = (int)mxGetScalar(*argv++);
   switch (con_id) {
   case 0: *resv = SWIG_Matlab_SetConstant(module_ns,"RowMajor",SWIG_From_int(static_cast< int >(iDynTree::RowMajor)));; break;
   case 1: *resv = SWIG_Matlab_SetConstant(module_ns,"ColumnMajor",SWIG_From_int(static_cast< int >(iDynTree::ColumnMajor)));; break;
-  case 2: *resv = SWIG_Matlab_SetConstant(module_ns,"NoJointDynamics",SWIG_From_int(static_cast< int >(iDynTree::NoJointDynamics)));; break;
-  case 3: *resv = SWIG_Matlab_SetConstant(module_ns,"URDFJointDynamics",SWIG_From_int(static_cast< int >(iDynTree::URDFJointDynamics)));; break;
-  case 4: *resv = SWIG_Matlab_SetConstant(module_ns,"SIX_AXIS_FORCE_TORQUE",SWIG_From_int(static_cast< int >(iDynTree::SIX_AXIS_FORCE_TORQUE)));; break;
-  case 5: *resv = SWIG_Matlab_SetConstant(module_ns,"ACCELEROMETER",SWIG_From_int(static_cast< int >(iDynTree::ACCELEROMETER)));; break;
-  case 6: *resv = SWIG_Matlab_SetConstant(module_ns,"GYROSCOPE",SWIG_From_int(static_cast< int >(iDynTree::GYROSCOPE)));; break;
-  case 7: *resv = SWIG_Matlab_SetConstant(module_ns,"THREE_AXIS_ANGULAR_ACCELEROMETER",SWIG_From_int(static_cast< int >(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER)));; break;
-  case 8: *resv = SWIG_Matlab_SetConstant(module_ns,"THREE_AXIS_FORCE_TORQUE_CONTACT",SWIG_From_int(static_cast< int >(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT)));; break;
-  case 9: *resv = SWIG_Matlab_SetConstant(module_ns,"INERTIAL_FIXED_REPRESENTATION",SWIG_From_int(static_cast< int >(iDynTree::INERTIAL_FIXED_REPRESENTATION)));; break;
-  case 10: *resv = SWIG_Matlab_SetConstant(module_ns,"BODY_FIXED_REPRESENTATION",SWIG_From_int(static_cast< int >(iDynTree::BODY_FIXED_REPRESENTATION)));; break;
-  case 11: *resv = SWIG_Matlab_SetConstant(module_ns,"MIXED_REPRESENTATION",SWIG_From_int(static_cast< int >(iDynTree::MIXED_REPRESENTATION)));; break;
-  case 12: *resv = SWIG_Matlab_SetConstant(module_ns,"FULL_WRENCH",SWIG_From_int(static_cast< int >(iDynTree::FULL_WRENCH)));; break;
-  case 13: *resv = SWIG_Matlab_SetConstant(module_ns,"PURE_FORCE",SWIG_From_int(static_cast< int >(iDynTree::PURE_FORCE)));; break;
-  case 14: *resv = SWIG_Matlab_SetConstant(module_ns,"PURE_FORCE_WITH_KNOWN_DIRECTION",SWIG_From_int(static_cast< int >(iDynTree::PURE_FORCE_WITH_KNOWN_DIRECTION)));; break;
-  case 15: *resv = SWIG_Matlab_SetConstant(module_ns,"NO_UNKNOWNS",SWIG_From_int(static_cast< int >(iDynTree::NO_UNKNOWNS)));; break;
-  case 16: *resv = SWIG_Matlab_SetConstant(module_ns,"ORIGINAL_BERDY_FIXED_BASE",SWIG_From_int(static_cast< int >(iDynTree::ORIGINAL_BERDY_FIXED_BASE)));; break;
-  case 17: *resv = SWIG_Matlab_SetConstant(module_ns,"BERDY_FLOATING_BASE",SWIG_From_int(static_cast< int >(iDynTree::BERDY_FLOATING_BASE)));; break;
-  case 18: *resv = SWIG_Matlab_SetConstant(module_ns,"BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES",SWIG_From_int(static_cast< int >(iDynTree::BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES)));; break;
-  case 19: *resv = SWIG_Matlab_SetConstant(module_ns,"LINK_BODY_PROPER_ACCELERATION",SWIG_From_int(static_cast< int >(iDynTree::LINK_BODY_PROPER_ACCELERATION)));; break;
-  case 20: *resv = SWIG_Matlab_SetConstant(module_ns,"NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV",SWIG_From_int(static_cast< int >(iDynTree::NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV)));; break;
-  case 21: *resv = SWIG_Matlab_SetConstant(module_ns,"JOINT_WRENCH",SWIG_From_int(static_cast< int >(iDynTree::JOINT_WRENCH)));; break;
-  case 22: *resv = SWIG_Matlab_SetConstant(module_ns,"DOF_TORQUE",SWIG_From_int(static_cast< int >(iDynTree::DOF_TORQUE)));; break;
-  case 23: *resv = SWIG_Matlab_SetConstant(module_ns,"NET_EXT_WRENCH",SWIG_From_int(static_cast< int >(iDynTree::NET_EXT_WRENCH)));; break;
-  case 24: *resv = SWIG_Matlab_SetConstant(module_ns,"DOF_ACCELERATION",SWIG_From_int(static_cast< int >(iDynTree::DOF_ACCELERATION)));; break;
-  case 25: *resv = SWIG_Matlab_SetConstant(module_ns,"LINK_BODY_PROPER_CLASSICAL_ACCELERATION",SWIG_From_int(static_cast< int >(iDynTree::LINK_BODY_PROPER_CLASSICAL_ACCELERATION)));; break;
-  case 26: *resv = SWIG_Matlab_SetConstant(module_ns,"SIX_AXIS_FORCE_TORQUE_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::SIX_AXIS_FORCE_TORQUE_SENSOR)));; break;
-  case 27: *resv = SWIG_Matlab_SetConstant(module_ns,"ACCELEROMETER_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::ACCELEROMETER_SENSOR)));; break;
-  case 28: *resv = SWIG_Matlab_SetConstant(module_ns,"GYROSCOPE_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::GYROSCOPE_SENSOR)));; break;
-  case 29: *resv = SWIG_Matlab_SetConstant(module_ns,"THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR)));; break;
-  case 30: *resv = SWIG_Matlab_SetConstant(module_ns,"THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR)));; break;
-  case 31: *resv = SWIG_Matlab_SetConstant(module_ns,"DOF_ACCELERATION_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::DOF_ACCELERATION_SENSOR)));; break;
-  case 32: *resv = SWIG_Matlab_SetConstant(module_ns,"DOF_TORQUE_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::DOF_TORQUE_SENSOR)));; break;
-  case 33: *resv = SWIG_Matlab_SetConstant(module_ns,"NET_EXT_WRENCH_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::NET_EXT_WRENCH_SENSOR)));; break;
-  case 34: *resv = SWIG_Matlab_SetConstant(module_ns,"JOINT_WRENCH_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::JOINT_WRENCH_SENSOR)));; break;
-  case 35: *resv = SWIG_Matlab_SetConstant(module_ns,"RCM_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::RCM_SENSOR)));; break;
-  case 36: *resv = SWIG_Matlab_SetConstant(module_ns,"POINT_LIGHT",SWIG_From_int(static_cast< int >(iDynTree::POINT_LIGHT)));; break;
-  case 37: *resv = SWIG_Matlab_SetConstant(module_ns,"DIRECTIONAL_LIGHT",SWIG_From_int(static_cast< int >(iDynTree::DIRECTIONAL_LIGHT)));; break;
-  case 38: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsRotationParametrizationQuaternion",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsRotationParametrizationQuaternion)));; break;
-  case 39: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsRotationParametrizationRollPitchYaw",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsRotationParametrizationRollPitchYaw)));; break;
-  case 40: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsTreatTargetAsConstraintNone",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsTreatTargetAsConstraintNone)));; break;
-  case 41: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsTreatTargetAsConstraintPositionOnly",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsTreatTargetAsConstraintPositionOnly)));; break;
-  case 42: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsTreatTargetAsConstraintRotationOnly",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsTreatTargetAsConstraintRotationOnly)));; break;
-  case 43: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsTreatTargetAsConstraintFull",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsTreatTargetAsConstraintFull)));; break;
+  case 2: *resv = SWIG_Matlab_SetConstant(module_ns,"INERTIAL_FIXED_REPRESENTATION",SWIG_From_int(static_cast< int >(iDynTree::INERTIAL_FIXED_REPRESENTATION)));; break;
+  case 3: *resv = SWIG_Matlab_SetConstant(module_ns,"BODY_FIXED_REPRESENTATION",SWIG_From_int(static_cast< int >(iDynTree::BODY_FIXED_REPRESENTATION)));; break;
+  case 4: *resv = SWIG_Matlab_SetConstant(module_ns,"MIXED_REPRESENTATION",SWIG_From_int(static_cast< int >(iDynTree::MIXED_REPRESENTATION)));; break;
+  case 5: *resv = SWIG_Matlab_SetConstant(module_ns,"SIX_AXIS_FORCE_TORQUE",SWIG_From_int(static_cast< int >(iDynTree::SIX_AXIS_FORCE_TORQUE)));; break;
+  case 6: *resv = SWIG_Matlab_SetConstant(module_ns,"ACCELEROMETER",SWIG_From_int(static_cast< int >(iDynTree::ACCELEROMETER)));; break;
+  case 7: *resv = SWIG_Matlab_SetConstant(module_ns,"GYROSCOPE",SWIG_From_int(static_cast< int >(iDynTree::GYROSCOPE)));; break;
+  case 8: *resv = SWIG_Matlab_SetConstant(module_ns,"THREE_AXIS_ANGULAR_ACCELEROMETER",SWIG_From_int(static_cast< int >(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER)));; break;
+  case 9: *resv = SWIG_Matlab_SetConstant(module_ns,"THREE_AXIS_FORCE_TORQUE_CONTACT",SWIG_From_int(static_cast< int >(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT)));; break;
+  case 10: *resv = SWIG_Matlab_SetConstant(module_ns,"FULL_WRENCH",SWIG_From_int(static_cast< int >(iDynTree::FULL_WRENCH)));; break;
+  case 11: *resv = SWIG_Matlab_SetConstant(module_ns,"PURE_FORCE",SWIG_From_int(static_cast< int >(iDynTree::PURE_FORCE)));; break;
+  case 12: *resv = SWIG_Matlab_SetConstant(module_ns,"PURE_FORCE_WITH_KNOWN_DIRECTION",SWIG_From_int(static_cast< int >(iDynTree::PURE_FORCE_WITH_KNOWN_DIRECTION)));; break;
+  case 13: *resv = SWIG_Matlab_SetConstant(module_ns,"NO_UNKNOWNS",SWIG_From_int(static_cast< int >(iDynTree::NO_UNKNOWNS)));; break;
+  case 14: *resv = SWIG_Matlab_SetConstant(module_ns,"ORIGINAL_BERDY_FIXED_BASE",SWIG_From_int(static_cast< int >(iDynTree::ORIGINAL_BERDY_FIXED_BASE)));; break;
+  case 15: *resv = SWIG_Matlab_SetConstant(module_ns,"BERDY_FLOATING_BASE",SWIG_From_int(static_cast< int >(iDynTree::BERDY_FLOATING_BASE)));; break;
+  case 16: *resv = SWIG_Matlab_SetConstant(module_ns,"BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES",SWIG_From_int(static_cast< int >(iDynTree::BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES)));; break;
+  case 17: *resv = SWIG_Matlab_SetConstant(module_ns,"LINK_BODY_PROPER_ACCELERATION",SWIG_From_int(static_cast< int >(iDynTree::LINK_BODY_PROPER_ACCELERATION)));; break;
+  case 18: *resv = SWIG_Matlab_SetConstant(module_ns,"NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV",SWIG_From_int(static_cast< int >(iDynTree::NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV)));; break;
+  case 19: *resv = SWIG_Matlab_SetConstant(module_ns,"JOINT_WRENCH",SWIG_From_int(static_cast< int >(iDynTree::JOINT_WRENCH)));; break;
+  case 20: *resv = SWIG_Matlab_SetConstant(module_ns,"DOF_TORQUE",SWIG_From_int(static_cast< int >(iDynTree::DOF_TORQUE)));; break;
+  case 21: *resv = SWIG_Matlab_SetConstant(module_ns,"NET_EXT_WRENCH",SWIG_From_int(static_cast< int >(iDynTree::NET_EXT_WRENCH)));; break;
+  case 22: *resv = SWIG_Matlab_SetConstant(module_ns,"DOF_ACCELERATION",SWIG_From_int(static_cast< int >(iDynTree::DOF_ACCELERATION)));; break;
+  case 23: *resv = SWIG_Matlab_SetConstant(module_ns,"LINK_BODY_PROPER_CLASSICAL_ACCELERATION",SWIG_From_int(static_cast< int >(iDynTree::LINK_BODY_PROPER_CLASSICAL_ACCELERATION)));; break;
+  case 24: *resv = SWIG_Matlab_SetConstant(module_ns,"SIX_AXIS_FORCE_TORQUE_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::SIX_AXIS_FORCE_TORQUE_SENSOR)));; break;
+  case 25: *resv = SWIG_Matlab_SetConstant(module_ns,"ACCELEROMETER_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::ACCELEROMETER_SENSOR)));; break;
+  case 26: *resv = SWIG_Matlab_SetConstant(module_ns,"GYROSCOPE_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::GYROSCOPE_SENSOR)));; break;
+  case 27: *resv = SWIG_Matlab_SetConstant(module_ns,"THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER_SENSOR)));; break;
+  case 28: *resv = SWIG_Matlab_SetConstant(module_ns,"THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR)));; break;
+  case 29: *resv = SWIG_Matlab_SetConstant(module_ns,"DOF_ACCELERATION_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::DOF_ACCELERATION_SENSOR)));; break;
+  case 30: *resv = SWIG_Matlab_SetConstant(module_ns,"DOF_TORQUE_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::DOF_TORQUE_SENSOR)));; break;
+  case 31: *resv = SWIG_Matlab_SetConstant(module_ns,"NET_EXT_WRENCH_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::NET_EXT_WRENCH_SENSOR)));; break;
+  case 32: *resv = SWIG_Matlab_SetConstant(module_ns,"JOINT_WRENCH_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::JOINT_WRENCH_SENSOR)));; break;
+  case 33: *resv = SWIG_Matlab_SetConstant(module_ns,"RCM_SENSOR",SWIG_From_int(static_cast< int >(iDynTree::RCM_SENSOR)));; break;
+  case 34: *resv = SWIG_Matlab_SetConstant(module_ns,"POINT_LIGHT",SWIG_From_int(static_cast< int >(iDynTree::POINT_LIGHT)));; break;
+  case 35: *resv = SWIG_Matlab_SetConstant(module_ns,"DIRECTIONAL_LIGHT",SWIG_From_int(static_cast< int >(iDynTree::DIRECTIONAL_LIGHT)));; break;
+  case 36: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsRotationParametrizationQuaternion",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsRotationParametrizationQuaternion)));; break;
+  case 37: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsRotationParametrizationRollPitchYaw",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsRotationParametrizationRollPitchYaw)));; break;
+  case 38: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsTreatTargetAsConstraintNone",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsTreatTargetAsConstraintNone)));; break;
+  case 39: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsTreatTargetAsConstraintPositionOnly",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsTreatTargetAsConstraintPositionOnly)));; break;
+  case 40: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsTreatTargetAsConstraintRotationOnly",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsTreatTargetAsConstraintRotationOnly)));; break;
+  case 41: *resv = SWIG_Matlab_SetConstant(module_ns,"InverseKinematicsTreatTargetAsConstraintFull",SWIG_From_int(static_cast< int >(iDynTree::InverseKinematicsTreatTargetAsConstraintFull)));; break;
   default:
     SWIG_Error(SWIG_RuntimeError, "No such constant.");
     return 1;
   }
   return 0;
 }
 
@@ -115146,2138 +110793,2055 @@
   case 64: return "IntVector_back";
   case 65: return "IntVector_assign";
   case 66: return "IntVector_resize";
   case 67: return "IntVector_insert";
   case 68: return "IntVector_reserve";
   case 69: return "IntVector_capacity";
   case 70: return "delete_IntVector";
-  case 71: return "MatrixDynSizeVector_pop";
-  case 72: return "MatrixDynSizeVector_brace";
-  case 73: return "MatrixDynSizeVector_setbrace";
-  case 74: return "MatrixDynSizeVector_append";
-  case 75: return "MatrixDynSizeVector_empty";
-  case 76: return "MatrixDynSizeVector_size";
-  case 77: return "MatrixDynSizeVector_swap";
-  case 78: return "MatrixDynSizeVector_begin";
-  case 79: return "MatrixDynSizeVector_end";
-  case 80: return "MatrixDynSizeVector_rbegin";
-  case 81: return "MatrixDynSizeVector_rend";
-  case 82: return "MatrixDynSizeVector_clear";
-  case 83: return "MatrixDynSizeVector_get_allocator";
-  case 84: return "MatrixDynSizeVector_pop_back";
-  case 85: return "MatrixDynSizeVector_erase";
-  case 86: return "new_MatrixDynSizeVector";
-  case 87: return "MatrixDynSizeVector_push_back";
-  case 88: return "MatrixDynSizeVector_front";
-  case 89: return "MatrixDynSizeVector_back";
-  case 90: return "MatrixDynSizeVector_assign";
-  case 91: return "MatrixDynSizeVector_resize";
-  case 92: return "MatrixDynSizeVector_insert";
-  case 93: return "MatrixDynSizeVector_reserve";
-  case 94: return "MatrixDynSizeVector_capacity";
-  case 95: return "delete_MatrixDynSizeVector";
-  case 96: return "VectorDynSizeVector_pop";
-  case 97: return "VectorDynSizeVector_brace";
-  case 98: return "VectorDynSizeVector_setbrace";
-  case 99: return "VectorDynSizeVector_append";
-  case 100: return "VectorDynSizeVector_empty";
-  case 101: return "VectorDynSizeVector_size";
-  case 102: return "VectorDynSizeVector_swap";
-  case 103: return "VectorDynSizeVector_begin";
-  case 104: return "VectorDynSizeVector_end";
-  case 105: return "VectorDynSizeVector_rbegin";
-  case 106: return "VectorDynSizeVector_rend";
-  case 107: return "VectorDynSizeVector_clear";
-  case 108: return "VectorDynSizeVector_get_allocator";
-  case 109: return "VectorDynSizeVector_pop_back";
-  case 110: return "VectorDynSizeVector_erase";
-  case 111: return "new_VectorDynSizeVector";
-  case 112: return "VectorDynSizeVector_push_back";
-  case 113: return "VectorDynSizeVector_front";
-  case 114: return "VectorDynSizeVector_back";
-  case 115: return "VectorDynSizeVector_assign";
-  case 116: return "VectorDynSizeVector_resize";
-  case 117: return "VectorDynSizeVector_insert";
-  case 118: return "VectorDynSizeVector_reserve";
-  case 119: return "VectorDynSizeVector_capacity";
-  case 120: return "delete_VectorDynSizeVector";
-  case 121: return "IndexVector_pop";
-  case 122: return "IndexVector_brace";
-  case 123: return "IndexVector_setbrace";
-  case 124: return "IndexVector_append";
-  case 125: return "IndexVector_empty";
-  case 126: return "IndexVector_size";
-  case 127: return "IndexVector_swap";
-  case 128: return "IndexVector_begin";
-  case 129: return "IndexVector_end";
-  case 130: return "IndexVector_rbegin";
-  case 131: return "IndexVector_rend";
-  case 132: return "IndexVector_clear";
-  case 133: return "IndexVector_get_allocator";
-  case 134: return "IndexVector_pop_back";
-  case 135: return "IndexVector_erase";
-  case 136: return "new_IndexVector";
-  case 137: return "IndexVector_push_back";
-  case 138: return "IndexVector_front";
-  case 139: return "IndexVector_back";
-  case 140: return "IndexVector_assign";
-  case 141: return "IndexVector_resize";
-  case 142: return "IndexVector_insert";
-  case 143: return "IndexVector_reserve";
-  case 144: return "IndexVector_capacity";
-  case 145: return "delete_IndexVector";
-  case 146: return "BerdySensors_pop";
-  case 147: return "BerdySensors_brace";
-  case 148: return "BerdySensors_setbrace";
-  case 149: return "BerdySensors_append";
-  case 150: return "BerdySensors_empty";
-  case 151: return "BerdySensors_size";
-  case 152: return "BerdySensors_swap";
-  case 153: return "BerdySensors_begin";
-  case 154: return "BerdySensors_end";
-  case 155: return "BerdySensors_rbegin";
-  case 156: return "BerdySensors_rend";
-  case 157: return "BerdySensors_clear";
-  case 158: return "BerdySensors_get_allocator";
-  case 159: return "BerdySensors_pop_back";
-  case 160: return "BerdySensors_erase";
-  case 161: return "new_BerdySensors";
-  case 162: return "BerdySensors_push_back";
-  case 163: return "BerdySensors_front";
-  case 164: return "BerdySensors_back";
-  case 165: return "BerdySensors_assign";
-  case 166: return "BerdySensors_resize";
-  case 167: return "BerdySensors_insert";
-  case 168: return "BerdySensors_reserve";
-  case 169: return "BerdySensors_capacity";
-  case 170: return "delete_BerdySensors";
-  case 171: return "BerdyDynamicVariables_pop";
-  case 172: return "BerdyDynamicVariables_brace";
-  case 173: return "BerdyDynamicVariables_setbrace";
-  case 174: return "BerdyDynamicVariables_append";
-  case 175: return "BerdyDynamicVariables_empty";
-  case 176: return "BerdyDynamicVariables_size";
-  case 177: return "BerdyDynamicVariables_swap";
-  case 178: return "BerdyDynamicVariables_begin";
-  case 179: return "BerdyDynamicVariables_end";
-  case 180: return "BerdyDynamicVariables_rbegin";
-  case 181: return "BerdyDynamicVariables_rend";
-  case 182: return "BerdyDynamicVariables_clear";
-  case 183: return "BerdyDynamicVariables_get_allocator";
-  case 184: return "BerdyDynamicVariables_pop_back";
-  case 185: return "BerdyDynamicVariables_erase";
-  case 186: return "new_BerdyDynamicVariables";
-  case 187: return "BerdyDynamicVariables_push_back";
-  case 188: return "BerdyDynamicVariables_front";
-  case 189: return "BerdyDynamicVariables_back";
-  case 190: return "BerdyDynamicVariables_assign";
-  case 191: return "BerdyDynamicVariables_resize";
-  case 192: return "BerdyDynamicVariables_insert";
-  case 193: return "BerdyDynamicVariables_reserve";
-  case 194: return "BerdyDynamicVariables_capacity";
-  case 195: return "delete_BerdyDynamicVariables";
-  case 196: return "_wrap_reportInfo";
-  case 197: return "_wrap_reportDebug";
-  case 198: return "IndexRange_offset_get";
-  case 199: return "IndexRange_offset_set";
-  case 200: return "IndexRange_size_get";
-  case 201: return "IndexRange_size_set";
-  case 202: return "IndexRange_isValid";
-  case 203: return "IndexRange_InvalidRange";
-  case 204: return "new_IndexRange";
-  case 205: return "delete_IndexRange";
-  case 206: return "_wrap_checkDoublesAreEqual";
-  case 207: return "new_MatrixDynSize";
-  case 208: return "delete_MatrixDynSize";
-  case 209: return "MatrixDynSize_paren";
-  case 210: return "MatrixDynSize_getVal";
-  case 211: return "MatrixDynSize_setVal";
-  case 212: return "MatrixDynSize_rows";
-  case 213: return "MatrixDynSize_cols";
-  case 214: return "MatrixDynSize_data";
-  case 215: return "MatrixDynSize_zero";
-  case 216: return "MatrixDynSize_resize";
-  case 217: return "MatrixDynSize_reserve";
-  case 218: return "MatrixDynSize_capacity";
-  case 219: return "MatrixDynSize_shrink_to_fit";
-  case 220: return "MatrixDynSize_fillRowMajorBuffer";
-  case 221: return "MatrixDynSize_fillColMajorBuffer";
-  case 222: return "MatrixDynSize_toString";
-  case 223: return "MatrixDynSize_display";
-  case 224: return "MatrixDynSize_toMatlab";
-  case 225: return "MatrixDynSize_fromMatlab";
-  case 226: return "new_SparseMatrixRowMajor";
-  case 227: return "delete_SparseMatrixRowMajor";
-  case 228: return "SparseMatrixRowMajor_numberOfNonZeros";
-  case 229: return "SparseMatrixRowMajor_resize";
-  case 230: return "SparseMatrixRowMajor_reserve";
-  case 231: return "SparseMatrixRowMajor_zero";
-  case 232: return "SparseMatrixRowMajor_setFromConstTriplets";
-  case 233: return "SparseMatrixRowMajor_setFromTriplets";
-  case 234: return "SparseMatrixRowMajor_sparseMatrixFromTriplets";
-  case 235: return "SparseMatrixRowMajor_paren";
-  case 236: return "SparseMatrixRowMajor_getValue";
-  case 237: return "SparseMatrixRowMajor_setValue";
-  case 238: return "SparseMatrixRowMajor_rows";
-  case 239: return "SparseMatrixRowMajor_columns";
-  case 240: return "SparseMatrixRowMajor_description";
-  case 241: return "SparseMatrixRowMajor_toMatlab";
-  case 242: return "SparseMatrixRowMajor_toMatlabDense";
-  case 243: return "SparseMatrixRowMajor_fromMatlab";
-  case 244: return "new_SparseMatrixColMajor";
-  case 245: return "delete_SparseMatrixColMajor";
-  case 246: return "SparseMatrixColMajor_numberOfNonZeros";
-  case 247: return "SparseMatrixColMajor_resize";
-  case 248: return "SparseMatrixColMajor_reserve";
-  case 249: return "SparseMatrixColMajor_zero";
-  case 250: return "SparseMatrixColMajor_setFromConstTriplets";
-  case 251: return "SparseMatrixColMajor_setFromTriplets";
-  case 252: return "SparseMatrixColMajor_sparseMatrixFromTriplets";
-  case 253: return "SparseMatrixColMajor_paren";
-  case 254: return "SparseMatrixColMajor_getValue";
-  case 255: return "SparseMatrixColMajor_setValue";
-  case 256: return "SparseMatrixColMajor_rows";
-  case 257: return "SparseMatrixColMajor_columns";
-  case 258: return "SparseMatrixColMajor_description";
-  case 259: return "SparseMatrixColMajor_toMatlab";
-  case 260: return "SparseMatrixColMajor_toMatlabDense";
-  case 261: return "SparseMatrixColMajor_fromMatlab";
-  case 262: return "new_VectorDynSize";
-  case 263: return "delete_VectorDynSize";
-  case 264: return "VectorDynSize_paren";
-  case 265: return "VectorDynSize_brace";
-  case 266: return "VectorDynSize_getVal";
-  case 267: return "VectorDynSize_setVal";
-  case 268: return "VectorDynSize_cbegin";
-  case 269: return "VectorDynSize_cend";
-  case 270: return "VectorDynSize_begin";
-  case 271: return "VectorDynSize_end";
-  case 272: return "VectorDynSize_size";
-  case 273: return "VectorDynSize_data";
-  case 274: return "VectorDynSize_zero";
-  case 275: return "VectorDynSize_reserve";
-  case 276: return "VectorDynSize_resize";
-  case 277: return "VectorDynSize_shrink_to_fit";
-  case 278: return "VectorDynSize_capacity";
-  case 279: return "VectorDynSize_fillBuffer";
-  case 280: return "VectorDynSize_toString";
-  case 281: return "VectorDynSize_display";
-  case 282: return "VectorDynSize_toMatlab";
-  case 283: return "VectorDynSize_fromMatlab";
-  case 284: return "new_Matrix1x6";
-  case 285: return "Matrix1x6_paren";
-  case 286: return "Matrix1x6_getVal";
-  case 287: return "Matrix1x6_setVal";
-  case 288: return "Matrix1x6_rows";
-  case 289: return "Matrix1x6_cols";
-  case 290: return "Matrix1x6_data";
-  case 291: return "Matrix1x6_zero";
-  case 292: return "Matrix1x6_fillRowMajorBuffer";
-  case 293: return "Matrix1x6_fillColMajorBuffer";
-  case 294: return "Matrix1x6_toString";
-  case 295: return "Matrix1x6_display";
-  case 296: return "Matrix1x6_toMatlab";
-  case 297: return "Matrix1x6_fromMatlab";
-  case 298: return "delete_Matrix1x6";
-  case 299: return "new_Matrix2x3";
-  case 300: return "Matrix2x3_paren";
-  case 301: return "Matrix2x3_getVal";
-  case 302: return "Matrix2x3_setVal";
-  case 303: return "Matrix2x3_rows";
-  case 304: return "Matrix2x3_cols";
-  case 305: return "Matrix2x3_data";
-  case 306: return "Matrix2x3_zero";
-  case 307: return "Matrix2x3_fillRowMajorBuffer";
-  case 308: return "Matrix2x3_fillColMajorBuffer";
-  case 309: return "Matrix2x3_toString";
-  case 310: return "Matrix2x3_display";
-  case 311: return "Matrix2x3_toMatlab";
-  case 312: return "Matrix2x3_fromMatlab";
-  case 313: return "delete_Matrix2x3";
-  case 314: return "new_Matrix3x3";
-  case 315: return "Matrix3x3_paren";
-  case 316: return "Matrix3x3_getVal";
-  case 317: return "Matrix3x3_setVal";
-  case 318: return "Matrix3x3_rows";
-  case 319: return "Matrix3x3_cols";
-  case 320: return "Matrix3x3_data";
-  case 321: return "Matrix3x3_zero";
-  case 322: return "Matrix3x3_fillRowMajorBuffer";
-  case 323: return "Matrix3x3_fillColMajorBuffer";
-  case 324: return "Matrix3x3_toString";
-  case 325: return "Matrix3x3_display";
-  case 326: return "Matrix3x3_toMatlab";
-  case 327: return "Matrix3x3_fromMatlab";
-  case 328: return "delete_Matrix3x3";
-  case 329: return "new_Matrix4x4";
-  case 330: return "Matrix4x4_paren";
-  case 331: return "Matrix4x4_getVal";
-  case 332: return "Matrix4x4_setVal";
-  case 333: return "Matrix4x4_rows";
-  case 334: return "Matrix4x4_cols";
-  case 335: return "Matrix4x4_data";
-  case 336: return "Matrix4x4_zero";
-  case 337: return "Matrix4x4_fillRowMajorBuffer";
-  case 338: return "Matrix4x4_fillColMajorBuffer";
-  case 339: return "Matrix4x4_toString";
-  case 340: return "Matrix4x4_display";
-  case 341: return "Matrix4x4_toMatlab";
-  case 342: return "Matrix4x4_fromMatlab";
-  case 343: return "delete_Matrix4x4";
-  case 344: return "new_Matrix6x6";
-  case 345: return "Matrix6x6_paren";
-  case 346: return "Matrix6x6_getVal";
-  case 347: return "Matrix6x6_setVal";
-  case 348: return "Matrix6x6_rows";
-  case 349: return "Matrix6x6_cols";
-  case 350: return "Matrix6x6_data";
-  case 351: return "Matrix6x6_zero";
-  case 352: return "Matrix6x6_fillRowMajorBuffer";
-  case 353: return "Matrix6x6_fillColMajorBuffer";
-  case 354: return "Matrix6x6_toString";
-  case 355: return "Matrix6x6_display";
-  case 356: return "Matrix6x6_toMatlab";
-  case 357: return "Matrix6x6_fromMatlab";
-  case 358: return "delete_Matrix6x6";
-  case 359: return "new_Matrix6x10";
-  case 360: return "Matrix6x10_paren";
-  case 361: return "Matrix6x10_getVal";
-  case 362: return "Matrix6x10_setVal";
-  case 363: return "Matrix6x10_rows";
-  case 364: return "Matrix6x10_cols";
-  case 365: return "Matrix6x10_data";
-  case 366: return "Matrix6x10_zero";
-  case 367: return "Matrix6x10_fillRowMajorBuffer";
-  case 368: return "Matrix6x10_fillColMajorBuffer";
-  case 369: return "Matrix6x10_toString";
-  case 370: return "Matrix6x10_display";
-  case 371: return "Matrix6x10_toMatlab";
-  case 372: return "Matrix6x10_fromMatlab";
-  case 373: return "delete_Matrix6x10";
-  case 374: return "new_Matrix10x16";
-  case 375: return "Matrix10x16_paren";
-  case 376: return "Matrix10x16_getVal";
-  case 377: return "Matrix10x16_setVal";
-  case 378: return "Matrix10x16_rows";
-  case 379: return "Matrix10x16_cols";
-  case 380: return "Matrix10x16_data";
-  case 381: return "Matrix10x16_zero";
-  case 382: return "Matrix10x16_fillRowMajorBuffer";
-  case 383: return "Matrix10x16_fillColMajorBuffer";
-  case 384: return "Matrix10x16_toString";
-  case 385: return "Matrix10x16_display";
-  case 386: return "Matrix10x16_toMatlab";
-  case 387: return "Matrix10x16_fromMatlab";
-  case 388: return "delete_Matrix10x16";
-  case 389: return "new_Vector3";
-  case 390: return "Vector3_paren";
-  case 391: return "Vector3_brace";
-  case 392: return "Vector3_getVal";
-  case 393: return "Vector3_setVal";
-  case 394: return "Vector3_cbegin";
-  case 395: return "Vector3_cend";
-  case 396: return "Vector3_begin";
-  case 397: return "Vector3_end";
-  case 398: return "Vector3_size";
-  case 399: return "Vector3_data";
-  case 400: return "Vector3_zero";
-  case 401: return "Vector3_fillBuffer";
-  case 402: return "Vector3_toString";
-  case 403: return "Vector3_display";
-  case 404: return "Vector3_toMatlab";
-  case 405: return "Vector3_fromMatlab";
-  case 406: return "delete_Vector3";
-  case 407: return "new_Vector4";
-  case 408: return "Vector4_paren";
-  case 409: return "Vector4_brace";
-  case 410: return "Vector4_getVal";
-  case 411: return "Vector4_setVal";
-  case 412: return "Vector4_cbegin";
-  case 413: return "Vector4_cend";
-  case 414: return "Vector4_begin";
-  case 415: return "Vector4_end";
-  case 416: return "Vector4_size";
-  case 417: return "Vector4_data";
-  case 418: return "Vector4_zero";
-  case 419: return "Vector4_fillBuffer";
-  case 420: return "Vector4_toString";
-  case 421: return "Vector4_display";
-  case 422: return "Vector4_toMatlab";
-  case 423: return "Vector4_fromMatlab";
-  case 424: return "delete_Vector4";
-  case 425: return "new_Vector6";
-  case 426: return "Vector6_paren";
-  case 427: return "Vector6_brace";
-  case 428: return "Vector6_getVal";
-  case 429: return "Vector6_setVal";
-  case 430: return "Vector6_cbegin";
-  case 431: return "Vector6_cend";
-  case 432: return "Vector6_begin";
-  case 433: return "Vector6_end";
-  case 434: return "Vector6_size";
-  case 435: return "Vector6_data";
-  case 436: return "Vector6_zero";
-  case 437: return "Vector6_fillBuffer";
-  case 438: return "Vector6_toString";
-  case 439: return "Vector6_display";
-  case 440: return "Vector6_toMatlab";
-  case 441: return "Vector6_fromMatlab";
-  case 442: return "delete_Vector6";
-  case 443: return "new_Vector10";
-  case 444: return "Vector10_paren";
-  case 445: return "Vector10_brace";
-  case 446: return "Vector10_getVal";
-  case 447: return "Vector10_setVal";
-  case 448: return "Vector10_cbegin";
-  case 449: return "Vector10_cend";
-  case 450: return "Vector10_begin";
-  case 451: return "Vector10_end";
-  case 452: return "Vector10_size";
-  case 453: return "Vector10_data";
-  case 454: return "Vector10_zero";
-  case 455: return "Vector10_fillBuffer";
-  case 456: return "Vector10_toString";
-  case 457: return "Vector10_display";
-  case 458: return "Vector10_toMatlab";
-  case 459: return "Vector10_fromMatlab";
-  case 460: return "delete_Vector10";
-  case 461: return "new_Vector16";
-  case 462: return "Vector16_paren";
-  case 463: return "Vector16_brace";
-  case 464: return "Vector16_getVal";
-  case 465: return "Vector16_setVal";
-  case 466: return "Vector16_cbegin";
-  case 467: return "Vector16_cend";
-  case 468: return "Vector16_begin";
-  case 469: return "Vector16_end";
-  case 470: return "Vector16_size";
-  case 471: return "Vector16_data";
-  case 472: return "Vector16_zero";
-  case 473: return "Vector16_fillBuffer";
-  case 474: return "Vector16_toString";
-  case 475: return "Vector16_display";
-  case 476: return "Vector16_toMatlab";
-  case 477: return "Vector16_fromMatlab";
-  case 478: return "delete_Vector16";
-  case 479: return "new_Position";
-  case 480: return "Position_changePoint";
-  case 481: return "Position_changeRefPoint";
-  case 482: return "Position_changeCoordinateFrame";
-  case 483: return "Position_compose";
-  case 484: return "Position_inverse";
-  case 485: return "Position_changePointOf";
-  case 486: return "Position_plus";
-  case 487: return "Position_minus";
-  case 488: return "Position_uminus";
-  case 489: return "Position_mtimes";
-  case 490: return "Position_toString";
-  case 491: return "Position_display";
-  case 492: return "Position_Zero";
-  case 493: return "delete_Position";
-  case 494: return "new_GeomVector3";
-  case 495: return "GeomVector3_changeCoordFrame";
-  case 496: return "GeomVector3_compose";
-  case 497: return "GeomVector3_inverse";
-  case 498: return "GeomVector3_dot";
-  case 499: return "GeomVector3_plus";
-  case 500: return "GeomVector3_minus";
-  case 501: return "GeomVector3_uminus";
-  case 502: return "GeomVector3_exp";
-  case 503: return "GeomVector3_cross";
-  case 504: return "delete_GeomVector3";
-  case 505: return "new_SpatialMotionVectorBase";
-  case 506: return "SpatialMotionVectorBase_getLinearVec3";
-  case 507: return "SpatialMotionVectorBase_getAngularVec3";
-  case 508: return "SpatialMotionVectorBase_setLinearVec3";
-  case 509: return "SpatialMotionVectorBase_setAngularVec3";
-  case 510: return "SpatialMotionVectorBase_paren";
-  case 511: return "SpatialMotionVectorBase_getVal";
-  case 512: return "SpatialMotionVectorBase_setVal";
-  case 513: return "SpatialMotionVectorBase_size";
-  case 514: return "SpatialMotionVectorBase_zero";
-  case 515: return "SpatialMotionVectorBase_changePoint";
-  case 516: return "SpatialMotionVectorBase_changeCoordFrame";
-  case 517: return "SpatialMotionVectorBase_compose";
-  case 518: return "SpatialMotionVectorBase_inverse";
-  case 519: return "SpatialMotionVectorBase_dot";
-  case 520: return "SpatialMotionVectorBase_plus";
-  case 521: return "SpatialMotionVectorBase_minus";
-  case 522: return "SpatialMotionVectorBase_uminus";
-  case 523: return "SpatialMotionVectorBase_Zero";
-  case 524: return "SpatialMotionVectorBase_asVector";
-  case 525: return "SpatialMotionVectorBase_toString";
-  case 526: return "SpatialMotionVectorBase_display";
-  case 527: return "SpatialMotionVectorBase_toMatlab";
-  case 528: return "SpatialMotionVectorBase_fromMatlab";
-  case 529: return "delete_SpatialMotionVectorBase";
-  case 530: return "new_SpatialForceVectorBase";
-  case 531: return "SpatialForceVectorBase_getLinearVec3";
-  case 532: return "SpatialForceVectorBase_getAngularVec3";
-  case 533: return "SpatialForceVectorBase_setLinearVec3";
-  case 534: return "SpatialForceVectorBase_setAngularVec3";
-  case 535: return "SpatialForceVectorBase_paren";
-  case 536: return "SpatialForceVectorBase_getVal";
-  case 537: return "SpatialForceVectorBase_setVal";
-  case 538: return "SpatialForceVectorBase_size";
-  case 539: return "SpatialForceVectorBase_zero";
-  case 540: return "SpatialForceVectorBase_changePoint";
-  case 541: return "SpatialForceVectorBase_changeCoordFrame";
-  case 542: return "SpatialForceVectorBase_compose";
-  case 543: return "SpatialForceVectorBase_inverse";
-  case 544: return "SpatialForceVectorBase_dot";
-  case 545: return "SpatialForceVectorBase_plus";
-  case 546: return "SpatialForceVectorBase_minus";
-  case 547: return "SpatialForceVectorBase_uminus";
-  case 548: return "SpatialForceVectorBase_Zero";
-  case 549: return "SpatialForceVectorBase_asVector";
-  case 550: return "SpatialForceVectorBase_toString";
-  case 551: return "SpatialForceVectorBase_display";
-  case 552: return "SpatialForceVectorBase_toMatlab";
-  case 553: return "SpatialForceVectorBase_fromMatlab";
-  case 554: return "delete_SpatialForceVectorBase";
-  case 555: return "new_Dummy";
-  case 556: return "delete_Dummy";
-  case 557: return "new_SpatialMotionVector";
-  case 558: return "SpatialMotionVector_mtimes";
-  case 559: return "SpatialMotionVector_cross";
-  case 560: return "SpatialMotionVector_asCrossProductMatrix";
-  case 561: return "SpatialMotionVector_asCrossProductMatrixWrench";
-  case 562: return "SpatialMotionVector_exp";
-  case 563: return "delete_SpatialMotionVector";
-  case 564: return "new_SpatialForceVector";
-  case 565: return "delete_SpatialForceVector";
-  case 566: return "SpatialForceVector_mtimes";
-  case 567: return "new_Twist";
-  case 568: return "Twist_plus";
-  case 569: return "Twist_minus";
-  case 570: return "Twist_uminus";
-  case 571: return "Twist_mtimes";
-  case 572: return "delete_Twist";
-  case 573: return "new_Wrench";
-  case 574: return "Wrench_plus";
-  case 575: return "Wrench_minus";
-  case 576: return "Wrench_uminus";
-  case 577: return "delete_Wrench";
-  case 578: return "new_SpatialMomentum";
-  case 579: return "SpatialMomentum_plus";
-  case 580: return "SpatialMomentum_minus";
-  case 581: return "SpatialMomentum_uminus";
-  case 582: return "delete_SpatialMomentum";
-  case 583: return "new_SpatialAcc";
-  case 584: return "SpatialAcc_plus";
-  case 585: return "SpatialAcc_minus";
-  case 586: return "SpatialAcc_uminus";
-  case 587: return "delete_SpatialAcc";
-  case 588: return "new_ClassicalAcc";
-  case 589: return "ClassicalAcc_changeCoordFrame";
-  case 590: return "ClassicalAcc_Zero";
-  case 591: return "ClassicalAcc_fromSpatial";
-  case 592: return "ClassicalAcc_toSpatial";
-  case 593: return "delete_ClassicalAcc";
-  case 594: return "new_Direction";
-  case 595: return "Direction_Normalize";
-  case 596: return "Direction_isParallel";
-  case 597: return "Direction_isPerpendicular";
-  case 598: return "Direction_reverse";
-  case 599: return "Direction_toString";
-  case 600: return "Direction_display";
-  case 601: return "Direction_Default";
-  case 602: return "delete_Direction";
-  case 603: return "new_Axis";
-  case 604: return "Axis_getDirection";
-  case 605: return "Axis_getOrigin";
-  case 606: return "Axis_setDirection";
-  case 607: return "Axis_setOrigin";
-  case 608: return "Axis_getRotationTransform";
-  case 609: return "Axis_getRotationTransformDerivative";
-  case 610: return "Axis_getRotationTwist";
-  case 611: return "Axis_getRotationSpatialAcc";
-  case 612: return "Axis_getTranslationTransform";
-  case 613: return "Axis_getTranslationTransformDerivative";
-  case 614: return "Axis_getTranslationTwist";
-  case 615: return "Axis_getTranslationSpatialAcc";
-  case 616: return "Axis_isParallel";
-  case 617: return "Axis_reverse";
-  case 618: return "Axis_toString";
-  case 619: return "Axis_display";
-  case 620: return "delete_Axis";
-  case 621: return "new_RotationalInertia";
-  case 622: return "RotationalInertia_Zero";
-  case 623: return "delete_RotationalInertia";
-  case 624: return "new_SpatialInertia";
-  case 625: return "SpatialInertia_combine";
-  case 626: return "SpatialInertia_fromRotationalInertiaWrtCenterOfMass";
-  case 627: return "SpatialInertia_getMass";
-  case 628: return "SpatialInertia_getCenterOfMass";
-  case 629: return "SpatialInertia_getRotationalInertiaWrtFrameOrigin";
-  case 630: return "SpatialInertia_getRotationalInertiaWrtCenterOfMass";
-  case 631: return "SpatialInertia_multiply";
-  case 632: return "SpatialInertia_zero";
-  case 633: return "SpatialInertia_asMatrix";
-  case 634: return "SpatialInertia_applyInverse";
-  case 635: return "SpatialInertia_getInverse";
-  case 636: return "SpatialInertia_plus";
-  case 637: return "SpatialInertia_mtimes";
-  case 638: return "SpatialInertia_biasWrench";
-  case 639: return "SpatialInertia_biasWrenchDerivative";
-  case 640: return "SpatialInertia_Zero";
-  case 641: return "SpatialInertia_asVector";
-  case 642: return "SpatialInertia_fromVector";
-  case 643: return "SpatialInertia_isPhysicallyConsistent";
-  case 644: return "SpatialInertia_momentumRegressor";
-  case 645: return "SpatialInertia_momentumDerivativeRegressor";
-  case 646: return "SpatialInertia_momentumDerivativeSlotineLiRegressor";
-  case 647: return "delete_SpatialInertia";
-  case 648: return "new_ArticulatedBodyInertia";
-  case 649: return "ArticulatedBodyInertia_getLinearLinearSubmatrix";
-  case 650: return "ArticulatedBodyInertia_getLinearAngularSubmatrix";
-  case 651: return "ArticulatedBodyInertia_getAngularAngularSubmatrix";
-  case 652: return "ArticulatedBodyInertia_combine";
-  case 653: return "ArticulatedBodyInertia_applyInverse";
-  case 654: return "ArticulatedBodyInertia_asMatrix";
-  case 655: return "ArticulatedBodyInertia_getInverse";
-  case 656: return "ArticulatedBodyInertia_plus";
-  case 657: return "ArticulatedBodyInertia_minus";
-  case 658: return "ArticulatedBodyInertia_mtimes";
-  case 659: return "ArticulatedBodyInertia_zero";
-  case 660: return "ArticulatedBodyInertia_ABADyadHelper";
-  case 661: return "ArticulatedBodyInertia_ABADyadHelperLin";
-  case 662: return "delete_ArticulatedBodyInertia";
-  case 663: return "RigidBodyInertiaNonLinearParametrization_mass_get";
-  case 664: return "RigidBodyInertiaNonLinearParametrization_mass_set";
-  case 665: return "RigidBodyInertiaNonLinearParametrization_com_get";
-  case 666: return "RigidBodyInertiaNonLinearParametrization_com_set";
-  case 667: return "RigidBodyInertiaNonLinearParametrization_link_R_centroidal_get";
-  case 668: return "RigidBodyInertiaNonLinearParametrization_link_R_centroidal_set";
-  case 669: return "RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_get";
-  case 670: return "RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_set";
-  case 671: return "RigidBodyInertiaNonLinearParametrization_getLinkCentroidalTransform";
-  case 672: return "RigidBodyInertiaNonLinearParametrization_fromRigidBodyInertia";
-  case 673: return "RigidBodyInertiaNonLinearParametrization_fromInertialParameters";
-  case 674: return "RigidBodyInertiaNonLinearParametrization_toRigidBodyInertia";
-  case 675: return "RigidBodyInertiaNonLinearParametrization_isPhysicallyConsistent";
-  case 676: return "RigidBodyInertiaNonLinearParametrization_asVectorWithRotationAsVec";
-  case 677: return "RigidBodyInertiaNonLinearParametrization_fromVectorWithRotationAsVec";
-  case 678: return "RigidBodyInertiaNonLinearParametrization_getGradientWithRotationAsVec";
-  case 679: return "new_RigidBodyInertiaNonLinearParametrization";
-  case 680: return "delete_RigidBodyInertiaNonLinearParametrization";
-  case 681: return "new_Rotation";
-  case 682: return "Rotation_changeOrientFrame";
-  case 683: return "Rotation_changeRefOrientFrame";
-  case 684: return "Rotation_changeCoordinateFrame";
-  case 685: return "Rotation_compose";
-  case 686: return "Rotation_inverse2";
-  case 687: return "Rotation_changeCoordFrameOf";
-  case 688: return "Rotation_inverse";
-  case 689: return "Rotation_mtimes";
-  case 690: return "Rotation_log";
-  case 691: return "Rotation_fromQuaternion";
-  case 692: return "Rotation_getRPY";
-  case 693: return "Rotation_asRPY";
-  case 694: return "Rotation_getQuaternion";
-  case 695: return "Rotation_asQuaternion";
-  case 696: return "Rotation_RotX";
-  case 697: return "Rotation_RotY";
-  case 698: return "Rotation_RotZ";
-  case 699: return "Rotation_RotAxis";
-  case 700: return "Rotation_RotAxisDerivative";
-  case 701: return "Rotation_RPY";
-  case 702: return "Rotation_RPYRightTrivializedDerivative";
-  case 703: return "Rotation_RPYRightTrivializedDerivativeRateOfChange";
-  case 704: return "Rotation_RPYRightTrivializedDerivativeInverse";
-  case 705: return "Rotation_RPYRightTrivializedDerivativeInverseRateOfChange";
-  case 706: return "Rotation_QuaternionRightTrivializedDerivative";
-  case 707: return "Rotation_QuaternionRightTrivializedDerivativeInverse";
-  case 708: return "Rotation_Identity";
-  case 709: return "Rotation_RotationFromQuaternion";
-  case 710: return "Rotation_leftJacobian";
-  case 711: return "Rotation_leftJacobianInverse";
-  case 712: return "Rotation_toString";
-  case 713: return "Rotation_display";
-  case 714: return "delete_Rotation";
-  case 715: return "new_Transform";
-  case 716: return "Transform_fromHomogeneousTransform";
-  case 717: return "Transform_getRotation";
-  case 718: return "Transform_getPosition";
-  case 719: return "Transform_setRotation";
-  case 720: return "Transform_setPosition";
-  case 721: return "Transform_compose";
-  case 722: return "Transform_inverse2";
-  case 723: return "Transform_inverse";
-  case 724: return "Transform_mtimes";
-  case 725: return "Transform_Identity";
-  case 726: return "Transform_asHomogeneousTransform";
-  case 727: return "Transform_asAdjointTransform";
-  case 728: return "Transform_asAdjointTransformWrench";
-  case 729: return "Transform_log";
-  case 730: return "Transform_toString";
-  case 731: return "Transform_display";
-  case 732: return "delete_Transform";
-  case 733: return "new_TransformDerivative";
-  case 734: return "delete_TransformDerivative";
-  case 735: return "TransformDerivative_getRotationDerivative";
-  case 736: return "TransformDerivative_getPositionDerivative";
-  case 737: return "TransformDerivative_setRotationDerivative";
-  case 738: return "TransformDerivative_setPositionDerivative";
-  case 739: return "TransformDerivative_Zero";
-  case 740: return "TransformDerivative_asHomogeneousTransformDerivative";
-  case 741: return "TransformDerivative_asAdjointTransformDerivative";
-  case 742: return "TransformDerivative_asAdjointTransformWrenchDerivative";
-  case 743: return "TransformDerivative_mtimes";
-  case 744: return "TransformDerivative_derivativeOfInverse";
-  case 745: return "TransformDerivative_transform";
-  case 746: return "dynamic_extent_get";
-  case 747: return "DynamicSpan_extent_get";
-  case 748: return "new_DynamicSpan";
-  case 749: return "delete_DynamicSpan";
-  case 750: return "DynamicSpan_first";
-  case 751: return "DynamicSpan_last";
-  case 752: return "DynamicSpan_subspan";
-  case 753: return "DynamicSpan_size";
-  case 754: return "DynamicSpan_size_bytes";
-  case 755: return "DynamicSpan_empty";
-  case 756: return "DynamicSpan_brace";
-  case 757: return "DynamicSpan_getVal";
-  case 758: return "DynamicSpan_setVal";
-  case 759: return "DynamicSpan_at";
-  case 760: return "DynamicSpan_paren";
-  case 761: return "DynamicSpan_begin";
-  case 762: return "DynamicSpan_end";
-  case 763: return "DynamicSpan_cbegin";
-  case 764: return "DynamicSpan_cend";
-  case 765: return "DynamicSpan_rbegin";
-  case 766: return "DynamicSpan_rend";
-  case 767: return "DynamicSpan_crbegin";
-  case 768: return "DynamicSpan_crend";
-  case 769: return "new_DynamicMatrixView";
-  case 770: return "DynamicMatrixView_storageOrder";
-  case 771: return "DynamicMatrixView_paren";
-  case 772: return "DynamicMatrixView_rows";
-  case 773: return "DynamicMatrixView_cols";
-  case 774: return "DynamicMatrixView_block";
-  case 775: return "delete_DynamicMatrixView";
-  case 776: return "LINK_INVALID_INDEX_get";
-  case 777: return "LINK_INVALID_INDEX_set";
-  case 778: return "LINK_INVALID_NAME_get";
-  case 779: return "LINK_INVALID_NAME_set";
-  case 780: return "JOINT_INVALID_INDEX_get";
-  case 781: return "JOINT_INVALID_INDEX_set";
-  case 782: return "JOINT_INVALID_NAME_get";
-  case 783: return "JOINT_INVALID_NAME_set";
-  case 784: return "DOF_INVALID_INDEX_get";
-  case 785: return "DOF_INVALID_INDEX_set";
-  case 786: return "DOF_INVALID_NAME_get";
-  case 787: return "DOF_INVALID_NAME_set";
-  case 788: return "FRAME_INVALID_INDEX_get";
-  case 789: return "FRAME_INVALID_INDEX_set";
-  case 790: return "FRAME_INVALID_NAME_get";
-  case 791: return "FRAME_INVALID_NAME_set";
-  case 792: return "TRAVERSAL_INVALID_INDEX_get";
-  case 793: return "TRAVERSAL_INVALID_INDEX_set";
-  case 794: return "new_LinkPositions";
-  case 795: return "LinkPositions_resize";
-  case 796: return "LinkPositions_isConsistent";
-  case 797: return "LinkPositions_getNrOfLinks";
-  case 798: return "LinkPositions_paren";
-  case 799: return "LinkPositions_toString";
-  case 800: return "delete_LinkPositions";
-  case 801: return "new_LinkWrenches";
-  case 802: return "LinkWrenches_resize";
-  case 803: return "LinkWrenches_isConsistent";
-  case 804: return "LinkWrenches_getNrOfLinks";
-  case 805: return "LinkWrenches_paren";
-  case 806: return "LinkWrenches_toString";
-  case 807: return "LinkWrenches_zero";
-  case 808: return "delete_LinkWrenches";
-  case 809: return "new_LinkInertias";
-  case 810: return "LinkInertias_resize";
-  case 811: return "LinkInertias_isConsistent";
-  case 812: return "LinkInertias_paren";
-  case 813: return "delete_LinkInertias";
-  case 814: return "new_LinkArticulatedBodyInertias";
-  case 815: return "LinkArticulatedBodyInertias_resize";
-  case 816: return "LinkArticulatedBodyInertias_isConsistent";
-  case 817: return "LinkArticulatedBodyInertias_paren";
-  case 818: return "delete_LinkArticulatedBodyInertias";
-  case 819: return "new_LinkVelArray";
-  case 820: return "LinkVelArray_resize";
-  case 821: return "LinkVelArray_isConsistent";
-  case 822: return "LinkVelArray_getNrOfLinks";
-  case 823: return "LinkVelArray_paren";
-  case 824: return "LinkVelArray_toString";
-  case 825: return "delete_LinkVelArray";
-  case 826: return "new_LinkAccArray";
-  case 827: return "LinkAccArray_resize";
-  case 828: return "LinkAccArray_isConsistent";
-  case 829: return "LinkAccArray_paren";
-  case 830: return "LinkAccArray_getNrOfLinks";
-  case 831: return "LinkAccArray_toString";
-  case 832: return "delete_LinkAccArray";
-  case 833: return "new_Link";
-  case 834: return "Link_inertia";
-  case 835: return "Link_setInertia";
-  case 836: return "Link_getInertia";
-  case 837: return "Link_setIndex";
-  case 838: return "Link_getIndex";
-  case 839: return "delete_Link";
-  case 840: return "delete_IJoint";
-  case 841: return "IJoint_clone";
-  case 842: return "IJoint_getNrOfPosCoords";
-  case 843: return "IJoint_getNrOfDOFs";
-  case 844: return "IJoint_setAttachedLinks";
-  case 845: return "IJoint_setRestTransform";
-  case 846: return "IJoint_getFirstAttachedLink";
-  case 847: return "IJoint_getSecondAttachedLink";
-  case 848: return "IJoint_getRestTransform";
-  case 849: return "IJoint_getTransform";
-  case 850: return "IJoint_getTransformDerivative";
-  case 851: return "IJoint_getMotionSubspaceVector";
-  case 852: return "IJoint_computeChildPosVelAcc";
-  case 853: return "IJoint_computeChildVelAcc";
-  case 854: return "IJoint_computeChildVel";
-  case 855: return "IJoint_computeChildAcc";
-  case 856: return "IJoint_computeChildBiasAcc";
-  case 857: return "IJoint_computeJointTorque";
-  case 858: return "IJoint_setIndex";
-  case 859: return "IJoint_getIndex";
-  case 860: return "IJoint_setPosCoordsOffset";
-  case 861: return "IJoint_getPosCoordsOffset";
-  case 862: return "IJoint_setDOFsOffset";
-  case 863: return "IJoint_getDOFsOffset";
-  case 864: return "IJoint_hasPosLimits";
-  case 865: return "IJoint_enablePosLimits";
-  case 866: return "IJoint_getPosLimits";
-  case 867: return "IJoint_getMinPosLimit";
-  case 868: return "IJoint_getMaxPosLimit";
-  case 869: return "IJoint_setPosLimits";
-  case 870: return "IJoint_getJointDynamicsType";
-  case 871: return "IJoint_setJointDynamicsType";
-  case 872: return "IJoint_setDamping";
-  case 873: return "IJoint_setStaticFriction";
-  case 874: return "IJoint_getDamping";
-  case 875: return "IJoint_getStaticFriction";
-  case 876: return "IJoint_isRevoluteJoint";
-  case 877: return "IJoint_isFixedJoint";
-  case 878: return "IJoint_isPrismaticJoint";
-  case 879: return "IJoint_asRevoluteJoint";
-  case 880: return "IJoint_asFixedJoint";
-  case 881: return "IJoint_asPrismaticJoint";
-  case 882: return "new_FixedJoint";
-  case 883: return "delete_FixedJoint";
-  case 884: return "FixedJoint_clone";
-  case 885: return "FixedJoint_getNrOfPosCoords";
-  case 886: return "FixedJoint_getNrOfDOFs";
-  case 887: return "FixedJoint_setAttachedLinks";
-  case 888: return "FixedJoint_setRestTransform";
-  case 889: return "FixedJoint_getFirstAttachedLink";
-  case 890: return "FixedJoint_getSecondAttachedLink";
-  case 891: return "FixedJoint_getRestTransform";
-  case 892: return "FixedJoint_getTransform";
-  case 893: return "FixedJoint_getTransformDerivative";
-  case 894: return "FixedJoint_getMotionSubspaceVector";
-  case 895: return "FixedJoint_computeChildPosVelAcc";
-  case 896: return "FixedJoint_computeChildVelAcc";
-  case 897: return "FixedJoint_computeChildVel";
-  case 898: return "FixedJoint_computeChildAcc";
-  case 899: return "FixedJoint_computeChildBiasAcc";
-  case 900: return "FixedJoint_computeJointTorque";
-  case 901: return "FixedJoint_setIndex";
-  case 902: return "FixedJoint_getIndex";
-  case 903: return "FixedJoint_setPosCoordsOffset";
-  case 904: return "FixedJoint_getPosCoordsOffset";
-  case 905: return "FixedJoint_setDOFsOffset";
-  case 906: return "FixedJoint_getDOFsOffset";
-  case 907: return "FixedJoint_hasPosLimits";
-  case 908: return "FixedJoint_enablePosLimits";
-  case 909: return "FixedJoint_getPosLimits";
-  case 910: return "FixedJoint_getMinPosLimit";
-  case 911: return "FixedJoint_getMaxPosLimit";
-  case 912: return "FixedJoint_setPosLimits";
-  case 913: return "FixedJoint_getJointDynamicsType";
-  case 914: return "FixedJoint_setJointDynamicsType";
-  case 915: return "FixedJoint_getDamping";
-  case 916: return "FixedJoint_getStaticFriction";
-  case 917: return "FixedJoint_setDamping";
-  case 918: return "FixedJoint_setStaticFriction";
-  case 919: return "delete_MovableJointImpl1";
-  case 920: return "MovableJointImpl1_getNrOfPosCoords";
-  case 921: return "MovableJointImpl1_getNrOfDOFs";
-  case 922: return "MovableJointImpl1_setIndex";
-  case 923: return "MovableJointImpl1_getIndex";
-  case 924: return "MovableJointImpl1_setPosCoordsOffset";
-  case 925: return "MovableJointImpl1_getPosCoordsOffset";
-  case 926: return "MovableJointImpl1_setDOFsOffset";
-  case 927: return "MovableJointImpl1_getDOFsOffset";
-  case 928: return "delete_MovableJointImpl2";
-  case 929: return "MovableJointImpl2_getNrOfPosCoords";
-  case 930: return "MovableJointImpl2_getNrOfDOFs";
-  case 931: return "MovableJointImpl2_setIndex";
-  case 932: return "MovableJointImpl2_getIndex";
-  case 933: return "MovableJointImpl2_setPosCoordsOffset";
-  case 934: return "MovableJointImpl2_getPosCoordsOffset";
-  case 935: return "MovableJointImpl2_setDOFsOffset";
-  case 936: return "MovableJointImpl2_getDOFsOffset";
-  case 937: return "delete_MovableJointImpl3";
-  case 938: return "MovableJointImpl3_getNrOfPosCoords";
-  case 939: return "MovableJointImpl3_getNrOfDOFs";
-  case 940: return "MovableJointImpl3_setIndex";
-  case 941: return "MovableJointImpl3_getIndex";
-  case 942: return "MovableJointImpl3_setPosCoordsOffset";
-  case 943: return "MovableJointImpl3_getPosCoordsOffset";
-  case 944: return "MovableJointImpl3_setDOFsOffset";
-  case 945: return "MovableJointImpl3_getDOFsOffset";
-  case 946: return "delete_MovableJointImpl4";
-  case 947: return "MovableJointImpl4_getNrOfPosCoords";
-  case 948: return "MovableJointImpl4_getNrOfDOFs";
-  case 949: return "MovableJointImpl4_setIndex";
-  case 950: return "MovableJointImpl4_getIndex";
-  case 951: return "MovableJointImpl4_setPosCoordsOffset";
-  case 952: return "MovableJointImpl4_getPosCoordsOffset";
-  case 953: return "MovableJointImpl4_setDOFsOffset";
-  case 954: return "MovableJointImpl4_getDOFsOffset";
-  case 955: return "delete_MovableJointImpl5";
-  case 956: return "MovableJointImpl5_getNrOfPosCoords";
-  case 957: return "MovableJointImpl5_getNrOfDOFs";
-  case 958: return "MovableJointImpl5_setIndex";
-  case 959: return "MovableJointImpl5_getIndex";
-  case 960: return "MovableJointImpl5_setPosCoordsOffset";
-  case 961: return "MovableJointImpl5_getPosCoordsOffset";
-  case 962: return "MovableJointImpl5_setDOFsOffset";
-  case 963: return "MovableJointImpl5_getDOFsOffset";
-  case 964: return "delete_MovableJointImpl6";
-  case 965: return "MovableJointImpl6_getNrOfPosCoords";
-  case 966: return "MovableJointImpl6_getNrOfDOFs";
-  case 967: return "MovableJointImpl6_setIndex";
-  case 968: return "MovableJointImpl6_getIndex";
-  case 969: return "MovableJointImpl6_setPosCoordsOffset";
-  case 970: return "MovableJointImpl6_getPosCoordsOffset";
-  case 971: return "MovableJointImpl6_setDOFsOffset";
-  case 972: return "MovableJointImpl6_getDOFsOffset";
-  case 973: return "new_RevoluteJoint";
-  case 974: return "delete_RevoluteJoint";
-  case 975: return "RevoluteJoint_clone";
-  case 976: return "RevoluteJoint_setAttachedLinks";
-  case 977: return "RevoluteJoint_setRestTransform";
-  case 978: return "RevoluteJoint_setAxis";
-  case 979: return "RevoluteJoint_getFirstAttachedLink";
-  case 980: return "RevoluteJoint_getSecondAttachedLink";
-  case 981: return "RevoluteJoint_getAxis";
-  case 982: return "RevoluteJoint_getRestTransform";
-  case 983: return "RevoluteJoint_getTransform";
-  case 984: return "RevoluteJoint_getTransformDerivative";
-  case 985: return "RevoluteJoint_getMotionSubspaceVector";
-  case 986: return "RevoluteJoint_computeChildPosVelAcc";
-  case 987: return "RevoluteJoint_computeChildVel";
-  case 988: return "RevoluteJoint_computeChildVelAcc";
-  case 989: return "RevoluteJoint_computeChildAcc";
-  case 990: return "RevoluteJoint_computeChildBiasAcc";
-  case 991: return "RevoluteJoint_computeJointTorque";
-  case 992: return "RevoluteJoint_hasPosLimits";
-  case 993: return "RevoluteJoint_enablePosLimits";
-  case 994: return "RevoluteJoint_getPosLimits";
-  case 995: return "RevoluteJoint_getMinPosLimit";
-  case 996: return "RevoluteJoint_getMaxPosLimit";
-  case 997: return "RevoluteJoint_setPosLimits";
-  case 998: return "RevoluteJoint_getJointDynamicsType";
-  case 999: return "RevoluteJoint_setJointDynamicsType";
-  case 1000: return "RevoluteJoint_getDamping";
-  case 1001: return "RevoluteJoint_getStaticFriction";
-  case 1002: return "RevoluteJoint_setDamping";
-  case 1003: return "RevoluteJoint_setStaticFriction";
-  case 1004: return "new_PrismaticJoint";
-  case 1005: return "delete_PrismaticJoint";
-  case 1006: return "PrismaticJoint_clone";
-  case 1007: return "PrismaticJoint_setAttachedLinks";
-  case 1008: return "PrismaticJoint_setRestTransform";
-  case 1009: return "PrismaticJoint_setAxis";
-  case 1010: return "PrismaticJoint_getFirstAttachedLink";
-  case 1011: return "PrismaticJoint_getSecondAttachedLink";
-  case 1012: return "PrismaticJoint_getAxis";
-  case 1013: return "PrismaticJoint_getRestTransform";
-  case 1014: return "PrismaticJoint_getTransform";
-  case 1015: return "PrismaticJoint_getTransformDerivative";
-  case 1016: return "PrismaticJoint_getMotionSubspaceVector";
-  case 1017: return "PrismaticJoint_computeChildPosVelAcc";
-  case 1018: return "PrismaticJoint_computeChildVel";
-  case 1019: return "PrismaticJoint_computeChildVelAcc";
-  case 1020: return "PrismaticJoint_computeChildAcc";
-  case 1021: return "PrismaticJoint_computeChildBiasAcc";
-  case 1022: return "PrismaticJoint_computeJointTorque";
-  case 1023: return "PrismaticJoint_hasPosLimits";
-  case 1024: return "PrismaticJoint_enablePosLimits";
-  case 1025: return "PrismaticJoint_getPosLimits";
-  case 1026: return "PrismaticJoint_getMinPosLimit";
-  case 1027: return "PrismaticJoint_getMaxPosLimit";
-  case 1028: return "PrismaticJoint_setPosLimits";
-  case 1029: return "PrismaticJoint_getJointDynamicsType";
-  case 1030: return "PrismaticJoint_setJointDynamicsType";
-  case 1031: return "PrismaticJoint_getDamping";
-  case 1032: return "PrismaticJoint_getStaticFriction";
-  case 1033: return "PrismaticJoint_setDamping";
-  case 1034: return "PrismaticJoint_setStaticFriction";
-  case 1035: return "new_Traversal";
-  case 1036: return "delete_Traversal";
-  case 1037: return "Traversal_getNrOfVisitedLinks";
-  case 1038: return "Traversal_getLink";
-  case 1039: return "Traversal_getBaseLink";
-  case 1040: return "Traversal_getParentLink";
-  case 1041: return "Traversal_getParentJoint";
-  case 1042: return "Traversal_getParentLinkFromLinkIndex";
-  case 1043: return "Traversal_getParentJointFromLinkIndex";
-  case 1044: return "Traversal_getTraversalIndexFromLinkIndex";
-  case 1045: return "Traversal_reset";
-  case 1046: return "Traversal_addTraversalBase";
-  case 1047: return "Traversal_addTraversalElement";
-  case 1048: return "Traversal_isParentOf";
-  case 1049: return "Traversal_getChildLinkIndexFromJointIndex";
-  case 1050: return "Traversal_getParentLinkIndexFromJointIndex";
-  case 1051: return "Traversal_toString";
-  case 1052: return "new_Material";
-  case 1053: return "Material_name";
-  case 1054: return "Material_hasColor";
-  case 1055: return "Material_color";
-  case 1056: return "Material_setColor";
-  case 1057: return "Material_hasTexture";
-  case 1058: return "Material_texture";
-  case 1059: return "Material_setTexture";
-  case 1060: return "delete_Material";
-  case 1061: return "delete_SolidShape";
-  case 1062: return "SolidShape_clone";
-  case 1063: return "SolidShape_getName";
-  case 1064: return "SolidShape_setName";
-  case 1065: return "SolidShape_isNameValid";
-  case 1066: return "SolidShape_getLink_H_geometry";
-  case 1067: return "SolidShape_setLink_H_geometry";
-  case 1068: return "SolidShape_isMaterialSet";
-  case 1069: return "SolidShape_getMaterial";
-  case 1070: return "SolidShape_setMaterial";
-  case 1071: return "SolidShape_isSphere";
-  case 1072: return "SolidShape_isBox";
-  case 1073: return "SolidShape_isCylinder";
-  case 1074: return "SolidShape_isExternalMesh";
-  case 1075: return "SolidShape_asSphere";
-  case 1076: return "SolidShape_asBox";
-  case 1077: return "SolidShape_asCylinder";
-  case 1078: return "SolidShape_asExternalMesh";
-  case 1079: return "delete_Sphere";
-  case 1080: return "Sphere_clone";
-  case 1081: return "Sphere_getRadius";
-  case 1082: return "Sphere_setRadius";
-  case 1083: return "new_Sphere";
-  case 1084: return "delete_Box";
-  case 1085: return "Box_clone";
-  case 1086: return "Box_getX";
-  case 1087: return "Box_setX";
-  case 1088: return "Box_getY";
-  case 1089: return "Box_setY";
-  case 1090: return "Box_getZ";
-  case 1091: return "Box_setZ";
-  case 1092: return "new_Box";
-  case 1093: return "delete_Cylinder";
-  case 1094: return "Cylinder_clone";
-  case 1095: return "Cylinder_getLength";
-  case 1096: return "Cylinder_setLength";
-  case 1097: return "Cylinder_getRadius";
-  case 1098: return "Cylinder_setRadius";
-  case 1099: return "new_Cylinder";
-  case 1100: return "delete_ExternalMesh";
-  case 1101: return "ExternalMesh_clone";
-  case 1102: return "ExternalMesh_getFilename";
-  case 1103: return "ExternalMesh_getPackageDirs";
-  case 1104: return "ExternalMesh_getFileLocationOnLocalFileSystem";
-  case 1105: return "ExternalMesh_setFilename";
-  case 1106: return "ExternalMesh_setPackageDirs";
-  case 1107: return "ExternalMesh_getScale";
-  case 1108: return "ExternalMesh_setScale";
-  case 1109: return "new_ExternalMesh";
-  case 1110: return "delete_ModelSolidShapes";
-  case 1111: return "new_ModelSolidShapes";
-  case 1112: return "ModelSolidShapes_clear";
-  case 1113: return "ModelSolidShapes_resize";
-  case 1114: return "ModelSolidShapes_isConsistent";
-  case 1115: return "ModelSolidShapes_getLinkSolidShapes";
-  case 1116: return "NR_OF_SENSOR_TYPES_get";
-  case 1117: return "_wrap_isLinkSensor";
-  case 1118: return "_wrap_isJointSensor";
-  case 1119: return "_wrap_getSensorTypeSize";
-  case 1120: return "delete_Sensor";
-  case 1121: return "Sensor_getName";
-  case 1122: return "Sensor_getSensorType";
-  case 1123: return "Sensor_isValid";
-  case 1124: return "Sensor_setName";
-  case 1125: return "Sensor_clone";
-  case 1126: return "Sensor_isConsistent";
-  case 1127: return "Sensor_updateIndices";
-  case 1128: return "delete_JointSensor";
-  case 1129: return "JointSensor_getParentJoint";
-  case 1130: return "JointSensor_getParentJointIndex";
-  case 1131: return "JointSensor_setParentJoint";
-  case 1132: return "JointSensor_setParentJointIndex";
-  case 1133: return "JointSensor_isConsistent";
-  case 1134: return "delete_LinkSensor";
-  case 1135: return "LinkSensor_getParentLink";
-  case 1136: return "LinkSensor_getParentLinkIndex";
-  case 1137: return "LinkSensor_getLinkSensorTransform";
-  case 1138: return "LinkSensor_setParentLink";
-  case 1139: return "LinkSensor_setParentLinkIndex";
-  case 1140: return "LinkSensor_setLinkSensorTransform";
-  case 1141: return "LinkSensor_isConsistent";
-  case 1142: return "new_SensorsList";
-  case 1143: return "delete_SensorsList";
-  case 1144: return "SensorsList_addSensor";
-  case 1145: return "SensorsList_setSerialization";
-  case 1146: return "SensorsList_getSerialization";
-  case 1147: return "SensorsList_getNrOfSensors";
-  case 1148: return "SensorsList_getSensorIndex";
-  case 1149: return "SensorsList_getSizeOfAllSensorsMeasurements";
-  case 1150: return "SensorsList_getSensor";
-  case 1151: return "SensorsList_isConsistent";
-  case 1152: return "SensorsList_removeSensor";
-  case 1153: return "SensorsList_removeAllSensorsOfType";
-  case 1154: return "SensorsList_getSixAxisForceTorqueSensor";
-  case 1155: return "SensorsList_getAccelerometerSensor";
-  case 1156: return "SensorsList_getGyroscopeSensor";
-  case 1157: return "SensorsList_getThreeAxisAngularAccelerometerSensor";
-  case 1158: return "SensorsList_getThreeAxisForceTorqueContactSensor";
-  case 1159: return "new_SensorsMeasurements";
-  case 1160: return "delete_SensorsMeasurements";
-  case 1161: return "SensorsMeasurements_setNrOfSensors";
-  case 1162: return "SensorsMeasurements_getNrOfSensors";
-  case 1163: return "SensorsMeasurements_resize";
-  case 1164: return "SensorsMeasurements_toVector";
-  case 1165: return "SensorsMeasurements_setMeasurement";
-  case 1166: return "SensorsMeasurements_getMeasurement";
-  case 1167: return "SensorsMeasurements_getSizeOfAllSensorsMeasurements";
-  case 1168: return "Neighbor_neighborLink_get";
-  case 1169: return "Neighbor_neighborLink_set";
-  case 1170: return "Neighbor_neighborJoint_get";
-  case 1171: return "Neighbor_neighborJoint_set";
-  case 1172: return "new_Neighbor";
-  case 1173: return "delete_Neighbor";
-  case 1174: return "new_Model";
-  case 1175: return "Model_copy";
-  case 1176: return "delete_Model";
-  case 1177: return "Model_getNrOfLinks";
-  case 1178: return "Model_getPackageDirs";
-  case 1179: return "Model_setPackageDirs";
-  case 1180: return "Model_getLinkName";
-  case 1181: return "Model_getLinkIndex";
-  case 1182: return "Model_isValidLinkIndex";
-  case 1183: return "Model_getLink";
-  case 1184: return "Model_addLink";
-  case 1185: return "Model_getNrOfJoints";
-  case 1186: return "Model_getJointName";
-  case 1187: return "Model_getTotalMass";
-  case 1188: return "Model_getJointIndex";
-  case 1189: return "Model_getJoint";
-  case 1190: return "Model_isValidJointIndex";
-  case 1191: return "Model_isLinkNameUsed";
-  case 1192: return "Model_isJointNameUsed";
-  case 1193: return "Model_isFrameNameUsed";
-  case 1194: return "Model_addJoint";
-  case 1195: return "Model_addJointAndLink";
-  case 1196: return "Model_insertLinkToExistingJointAndAddJointForDisplacedLink";
-  case 1197: return "Model_getNrOfPosCoords";
-  case 1198: return "Model_getNrOfDOFs";
-  case 1199: return "Model_getNrOfFrames";
-  case 1200: return "Model_addAdditionalFrameToLink";
-  case 1201: return "Model_getFrameName";
-  case 1202: return "Model_getFrameIndex";
-  case 1203: return "Model_isValidFrameIndex";
-  case 1204: return "Model_getFrameTransform";
-  case 1205: return "Model_getFrameLink";
-  case 1206: return "Model_getLinkAdditionalFrames";
-  case 1207: return "Model_getNrOfNeighbors";
-  case 1208: return "Model_getNeighbor";
-  case 1209: return "Model_setDefaultBaseLink";
-  case 1210: return "Model_getDefaultBaseLink";
-  case 1211: return "Model_computeFullTreeTraversal";
-  case 1212: return "Model_getInertialParameters";
-  case 1213: return "Model_updateInertialParameters";
-  case 1214: return "Model_visualSolidShapes";
-  case 1215: return "Model_collisionSolidShapes";
-  case 1216: return "Model_sensors";
-  case 1217: return "Model_toString";
-  case 1218: return "Model_isValid";
-  case 1219: return "new_JointPosDoubleArray";
-  case 1220: return "JointPosDoubleArray_resize";
-  case 1221: return "JointPosDoubleArray_isConsistent";
-  case 1222: return "delete_JointPosDoubleArray";
-  case 1223: return "new_JointDOFsDoubleArray";
-  case 1224: return "JointDOFsDoubleArray_resize";
-  case 1225: return "JointDOFsDoubleArray_isConsistent";
-  case 1226: return "delete_JointDOFsDoubleArray";
-  case 1227: return "new_DOFSpatialForceArray";
-  case 1228: return "DOFSpatialForceArray_resize";
-  case 1229: return "DOFSpatialForceArray_isConsistent";
-  case 1230: return "DOFSpatialForceArray_paren";
-  case 1231: return "delete_DOFSpatialForceArray";
-  case 1232: return "new_DOFSpatialMotionArray";
-  case 1233: return "DOFSpatialMotionArray_resize";
-  case 1234: return "DOFSpatialMotionArray_isConsistent";
-  case 1235: return "DOFSpatialMotionArray_paren";
-  case 1236: return "delete_DOFSpatialMotionArray";
-  case 1237: return "new_FrameFreeFloatingJacobian";
-  case 1238: return "FrameFreeFloatingJacobian_resize";
-  case 1239: return "FrameFreeFloatingJacobian_isConsistent";
-  case 1240: return "delete_FrameFreeFloatingJacobian";
-  case 1241: return "new_MomentumFreeFloatingJacobian";
-  case 1242: return "MomentumFreeFloatingJacobian_resize";
-  case 1243: return "MomentumFreeFloatingJacobian_isConsistent";
-  case 1244: return "delete_MomentumFreeFloatingJacobian";
-  case 1245: return "new_FreeFloatingMassMatrix";
-  case 1246: return "FreeFloatingMassMatrix_resize";
-  case 1247: return "delete_FreeFloatingMassMatrix";
-  case 1248: return "new_FreeFloatingPos";
-  case 1249: return "FreeFloatingPos_resize";
-  case 1250: return "FreeFloatingPos_worldBasePos";
-  case 1251: return "FreeFloatingPos_jointPos";
-  case 1252: return "FreeFloatingPos_getNrOfPosCoords";
-  case 1253: return "delete_FreeFloatingPos";
-  case 1254: return "new_FreeFloatingGeneralizedTorques";
-  case 1255: return "FreeFloatingGeneralizedTorques_resize";
-  case 1256: return "FreeFloatingGeneralizedTorques_baseWrench";
-  case 1257: return "FreeFloatingGeneralizedTorques_jointTorques";
-  case 1258: return "FreeFloatingGeneralizedTorques_getNrOfDOFs";
-  case 1259: return "delete_FreeFloatingGeneralizedTorques";
-  case 1260: return "new_FreeFloatingVel";
-  case 1261: return "FreeFloatingVel_resize";
-  case 1262: return "FreeFloatingVel_baseVel";
-  case 1263: return "FreeFloatingVel_jointVel";
-  case 1264: return "FreeFloatingVel_getNrOfDOFs";
-  case 1265: return "delete_FreeFloatingVel";
-  case 1266: return "new_FreeFloatingAcc";
-  case 1267: return "FreeFloatingAcc_resize";
-  case 1268: return "FreeFloatingAcc_baseAcc";
-  case 1269: return "FreeFloatingAcc_jointAcc";
-  case 1270: return "FreeFloatingAcc_getNrOfDOFs";
-  case 1271: return "delete_FreeFloatingAcc";
-  case 1272: return "ContactWrench_contactId";
-  case 1273: return "ContactWrench_contactPoint";
-  case 1274: return "ContactWrench_contactWrench";
-  case 1275: return "new_ContactWrench";
-  case 1276: return "delete_ContactWrench";
-  case 1277: return "new_LinkContactWrenches";
-  case 1278: return "LinkContactWrenches_resize";
-  case 1279: return "LinkContactWrenches_getNrOfContactsForLink";
-  case 1280: return "LinkContactWrenches_setNrOfContactsForLink";
-  case 1281: return "LinkContactWrenches_getNrOfLinks";
-  case 1282: return "LinkContactWrenches_contactWrench";
-  case 1283: return "LinkContactWrenches_computeNetWrenches";
-  case 1284: return "LinkContactWrenches_toString";
-  case 1285: return "delete_LinkContactWrenches";
-  case 1286: return "_wrap_getRandomLink";
-  case 1287: return "_wrap_addRandomLinkToModel";
-  case 1288: return "_wrap_addRandomAdditionalFrameToModel";
-  case 1289: return "_wrap_getRandomLinkIndexOfModel";
-  case 1290: return "_wrap_getRandomLinkOfModel";
-  case 1291: return "_wrap_int2string";
-  case 1292: return "_wrap_getRandomModel";
-  case 1293: return "_wrap_getRandomChain";
-  case 1294: return "_wrap_getRandomJointPositions";
-  case 1295: return "_wrap_getRandomInverseDynamicsInputs";
-  case 1296: return "_wrap_removeFakeLinks";
-  case 1297: return "_wrap_createReducedModel";
-  case 1298: return "_wrap_createModelWithNormalizedJointNumbering";
-  case 1299: return "_wrap_extractSubModel";
-  case 1300: return "new_SubModelDecomposition";
-  case 1301: return "delete_SubModelDecomposition";
-  case 1302: return "SubModelDecomposition_splitModelAlongJoints";
-  case 1303: return "SubModelDecomposition_setNrOfSubModels";
-  case 1304: return "SubModelDecomposition_getNrOfSubModels";
-  case 1305: return "SubModelDecomposition_getNrOfLinks";
-  case 1306: return "SubModelDecomposition_getTraversal";
-  case 1307: return "SubModelDecomposition_getSubModelOfLink";
-  case 1308: return "SubModelDecomposition_getSubModelOfFrame";
-  case 1309: return "_wrap_computeTransformToTraversalBase";
-  case 1310: return "_wrap_computeTransformToSubModelBase";
-  case 1311: return "new_SixAxisForceTorqueSensor";
-  case 1312: return "delete_SixAxisForceTorqueSensor";
-  case 1313: return "SixAxisForceTorqueSensor_setName";
-  case 1314: return "SixAxisForceTorqueSensor_setFirstLinkSensorTransform";
-  case 1315: return "SixAxisForceTorqueSensor_setSecondLinkSensorTransform";
-  case 1316: return "SixAxisForceTorqueSensor_getFirstLinkIndex";
-  case 1317: return "SixAxisForceTorqueSensor_getSecondLinkIndex";
-  case 1318: return "SixAxisForceTorqueSensor_setFirstLinkName";
-  case 1319: return "SixAxisForceTorqueSensor_setSecondLinkName";
-  case 1320: return "SixAxisForceTorqueSensor_getFirstLinkName";
-  case 1321: return "SixAxisForceTorqueSensor_getSecondLinkName";
-  case 1322: return "SixAxisForceTorqueSensor_setParentJoint";
-  case 1323: return "SixAxisForceTorqueSensor_setParentJointIndex";
-  case 1324: return "SixAxisForceTorqueSensor_setAppliedWrenchLink";
-  case 1325: return "SixAxisForceTorqueSensor_getName";
-  case 1326: return "SixAxisForceTorqueSensor_getSensorType";
-  case 1327: return "SixAxisForceTorqueSensor_getParentJoint";
-  case 1328: return "SixAxisForceTorqueSensor_getParentJointIndex";
-  case 1329: return "SixAxisForceTorqueSensor_isValid";
-  case 1330: return "SixAxisForceTorqueSensor_clone";
-  case 1331: return "SixAxisForceTorqueSensor_updateIndices";
-  case 1332: return "SixAxisForceTorqueSensor_getAppliedWrenchLink";
-  case 1333: return "SixAxisForceTorqueSensor_isLinkAttachedToSensor";
-  case 1334: return "SixAxisForceTorqueSensor_getLinkSensorTransform";
-  case 1335: return "SixAxisForceTorqueSensor_getWrenchAppliedOnLink";
-  case 1336: return "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix";
-  case 1337: return "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix";
-  case 1338: return "SixAxisForceTorqueSensor_predictMeasurement";
-  case 1339: return "SixAxisForceTorqueSensor_toString";
-  case 1340: return "new_AccelerometerSensor";
-  case 1341: return "delete_AccelerometerSensor";
-  case 1342: return "AccelerometerSensor_setName";
-  case 1343: return "AccelerometerSensor_setLinkSensorTransform";
-  case 1344: return "AccelerometerSensor_setParentLink";
-  case 1345: return "AccelerometerSensor_setParentLinkIndex";
-  case 1346: return "AccelerometerSensor_getName";
-  case 1347: return "AccelerometerSensor_getSensorType";
-  case 1348: return "AccelerometerSensor_getParentLink";
-  case 1349: return "AccelerometerSensor_getParentLinkIndex";
-  case 1350: return "AccelerometerSensor_getLinkSensorTransform";
-  case 1351: return "AccelerometerSensor_isValid";
-  case 1352: return "AccelerometerSensor_clone";
-  case 1353: return "AccelerometerSensor_updateIndices";
-  case 1354: return "AccelerometerSensor_predictMeasurement";
-  case 1355: return "new_GyroscopeSensor";
-  case 1356: return "delete_GyroscopeSensor";
-  case 1357: return "GyroscopeSensor_setName";
-  case 1358: return "GyroscopeSensor_setLinkSensorTransform";
-  case 1359: return "GyroscopeSensor_setParentLink";
-  case 1360: return "GyroscopeSensor_setParentLinkIndex";
-  case 1361: return "GyroscopeSensor_getName";
-  case 1362: return "GyroscopeSensor_getSensorType";
-  case 1363: return "GyroscopeSensor_getParentLink";
-  case 1364: return "GyroscopeSensor_getParentLinkIndex";
-  case 1365: return "GyroscopeSensor_getLinkSensorTransform";
-  case 1366: return "GyroscopeSensor_isValid";
-  case 1367: return "GyroscopeSensor_clone";
-  case 1368: return "GyroscopeSensor_updateIndices";
-  case 1369: return "GyroscopeSensor_predictMeasurement";
-  case 1370: return "new_ThreeAxisAngularAccelerometerSensor";
-  case 1371: return "delete_ThreeAxisAngularAccelerometerSensor";
-  case 1372: return "ThreeAxisAngularAccelerometerSensor_setName";
-  case 1373: return "ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform";
-  case 1374: return "ThreeAxisAngularAccelerometerSensor_setParentLink";
-  case 1375: return "ThreeAxisAngularAccelerometerSensor_setParentLinkIndex";
-  case 1376: return "ThreeAxisAngularAccelerometerSensor_getName";
-  case 1377: return "ThreeAxisAngularAccelerometerSensor_getSensorType";
-  case 1378: return "ThreeAxisAngularAccelerometerSensor_getParentLink";
-  case 1379: return "ThreeAxisAngularAccelerometerSensor_getParentLinkIndex";
-  case 1380: return "ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform";
-  case 1381: return "ThreeAxisAngularAccelerometerSensor_isValid";
-  case 1382: return "ThreeAxisAngularAccelerometerSensor_clone";
-  case 1383: return "ThreeAxisAngularAccelerometerSensor_updateIndices";
-  case 1384: return "ThreeAxisAngularAccelerometerSensor_predictMeasurement";
-  case 1385: return "new_ThreeAxisForceTorqueContactSensor";
-  case 1386: return "delete_ThreeAxisForceTorqueContactSensor";
-  case 1387: return "ThreeAxisForceTorqueContactSensor_setName";
-  case 1388: return "ThreeAxisForceTorqueContactSensor_setLinkSensorTransform";
-  case 1389: return "ThreeAxisForceTorqueContactSensor_setParentLink";
-  case 1390: return "ThreeAxisForceTorqueContactSensor_setParentLinkIndex";
-  case 1391: return "ThreeAxisForceTorqueContactSensor_getName";
-  case 1392: return "ThreeAxisForceTorqueContactSensor_getSensorType";
-  case 1393: return "ThreeAxisForceTorqueContactSensor_getParentLink";
-  case 1394: return "ThreeAxisForceTorqueContactSensor_getParentLinkIndex";
-  case 1395: return "ThreeAxisForceTorqueContactSensor_getLinkSensorTransform";
-  case 1396: return "ThreeAxisForceTorqueContactSensor_isValid";
-  case 1397: return "ThreeAxisForceTorqueContactSensor_clone";
-  case 1398: return "ThreeAxisForceTorqueContactSensor_updateIndices";
-  case 1399: return "ThreeAxisForceTorqueContactSensor_setLoadCellLocations";
-  case 1400: return "ThreeAxisForceTorqueContactSensor_getLoadCellLocations";
-  case 1401: return "ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements";
-  case 1402: return "ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements";
-  case 1403: return "_wrap_predictSensorsMeasurements";
-  case 1404: return "_wrap_predictSensorsMeasurementsFromRawBuffers";
-  case 1405: return "SolidShapesVector_pop";
-  case 1406: return "SolidShapesVector_brace";
-  case 1407: return "SolidShapesVector_setbrace";
-  case 1408: return "SolidShapesVector_append";
-  case 1409: return "SolidShapesVector_empty";
-  case 1410: return "SolidShapesVector_size";
-  case 1411: return "SolidShapesVector_swap";
-  case 1412: return "SolidShapesVector_begin";
-  case 1413: return "SolidShapesVector_end";
-  case 1414: return "SolidShapesVector_rbegin";
-  case 1415: return "SolidShapesVector_rend";
-  case 1416: return "SolidShapesVector_clear";
-  case 1417: return "SolidShapesVector_get_allocator";
-  case 1418: return "SolidShapesVector_pop_back";
-  case 1419: return "SolidShapesVector_erase";
-  case 1420: return "new_SolidShapesVector";
-  case 1421: return "SolidShapesVector_push_back";
-  case 1422: return "SolidShapesVector_front";
-  case 1423: return "SolidShapesVector_back";
-  case 1424: return "SolidShapesVector_assign";
-  case 1425: return "SolidShapesVector_resize";
-  case 1426: return "SolidShapesVector_insert";
-  case 1427: return "SolidShapesVector_reserve";
-  case 1428: return "SolidShapesVector_capacity";
-  case 1429: return "delete_SolidShapesVector";
-  case 1430: return "LinksSolidShapesVector_pop";
-  case 1431: return "LinksSolidShapesVector_brace";
-  case 1432: return "LinksSolidShapesVector_setbrace";
-  case 1433: return "LinksSolidShapesVector_append";
-  case 1434: return "LinksSolidShapesVector_empty";
-  case 1435: return "LinksSolidShapesVector_size";
-  case 1436: return "LinksSolidShapesVector_swap";
-  case 1437: return "LinksSolidShapesVector_begin";
-  case 1438: return "LinksSolidShapesVector_end";
-  case 1439: return "LinksSolidShapesVector_rbegin";
-  case 1440: return "LinksSolidShapesVector_rend";
-  case 1441: return "LinksSolidShapesVector_clear";
-  case 1442: return "LinksSolidShapesVector_get_allocator";
-  case 1443: return "LinksSolidShapesVector_pop_back";
-  case 1444: return "LinksSolidShapesVector_erase";
-  case 1445: return "new_LinksSolidShapesVector";
-  case 1446: return "LinksSolidShapesVector_push_back";
-  case 1447: return "LinksSolidShapesVector_front";
-  case 1448: return "LinksSolidShapesVector_back";
-  case 1449: return "LinksSolidShapesVector_assign";
-  case 1450: return "LinksSolidShapesVector_resize";
-  case 1451: return "LinksSolidShapesVector_insert";
-  case 1452: return "LinksSolidShapesVector_reserve";
-  case 1453: return "LinksSolidShapesVector_capacity";
-  case 1454: return "delete_LinksSolidShapesVector";
-  case 1455: return "_wrap_ForwardPositionKinematics";
-  case 1456: return "_wrap_ForwardVelAccKinematics";
-  case 1457: return "_wrap_ForwardPosVelAccKinematics";
-  case 1458: return "_wrap_ForwardPosVelKinematics";
-  case 1459: return "_wrap_ForwardAccKinematics";
-  case 1460: return "_wrap_ForwardBiasAccKinematics";
-  case 1461: return "_wrap_ComputeLinearAndAngularMomentum";
-  case 1462: return "_wrap_ComputeLinearAndAngularMomentumDerivativeBias";
-  case 1463: return "_wrap_RNEADynamicPhase";
-  case 1464: return "_wrap_CompositeRigidBodyAlgorithm";
-  case 1465: return "new_ArticulatedBodyAlgorithmInternalBuffers";
-  case 1466: return "ArticulatedBodyAlgorithmInternalBuffers_resize";
-  case 1467: return "ArticulatedBodyAlgorithmInternalBuffers_isConsistent";
-  case 1468: return "ArticulatedBodyAlgorithmInternalBuffers_S_get";
-  case 1469: return "ArticulatedBodyAlgorithmInternalBuffers_S_set";
-  case 1470: return "ArticulatedBodyAlgorithmInternalBuffers_U_get";
-  case 1471: return "ArticulatedBodyAlgorithmInternalBuffers_U_set";
-  case 1472: return "ArticulatedBodyAlgorithmInternalBuffers_D_get";
-  case 1473: return "ArticulatedBodyAlgorithmInternalBuffers_D_set";
-  case 1474: return "ArticulatedBodyAlgorithmInternalBuffers_u_get";
-  case 1475: return "ArticulatedBodyAlgorithmInternalBuffers_u_set";
-  case 1476: return "ArticulatedBodyAlgorithmInternalBuffers_linksVel_get";
-  case 1477: return "ArticulatedBodyAlgorithmInternalBuffers_linksVel_set";
-  case 1478: return "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get";
-  case 1479: return "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set";
-  case 1480: return "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get";
-  case 1481: return "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set";
-  case 1482: return "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get";
-  case 1483: return "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set";
-  case 1484: return "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get";
-  case 1485: return "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set";
-  case 1486: return "delete_ArticulatedBodyAlgorithmInternalBuffers";
-  case 1487: return "_wrap_ArticulatedBodyAlgorithm";
-  case 1488: return "_wrap_InverseDynamicsInertialParametersRegressor";
-  case 1489: return "DHLink_A_get";
-  case 1490: return "DHLink_A_set";
-  case 1491: return "DHLink_D_get";
-  case 1492: return "DHLink_D_set";
-  case 1493: return "DHLink_Alpha_get";
-  case 1494: return "DHLink_Alpha_set";
-  case 1495: return "DHLink_Offset_get";
-  case 1496: return "DHLink_Offset_set";
-  case 1497: return "DHLink_Min_get";
-  case 1498: return "DHLink_Min_set";
-  case 1499: return "DHLink_Max_get";
-  case 1500: return "DHLink_Max_set";
-  case 1501: return "new_DHLink";
-  case 1502: return "delete_DHLink";
-  case 1503: return "DHChain_setNrOfDOFs";
-  case 1504: return "DHChain_getNrOfDOFs";
-  case 1505: return "DHChain_setH0";
-  case 1506: return "DHChain_getH0";
-  case 1507: return "DHChain_setHN";
-  case 1508: return "DHChain_getHN";
-  case 1509: return "DHChain_paren";
-  case 1510: return "DHChain_getDOFName";
-  case 1511: return "DHChain_setDOFName";
-  case 1512: return "DHChain_toModel";
-  case 1513: return "DHChain_fromModel";
-  case 1514: return "new_DHChain";
-  case 1515: return "delete_DHChain";
-  case 1516: return "_wrap_TransformFromDHCraig1989";
-  case 1517: return "_wrap_TransformFromDH";
-  case 1518: return "_wrap_ExtractDHChainFromModel";
-  case 1519: return "_wrap_CreateModelFromDHChain";
-  case 1520: return "_wrap_dofsListFromURDF";
-  case 1521: return "_wrap_dofsListFromURDFString";
-  case 1522: return "ModelParserOptions_addSensorFramesAsAdditionalFrames_get";
-  case 1523: return "ModelParserOptions_addSensorFramesAsAdditionalFrames_set";
-  case 1524: return "ModelParserOptions_originalFilename_get";
-  case 1525: return "ModelParserOptions_originalFilename_set";
-  case 1526: return "new_ModelParserOptions";
-  case 1527: return "delete_ModelParserOptions";
-  case 1528: return "new_ModelLoader";
-  case 1529: return "delete_ModelLoader";
-  case 1530: return "ModelLoader_parsingOptions";
-  case 1531: return "ModelLoader_setParsingOptions";
-  case 1532: return "ModelLoader_loadModelFromString";
-  case 1533: return "ModelLoader_loadModelFromFile";
-  case 1534: return "ModelLoader_loadReducedModelFromFullModel";
-  case 1535: return "ModelLoader_loadReducedModelFromString";
-  case 1536: return "ModelLoader_loadReducedModelFromFile";
-  case 1537: return "ModelLoader_model";
-  case 1538: return "ModelLoader_sensors";
-  case 1539: return "ModelLoader_isValid";
-  case 1540: return "ModelExporterOptions_baseLink_get";
-  case 1541: return "ModelExporterOptions_baseLink_set";
-  case 1542: return "ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_get";
-  case 1543: return "ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_set";
-  case 1544: return "ModelExporterOptions_robotExportedName_get";
-  case 1545: return "ModelExporterOptions_robotExportedName_set";
-  case 1546: return "ModelExporterOptions_xmlBlobs_get";
-  case 1547: return "ModelExporterOptions_xmlBlobs_set";
-  case 1548: return "new_ModelExporterOptions";
-  case 1549: return "delete_ModelExporterOptions";
-  case 1550: return "new_ModelExporter";
-  case 1551: return "delete_ModelExporter";
-  case 1552: return "ModelExporter_exportingOptions";
-  case 1553: return "ModelExporter_setExportingOptions";
-  case 1554: return "ModelExporter_init";
-  case 1555: return "ModelExporter_model";
-  case 1556: return "ModelExporter_sensors";
-  case 1557: return "ModelExporter_isValid";
-  case 1558: return "ModelExporter_exportModelToString";
-  case 1559: return "ModelExporter_exportModelToFile";
-  case 1560: return "new_ModelCalibrationHelper";
-  case 1561: return "delete_ModelCalibrationHelper";
-  case 1562: return "ModelCalibrationHelper_loadModelFromString";
-  case 1563: return "ModelCalibrationHelper_loadModelFromFile";
-  case 1564: return "ModelCalibrationHelper_updateModelInertialParametersToString";
-  case 1565: return "ModelCalibrationHelper_updateModelInertialParametersToFile";
-  case 1566: return "ModelCalibrationHelper_model";
-  case 1567: return "ModelCalibrationHelper_sensors";
-  case 1568: return "ModelCalibrationHelper_isValid";
-  case 1569: return "new_UnknownWrenchContact";
-  case 1570: return "UnknownWrenchContact_unknownType_get";
-  case 1571: return "UnknownWrenchContact_unknownType_set";
-  case 1572: return "UnknownWrenchContact_contactPoint_get";
-  case 1573: return "UnknownWrenchContact_contactPoint_set";
-  case 1574: return "UnknownWrenchContact_forceDirection_get";
-  case 1575: return "UnknownWrenchContact_forceDirection_set";
-  case 1576: return "UnknownWrenchContact_knownWrench_get";
-  case 1577: return "UnknownWrenchContact_knownWrench_set";
-  case 1578: return "UnknownWrenchContact_contactId_get";
-  case 1579: return "UnknownWrenchContact_contactId_set";
-  case 1580: return "delete_UnknownWrenchContact";
-  case 1581: return "new_LinkUnknownWrenchContacts";
-  case 1582: return "LinkUnknownWrenchContacts_clear";
-  case 1583: return "LinkUnknownWrenchContacts_resize";
-  case 1584: return "LinkUnknownWrenchContacts_getNrOfContactsForLink";
-  case 1585: return "LinkUnknownWrenchContacts_setNrOfContactsForLink";
-  case 1586: return "LinkUnknownWrenchContacts_addNewContactForLink";
-  case 1587: return "LinkUnknownWrenchContacts_addNewContactInFrame";
-  case 1588: return "LinkUnknownWrenchContacts_addNewUnknownFullWrenchInFrameOrigin";
-  case 1589: return "LinkUnknownWrenchContacts_contactWrench";
-  case 1590: return "LinkUnknownWrenchContacts_toString";
-  case 1591: return "delete_LinkUnknownWrenchContacts";
-  case 1592: return "new_estimateExternalWrenchesBuffers";
-  case 1593: return "estimateExternalWrenchesBuffers_resize";
-  case 1594: return "estimateExternalWrenchesBuffers_getNrOfSubModels";
-  case 1595: return "estimateExternalWrenchesBuffers_getNrOfLinks";
-  case 1596: return "estimateExternalWrenchesBuffers_isConsistent";
-  case 1597: return "estimateExternalWrenchesBuffers_A_get";
-  case 1598: return "estimateExternalWrenchesBuffers_A_set";
-  case 1599: return "estimateExternalWrenchesBuffers_x_get";
-  case 1600: return "estimateExternalWrenchesBuffers_x_set";
-  case 1601: return "estimateExternalWrenchesBuffers_b_get";
-  case 1602: return "estimateExternalWrenchesBuffers_b_set";
-  case 1603: return "estimateExternalWrenchesBuffers_b_contacts_subtree_get";
-  case 1604: return "estimateExternalWrenchesBuffers_b_contacts_subtree_set";
-  case 1605: return "estimateExternalWrenchesBuffers_subModelBase_H_link_get";
-  case 1606: return "estimateExternalWrenchesBuffers_subModelBase_H_link_set";
-  case 1607: return "delete_estimateExternalWrenchesBuffers";
-  case 1608: return "_wrap_estimateExternalWrenchesWithoutInternalFT";
-  case 1609: return "_wrap_estimateExternalWrenches";
-  case 1610: return "_wrap_dynamicsEstimationForwardVelAccKinematics";
-  case 1611: return "_wrap_dynamicsEstimationForwardVelKinematics";
-  case 1612: return "_wrap_computeLinkNetWrenchesWithoutGravity";
-  case 1613: return "_wrap_estimateLinkContactWrenchesFromLinkNetExternalWrenches";
-  case 1614: return "new_ExtWrenchesAndJointTorquesEstimator";
-  case 1615: return "delete_ExtWrenchesAndJointTorquesEstimator";
-  case 1616: return "ExtWrenchesAndJointTorquesEstimator_setModel";
-  case 1617: return "ExtWrenchesAndJointTorquesEstimator_setModelAndSensors";
-  case 1618: return "ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFile";
-  case 1619: return "ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFileWithSpecifiedDOFs";
-  case 1620: return "ExtWrenchesAndJointTorquesEstimator_model";
-  case 1621: return "ExtWrenchesAndJointTorquesEstimator_sensors";
-  case 1622: return "ExtWrenchesAndJointTorquesEstimator_submodels";
-  case 1623: return "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase";
-  case 1624: return "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase";
-  case 1625: return "ExtWrenchesAndJointTorquesEstimator_computeExpectedFTSensorsMeasurements";
-  case 1626: return "ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics";
-  case 1627: return "ExtWrenchesAndJointTorquesEstimator_estimateExtWrenchesAndJointTorques";
-  case 1628: return "ExtWrenchesAndJointTorquesEstimator_checkThatTheModelIsStill";
-  case 1629: return "ExtWrenchesAndJointTorquesEstimator_estimateLinkNetWrenchesWithoutGravity";
-  case 1630: return "new_SimpleLeggedOdometry";
-  case 1631: return "delete_SimpleLeggedOdometry";
-  case 1632: return "SimpleLeggedOdometry_setModel";
-  case 1633: return "SimpleLeggedOdometry_model";
-  case 1634: return "SimpleLeggedOdometry_updateKinematics";
-  case 1635: return "SimpleLeggedOdometry_init";
-  case 1636: return "SimpleLeggedOdometry_changeFixedFrame";
-  case 1637: return "SimpleLeggedOdometry_getCurrentFixedLink";
-  case 1638: return "SimpleLeggedOdometry_getWorldLinkTransform";
-  case 1639: return "SimpleLeggedOdometry_getWorldFrameTransform";
-  case 1640: return "_wrap_isLinkBerdyDynamicVariable";
-  case 1641: return "_wrap_isJointBerdyDynamicVariable";
-  case 1642: return "_wrap_isDOFBerdyDynamicVariable";
-  case 1643: return "new_BerdyOptions";
-  case 1644: return "BerdyOptions_berdyVariant_get";
-  case 1645: return "BerdyOptions_berdyVariant_set";
-  case 1646: return "BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_get";
-  case 1647: return "BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_set";
-  case 1648: return "BerdyOptions_includeAllJointAccelerationsAsSensors_get";
-  case 1649: return "BerdyOptions_includeAllJointAccelerationsAsSensors_set";
-  case 1650: return "BerdyOptions_includeAllJointTorquesAsSensors_get";
-  case 1651: return "BerdyOptions_includeAllJointTorquesAsSensors_set";
-  case 1652: return "BerdyOptions_includeAllNetExternalWrenchesAsSensors_get";
-  case 1653: return "BerdyOptions_includeAllNetExternalWrenchesAsSensors_set";
-  case 1654: return "BerdyOptions_includeFixedBaseExternalWrench_get";
-  case 1655: return "BerdyOptions_includeFixedBaseExternalWrench_set";
-  case 1656: return "BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_get";
-  case 1657: return "BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_set";
-  case 1658: return "BerdyOptions_baseLink_get";
-  case 1659: return "BerdyOptions_baseLink_set";
-  case 1660: return "BerdyOptions_checkConsistency";
-  case 1661: return "delete_BerdyOptions";
-  case 1662: return "BerdySensor_type_get";
-  case 1663: return "BerdySensor_type_set";
-  case 1664: return "BerdySensor_id_get";
-  case 1665: return "BerdySensor_id_set";
-  case 1666: return "BerdySensor_range_get";
-  case 1667: return "BerdySensor_range_set";
-  case 1668: return "BerdySensor_eq";
-  case 1669: return "BerdySensor_lt";
-  case 1670: return "new_BerdySensor";
-  case 1671: return "delete_BerdySensor";
-  case 1672: return "BerdyDynamicVariable_type_get";
-  case 1673: return "BerdyDynamicVariable_type_set";
-  case 1674: return "BerdyDynamicVariable_id_get";
-  case 1675: return "BerdyDynamicVariable_id_set";
-  case 1676: return "BerdyDynamicVariable_range_get";
-  case 1677: return "BerdyDynamicVariable_range_set";
-  case 1678: return "BerdyDynamicVariable_eq";
-  case 1679: return "BerdyDynamicVariable_lt";
-  case 1680: return "new_BerdyDynamicVariable";
-  case 1681: return "delete_BerdyDynamicVariable";
-  case 1682: return "new_BerdyHelper";
-  case 1683: return "BerdyHelper_dynamicTraversal";
-  case 1684: return "BerdyHelper_model";
-  case 1685: return "BerdyHelper_sensors";
-  case 1686: return "BerdyHelper_isValid";
-  case 1687: return "BerdyHelper_init";
-  case 1688: return "BerdyHelper_getOptions";
-  case 1689: return "BerdyHelper_getNrOfDynamicVariables";
-  case 1690: return "BerdyHelper_getNrOfDynamicEquations";
-  case 1691: return "BerdyHelper_getNrOfSensorsMeasurements";
-  case 1692: return "BerdyHelper_resizeAndZeroBerdyMatrices";
-  case 1693: return "BerdyHelper_getBerdyMatrices";
-  case 1694: return "BerdyHelper_getSensorsOrdering";
-  case 1695: return "BerdyHelper_getRangeSensorVariable";
-  case 1696: return "BerdyHelper_getRangeDOFSensorVariable";
-  case 1697: return "BerdyHelper_getRangeJointSensorVariable";
-  case 1698: return "BerdyHelper_getRangeLinkSensorVariable";
-  case 1699: return "BerdyHelper_getRangeRCMSensorVariable";
-  case 1700: return "BerdyHelper_getRangeLinkVariable";
-  case 1701: return "BerdyHelper_getRangeJointVariable";
-  case 1702: return "BerdyHelper_getRangeDOFVariable";
-  case 1703: return "BerdyHelper_getDynamicVariablesOrdering";
-  case 1704: return "BerdyHelper_serializeDynamicVariables";
-  case 1705: return "BerdyHelper_serializeSensorVariables";
-  case 1706: return "BerdyHelper_serializeDynamicVariablesComputedFromFixedBaseRNEA";
-  case 1707: return "BerdyHelper_extractJointTorquesFromDynamicVariables";
-  case 1708: return "BerdyHelper_extractLinkNetExternalWrenchesFromDynamicVariables";
-  case 1709: return "BerdyHelper_updateKinematicsFromFloatingBase";
-  case 1710: return "BerdyHelper_updateKinematicsFromFixedBase";
-  case 1711: return "BerdyHelper_updateKinematicsFromTraversalFixedBase";
-  case 1712: return "BerdyHelper_setNetExternalWrenchMeasurementFrame";
-  case 1713: return "BerdyHelper_getNetExternalWrenchMeasurementFrame";
-  case 1714: return "delete_BerdyHelper";
-  case 1715: return "new_BerdySparseMAPSolver";
-  case 1716: return "delete_BerdySparseMAPSolver";
-  case 1717: return "BerdySparseMAPSolver_setDynamicsConstraintsPriorCovariance";
-  case 1718: return "BerdySparseMAPSolver_setDynamicsRegularizationPriorCovariance";
-  case 1719: return "BerdySparseMAPSolver_setDynamicsRegularizationPriorExpectedValue";
-  case 1720: return "BerdySparseMAPSolver_setMeasurementsPriorCovariance";
-  case 1721: return "BerdySparseMAPSolver_dynamicsConstraintsPriorCovarianceInverse";
-  case 1722: return "BerdySparseMAPSolver_dynamicsRegularizationPriorCovarianceInverse";
-  case 1723: return "BerdySparseMAPSolver_dynamicsRegularizationPriorExpectedValue";
-  case 1724: return "BerdySparseMAPSolver_measurementsPriorCovarianceInverse";
-  case 1725: return "BerdySparseMAPSolver_isValid";
-  case 1726: return "BerdySparseMAPSolver_initialize";
-  case 1727: return "BerdySparseMAPSolver_updateEstimateInformationFixedBase";
-  case 1728: return "BerdySparseMAPSolver_updateEstimateInformationFloatingBase";
-  case 1729: return "BerdySparseMAPSolver_doEstimate";
-  case 1730: return "BerdySparseMAPSolver_getLastEstimate";
-  case 1731: return "AttitudeEstimatorState_m_orientation_get";
-  case 1732: return "AttitudeEstimatorState_m_orientation_set";
-  case 1733: return "AttitudeEstimatorState_m_angular_velocity_get";
-  case 1734: return "AttitudeEstimatorState_m_angular_velocity_set";
-  case 1735: return "AttitudeEstimatorState_m_gyroscope_bias_get";
-  case 1736: return "AttitudeEstimatorState_m_gyroscope_bias_set";
-  case 1737: return "new_AttitudeEstimatorState";
-  case 1738: return "delete_AttitudeEstimatorState";
-  case 1739: return "delete_IAttitudeEstimator";
-  case 1740: return "IAttitudeEstimator_updateFilterWithMeasurements";
-  case 1741: return "IAttitudeEstimator_propagateStates";
-  case 1742: return "IAttitudeEstimator_getOrientationEstimateAsRotationMatrix";
-  case 1743: return "IAttitudeEstimator_getOrientationEstimateAsQuaternion";
-  case 1744: return "IAttitudeEstimator_getOrientationEstimateAsRPY";
-  case 1745: return "IAttitudeEstimator_getInternalStateSize";
-  case 1746: return "IAttitudeEstimator_getInternalState";
-  case 1747: return "IAttitudeEstimator_getDefaultInternalInitialState";
-  case 1748: return "IAttitudeEstimator_setInternalState";
-  case 1749: return "IAttitudeEstimator_setInternalStateInitialOrientation";
-  case 1750: return "AttitudeMahonyFilterParameters_time_step_in_seconds_get";
-  case 1751: return "AttitudeMahonyFilterParameters_time_step_in_seconds_set";
-  case 1752: return "AttitudeMahonyFilterParameters_kp_get";
-  case 1753: return "AttitudeMahonyFilterParameters_kp_set";
-  case 1754: return "AttitudeMahonyFilterParameters_ki_get";
-  case 1755: return "AttitudeMahonyFilterParameters_ki_set";
-  case 1756: return "AttitudeMahonyFilterParameters_use_magnetometer_measurements_get";
-  case 1757: return "AttitudeMahonyFilterParameters_use_magnetometer_measurements_set";
-  case 1758: return "AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_get";
-  case 1759: return "AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_set";
-  case 1760: return "new_AttitudeMahonyFilterParameters";
-  case 1761: return "delete_AttitudeMahonyFilterParameters";
-  case 1762: return "new_AttitudeMahonyFilter";
-  case 1763: return "AttitudeMahonyFilter_useMagnetoMeterMeasurements";
-  case 1764: return "AttitudeMahonyFilter_setConfidenceForMagnetometerMeasurements";
-  case 1765: return "AttitudeMahonyFilter_setGainkp";
-  case 1766: return "AttitudeMahonyFilter_setGainki";
-  case 1767: return "AttitudeMahonyFilter_setTimeStepInSeconds";
-  case 1768: return "AttitudeMahonyFilter_setGravityDirection";
-  case 1769: return "AttitudeMahonyFilter_setParameters";
-  case 1770: return "AttitudeMahonyFilter_getParameters";
-  case 1771: return "AttitudeMahonyFilter_updateFilterWithMeasurements";
-  case 1772: return "AttitudeMahonyFilter_propagateStates";
-  case 1773: return "AttitudeMahonyFilter_getOrientationEstimateAsRotationMatrix";
-  case 1774: return "AttitudeMahonyFilter_getOrientationEstimateAsQuaternion";
-  case 1775: return "AttitudeMahonyFilter_getOrientationEstimateAsRPY";
-  case 1776: return "AttitudeMahonyFilter_getInternalStateSize";
-  case 1777: return "AttitudeMahonyFilter_getInternalState";
-  case 1778: return "AttitudeMahonyFilter_getDefaultInternalInitialState";
-  case 1779: return "AttitudeMahonyFilter_setInternalState";
-  case 1780: return "AttitudeMahonyFilter_setInternalStateInitialOrientation";
-  case 1781: return "delete_AttitudeMahonyFilter";
-  case 1782: return "DiscreteExtendedKalmanFilterHelper_ekf_f";
-  case 1783: return "DiscreteExtendedKalmanFilterHelper_ekf_h";
-  case 1784: return "DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianF";
-  case 1785: return "DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianH";
-  case 1786: return "DiscreteExtendedKalmanFilterHelper_ekfPredict";
-  case 1787: return "DiscreteExtendedKalmanFilterHelper_ekfUpdate";
-  case 1788: return "DiscreteExtendedKalmanFilterHelper_ekfInit";
-  case 1789: return "DiscreteExtendedKalmanFilterHelper_ekfReset";
-  case 1790: return "DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementVector";
-  case 1791: return "DiscreteExtendedKalmanFilterHelper_ekfSetInputVector";
-  case 1792: return "DiscreteExtendedKalmanFilterHelper_ekfSetInitialState";
-  case 1793: return "DiscreteExtendedKalmanFilterHelper_ekfSetStateCovariance";
-  case 1794: return "DiscreteExtendedKalmanFilterHelper_ekfSetSystemNoiseCovariance";
-  case 1795: return "DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementNoiseCovariance";
-  case 1796: return "DiscreteExtendedKalmanFilterHelper_ekfSetStateSize";
-  case 1797: return "DiscreteExtendedKalmanFilterHelper_ekfSetInputSize";
-  case 1798: return "DiscreteExtendedKalmanFilterHelper_ekfSetOutputSize";
-  case 1799: return "DiscreteExtendedKalmanFilterHelper_ekfGetStates";
-  case 1800: return "DiscreteExtendedKalmanFilterHelper_ekfGetStateCovariance";
-  case 1801: return "delete_DiscreteExtendedKalmanFilterHelper";
-  case 1802: return "output_dimensions_with_magnetometer_get";
-  case 1803: return "output_dimensions_without_magnetometer_get";
-  case 1804: return "input_dimensions_get";
-  case 1805: return "AttitudeQuaternionEKFParameters_time_step_in_seconds_get";
-  case 1806: return "AttitudeQuaternionEKFParameters_time_step_in_seconds_set";
-  case 1807: return "AttitudeQuaternionEKFParameters_bias_correlation_time_factor_get";
-  case 1808: return "AttitudeQuaternionEKFParameters_bias_correlation_time_factor_set";
-  case 1809: return "AttitudeQuaternionEKFParameters_accelerometer_noise_variance_get";
-  case 1810: return "AttitudeQuaternionEKFParameters_accelerometer_noise_variance_set";
-  case 1811: return "AttitudeQuaternionEKFParameters_magnetometer_noise_variance_get";
-  case 1812: return "AttitudeQuaternionEKFParameters_magnetometer_noise_variance_set";
-  case 1813: return "AttitudeQuaternionEKFParameters_gyroscope_noise_variance_get";
-  case 1814: return "AttitudeQuaternionEKFParameters_gyroscope_noise_variance_set";
-  case 1815: return "AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_get";
-  case 1816: return "AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_set";
-  case 1817: return "AttitudeQuaternionEKFParameters_initial_orientation_error_variance_get";
-  case 1818: return "AttitudeQuaternionEKFParameters_initial_orientation_error_variance_set";
-  case 1819: return "AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_get";
-  case 1820: return "AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_set";
-  case 1821: return "AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_get";
-  case 1822: return "AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_set";
-  case 1823: return "AttitudeQuaternionEKFParameters_use_magnetometer_measurements_get";
-  case 1824: return "AttitudeQuaternionEKFParameters_use_magnetometer_measurements_set";
-  case 1825: return "new_AttitudeQuaternionEKFParameters";
-  case 1826: return "delete_AttitudeQuaternionEKFParameters";
-  case 1827: return "new_AttitudeQuaternionEKF";
-  case 1828: return "AttitudeQuaternionEKF_getParameters";
-  case 1829: return "AttitudeQuaternionEKF_setParameters";
-  case 1830: return "AttitudeQuaternionEKF_setGravityDirection";
-  case 1831: return "AttitudeQuaternionEKF_setTimeStepInSeconds";
-  case 1832: return "AttitudeQuaternionEKF_setBiasCorrelationTimeFactor";
-  case 1833: return "AttitudeQuaternionEKF_useMagnetometerMeasurements";
-  case 1834: return "AttitudeQuaternionEKF_setMeasurementNoiseVariance";
-  case 1835: return "AttitudeQuaternionEKF_setSystemNoiseVariance";
-  case 1836: return "AttitudeQuaternionEKF_setInitialStateCovariance";
-  case 1837: return "AttitudeQuaternionEKF_initializeFilter";
-  case 1838: return "AttitudeQuaternionEKF_updateFilterWithMeasurements";
-  case 1839: return "AttitudeQuaternionEKF_propagateStates";
-  case 1840: return "AttitudeQuaternionEKF_getOrientationEstimateAsRotationMatrix";
-  case 1841: return "AttitudeQuaternionEKF_getOrientationEstimateAsQuaternion";
-  case 1842: return "AttitudeQuaternionEKF_getOrientationEstimateAsRPY";
-  case 1843: return "AttitudeQuaternionEKF_getInternalStateSize";
-  case 1844: return "AttitudeQuaternionEKF_getInternalState";
-  case 1845: return "AttitudeQuaternionEKF_getDefaultInternalInitialState";
-  case 1846: return "AttitudeQuaternionEKF_setInternalState";
-  case 1847: return "AttitudeQuaternionEKF_setInternalStateInitialOrientation";
-  case 1848: return "delete_AttitudeQuaternionEKF";
-  case 1849: return "_wrap_estimateInertialParametersFromLinkBoundingBoxesAndTotalMass";
-  case 1850: return "_wrap_computeBoundingBoxFromShape";
-  case 1851: return "_wrap_computeBoxVertices";
-  case 1852: return "new_KinDynComputations";
-  case 1853: return "delete_KinDynComputations";
-  case 1854: return "KinDynComputations_loadRobotModel";
-  case 1855: return "KinDynComputations_isValid";
-  case 1856: return "KinDynComputations_setFrameVelocityRepresentation";
-  case 1857: return "KinDynComputations_getFrameVelocityRepresentation";
-  case 1858: return "KinDynComputations_getNrOfDegreesOfFreedom";
-  case 1859: return "KinDynComputations_getDescriptionOfDegreeOfFreedom";
-  case 1860: return "KinDynComputations_getDescriptionOfDegreesOfFreedom";
-  case 1861: return "KinDynComputations_getNrOfLinks";
-  case 1862: return "KinDynComputations_getNrOfFrames";
-  case 1863: return "KinDynComputations_getFloatingBase";
-  case 1864: return "KinDynComputations_setFloatingBase";
-  case 1865: return "KinDynComputations_model";
-  case 1866: return "KinDynComputations_getRobotModel";
-  case 1867: return "KinDynComputations_getRelativeJacobianSparsityPattern";
-  case 1868: return "KinDynComputations_getFrameFreeFloatingJacobianSparsityPattern";
-  case 1869: return "KinDynComputations_setJointPos";
-  case 1870: return "KinDynComputations_setRobotState";
-  case 1871: return "KinDynComputations_getRobotState";
-  case 1872: return "KinDynComputations_getWorldBaseTransform";
-  case 1873: return "KinDynComputations_getBaseTwist";
-  case 1874: return "KinDynComputations_getJointPos";
-  case 1875: return "KinDynComputations_getJointVel";
-  case 1876: return "KinDynComputations_getModelVel";
-  case 1877: return "KinDynComputations_getFrameIndex";
-  case 1878: return "KinDynComputations_getFrameName";
-  case 1879: return "KinDynComputations_getWorldTransform";
-  case 1880: return "KinDynComputations_getWorldTransformsAsHomogeneous";
-  case 1881: return "KinDynComputations_getRelativeTransformExplicit";
-  case 1882: return "KinDynComputations_getRelativeTransform";
-  case 1883: return "KinDynComputations_getFrameVel";
-  case 1884: return "KinDynComputations_getFrameAcc";
-  case 1885: return "KinDynComputations_getFrameFreeFloatingJacobian";
-  case 1886: return "KinDynComputations_getRelativeJacobian";
-  case 1887: return "KinDynComputations_getRelativeJacobianExplicit";
-  case 1888: return "KinDynComputations_getFrameBiasAcc";
-  case 1889: return "KinDynComputations_getCenterOfMassPosition";
-  case 1890: return "KinDynComputations_getCenterOfMassVelocity";
-  case 1891: return "KinDynComputations_getCenterOfMassJacobian";
-  case 1892: return "KinDynComputations_getCenterOfMassBiasAcc";
-  case 1893: return "KinDynComputations_getAverageVelocity";
-  case 1894: return "KinDynComputations_getAverageVelocityJacobian";
-  case 1895: return "KinDynComputations_getCentroidalAverageVelocity";
-  case 1896: return "KinDynComputations_getCentroidalAverageVelocityJacobian";
-  case 1897: return "KinDynComputations_getLinearAngularMomentum";
-  case 1898: return "KinDynComputations_getLinearAngularMomentumJacobian";
-  case 1899: return "KinDynComputations_getCentroidalTotalMomentum";
-  case 1900: return "KinDynComputations_getCentroidalTotalMomentumJacobian";
-  case 1901: return "KinDynComputations_getFreeFloatingMassMatrix";
-  case 1902: return "KinDynComputations_inverseDynamics";
-  case 1903: return "KinDynComputations_inverseDynamicsWithInternalJointForceTorques";
-  case 1904: return "KinDynComputations_generalizedBiasForces";
-  case 1905: return "KinDynComputations_generalizedGravityForces";
-  case 1906: return "KinDynComputations_generalizedExternalForces";
-  case 1907: return "KinDynComputations_inverseDynamicsInertialParametersRegressor";
-  case 1908: return "Matrix4x4Vector_pop";
-  case 1909: return "Matrix4x4Vector_brace";
-  case 1910: return "Matrix4x4Vector_setbrace";
-  case 1911: return "Matrix4x4Vector_append";
-  case 1912: return "Matrix4x4Vector_empty";
-  case 1913: return "Matrix4x4Vector_size";
-  case 1914: return "Matrix4x4Vector_swap";
-  case 1915: return "Matrix4x4Vector_begin";
-  case 1916: return "Matrix4x4Vector_end";
-  case 1917: return "Matrix4x4Vector_rbegin";
-  case 1918: return "Matrix4x4Vector_rend";
-  case 1919: return "Matrix4x4Vector_clear";
-  case 1920: return "Matrix4x4Vector_get_allocator";
-  case 1921: return "Matrix4x4Vector_pop_back";
-  case 1922: return "Matrix4x4Vector_erase";
-  case 1923: return "new_Matrix4x4Vector";
-  case 1924: return "Matrix4x4Vector_push_back";
-  case 1925: return "Matrix4x4Vector_front";
-  case 1926: return "Matrix4x4Vector_back";
-  case 1927: return "Matrix4x4Vector_assign";
-  case 1928: return "Matrix4x4Vector_resize";
-  case 1929: return "Matrix4x4Vector_insert";
-  case 1930: return "Matrix4x4Vector_reserve";
-  case 1931: return "Matrix4x4Vector_capacity";
-  case 1932: return "Matrix4x4Vector_toMatlab";
-  case 1933: return "delete_Matrix4x4Vector";
-  case 1934: return "ICameraAnimator_enableMouseControl";
-  case 1935: return "ICameraAnimator_getMoveSpeed";
-  case 1936: return "ICameraAnimator_setMoveSpeed";
-  case 1937: return "ICameraAnimator_getRotateSpeed";
-  case 1938: return "ICameraAnimator_setRotateSpeed";
-  case 1939: return "ICameraAnimator_getZoomSpeed";
-  case 1940: return "ICameraAnimator_setZoomSpeed";
-  case 1941: return "delete_ICameraAnimator";
-  case 1942: return "delete_ICamera";
-  case 1943: return "ICamera_setPosition";
-  case 1944: return "ICamera_setTarget";
-  case 1945: return "ICamera_getPosition";
-  case 1946: return "ICamera_getTarget";
-  case 1947: return "ICamera_setUpVector";
-  case 1948: return "ICamera_animator";
-  case 1949: return "ColorViz_r_get";
-  case 1950: return "ColorViz_r_set";
-  case 1951: return "ColorViz_g_get";
-  case 1952: return "ColorViz_g_set";
-  case 1953: return "ColorViz_b_get";
-  case 1954: return "ColorViz_b_set";
-  case 1955: return "ColorViz_a_get";
-  case 1956: return "ColorViz_a_set";
-  case 1957: return "new_ColorViz";
-  case 1958: return "delete_ColorViz";
-  case 1959: return "PixelViz_width_get";
-  case 1960: return "PixelViz_width_set";
-  case 1961: return "PixelViz_height_get";
-  case 1962: return "PixelViz_height_set";
-  case 1963: return "new_PixelViz";
-  case 1964: return "delete_PixelViz";
-  case 1965: return "delete_ILight";
-  case 1966: return "ILight_getName";
-  case 1967: return "ILight_setType";
-  case 1968: return "ILight_getType";
-  case 1969: return "ILight_setPosition";
-  case 1970: return "ILight_getPosition";
-  case 1971: return "ILight_setDirection";
-  case 1972: return "ILight_getDirection";
-  case 1973: return "ILight_setAmbientColor";
-  case 1974: return "ILight_getAmbientColor";
-  case 1975: return "ILight_setSpecularColor";
-  case 1976: return "ILight_getSpecularColor";
-  case 1977: return "ILight_setDiffuseColor";
-  case 1978: return "ILight_getDiffuseColor";
-  case 1979: return "delete_IEnvironment";
-  case 1980: return "IEnvironment_getElements";
-  case 1981: return "IEnvironment_setElementVisibility";
-  case 1982: return "IEnvironment_setBackgroundColor";
-  case 1983: return "IEnvironment_setFloorGridColor";
-  case 1984: return "IEnvironment_setAmbientLight";
-  case 1985: return "IEnvironment_getLights";
-  case 1986: return "IEnvironment_addLight";
-  case 1987: return "IEnvironment_lightViz";
-  case 1988: return "IEnvironment_removeLight";
-  case 1989: return "delete_IJetsVisualization";
-  case 1990: return "IJetsVisualization_setJetsFrames";
-  case 1991: return "IJetsVisualization_getNrOfJets";
-  case 1992: return "IJetsVisualization_getJetDirection";
-  case 1993: return "IJetsVisualization_setJetDirection";
-  case 1994: return "IJetsVisualization_setJetColor";
-  case 1995: return "IJetsVisualization_setJetsDimensions";
-  case 1996: return "IJetsVisualization_setJetsIntensity";
-  case 1997: return "delete_ILabel";
-  case 1998: return "ILabel_setText";
-  case 1999: return "ILabel_getText";
-  case 2000: return "ILabel_setSize";
-  case 2001: return "ILabel_width";
-  case 2002: return "ILabel_height";
-  case 2003: return "ILabel_setPosition";
-  case 2004: return "ILabel_getPosition";
-  case 2005: return "ILabel_setColor";
-  case 2006: return "ILabel_setVisible";
-  case 2007: return "delete_IVectorsVisualization";
-  case 2008: return "IVectorsVisualization_addVector";
-  case 2009: return "IVectorsVisualization_getNrOfVectors";
-  case 2010: return "IVectorsVisualization_getVector";
-  case 2011: return "IVectorsVisualization_updateVector";
-  case 2012: return "IVectorsVisualization_setVectorColor";
-  case 2013: return "IVectorsVisualization_setVectorsDefaultColor";
-  case 2014: return "IVectorsVisualization_setVectorsColor";
-  case 2015: return "IVectorsVisualization_setVectorsAspect";
-  case 2016: return "IVectorsVisualization_setVisible";
-  case 2017: return "IVectorsVisualization_getVectorLabel";
-  case 2018: return "delete_IFrameVisualization";
-  case 2019: return "IFrameVisualization_addFrame";
-  case 2020: return "IFrameVisualization_setVisible";
-  case 2021: return "IFrameVisualization_getNrOfFrames";
-  case 2022: return "IFrameVisualization_getFrameTransform";
-  case 2023: return "IFrameVisualization_updateFrame";
-  case 2024: return "IFrameVisualization_getFrameLabel";
-  case 2025: return "delete_IModelVisualization";
-  case 2026: return "IModelVisualization_setPositions";
-  case 2027: return "IModelVisualization_setLinkPositions";
-  case 2028: return "IModelVisualization_model";
-  case 2029: return "IModelVisualization_getInstanceName";
-  case 2030: return "IModelVisualization_setModelVisibility";
-  case 2031: return "IModelVisualization_setModelColor";
-  case 2032: return "IModelVisualization_resetModelColor";
-  case 2033: return "IModelVisualization_setLinkColor";
-  case 2034: return "IModelVisualization_resetLinkColor";
-  case 2035: return "IModelVisualization_getLinkNames";
-  case 2036: return "IModelVisualization_setLinkVisibility";
-  case 2037: return "IModelVisualization_getFeatures";
-  case 2038: return "IModelVisualization_setFeatureVisibility";
-  case 2039: return "IModelVisualization_jets";
-  case 2040: return "IModelVisualization_getWorldLinkTransform";
-  case 2041: return "IModelVisualization_getWorldFrameTransform";
-  case 2042: return "IModelVisualization_label";
-  case 2043: return "delete_ITexture";
-  case 2044: return "ITexture_environment";
-  case 2045: return "ITexture_getPixelColor";
-  case 2046: return "ITexture_getPixels";
-  case 2047: return "ITexture_drawToFile";
-  case 2048: return "ITexture_enableDraw";
-  case 2049: return "ITexture_width";
-  case 2050: return "ITexture_height";
-  case 2051: return "ITexture_setSubDrawArea";
-  case 2052: return "VisualizerOptions_verbose_get";
-  case 2053: return "VisualizerOptions_verbose_set";
-  case 2054: return "VisualizerOptions_winWidth_get";
-  case 2055: return "VisualizerOptions_winWidth_set";
-  case 2056: return "VisualizerOptions_winHeight_get";
-  case 2057: return "VisualizerOptions_winHeight_set";
-  case 2058: return "VisualizerOptions_rootFrameArrowsDimension_get";
-  case 2059: return "VisualizerOptions_rootFrameArrowsDimension_set";
-  case 2060: return "new_VisualizerOptions";
-  case 2061: return "delete_VisualizerOptions";
-  case 2062: return "delete_ITexturesHandler";
-  case 2063: return "ITexturesHandler_add";
-  case 2064: return "ITexturesHandler_get";
-  case 2065: return "new_Visualizer";
-  case 2066: return "delete_Visualizer";
-  case 2067: return "Visualizer_init";
-  case 2068: return "Visualizer_getNrOfVisualizedModels";
-  case 2069: return "Visualizer_getModelInstanceName";
-  case 2070: return "Visualizer_getModelInstanceIndex";
-  case 2071: return "Visualizer_addModel";
-  case 2072: return "Visualizer_modelViz";
-  case 2073: return "Visualizer_camera";
-  case 2074: return "Visualizer_enviroment";
-  case 2075: return "Visualizer_environment";
-  case 2076: return "Visualizer_vectors";
-  case 2077: return "Visualizer_frames";
-  case 2078: return "Visualizer_textures";
-  case 2079: return "Visualizer_getLabel";
-  case 2080: return "Visualizer_width";
-  case 2081: return "Visualizer_height";
-  case 2082: return "Visualizer_run";
-  case 2083: return "Visualizer_draw";
-  case 2084: return "Visualizer_subDraw";
-  case 2085: return "Visualizer_drawToFile";
-  case 2086: return "Visualizer_close";
-  case 2087: return "Visualizer_isWindowActive";
-  case 2088: return "Visualizer_setColorPalette";
-  case 2089: return "Polygon_m_vertices_get";
-  case 2090: return "Polygon_m_vertices_set";
-  case 2091: return "new_Polygon";
-  case 2092: return "Polygon_setNrOfVertices";
-  case 2093: return "Polygon_getNrOfVertices";
-  case 2094: return "Polygon_isValid";
-  case 2095: return "Polygon_applyTransform";
-  case 2096: return "Polygon_paren";
-  case 2097: return "Polygon_XYRectangleFromOffsets";
-  case 2098: return "delete_Polygon";
-  case 2099: return "Polygon2D_m_vertices_get";
-  case 2100: return "Polygon2D_m_vertices_set";
-  case 2101: return "new_Polygon2D";
-  case 2102: return "Polygon2D_setNrOfVertices";
-  case 2103: return "Polygon2D_getNrOfVertices";
-  case 2104: return "Polygon2D_isValid";
-  case 2105: return "Polygon2D_paren";
-  case 2106: return "delete_Polygon2D";
-  case 2107: return "ConvexHullProjectionConstraint_setActive";
-  case 2108: return "ConvexHullProjectionConstraint_isActive";
-  case 2109: return "ConvexHullProjectionConstraint_getNrOfConstraints";
-  case 2110: return "ConvexHullProjectionConstraint_projectedConvexHull_get";
-  case 2111: return "ConvexHullProjectionConstraint_projectedConvexHull_set";
-  case 2112: return "ConvexHullProjectionConstraint_A_get";
-  case 2113: return "ConvexHullProjectionConstraint_A_set";
-  case 2114: return "ConvexHullProjectionConstraint_b_get";
-  case 2115: return "ConvexHullProjectionConstraint_b_set";
-  case 2116: return "ConvexHullProjectionConstraint_P_get";
-  case 2117: return "ConvexHullProjectionConstraint_P_set";
-  case 2118: return "ConvexHullProjectionConstraint_Pdirection_get";
-  case 2119: return "ConvexHullProjectionConstraint_Pdirection_set";
-  case 2120: return "ConvexHullProjectionConstraint_AtimesP_get";
-  case 2121: return "ConvexHullProjectionConstraint_AtimesP_set";
-  case 2122: return "ConvexHullProjectionConstraint_o_get";
-  case 2123: return "ConvexHullProjectionConstraint_o_set";
-  case 2124: return "ConvexHullProjectionConstraint_buildConvexHull";
-  case 2125: return "ConvexHullProjectionConstraint_supportFrameIndices_get";
-  case 2126: return "ConvexHullProjectionConstraint_supportFrameIndices_set";
-  case 2127: return "ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_get";
-  case 2128: return "ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_set";
-  case 2129: return "ConvexHullProjectionConstraint_project";
-  case 2130: return "ConvexHullProjectionConstraint_computeMargin";
-  case 2131: return "ConvexHullProjectionConstraint_setProjectionAlongDirection";
-  case 2132: return "ConvexHullProjectionConstraint_projectAlongDirection";
-  case 2133: return "new_ConvexHullProjectionConstraint";
-  case 2134: return "delete_ConvexHullProjectionConstraint";
-  case 2135: return "_wrap_sizeOfRotationParametrization";
-  case 2136: return "new_InverseKinematics";
-  case 2137: return "delete_InverseKinematics";
-  case 2138: return "InverseKinematics_loadModelFromFile";
-  case 2139: return "InverseKinematics_setModel";
-  case 2140: return "InverseKinematics_setJointLimits";
-  case 2141: return "InverseKinematics_getJointLimits";
-  case 2142: return "InverseKinematics_clearProblem";
-  case 2143: return "InverseKinematics_setFloatingBaseOnFrameNamed";
-  case 2144: return "InverseKinematics_setCurrentRobotConfiguration";
-  case 2145: return "InverseKinematics_setJointConfiguration";
-  case 2146: return "InverseKinematics_setRotationParametrization";
-  case 2147: return "InverseKinematics_rotationParametrization";
-  case 2148: return "InverseKinematics_setMaxIterations";
-  case 2149: return "InverseKinematics_maxIterations";
-  case 2150: return "InverseKinematics_setMaxCPUTime";
-  case 2151: return "InverseKinematics_maxCPUTime";
-  case 2152: return "InverseKinematics_setCostTolerance";
-  case 2153: return "InverseKinematics_costTolerance";
-  case 2154: return "InverseKinematics_setConstraintsTolerance";
-  case 2155: return "InverseKinematics_constraintsTolerance";
-  case 2156: return "InverseKinematics_setVerbosity";
-  case 2157: return "InverseKinematics_linearSolverName";
-  case 2158: return "InverseKinematics_setLinearSolverName";
-  case 2159: return "InverseKinematics_addFrameConstraint";
-  case 2160: return "InverseKinematics_addFramePositionConstraint";
-  case 2161: return "InverseKinematics_addFrameRotationConstraint";
-  case 2162: return "InverseKinematics_activateFrameConstraint";
-  case 2163: return "InverseKinematics_deactivateFrameConstraint";
-  case 2164: return "InverseKinematics_isFrameConstraintActive";
-  case 2165: return "InverseKinematics_addCenterOfMassProjectionConstraint";
-  case 2166: return "InverseKinematics_getCenterOfMassProjectionMargin";
-  case 2167: return "InverseKinematics_getCenterOfMassProjectConstraintConvexHull";
-  case 2168: return "InverseKinematics_addTarget";
-  case 2169: return "InverseKinematics_addPositionTarget";
-  case 2170: return "InverseKinematics_addRotationTarget";
-  case 2171: return "InverseKinematics_updateTarget";
-  case 2172: return "InverseKinematics_updatePositionTarget";
-  case 2173: return "InverseKinematics_updateRotationTarget";
-  case 2174: return "InverseKinematics_setDefaultTargetResolutionMode";
-  case 2175: return "InverseKinematics_defaultTargetResolutionMode";
-  case 2176: return "InverseKinematics_setTargetResolutionMode";
-  case 2177: return "InverseKinematics_targetResolutionMode";
-  case 2178: return "InverseKinematics_setDesiredFullJointsConfiguration";
-  case 2179: return "InverseKinematics_setDesiredReducedJointConfiguration";
-  case 2180: return "InverseKinematics_setFullJointsInitialCondition";
-  case 2181: return "InverseKinematics_setReducedInitialCondition";
-  case 2182: return "InverseKinematics_solve";
-  case 2183: return "InverseKinematics_getFullJointsSolution";
-  case 2184: return "InverseKinematics_getReducedSolution";
-  case 2185: return "InverseKinematics_getPoseForFrame";
-  case 2186: return "InverseKinematics_fullModel";
-  case 2187: return "InverseKinematics_reducedModel";
-  case 2188: return "InverseKinematics_setCOMTarget";
-  case 2189: return "InverseKinematics_setCOMAsConstraint";
-  case 2190: return "InverseKinematics_setCOMAsConstraintTolerance";
-  case 2191: return "InverseKinematics_isCOMAConstraint";
-  case 2192: return "InverseKinematics_isCOMTargetActive";
-  case 2193: return "InverseKinematics_deactivateCOMTarget";
-  case 2194: return "InverseKinematics_setCOMConstraintProjectionDirection";
+  case 71: return "BerdySensors_pop";
+  case 72: return "BerdySensors_brace";
+  case 73: return "BerdySensors_setbrace";
+  case 74: return "BerdySensors_append";
+  case 75: return "BerdySensors_empty";
+  case 76: return "BerdySensors_size";
+  case 77: return "BerdySensors_swap";
+  case 78: return "BerdySensors_begin";
+  case 79: return "BerdySensors_end";
+  case 80: return "BerdySensors_rbegin";
+  case 81: return "BerdySensors_rend";
+  case 82: return "BerdySensors_clear";
+  case 83: return "BerdySensors_get_allocator";
+  case 84: return "BerdySensors_pop_back";
+  case 85: return "BerdySensors_erase";
+  case 86: return "new_BerdySensors";
+  case 87: return "BerdySensors_push_back";
+  case 88: return "BerdySensors_front";
+  case 89: return "BerdySensors_back";
+  case 90: return "BerdySensors_assign";
+  case 91: return "BerdySensors_resize";
+  case 92: return "BerdySensors_insert";
+  case 93: return "BerdySensors_reserve";
+  case 94: return "BerdySensors_capacity";
+  case 95: return "delete_BerdySensors";
+  case 96: return "BerdyDynamicVariables_pop";
+  case 97: return "BerdyDynamicVariables_brace";
+  case 98: return "BerdyDynamicVariables_setbrace";
+  case 99: return "BerdyDynamicVariables_append";
+  case 100: return "BerdyDynamicVariables_empty";
+  case 101: return "BerdyDynamicVariables_size";
+  case 102: return "BerdyDynamicVariables_swap";
+  case 103: return "BerdyDynamicVariables_begin";
+  case 104: return "BerdyDynamicVariables_end";
+  case 105: return "BerdyDynamicVariables_rbegin";
+  case 106: return "BerdyDynamicVariables_rend";
+  case 107: return "BerdyDynamicVariables_clear";
+  case 108: return "BerdyDynamicVariables_get_allocator";
+  case 109: return "BerdyDynamicVariables_pop_back";
+  case 110: return "BerdyDynamicVariables_erase";
+  case 111: return "new_BerdyDynamicVariables";
+  case 112: return "BerdyDynamicVariables_push_back";
+  case 113: return "BerdyDynamicVariables_front";
+  case 114: return "BerdyDynamicVariables_back";
+  case 115: return "BerdyDynamicVariables_assign";
+  case 116: return "BerdyDynamicVariables_resize";
+  case 117: return "BerdyDynamicVariables_insert";
+  case 118: return "BerdyDynamicVariables_reserve";
+  case 119: return "BerdyDynamicVariables_capacity";
+  case 120: return "delete_BerdyDynamicVariables";
+  case 121: return "_wrap_reportInfo";
+  case 122: return "_wrap_reportDebug";
+  case 123: return "IndexRange_offset_get";
+  case 124: return "IndexRange_offset_set";
+  case 125: return "IndexRange_size_get";
+  case 126: return "IndexRange_size_set";
+  case 127: return "IndexRange_isValid";
+  case 128: return "IndexRange_InvalidRange";
+  case 129: return "new_IndexRange";
+  case 130: return "delete_IndexRange";
+  case 131: return "_wrap_checkDoublesAreEqual";
+  case 132: return "new_MatrixDynSize";
+  case 133: return "delete_MatrixDynSize";
+  case 134: return "MatrixDynSize_paren";
+  case 135: return "MatrixDynSize_getVal";
+  case 136: return "MatrixDynSize_setVal";
+  case 137: return "MatrixDynSize_rows";
+  case 138: return "MatrixDynSize_cols";
+  case 139: return "MatrixDynSize_data";
+  case 140: return "MatrixDynSize_zero";
+  case 141: return "MatrixDynSize_resize";
+  case 142: return "MatrixDynSize_reserve";
+  case 143: return "MatrixDynSize_capacity";
+  case 144: return "MatrixDynSize_shrink_to_fit";
+  case 145: return "MatrixDynSize_fillRowMajorBuffer";
+  case 146: return "MatrixDynSize_fillColMajorBuffer";
+  case 147: return "MatrixDynSize_toString";
+  case 148: return "MatrixDynSize_display";
+  case 149: return "MatrixDynSize_toMatlab";
+  case 150: return "MatrixDynSize_fromMatlab";
+  case 151: return "new_SparseMatrixRowMajor";
+  case 152: return "delete_SparseMatrixRowMajor";
+  case 153: return "SparseMatrixRowMajor_numberOfNonZeros";
+  case 154: return "SparseMatrixRowMajor_resize";
+  case 155: return "SparseMatrixRowMajor_reserve";
+  case 156: return "SparseMatrixRowMajor_zero";
+  case 157: return "SparseMatrixRowMajor_setFromConstTriplets";
+  case 158: return "SparseMatrixRowMajor_setFromTriplets";
+  case 159: return "SparseMatrixRowMajor_sparseMatrixFromTriplets";
+  case 160: return "SparseMatrixRowMajor_paren";
+  case 161: return "SparseMatrixRowMajor_getValue";
+  case 162: return "SparseMatrixRowMajor_setValue";
+  case 163: return "SparseMatrixRowMajor_rows";
+  case 164: return "SparseMatrixRowMajor_columns";
+  case 165: return "SparseMatrixRowMajor_description";
+  case 166: return "SparseMatrixRowMajor_toMatlab";
+  case 167: return "SparseMatrixRowMajor_toMatlabDense";
+  case 168: return "SparseMatrixRowMajor_fromMatlab";
+  case 169: return "new_SparseMatrixColMajor";
+  case 170: return "delete_SparseMatrixColMajor";
+  case 171: return "SparseMatrixColMajor_numberOfNonZeros";
+  case 172: return "SparseMatrixColMajor_resize";
+  case 173: return "SparseMatrixColMajor_reserve";
+  case 174: return "SparseMatrixColMajor_zero";
+  case 175: return "SparseMatrixColMajor_setFromConstTriplets";
+  case 176: return "SparseMatrixColMajor_setFromTriplets";
+  case 177: return "SparseMatrixColMajor_sparseMatrixFromTriplets";
+  case 178: return "SparseMatrixColMajor_paren";
+  case 179: return "SparseMatrixColMajor_getValue";
+  case 180: return "SparseMatrixColMajor_setValue";
+  case 181: return "SparseMatrixColMajor_rows";
+  case 182: return "SparseMatrixColMajor_columns";
+  case 183: return "SparseMatrixColMajor_description";
+  case 184: return "SparseMatrixColMajor_toMatlab";
+  case 185: return "SparseMatrixColMajor_toMatlabDense";
+  case 186: return "SparseMatrixColMajor_fromMatlab";
+  case 187: return "new_VectorDynSize";
+  case 188: return "delete_VectorDynSize";
+  case 189: return "VectorDynSize_paren";
+  case 190: return "VectorDynSize_brace";
+  case 191: return "VectorDynSize_getVal";
+  case 192: return "VectorDynSize_setVal";
+  case 193: return "VectorDynSize_cbegin";
+  case 194: return "VectorDynSize_cend";
+  case 195: return "VectorDynSize_begin";
+  case 196: return "VectorDynSize_end";
+  case 197: return "VectorDynSize_size";
+  case 198: return "VectorDynSize_data";
+  case 199: return "VectorDynSize_zero";
+  case 200: return "VectorDynSize_reserve";
+  case 201: return "VectorDynSize_resize";
+  case 202: return "VectorDynSize_shrink_to_fit";
+  case 203: return "VectorDynSize_capacity";
+  case 204: return "VectorDynSize_fillBuffer";
+  case 205: return "VectorDynSize_toString";
+  case 206: return "VectorDynSize_display";
+  case 207: return "VectorDynSize_toMatlab";
+  case 208: return "VectorDynSize_fromMatlab";
+  case 209: return "new_Matrix1x6";
+  case 210: return "Matrix1x6_paren";
+  case 211: return "Matrix1x6_getVal";
+  case 212: return "Matrix1x6_setVal";
+  case 213: return "Matrix1x6_rows";
+  case 214: return "Matrix1x6_cols";
+  case 215: return "Matrix1x6_data";
+  case 216: return "Matrix1x6_zero";
+  case 217: return "Matrix1x6_fillRowMajorBuffer";
+  case 218: return "Matrix1x6_fillColMajorBuffer";
+  case 219: return "Matrix1x6_toString";
+  case 220: return "Matrix1x6_display";
+  case 221: return "Matrix1x6_toMatlab";
+  case 222: return "Matrix1x6_fromMatlab";
+  case 223: return "delete_Matrix1x6";
+  case 224: return "new_Matrix2x3";
+  case 225: return "Matrix2x3_paren";
+  case 226: return "Matrix2x3_getVal";
+  case 227: return "Matrix2x3_setVal";
+  case 228: return "Matrix2x3_rows";
+  case 229: return "Matrix2x3_cols";
+  case 230: return "Matrix2x3_data";
+  case 231: return "Matrix2x3_zero";
+  case 232: return "Matrix2x3_fillRowMajorBuffer";
+  case 233: return "Matrix2x3_fillColMajorBuffer";
+  case 234: return "Matrix2x3_toString";
+  case 235: return "Matrix2x3_display";
+  case 236: return "Matrix2x3_toMatlab";
+  case 237: return "Matrix2x3_fromMatlab";
+  case 238: return "delete_Matrix2x3";
+  case 239: return "new_Matrix3x3";
+  case 240: return "Matrix3x3_paren";
+  case 241: return "Matrix3x3_getVal";
+  case 242: return "Matrix3x3_setVal";
+  case 243: return "Matrix3x3_rows";
+  case 244: return "Matrix3x3_cols";
+  case 245: return "Matrix3x3_data";
+  case 246: return "Matrix3x3_zero";
+  case 247: return "Matrix3x3_fillRowMajorBuffer";
+  case 248: return "Matrix3x3_fillColMajorBuffer";
+  case 249: return "Matrix3x3_toString";
+  case 250: return "Matrix3x3_display";
+  case 251: return "Matrix3x3_toMatlab";
+  case 252: return "Matrix3x3_fromMatlab";
+  case 253: return "delete_Matrix3x3";
+  case 254: return "new_Matrix4x4";
+  case 255: return "Matrix4x4_paren";
+  case 256: return "Matrix4x4_getVal";
+  case 257: return "Matrix4x4_setVal";
+  case 258: return "Matrix4x4_rows";
+  case 259: return "Matrix4x4_cols";
+  case 260: return "Matrix4x4_data";
+  case 261: return "Matrix4x4_zero";
+  case 262: return "Matrix4x4_fillRowMajorBuffer";
+  case 263: return "Matrix4x4_fillColMajorBuffer";
+  case 264: return "Matrix4x4_toString";
+  case 265: return "Matrix4x4_display";
+  case 266: return "Matrix4x4_toMatlab";
+  case 267: return "Matrix4x4_fromMatlab";
+  case 268: return "delete_Matrix4x4";
+  case 269: return "new_Matrix6x6";
+  case 270: return "Matrix6x6_paren";
+  case 271: return "Matrix6x6_getVal";
+  case 272: return "Matrix6x6_setVal";
+  case 273: return "Matrix6x6_rows";
+  case 274: return "Matrix6x6_cols";
+  case 275: return "Matrix6x6_data";
+  case 276: return "Matrix6x6_zero";
+  case 277: return "Matrix6x6_fillRowMajorBuffer";
+  case 278: return "Matrix6x6_fillColMajorBuffer";
+  case 279: return "Matrix6x6_toString";
+  case 280: return "Matrix6x6_display";
+  case 281: return "Matrix6x6_toMatlab";
+  case 282: return "Matrix6x6_fromMatlab";
+  case 283: return "delete_Matrix6x6";
+  case 284: return "new_Matrix6x10";
+  case 285: return "Matrix6x10_paren";
+  case 286: return "Matrix6x10_getVal";
+  case 287: return "Matrix6x10_setVal";
+  case 288: return "Matrix6x10_rows";
+  case 289: return "Matrix6x10_cols";
+  case 290: return "Matrix6x10_data";
+  case 291: return "Matrix6x10_zero";
+  case 292: return "Matrix6x10_fillRowMajorBuffer";
+  case 293: return "Matrix6x10_fillColMajorBuffer";
+  case 294: return "Matrix6x10_toString";
+  case 295: return "Matrix6x10_display";
+  case 296: return "Matrix6x10_toMatlab";
+  case 297: return "Matrix6x10_fromMatlab";
+  case 298: return "delete_Matrix6x10";
+  case 299: return "new_Matrix10x16";
+  case 300: return "Matrix10x16_paren";
+  case 301: return "Matrix10x16_getVal";
+  case 302: return "Matrix10x16_setVal";
+  case 303: return "Matrix10x16_rows";
+  case 304: return "Matrix10x16_cols";
+  case 305: return "Matrix10x16_data";
+  case 306: return "Matrix10x16_zero";
+  case 307: return "Matrix10x16_fillRowMajorBuffer";
+  case 308: return "Matrix10x16_fillColMajorBuffer";
+  case 309: return "Matrix10x16_toString";
+  case 310: return "Matrix10x16_display";
+  case 311: return "Matrix10x16_toMatlab";
+  case 312: return "Matrix10x16_fromMatlab";
+  case 313: return "delete_Matrix10x16";
+  case 314: return "new_Vector3";
+  case 315: return "Vector3_paren";
+  case 316: return "Vector3_brace";
+  case 317: return "Vector3_getVal";
+  case 318: return "Vector3_setVal";
+  case 319: return "Vector3_cbegin";
+  case 320: return "Vector3_cend";
+  case 321: return "Vector3_begin";
+  case 322: return "Vector3_end";
+  case 323: return "Vector3_size";
+  case 324: return "Vector3_data";
+  case 325: return "Vector3_zero";
+  case 326: return "Vector3_fillBuffer";
+  case 327: return "Vector3_toString";
+  case 328: return "Vector3_display";
+  case 329: return "Vector3_toMatlab";
+  case 330: return "Vector3_fromMatlab";
+  case 331: return "delete_Vector3";
+  case 332: return "new_Vector4";
+  case 333: return "Vector4_paren";
+  case 334: return "Vector4_brace";
+  case 335: return "Vector4_getVal";
+  case 336: return "Vector4_setVal";
+  case 337: return "Vector4_cbegin";
+  case 338: return "Vector4_cend";
+  case 339: return "Vector4_begin";
+  case 340: return "Vector4_end";
+  case 341: return "Vector4_size";
+  case 342: return "Vector4_data";
+  case 343: return "Vector4_zero";
+  case 344: return "Vector4_fillBuffer";
+  case 345: return "Vector4_toString";
+  case 346: return "Vector4_display";
+  case 347: return "Vector4_toMatlab";
+  case 348: return "Vector4_fromMatlab";
+  case 349: return "delete_Vector4";
+  case 350: return "new_Vector6";
+  case 351: return "Vector6_paren";
+  case 352: return "Vector6_brace";
+  case 353: return "Vector6_getVal";
+  case 354: return "Vector6_setVal";
+  case 355: return "Vector6_cbegin";
+  case 356: return "Vector6_cend";
+  case 357: return "Vector6_begin";
+  case 358: return "Vector6_end";
+  case 359: return "Vector6_size";
+  case 360: return "Vector6_data";
+  case 361: return "Vector6_zero";
+  case 362: return "Vector6_fillBuffer";
+  case 363: return "Vector6_toString";
+  case 364: return "Vector6_display";
+  case 365: return "Vector6_toMatlab";
+  case 366: return "Vector6_fromMatlab";
+  case 367: return "delete_Vector6";
+  case 368: return "new_Vector10";
+  case 369: return "Vector10_paren";
+  case 370: return "Vector10_brace";
+  case 371: return "Vector10_getVal";
+  case 372: return "Vector10_setVal";
+  case 373: return "Vector10_cbegin";
+  case 374: return "Vector10_cend";
+  case 375: return "Vector10_begin";
+  case 376: return "Vector10_end";
+  case 377: return "Vector10_size";
+  case 378: return "Vector10_data";
+  case 379: return "Vector10_zero";
+  case 380: return "Vector10_fillBuffer";
+  case 381: return "Vector10_toString";
+  case 382: return "Vector10_display";
+  case 383: return "Vector10_toMatlab";
+  case 384: return "Vector10_fromMatlab";
+  case 385: return "delete_Vector10";
+  case 386: return "new_Vector16";
+  case 387: return "Vector16_paren";
+  case 388: return "Vector16_brace";
+  case 389: return "Vector16_getVal";
+  case 390: return "Vector16_setVal";
+  case 391: return "Vector16_cbegin";
+  case 392: return "Vector16_cend";
+  case 393: return "Vector16_begin";
+  case 394: return "Vector16_end";
+  case 395: return "Vector16_size";
+  case 396: return "Vector16_data";
+  case 397: return "Vector16_zero";
+  case 398: return "Vector16_fillBuffer";
+  case 399: return "Vector16_toString";
+  case 400: return "Vector16_display";
+  case 401: return "Vector16_toMatlab";
+  case 402: return "Vector16_fromMatlab";
+  case 403: return "delete_Vector16";
+  case 404: return "new_PositionRaw";
+  case 405: return "PositionRaw_changePoint";
+  case 406: return "PositionRaw_changeRefPoint";
+  case 407: return "PositionRaw_compose";
+  case 408: return "PositionRaw_inverse";
+  case 409: return "PositionRaw_changePointOf";
+  case 410: return "PositionRaw_toString";
+  case 411: return "PositionRaw_display";
+  case 412: return "delete_PositionRaw";
+  case 413: return "new_Position";
+  case 414: return "Position_changePoint";
+  case 415: return "Position_changeRefPoint";
+  case 416: return "Position_changeCoordinateFrame";
+  case 417: return "Position_compose";
+  case 418: return "Position_inverse";
+  case 419: return "Position_changePointOf";
+  case 420: return "Position_plus";
+  case 421: return "Position_minus";
+  case 422: return "Position_uminus";
+  case 423: return "Position_mtimes";
+  case 424: return "Position_toString";
+  case 425: return "Position_display";
+  case 426: return "Position_Zero";
+  case 427: return "delete_Position";
+  case 428: return "new_GeomVector3";
+  case 429: return "GeomVector3_changeCoordFrame";
+  case 430: return "GeomVector3_compose";
+  case 431: return "GeomVector3_inverse";
+  case 432: return "GeomVector3_dot";
+  case 433: return "GeomVector3_plus";
+  case 434: return "GeomVector3_minus";
+  case 435: return "GeomVector3_uminus";
+  case 436: return "GeomVector3_exp";
+  case 437: return "GeomVector3_cross";
+  case 438: return "delete_GeomVector3";
+  case 439: return "new_SpatialMotionVectorBase";
+  case 440: return "SpatialMotionVectorBase_getLinearVec3";
+  case 441: return "SpatialMotionVectorBase_getAngularVec3";
+  case 442: return "SpatialMotionVectorBase_setLinearVec3";
+  case 443: return "SpatialMotionVectorBase_setAngularVec3";
+  case 444: return "SpatialMotionVectorBase_paren";
+  case 445: return "SpatialMotionVectorBase_getVal";
+  case 446: return "SpatialMotionVectorBase_setVal";
+  case 447: return "SpatialMotionVectorBase_size";
+  case 448: return "SpatialMotionVectorBase_zero";
+  case 449: return "SpatialMotionVectorBase_changePoint";
+  case 450: return "SpatialMotionVectorBase_changeCoordFrame";
+  case 451: return "SpatialMotionVectorBase_compose";
+  case 452: return "SpatialMotionVectorBase_inverse";
+  case 453: return "SpatialMotionVectorBase_dot";
+  case 454: return "SpatialMotionVectorBase_plus";
+  case 455: return "SpatialMotionVectorBase_minus";
+  case 456: return "SpatialMotionVectorBase_uminus";
+  case 457: return "SpatialMotionVectorBase_Zero";
+  case 458: return "SpatialMotionVectorBase_asVector";
+  case 459: return "SpatialMotionVectorBase_toString";
+  case 460: return "SpatialMotionVectorBase_display";
+  case 461: return "SpatialMotionVectorBase_toMatlab";
+  case 462: return "SpatialMotionVectorBase_fromMatlab";
+  case 463: return "delete_SpatialMotionVectorBase";
+  case 464: return "new_SpatialForceVectorBase";
+  case 465: return "SpatialForceVectorBase_getLinearVec3";
+  case 466: return "SpatialForceVectorBase_getAngularVec3";
+  case 467: return "SpatialForceVectorBase_setLinearVec3";
+  case 468: return "SpatialForceVectorBase_setAngularVec3";
+  case 469: return "SpatialForceVectorBase_paren";
+  case 470: return "SpatialForceVectorBase_getVal";
+  case 471: return "SpatialForceVectorBase_setVal";
+  case 472: return "SpatialForceVectorBase_size";
+  case 473: return "SpatialForceVectorBase_zero";
+  case 474: return "SpatialForceVectorBase_changePoint";
+  case 475: return "SpatialForceVectorBase_changeCoordFrame";
+  case 476: return "SpatialForceVectorBase_compose";
+  case 477: return "SpatialForceVectorBase_inverse";
+  case 478: return "SpatialForceVectorBase_dot";
+  case 479: return "SpatialForceVectorBase_plus";
+  case 480: return "SpatialForceVectorBase_minus";
+  case 481: return "SpatialForceVectorBase_uminus";
+  case 482: return "SpatialForceVectorBase_Zero";
+  case 483: return "SpatialForceVectorBase_asVector";
+  case 484: return "SpatialForceVectorBase_toString";
+  case 485: return "SpatialForceVectorBase_display";
+  case 486: return "SpatialForceVectorBase_toMatlab";
+  case 487: return "SpatialForceVectorBase_fromMatlab";
+  case 488: return "delete_SpatialForceVectorBase";
+  case 489: return "new_Dummy";
+  case 490: return "delete_Dummy";
+  case 491: return "new_SpatialMotionVector";
+  case 492: return "SpatialMotionVector_mtimes";
+  case 493: return "SpatialMotionVector_cross";
+  case 494: return "SpatialMotionVector_asCrossProductMatrix";
+  case 495: return "SpatialMotionVector_asCrossProductMatrixWrench";
+  case 496: return "SpatialMotionVector_exp";
+  case 497: return "delete_SpatialMotionVector";
+  case 498: return "new_SpatialForceVector";
+  case 499: return "delete_SpatialForceVector";
+  case 500: return "SpatialForceVector_mtimes";
+  case 501: return "new_Twist";
+  case 502: return "Twist_plus";
+  case 503: return "Twist_minus";
+  case 504: return "Twist_uminus";
+  case 505: return "Twist_mtimes";
+  case 506: return "delete_Twist";
+  case 507: return "new_Wrench";
+  case 508: return "Wrench_plus";
+  case 509: return "Wrench_minus";
+  case 510: return "Wrench_uminus";
+  case 511: return "delete_Wrench";
+  case 512: return "new_SpatialMomentum";
+  case 513: return "SpatialMomentum_plus";
+  case 514: return "SpatialMomentum_minus";
+  case 515: return "SpatialMomentum_uminus";
+  case 516: return "delete_SpatialMomentum";
+  case 517: return "new_SpatialAcc";
+  case 518: return "SpatialAcc_plus";
+  case 519: return "SpatialAcc_minus";
+  case 520: return "SpatialAcc_uminus";
+  case 521: return "delete_SpatialAcc";
+  case 522: return "new_ClassicalAcc";
+  case 523: return "ClassicalAcc_changeCoordFrame";
+  case 524: return "ClassicalAcc_Zero";
+  case 525: return "ClassicalAcc_fromSpatial";
+  case 526: return "ClassicalAcc_toSpatial";
+  case 527: return "delete_ClassicalAcc";
+  case 528: return "new_Direction";
+  case 529: return "Direction_Normalize";
+  case 530: return "Direction_isParallel";
+  case 531: return "Direction_isPerpendicular";
+  case 532: return "Direction_reverse";
+  case 533: return "Direction_toString";
+  case 534: return "Direction_display";
+  case 535: return "Direction_Default";
+  case 536: return "delete_Direction";
+  case 537: return "new_Axis";
+  case 538: return "Axis_getDirection";
+  case 539: return "Axis_getOrigin";
+  case 540: return "Axis_setDirection";
+  case 541: return "Axis_setOrigin";
+  case 542: return "Axis_getRotationTransform";
+  case 543: return "Axis_getRotationTransformDerivative";
+  case 544: return "Axis_getRotationTwist";
+  case 545: return "Axis_getRotationSpatialAcc";
+  case 546: return "Axis_getTranslationTransform";
+  case 547: return "Axis_getTranslationTransformDerivative";
+  case 548: return "Axis_getTranslationTwist";
+  case 549: return "Axis_getTranslationSpatialAcc";
+  case 550: return "Axis_isParallel";
+  case 551: return "Axis_reverse";
+  case 552: return "Axis_toString";
+  case 553: return "Axis_display";
+  case 554: return "delete_Axis";
+  case 555: return "new_RotationalInertiaRaw";
+  case 556: return "RotationalInertiaRaw_Zero";
+  case 557: return "delete_RotationalInertiaRaw";
+  case 558: return "new_SpatialInertiaRaw";
+  case 559: return "SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass";
+  case 560: return "SpatialInertiaRaw_getMass";
+  case 561: return "SpatialInertiaRaw_getCenterOfMass";
+  case 562: return "SpatialInertiaRaw_getRotationalInertiaWrtFrameOrigin";
+  case 563: return "SpatialInertiaRaw_getRotationalInertiaWrtCenterOfMass";
+  case 564: return "SpatialInertiaRaw_combine";
+  case 565: return "SpatialInertiaRaw_multiply";
+  case 566: return "SpatialInertiaRaw_zero";
+  case 567: return "delete_SpatialInertiaRaw";
+  case 568: return "new_SpatialInertia";
+  case 569: return "SpatialInertia_combine";
+  case 570: return "SpatialInertia_asMatrix";
+  case 571: return "SpatialInertia_applyInverse";
+  case 572: return "SpatialInertia_getInverse";
+  case 573: return "SpatialInertia_plus";
+  case 574: return "SpatialInertia_mtimes";
+  case 575: return "SpatialInertia_biasWrench";
+  case 576: return "SpatialInertia_biasWrenchDerivative";
+  case 577: return "SpatialInertia_Zero";
+  case 578: return "SpatialInertia_asVector";
+  case 579: return "SpatialInertia_fromVector";
+  case 580: return "SpatialInertia_isPhysicallyConsistent";
+  case 581: return "SpatialInertia_momentumRegressor";
+  case 582: return "SpatialInertia_momentumDerivativeRegressor";
+  case 583: return "SpatialInertia_momentumDerivativeSlotineLiRegressor";
+  case 584: return "delete_SpatialInertia";
+  case 585: return "new_ArticulatedBodyInertia";
+  case 586: return "ArticulatedBodyInertia_getLinearLinearSubmatrix";
+  case 587: return "ArticulatedBodyInertia_getLinearAngularSubmatrix";
+  case 588: return "ArticulatedBodyInertia_getAngularAngularSubmatrix";
+  case 589: return "ArticulatedBodyInertia_combine";
+  case 590: return "ArticulatedBodyInertia_applyInverse";
+  case 591: return "ArticulatedBodyInertia_asMatrix";
+  case 592: return "ArticulatedBodyInertia_getInverse";
+  case 593: return "ArticulatedBodyInertia_plus";
+  case 594: return "ArticulatedBodyInertia_minus";
+  case 595: return "ArticulatedBodyInertia_mtimes";
+  case 596: return "ArticulatedBodyInertia_zero";
+  case 597: return "ArticulatedBodyInertia_ABADyadHelper";
+  case 598: return "ArticulatedBodyInertia_ABADyadHelperLin";
+  case 599: return "delete_ArticulatedBodyInertia";
+  case 600: return "RigidBodyInertiaNonLinearParametrization_mass_get";
+  case 601: return "RigidBodyInertiaNonLinearParametrization_mass_set";
+  case 602: return "RigidBodyInertiaNonLinearParametrization_com_get";
+  case 603: return "RigidBodyInertiaNonLinearParametrization_com_set";
+  case 604: return "RigidBodyInertiaNonLinearParametrization_link_R_centroidal_get";
+  case 605: return "RigidBodyInertiaNonLinearParametrization_link_R_centroidal_set";
+  case 606: return "RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_get";
+  case 607: return "RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_set";
+  case 608: return "RigidBodyInertiaNonLinearParametrization_getLinkCentroidalTransform";
+  case 609: return "RigidBodyInertiaNonLinearParametrization_fromRigidBodyInertia";
+  case 610: return "RigidBodyInertiaNonLinearParametrization_fromInertialParameters";
+  case 611: return "RigidBodyInertiaNonLinearParametrization_toRigidBodyInertia";
+  case 612: return "RigidBodyInertiaNonLinearParametrization_isPhysicallyConsistent";
+  case 613: return "RigidBodyInertiaNonLinearParametrization_asVectorWithRotationAsVec";
+  case 614: return "RigidBodyInertiaNonLinearParametrization_fromVectorWithRotationAsVec";
+  case 615: return "RigidBodyInertiaNonLinearParametrization_getGradientWithRotationAsVec";
+  case 616: return "new_RigidBodyInertiaNonLinearParametrization";
+  case 617: return "delete_RigidBodyInertiaNonLinearParametrization";
+  case 618: return "new_RotationRaw";
+  case 619: return "RotationRaw_changeOrientFrame";
+  case 620: return "RotationRaw_changeRefOrientFrame";
+  case 621: return "RotationRaw_compose";
+  case 622: return "RotationRaw_inverse2";
+  case 623: return "RotationRaw_changeCoordFrameOf";
+  case 624: return "RotationRaw_RotX";
+  case 625: return "RotationRaw_RotY";
+  case 626: return "RotationRaw_RotZ";
+  case 627: return "RotationRaw_RPY";
+  case 628: return "RotationRaw_Identity";
+  case 629: return "RotationRaw_toString";
+  case 630: return "RotationRaw_display";
+  case 631: return "delete_RotationRaw";
+  case 632: return "new_Rotation";
+  case 633: return "Rotation_changeOrientFrame";
+  case 634: return "Rotation_changeRefOrientFrame";
+  case 635: return "Rotation_changeCoordinateFrame";
+  case 636: return "Rotation_compose";
+  case 637: return "Rotation_inverse2";
+  case 638: return "Rotation_changeCoordFrameOf";
+  case 639: return "Rotation_inverse";
+  case 640: return "Rotation_mtimes";
+  case 641: return "Rotation_log";
+  case 642: return "Rotation_fromQuaternion";
+  case 643: return "Rotation_getRPY";
+  case 644: return "Rotation_asRPY";
+  case 645: return "Rotation_getQuaternion";
+  case 646: return "Rotation_asQuaternion";
+  case 647: return "Rotation_RotX";
+  case 648: return "Rotation_RotY";
+  case 649: return "Rotation_RotZ";
+  case 650: return "Rotation_RotAxis";
+  case 651: return "Rotation_RotAxisDerivative";
+  case 652: return "Rotation_RPY";
+  case 653: return "Rotation_RPYRightTrivializedDerivative";
+  case 654: return "Rotation_RPYRightTrivializedDerivativeRateOfChange";
+  case 655: return "Rotation_RPYRightTrivializedDerivativeInverse";
+  case 656: return "Rotation_RPYRightTrivializedDerivativeInverseRateOfChange";
+  case 657: return "Rotation_QuaternionRightTrivializedDerivative";
+  case 658: return "Rotation_QuaternionRightTrivializedDerivativeInverse";
+  case 659: return "Rotation_Identity";
+  case 660: return "Rotation_RotationFromQuaternion";
+  case 661: return "Rotation_leftJacobian";
+  case 662: return "Rotation_leftJacobianInverse";
+  case 663: return "Rotation_toString";
+  case 664: return "Rotation_display";
+  case 665: return "delete_Rotation";
+  case 666: return "new_Transform";
+  case 667: return "Transform_fromHomogeneousTransform";
+  case 668: return "Transform_getRotation";
+  case 669: return "Transform_getPosition";
+  case 670: return "Transform_setRotation";
+  case 671: return "Transform_setPosition";
+  case 672: return "Transform_compose";
+  case 673: return "Transform_inverse2";
+  case 674: return "Transform_inverse";
+  case 675: return "Transform_mtimes";
+  case 676: return "Transform_Identity";
+  case 677: return "Transform_asHomogeneousTransform";
+  case 678: return "Transform_asAdjointTransform";
+  case 679: return "Transform_asAdjointTransformWrench";
+  case 680: return "Transform_log";
+  case 681: return "Transform_toString";
+  case 682: return "Transform_display";
+  case 683: return "delete_Transform";
+  case 684: return "new_TransformDerivative";
+  case 685: return "delete_TransformDerivative";
+  case 686: return "TransformDerivative_getRotationDerivative";
+  case 687: return "TransformDerivative_getPositionDerivative";
+  case 688: return "TransformDerivative_setRotationDerivative";
+  case 689: return "TransformDerivative_setPositionDerivative";
+  case 690: return "TransformDerivative_Zero";
+  case 691: return "TransformDerivative_asHomogeneousTransformDerivative";
+  case 692: return "TransformDerivative_asAdjointTransformDerivative";
+  case 693: return "TransformDerivative_asAdjointTransformWrenchDerivative";
+  case 694: return "TransformDerivative_mtimes";
+  case 695: return "TransformDerivative_derivativeOfInverse";
+  case 696: return "TransformDerivative_transform";
+  case 697: return "dynamic_extent_get";
+  case 698: return "DynamicSpan_extent_get";
+  case 699: return "new_DynamicSpan";
+  case 700: return "delete_DynamicSpan";
+  case 701: return "DynamicSpan_first";
+  case 702: return "DynamicSpan_last";
+  case 703: return "DynamicSpan_subspan";
+  case 704: return "DynamicSpan_size";
+  case 705: return "DynamicSpan_size_bytes";
+  case 706: return "DynamicSpan_empty";
+  case 707: return "DynamicSpan_brace";
+  case 708: return "DynamicSpan_getVal";
+  case 709: return "DynamicSpan_setVal";
+  case 710: return "DynamicSpan_at";
+  case 711: return "DynamicSpan_paren";
+  case 712: return "DynamicSpan_begin";
+  case 713: return "DynamicSpan_end";
+  case 714: return "DynamicSpan_cbegin";
+  case 715: return "DynamicSpan_cend";
+  case 716: return "DynamicSpan_rbegin";
+  case 717: return "DynamicSpan_rend";
+  case 718: return "DynamicSpan_crbegin";
+  case 719: return "DynamicSpan_crend";
+  case 720: return "new_DynamicMatrixView";
+  case 721: return "DynamicMatrixView_storageOrder";
+  case 722: return "DynamicMatrixView_paren";
+  case 723: return "DynamicMatrixView_rows";
+  case 724: return "DynamicMatrixView_cols";
+  case 725: return "DynamicMatrixView_block";
+  case 726: return "delete_DynamicMatrixView";
+  case 727: return "LINK_INVALID_INDEX_get";
+  case 728: return "LINK_INVALID_INDEX_set";
+  case 729: return "LINK_INVALID_NAME_get";
+  case 730: return "LINK_INVALID_NAME_set";
+  case 731: return "JOINT_INVALID_INDEX_get";
+  case 732: return "JOINT_INVALID_INDEX_set";
+  case 733: return "JOINT_INVALID_NAME_get";
+  case 734: return "JOINT_INVALID_NAME_set";
+  case 735: return "DOF_INVALID_INDEX_get";
+  case 736: return "DOF_INVALID_INDEX_set";
+  case 737: return "DOF_INVALID_NAME_get";
+  case 738: return "DOF_INVALID_NAME_set";
+  case 739: return "FRAME_INVALID_INDEX_get";
+  case 740: return "FRAME_INVALID_INDEX_set";
+  case 741: return "FRAME_INVALID_NAME_get";
+  case 742: return "FRAME_INVALID_NAME_set";
+  case 743: return "TRAVERSAL_INVALID_INDEX_get";
+  case 744: return "TRAVERSAL_INVALID_INDEX_set";
+  case 745: return "new_LinkPositions";
+  case 746: return "LinkPositions_resize";
+  case 747: return "LinkPositions_isConsistent";
+  case 748: return "LinkPositions_getNrOfLinks";
+  case 749: return "LinkPositions_paren";
+  case 750: return "LinkPositions_toString";
+  case 751: return "delete_LinkPositions";
+  case 752: return "new_LinkWrenches";
+  case 753: return "LinkWrenches_resize";
+  case 754: return "LinkWrenches_isConsistent";
+  case 755: return "LinkWrenches_getNrOfLinks";
+  case 756: return "LinkWrenches_paren";
+  case 757: return "LinkWrenches_toString";
+  case 758: return "LinkWrenches_zero";
+  case 759: return "delete_LinkWrenches";
+  case 760: return "new_LinkInertias";
+  case 761: return "LinkInertias_resize";
+  case 762: return "LinkInertias_isConsistent";
+  case 763: return "LinkInertias_paren";
+  case 764: return "delete_LinkInertias";
+  case 765: return "new_LinkArticulatedBodyInertias";
+  case 766: return "LinkArticulatedBodyInertias_resize";
+  case 767: return "LinkArticulatedBodyInertias_isConsistent";
+  case 768: return "LinkArticulatedBodyInertias_paren";
+  case 769: return "delete_LinkArticulatedBodyInertias";
+  case 770: return "new_LinkVelArray";
+  case 771: return "LinkVelArray_resize";
+  case 772: return "LinkVelArray_isConsistent";
+  case 773: return "LinkVelArray_getNrOfLinks";
+  case 774: return "LinkVelArray_paren";
+  case 775: return "LinkVelArray_toString";
+  case 776: return "delete_LinkVelArray";
+  case 777: return "new_LinkAccArray";
+  case 778: return "LinkAccArray_resize";
+  case 779: return "LinkAccArray_isConsistent";
+  case 780: return "LinkAccArray_paren";
+  case 781: return "LinkAccArray_getNrOfLinks";
+  case 782: return "LinkAccArray_toString";
+  case 783: return "delete_LinkAccArray";
+  case 784: return "new_Link";
+  case 785: return "Link_inertia";
+  case 786: return "Link_setInertia";
+  case 787: return "Link_getInertia";
+  case 788: return "Link_setIndex";
+  case 789: return "Link_getIndex";
+  case 790: return "delete_Link";
+  case 791: return "delete_IJoint";
+  case 792: return "IJoint_clone";
+  case 793: return "IJoint_getNrOfPosCoords";
+  case 794: return "IJoint_getNrOfDOFs";
+  case 795: return "IJoint_setAttachedLinks";
+  case 796: return "IJoint_setRestTransform";
+  case 797: return "IJoint_getFirstAttachedLink";
+  case 798: return "IJoint_getSecondAttachedLink";
+  case 799: return "IJoint_getRestTransform";
+  case 800: return "IJoint_getTransform";
+  case 801: return "IJoint_getTransformDerivative";
+  case 802: return "IJoint_getMotionSubspaceVector";
+  case 803: return "IJoint_computeChildPosVelAcc";
+  case 804: return "IJoint_computeChildVelAcc";
+  case 805: return "IJoint_computeChildVel";
+  case 806: return "IJoint_computeChildAcc";
+  case 807: return "IJoint_computeChildBiasAcc";
+  case 808: return "IJoint_computeJointTorque";
+  case 809: return "IJoint_setIndex";
+  case 810: return "IJoint_getIndex";
+  case 811: return "IJoint_setPosCoordsOffset";
+  case 812: return "IJoint_getPosCoordsOffset";
+  case 813: return "IJoint_setDOFsOffset";
+  case 814: return "IJoint_getDOFsOffset";
+  case 815: return "IJoint_hasPosLimits";
+  case 816: return "IJoint_enablePosLimits";
+  case 817: return "IJoint_getPosLimits";
+  case 818: return "IJoint_getMinPosLimit";
+  case 819: return "IJoint_getMaxPosLimit";
+  case 820: return "IJoint_setPosLimits";
+  case 821: return "IJoint_isRevoluteJoint";
+  case 822: return "IJoint_isFixedJoint";
+  case 823: return "IJoint_isPrismaticJoint";
+  case 824: return "IJoint_asRevoluteJoint";
+  case 825: return "IJoint_asFixedJoint";
+  case 826: return "IJoint_asPrismaticJoint";
+  case 827: return "new_FixedJoint";
+  case 828: return "delete_FixedJoint";
+  case 829: return "FixedJoint_clone";
+  case 830: return "FixedJoint_getNrOfPosCoords";
+  case 831: return "FixedJoint_getNrOfDOFs";
+  case 832: return "FixedJoint_setAttachedLinks";
+  case 833: return "FixedJoint_setRestTransform";
+  case 834: return "FixedJoint_getFirstAttachedLink";
+  case 835: return "FixedJoint_getSecondAttachedLink";
+  case 836: return "FixedJoint_getRestTransform";
+  case 837: return "FixedJoint_getTransform";
+  case 838: return "FixedJoint_getTransformDerivative";
+  case 839: return "FixedJoint_getMotionSubspaceVector";
+  case 840: return "FixedJoint_computeChildPosVelAcc";
+  case 841: return "FixedJoint_computeChildVelAcc";
+  case 842: return "FixedJoint_computeChildVel";
+  case 843: return "FixedJoint_computeChildAcc";
+  case 844: return "FixedJoint_computeChildBiasAcc";
+  case 845: return "FixedJoint_computeJointTorque";
+  case 846: return "FixedJoint_setIndex";
+  case 847: return "FixedJoint_getIndex";
+  case 848: return "FixedJoint_setPosCoordsOffset";
+  case 849: return "FixedJoint_getPosCoordsOffset";
+  case 850: return "FixedJoint_setDOFsOffset";
+  case 851: return "FixedJoint_getDOFsOffset";
+  case 852: return "FixedJoint_hasPosLimits";
+  case 853: return "FixedJoint_enablePosLimits";
+  case 854: return "FixedJoint_getPosLimits";
+  case 855: return "FixedJoint_getMinPosLimit";
+  case 856: return "FixedJoint_getMaxPosLimit";
+  case 857: return "FixedJoint_setPosLimits";
+  case 858: return "delete_MovableJointImpl1";
+  case 859: return "MovableJointImpl1_getNrOfPosCoords";
+  case 860: return "MovableJointImpl1_getNrOfDOFs";
+  case 861: return "MovableJointImpl1_setIndex";
+  case 862: return "MovableJointImpl1_getIndex";
+  case 863: return "MovableJointImpl1_setPosCoordsOffset";
+  case 864: return "MovableJointImpl1_getPosCoordsOffset";
+  case 865: return "MovableJointImpl1_setDOFsOffset";
+  case 866: return "MovableJointImpl1_getDOFsOffset";
+  case 867: return "delete_MovableJointImpl2";
+  case 868: return "MovableJointImpl2_getNrOfPosCoords";
+  case 869: return "MovableJointImpl2_getNrOfDOFs";
+  case 870: return "MovableJointImpl2_setIndex";
+  case 871: return "MovableJointImpl2_getIndex";
+  case 872: return "MovableJointImpl2_setPosCoordsOffset";
+  case 873: return "MovableJointImpl2_getPosCoordsOffset";
+  case 874: return "MovableJointImpl2_setDOFsOffset";
+  case 875: return "MovableJointImpl2_getDOFsOffset";
+  case 876: return "delete_MovableJointImpl3";
+  case 877: return "MovableJointImpl3_getNrOfPosCoords";
+  case 878: return "MovableJointImpl3_getNrOfDOFs";
+  case 879: return "MovableJointImpl3_setIndex";
+  case 880: return "MovableJointImpl3_getIndex";
+  case 881: return "MovableJointImpl3_setPosCoordsOffset";
+  case 882: return "MovableJointImpl3_getPosCoordsOffset";
+  case 883: return "MovableJointImpl3_setDOFsOffset";
+  case 884: return "MovableJointImpl3_getDOFsOffset";
+  case 885: return "delete_MovableJointImpl4";
+  case 886: return "MovableJointImpl4_getNrOfPosCoords";
+  case 887: return "MovableJointImpl4_getNrOfDOFs";
+  case 888: return "MovableJointImpl4_setIndex";
+  case 889: return "MovableJointImpl4_getIndex";
+  case 890: return "MovableJointImpl4_setPosCoordsOffset";
+  case 891: return "MovableJointImpl4_getPosCoordsOffset";
+  case 892: return "MovableJointImpl4_setDOFsOffset";
+  case 893: return "MovableJointImpl4_getDOFsOffset";
+  case 894: return "delete_MovableJointImpl5";
+  case 895: return "MovableJointImpl5_getNrOfPosCoords";
+  case 896: return "MovableJointImpl5_getNrOfDOFs";
+  case 897: return "MovableJointImpl5_setIndex";
+  case 898: return "MovableJointImpl5_getIndex";
+  case 899: return "MovableJointImpl5_setPosCoordsOffset";
+  case 900: return "MovableJointImpl5_getPosCoordsOffset";
+  case 901: return "MovableJointImpl5_setDOFsOffset";
+  case 902: return "MovableJointImpl5_getDOFsOffset";
+  case 903: return "delete_MovableJointImpl6";
+  case 904: return "MovableJointImpl6_getNrOfPosCoords";
+  case 905: return "MovableJointImpl6_getNrOfDOFs";
+  case 906: return "MovableJointImpl6_setIndex";
+  case 907: return "MovableJointImpl6_getIndex";
+  case 908: return "MovableJointImpl6_setPosCoordsOffset";
+  case 909: return "MovableJointImpl6_getPosCoordsOffset";
+  case 910: return "MovableJointImpl6_setDOFsOffset";
+  case 911: return "MovableJointImpl6_getDOFsOffset";
+  case 912: return "new_RevoluteJoint";
+  case 913: return "delete_RevoluteJoint";
+  case 914: return "RevoluteJoint_clone";
+  case 915: return "RevoluteJoint_setAttachedLinks";
+  case 916: return "RevoluteJoint_setRestTransform";
+  case 917: return "RevoluteJoint_setAxis";
+  case 918: return "RevoluteJoint_getFirstAttachedLink";
+  case 919: return "RevoluteJoint_getSecondAttachedLink";
+  case 920: return "RevoluteJoint_getAxis";
+  case 921: return "RevoluteJoint_getRestTransform";
+  case 922: return "RevoluteJoint_getTransform";
+  case 923: return "RevoluteJoint_getTransformDerivative";
+  case 924: return "RevoluteJoint_getMotionSubspaceVector";
+  case 925: return "RevoluteJoint_computeChildPosVelAcc";
+  case 926: return "RevoluteJoint_computeChildVel";
+  case 927: return "RevoluteJoint_computeChildVelAcc";
+  case 928: return "RevoluteJoint_computeChildAcc";
+  case 929: return "RevoluteJoint_computeChildBiasAcc";
+  case 930: return "RevoluteJoint_computeJointTorque";
+  case 931: return "RevoluteJoint_hasPosLimits";
+  case 932: return "RevoluteJoint_enablePosLimits";
+  case 933: return "RevoluteJoint_getPosLimits";
+  case 934: return "RevoluteJoint_getMinPosLimit";
+  case 935: return "RevoluteJoint_getMaxPosLimit";
+  case 936: return "RevoluteJoint_setPosLimits";
+  case 937: return "new_PrismaticJoint";
+  case 938: return "delete_PrismaticJoint";
+  case 939: return "PrismaticJoint_clone";
+  case 940: return "PrismaticJoint_setAttachedLinks";
+  case 941: return "PrismaticJoint_setRestTransform";
+  case 942: return "PrismaticJoint_setAxis";
+  case 943: return "PrismaticJoint_getFirstAttachedLink";
+  case 944: return "PrismaticJoint_getSecondAttachedLink";
+  case 945: return "PrismaticJoint_getAxis";
+  case 946: return "PrismaticJoint_getRestTransform";
+  case 947: return "PrismaticJoint_getTransform";
+  case 948: return "PrismaticJoint_getTransformDerivative";
+  case 949: return "PrismaticJoint_getMotionSubspaceVector";
+  case 950: return "PrismaticJoint_computeChildPosVelAcc";
+  case 951: return "PrismaticJoint_computeChildVel";
+  case 952: return "PrismaticJoint_computeChildVelAcc";
+  case 953: return "PrismaticJoint_computeChildAcc";
+  case 954: return "PrismaticJoint_computeChildBiasAcc";
+  case 955: return "PrismaticJoint_computeJointTorque";
+  case 956: return "PrismaticJoint_hasPosLimits";
+  case 957: return "PrismaticJoint_enablePosLimits";
+  case 958: return "PrismaticJoint_getPosLimits";
+  case 959: return "PrismaticJoint_getMinPosLimit";
+  case 960: return "PrismaticJoint_getMaxPosLimit";
+  case 961: return "PrismaticJoint_setPosLimits";
+  case 962: return "new_Traversal";
+  case 963: return "delete_Traversal";
+  case 964: return "Traversal_getNrOfVisitedLinks";
+  case 965: return "Traversal_getLink";
+  case 966: return "Traversal_getBaseLink";
+  case 967: return "Traversal_getParentLink";
+  case 968: return "Traversal_getParentJoint";
+  case 969: return "Traversal_getParentLinkFromLinkIndex";
+  case 970: return "Traversal_getParentJointFromLinkIndex";
+  case 971: return "Traversal_getTraversalIndexFromLinkIndex";
+  case 972: return "Traversal_reset";
+  case 973: return "Traversal_addTraversalBase";
+  case 974: return "Traversal_addTraversalElement";
+  case 975: return "Traversal_isParentOf";
+  case 976: return "Traversal_getChildLinkIndexFromJointIndex";
+  case 977: return "Traversal_getParentLinkIndexFromJointIndex";
+  case 978: return "Traversal_toString";
+  case 979: return "new_Material";
+  case 980: return "Material_name";
+  case 981: return "Material_hasColor";
+  case 982: return "Material_color";
+  case 983: return "Material_setColor";
+  case 984: return "Material_hasTexture";
+  case 985: return "Material_texture";
+  case 986: return "Material_setTexture";
+  case 987: return "delete_Material";
+  case 988: return "delete_SolidShape";
+  case 989: return "SolidShape_clone";
+  case 990: return "SolidShape_getName";
+  case 991: return "SolidShape_setName";
+  case 992: return "SolidShape_isNameValid";
+  case 993: return "SolidShape_getLink_H_geometry";
+  case 994: return "SolidShape_setLink_H_geometry";
+  case 995: return "SolidShape_isMaterialSet";
+  case 996: return "SolidShape_getMaterial";
+  case 997: return "SolidShape_setMaterial";
+  case 998: return "SolidShape_isSphere";
+  case 999: return "SolidShape_isBox";
+  case 1000: return "SolidShape_isCylinder";
+  case 1001: return "SolidShape_isExternalMesh";
+  case 1002: return "SolidShape_asSphere";
+  case 1003: return "SolidShape_asBox";
+  case 1004: return "SolidShape_asCylinder";
+  case 1005: return "SolidShape_asExternalMesh";
+  case 1006: return "delete_Sphere";
+  case 1007: return "Sphere_clone";
+  case 1008: return "Sphere_getRadius";
+  case 1009: return "Sphere_setRadius";
+  case 1010: return "new_Sphere";
+  case 1011: return "delete_Box";
+  case 1012: return "Box_clone";
+  case 1013: return "Box_getX";
+  case 1014: return "Box_setX";
+  case 1015: return "Box_getY";
+  case 1016: return "Box_setY";
+  case 1017: return "Box_getZ";
+  case 1018: return "Box_setZ";
+  case 1019: return "new_Box";
+  case 1020: return "delete_Cylinder";
+  case 1021: return "Cylinder_clone";
+  case 1022: return "Cylinder_getLength";
+  case 1023: return "Cylinder_setLength";
+  case 1024: return "Cylinder_getRadius";
+  case 1025: return "Cylinder_setRadius";
+  case 1026: return "new_Cylinder";
+  case 1027: return "delete_ExternalMesh";
+  case 1028: return "ExternalMesh_clone";
+  case 1029: return "ExternalMesh_getFilename";
+  case 1030: return "ExternalMesh_getFileLocationOnLocalFileSystem";
+  case 1031: return "ExternalMesh_setFilename";
+  case 1032: return "ExternalMesh_getScale";
+  case 1033: return "ExternalMesh_setScale";
+  case 1034: return "new_ExternalMesh";
+  case 1035: return "delete_ModelSolidShapes";
+  case 1036: return "new_ModelSolidShapes";
+  case 1037: return "ModelSolidShapes_clear";
+  case 1038: return "ModelSolidShapes_resize";
+  case 1039: return "ModelSolidShapes_isConsistent";
+  case 1040: return "ModelSolidShapes_getLinkSolidShapes";
+  case 1041: return "Neighbor_neighborLink_get";
+  case 1042: return "Neighbor_neighborLink_set";
+  case 1043: return "Neighbor_neighborJoint_get";
+  case 1044: return "Neighbor_neighborJoint_set";
+  case 1045: return "new_Neighbor";
+  case 1046: return "delete_Neighbor";
+  case 1047: return "new_Model";
+  case 1048: return "Model_copy";
+  case 1049: return "delete_Model";
+  case 1050: return "Model_getNrOfLinks";
+  case 1051: return "Model_getLinkName";
+  case 1052: return "Model_getLinkIndex";
+  case 1053: return "Model_isValidLinkIndex";
+  case 1054: return "Model_getLink";
+  case 1055: return "Model_addLink";
+  case 1056: return "Model_getNrOfJoints";
+  case 1057: return "Model_getJointName";
+  case 1058: return "Model_getTotalMass";
+  case 1059: return "Model_getJointIndex";
+  case 1060: return "Model_getJoint";
+  case 1061: return "Model_isValidJointIndex";
+  case 1062: return "Model_isLinkNameUsed";
+  case 1063: return "Model_isJointNameUsed";
+  case 1064: return "Model_isFrameNameUsed";
+  case 1065: return "Model_addJoint";
+  case 1066: return "Model_addJointAndLink";
+  case 1067: return "Model_insertLinkToExistingJointAndAddJointForDisplacedLink";
+  case 1068: return "Model_getNrOfPosCoords";
+  case 1069: return "Model_getNrOfDOFs";
+  case 1070: return "Model_getNrOfFrames";
+  case 1071: return "Model_addAdditionalFrameToLink";
+  case 1072: return "Model_getFrameName";
+  case 1073: return "Model_getFrameIndex";
+  case 1074: return "Model_isValidFrameIndex";
+  case 1075: return "Model_getFrameTransform";
+  case 1076: return "Model_getFrameLink";
+  case 1077: return "Model_getLinkAdditionalFrames";
+  case 1078: return "Model_getNrOfNeighbors";
+  case 1079: return "Model_getNeighbor";
+  case 1080: return "Model_setDefaultBaseLink";
+  case 1081: return "Model_getDefaultBaseLink";
+  case 1082: return "Model_computeFullTreeTraversal";
+  case 1083: return "Model_getInertialParameters";
+  case 1084: return "Model_updateInertialParameters";
+  case 1085: return "Model_visualSolidShapes";
+  case 1086: return "Model_collisionSolidShapes";
+  case 1087: return "Model_toString";
+  case 1088: return "new_JointPosDoubleArray";
+  case 1089: return "JointPosDoubleArray_resize";
+  case 1090: return "JointPosDoubleArray_isConsistent";
+  case 1091: return "delete_JointPosDoubleArray";
+  case 1092: return "new_JointDOFsDoubleArray";
+  case 1093: return "JointDOFsDoubleArray_resize";
+  case 1094: return "JointDOFsDoubleArray_isConsistent";
+  case 1095: return "delete_JointDOFsDoubleArray";
+  case 1096: return "new_DOFSpatialForceArray";
+  case 1097: return "DOFSpatialForceArray_resize";
+  case 1098: return "DOFSpatialForceArray_isConsistent";
+  case 1099: return "DOFSpatialForceArray_paren";
+  case 1100: return "delete_DOFSpatialForceArray";
+  case 1101: return "new_DOFSpatialMotionArray";
+  case 1102: return "DOFSpatialMotionArray_resize";
+  case 1103: return "DOFSpatialMotionArray_isConsistent";
+  case 1104: return "DOFSpatialMotionArray_paren";
+  case 1105: return "delete_DOFSpatialMotionArray";
+  case 1106: return "new_FrameFreeFloatingJacobian";
+  case 1107: return "FrameFreeFloatingJacobian_resize";
+  case 1108: return "FrameFreeFloatingJacobian_isConsistent";
+  case 1109: return "delete_FrameFreeFloatingJacobian";
+  case 1110: return "new_MomentumFreeFloatingJacobian";
+  case 1111: return "MomentumFreeFloatingJacobian_resize";
+  case 1112: return "MomentumFreeFloatingJacobian_isConsistent";
+  case 1113: return "delete_MomentumFreeFloatingJacobian";
+  case 1114: return "new_FreeFloatingMassMatrix";
+  case 1115: return "FreeFloatingMassMatrix_resize";
+  case 1116: return "delete_FreeFloatingMassMatrix";
+  case 1117: return "new_FreeFloatingPos";
+  case 1118: return "FreeFloatingPos_resize";
+  case 1119: return "FreeFloatingPos_worldBasePos";
+  case 1120: return "FreeFloatingPos_jointPos";
+  case 1121: return "FreeFloatingPos_getNrOfPosCoords";
+  case 1122: return "delete_FreeFloatingPos";
+  case 1123: return "new_FreeFloatingGeneralizedTorques";
+  case 1124: return "FreeFloatingGeneralizedTorques_resize";
+  case 1125: return "FreeFloatingGeneralizedTorques_baseWrench";
+  case 1126: return "FreeFloatingGeneralizedTorques_jointTorques";
+  case 1127: return "FreeFloatingGeneralizedTorques_getNrOfDOFs";
+  case 1128: return "delete_FreeFloatingGeneralizedTorques";
+  case 1129: return "new_FreeFloatingVel";
+  case 1130: return "FreeFloatingVel_resize";
+  case 1131: return "FreeFloatingVel_baseVel";
+  case 1132: return "FreeFloatingVel_jointVel";
+  case 1133: return "FreeFloatingVel_getNrOfDOFs";
+  case 1134: return "delete_FreeFloatingVel";
+  case 1135: return "new_FreeFloatingAcc";
+  case 1136: return "FreeFloatingAcc_resize";
+  case 1137: return "FreeFloatingAcc_baseAcc";
+  case 1138: return "FreeFloatingAcc_jointAcc";
+  case 1139: return "FreeFloatingAcc_getNrOfDOFs";
+  case 1140: return "delete_FreeFloatingAcc";
+  case 1141: return "ContactWrench_contactId";
+  case 1142: return "ContactWrench_contactPoint";
+  case 1143: return "ContactWrench_contactWrench";
+  case 1144: return "new_ContactWrench";
+  case 1145: return "delete_ContactWrench";
+  case 1146: return "new_LinkContactWrenches";
+  case 1147: return "LinkContactWrenches_resize";
+  case 1148: return "LinkContactWrenches_getNrOfContactsForLink";
+  case 1149: return "LinkContactWrenches_setNrOfContactsForLink";
+  case 1150: return "LinkContactWrenches_getNrOfLinks";
+  case 1151: return "LinkContactWrenches_contactWrench";
+  case 1152: return "LinkContactWrenches_computeNetWrenches";
+  case 1153: return "LinkContactWrenches_toString";
+  case 1154: return "delete_LinkContactWrenches";
+  case 1155: return "_wrap_getRandomLink";
+  case 1156: return "_wrap_addRandomLinkToModel";
+  case 1157: return "_wrap_addRandomAdditionalFrameToModel";
+  case 1158: return "_wrap_getRandomLinkIndexOfModel";
+  case 1159: return "_wrap_getRandomLinkOfModel";
+  case 1160: return "_wrap_int2string";
+  case 1161: return "_wrap_getRandomModel";
+  case 1162: return "_wrap_getRandomChain";
+  case 1163: return "_wrap_getRandomJointPositions";
+  case 1164: return "_wrap_getRandomInverseDynamicsInputs";
+  case 1165: return "_wrap_removeFakeLinks";
+  case 1166: return "_wrap_createReducedModel";
+  case 1167: return "_wrap_createModelWithNormalizedJointNumbering";
+  case 1168: return "_wrap_extractSubModel";
+  case 1169: return "new_SubModelDecomposition";
+  case 1170: return "delete_SubModelDecomposition";
+  case 1171: return "SubModelDecomposition_splitModelAlongJoints";
+  case 1172: return "SubModelDecomposition_setNrOfSubModels";
+  case 1173: return "SubModelDecomposition_getNrOfSubModels";
+  case 1174: return "SubModelDecomposition_getNrOfLinks";
+  case 1175: return "SubModelDecomposition_getTraversal";
+  case 1176: return "SubModelDecomposition_getSubModelOfLink";
+  case 1177: return "SubModelDecomposition_getSubModelOfFrame";
+  case 1178: return "_wrap_computeTransformToTraversalBase";
+  case 1179: return "_wrap_computeTransformToSubModelBase";
+  case 1180: return "SolidShapesVector_pop";
+  case 1181: return "SolidShapesVector_brace";
+  case 1182: return "SolidShapesVector_setbrace";
+  case 1183: return "SolidShapesVector_append";
+  case 1184: return "SolidShapesVector_empty";
+  case 1185: return "SolidShapesVector_size";
+  case 1186: return "SolidShapesVector_swap";
+  case 1187: return "SolidShapesVector_begin";
+  case 1188: return "SolidShapesVector_end";
+  case 1189: return "SolidShapesVector_rbegin";
+  case 1190: return "SolidShapesVector_rend";
+  case 1191: return "SolidShapesVector_clear";
+  case 1192: return "SolidShapesVector_get_allocator";
+  case 1193: return "SolidShapesVector_pop_back";
+  case 1194: return "SolidShapesVector_erase";
+  case 1195: return "new_SolidShapesVector";
+  case 1196: return "SolidShapesVector_push_back";
+  case 1197: return "SolidShapesVector_front";
+  case 1198: return "SolidShapesVector_back";
+  case 1199: return "SolidShapesVector_assign";
+  case 1200: return "SolidShapesVector_resize";
+  case 1201: return "SolidShapesVector_insert";
+  case 1202: return "SolidShapesVector_reserve";
+  case 1203: return "SolidShapesVector_capacity";
+  case 1204: return "delete_SolidShapesVector";
+  case 1205: return "LinksSolidShapesVector_pop";
+  case 1206: return "LinksSolidShapesVector_brace";
+  case 1207: return "LinksSolidShapesVector_setbrace";
+  case 1208: return "LinksSolidShapesVector_append";
+  case 1209: return "LinksSolidShapesVector_empty";
+  case 1210: return "LinksSolidShapesVector_size";
+  case 1211: return "LinksSolidShapesVector_swap";
+  case 1212: return "LinksSolidShapesVector_begin";
+  case 1213: return "LinksSolidShapesVector_end";
+  case 1214: return "LinksSolidShapesVector_rbegin";
+  case 1215: return "LinksSolidShapesVector_rend";
+  case 1216: return "LinksSolidShapesVector_clear";
+  case 1217: return "LinksSolidShapesVector_get_allocator";
+  case 1218: return "LinksSolidShapesVector_pop_back";
+  case 1219: return "LinksSolidShapesVector_erase";
+  case 1220: return "new_LinksSolidShapesVector";
+  case 1221: return "LinksSolidShapesVector_push_back";
+  case 1222: return "LinksSolidShapesVector_front";
+  case 1223: return "LinksSolidShapesVector_back";
+  case 1224: return "LinksSolidShapesVector_assign";
+  case 1225: return "LinksSolidShapesVector_resize";
+  case 1226: return "LinksSolidShapesVector_insert";
+  case 1227: return "LinksSolidShapesVector_reserve";
+  case 1228: return "LinksSolidShapesVector_capacity";
+  case 1229: return "delete_LinksSolidShapesVector";
+  case 1230: return "_wrap_ForwardPositionKinematics";
+  case 1231: return "_wrap_ForwardVelAccKinematics";
+  case 1232: return "_wrap_ForwardPosVelAccKinematics";
+  case 1233: return "_wrap_ForwardPosVelKinematics";
+  case 1234: return "_wrap_ForwardAccKinematics";
+  case 1235: return "_wrap_ForwardBiasAccKinematics";
+  case 1236: return "_wrap_ComputeLinearAndAngularMomentum";
+  case 1237: return "_wrap_ComputeLinearAndAngularMomentumDerivativeBias";
+  case 1238: return "_wrap_RNEADynamicPhase";
+  case 1239: return "_wrap_CompositeRigidBodyAlgorithm";
+  case 1240: return "new_ArticulatedBodyAlgorithmInternalBuffers";
+  case 1241: return "ArticulatedBodyAlgorithmInternalBuffers_resize";
+  case 1242: return "ArticulatedBodyAlgorithmInternalBuffers_isConsistent";
+  case 1243: return "ArticulatedBodyAlgorithmInternalBuffers_S_get";
+  case 1244: return "ArticulatedBodyAlgorithmInternalBuffers_S_set";
+  case 1245: return "ArticulatedBodyAlgorithmInternalBuffers_U_get";
+  case 1246: return "ArticulatedBodyAlgorithmInternalBuffers_U_set";
+  case 1247: return "ArticulatedBodyAlgorithmInternalBuffers_D_get";
+  case 1248: return "ArticulatedBodyAlgorithmInternalBuffers_D_set";
+  case 1249: return "ArticulatedBodyAlgorithmInternalBuffers_u_get";
+  case 1250: return "ArticulatedBodyAlgorithmInternalBuffers_u_set";
+  case 1251: return "ArticulatedBodyAlgorithmInternalBuffers_linksVel_get";
+  case 1252: return "ArticulatedBodyAlgorithmInternalBuffers_linksVel_set";
+  case 1253: return "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get";
+  case 1254: return "ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set";
+  case 1255: return "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get";
+  case 1256: return "ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set";
+  case 1257: return "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get";
+  case 1258: return "ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set";
+  case 1259: return "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get";
+  case 1260: return "ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set";
+  case 1261: return "delete_ArticulatedBodyAlgorithmInternalBuffers";
+  case 1262: return "_wrap_ArticulatedBodyAlgorithm";
+  case 1263: return "_wrap_InverseDynamicsInertialParametersRegressor";
+  case 1264: return "DHLink_A_get";
+  case 1265: return "DHLink_A_set";
+  case 1266: return "DHLink_D_get";
+  case 1267: return "DHLink_D_set";
+  case 1268: return "DHLink_Alpha_get";
+  case 1269: return "DHLink_Alpha_set";
+  case 1270: return "DHLink_Offset_get";
+  case 1271: return "DHLink_Offset_set";
+  case 1272: return "DHLink_Min_get";
+  case 1273: return "DHLink_Min_set";
+  case 1274: return "DHLink_Max_get";
+  case 1275: return "DHLink_Max_set";
+  case 1276: return "new_DHLink";
+  case 1277: return "delete_DHLink";
+  case 1278: return "DHChain_setNrOfDOFs";
+  case 1279: return "DHChain_getNrOfDOFs";
+  case 1280: return "DHChain_setH0";
+  case 1281: return "DHChain_getH0";
+  case 1282: return "DHChain_setHN";
+  case 1283: return "DHChain_getHN";
+  case 1284: return "DHChain_paren";
+  case 1285: return "DHChain_getDOFName";
+  case 1286: return "DHChain_setDOFName";
+  case 1287: return "DHChain_toModel";
+  case 1288: return "DHChain_fromModel";
+  case 1289: return "new_DHChain";
+  case 1290: return "delete_DHChain";
+  case 1291: return "_wrap_TransformFromDHCraig1989";
+  case 1292: return "_wrap_TransformFromDH";
+  case 1293: return "_wrap_ExtractDHChainFromModel";
+  case 1294: return "_wrap_CreateModelFromDHChain";
+  case 1295: return "NR_OF_SENSOR_TYPES_get";
+  case 1296: return "_wrap_isLinkSensor";
+  case 1297: return "_wrap_isJointSensor";
+  case 1298: return "_wrap_getSensorTypeSize";
+  case 1299: return "delete_Sensor";
+  case 1300: return "Sensor_getName";
+  case 1301: return "Sensor_getSensorType";
+  case 1302: return "Sensor_isValid";
+  case 1303: return "Sensor_setName";
+  case 1304: return "Sensor_clone";
+  case 1305: return "Sensor_isConsistent";
+  case 1306: return "Sensor_updateIndices";
+  case 1307: return "delete_JointSensor";
+  case 1308: return "JointSensor_getParentJoint";
+  case 1309: return "JointSensor_getParentJointIndex";
+  case 1310: return "JointSensor_setParentJoint";
+  case 1311: return "JointSensor_setParentJointIndex";
+  case 1312: return "JointSensor_isConsistent";
+  case 1313: return "delete_LinkSensor";
+  case 1314: return "LinkSensor_getParentLink";
+  case 1315: return "LinkSensor_getParentLinkIndex";
+  case 1316: return "LinkSensor_getLinkSensorTransform";
+  case 1317: return "LinkSensor_setParentLink";
+  case 1318: return "LinkSensor_setParentLinkIndex";
+  case 1319: return "LinkSensor_setLinkSensorTransform";
+  case 1320: return "LinkSensor_isConsistent";
+  case 1321: return "new_SensorsList";
+  case 1322: return "delete_SensorsList";
+  case 1323: return "SensorsList_addSensor";
+  case 1324: return "SensorsList_setSerialization";
+  case 1325: return "SensorsList_getSerialization";
+  case 1326: return "SensorsList_getNrOfSensors";
+  case 1327: return "SensorsList_getSensorIndex";
+  case 1328: return "SensorsList_getSizeOfAllSensorsMeasurements";
+  case 1329: return "SensorsList_getSensor";
+  case 1330: return "SensorsList_isConsistent";
+  case 1331: return "SensorsList_removeSensor";
+  case 1332: return "SensorsList_removeAllSensorsOfType";
+  case 1333: return "SensorsList_getSixAxisForceTorqueSensor";
+  case 1334: return "SensorsList_getAccelerometerSensor";
+  case 1335: return "SensorsList_getGyroscopeSensor";
+  case 1336: return "SensorsList_getThreeAxisAngularAccelerometerSensor";
+  case 1337: return "SensorsList_getThreeAxisForceTorqueContactSensor";
+  case 1338: return "new_SensorsMeasurements";
+  case 1339: return "delete_SensorsMeasurements";
+  case 1340: return "SensorsMeasurements_setNrOfSensors";
+  case 1341: return "SensorsMeasurements_getNrOfSensors";
+  case 1342: return "SensorsMeasurements_resize";
+  case 1343: return "SensorsMeasurements_toVector";
+  case 1344: return "SensorsMeasurements_setMeasurement";
+  case 1345: return "SensorsMeasurements_getMeasurement";
+  case 1346: return "SensorsMeasurements_getSizeOfAllSensorsMeasurements";
+  case 1347: return "new_SixAxisForceTorqueSensor";
+  case 1348: return "delete_SixAxisForceTorqueSensor";
+  case 1349: return "SixAxisForceTorqueSensor_setName";
+  case 1350: return "SixAxisForceTorqueSensor_setFirstLinkSensorTransform";
+  case 1351: return "SixAxisForceTorqueSensor_setSecondLinkSensorTransform";
+  case 1352: return "SixAxisForceTorqueSensor_getFirstLinkIndex";
+  case 1353: return "SixAxisForceTorqueSensor_getSecondLinkIndex";
+  case 1354: return "SixAxisForceTorqueSensor_setFirstLinkName";
+  case 1355: return "SixAxisForceTorqueSensor_setSecondLinkName";
+  case 1356: return "SixAxisForceTorqueSensor_getFirstLinkName";
+  case 1357: return "SixAxisForceTorqueSensor_getSecondLinkName";
+  case 1358: return "SixAxisForceTorqueSensor_setParentJoint";
+  case 1359: return "SixAxisForceTorqueSensor_setParentJointIndex";
+  case 1360: return "SixAxisForceTorqueSensor_setAppliedWrenchLink";
+  case 1361: return "SixAxisForceTorqueSensor_getName";
+  case 1362: return "SixAxisForceTorqueSensor_getSensorType";
+  case 1363: return "SixAxisForceTorqueSensor_getParentJoint";
+  case 1364: return "SixAxisForceTorqueSensor_getParentJointIndex";
+  case 1365: return "SixAxisForceTorqueSensor_isValid";
+  case 1366: return "SixAxisForceTorqueSensor_clone";
+  case 1367: return "SixAxisForceTorqueSensor_updateIndices";
+  case 1368: return "SixAxisForceTorqueSensor_getAppliedWrenchLink";
+  case 1369: return "SixAxisForceTorqueSensor_isLinkAttachedToSensor";
+  case 1370: return "SixAxisForceTorqueSensor_getLinkSensorTransform";
+  case 1371: return "SixAxisForceTorqueSensor_getWrenchAppliedOnLink";
+  case 1372: return "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix";
+  case 1373: return "SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix";
+  case 1374: return "SixAxisForceTorqueSensor_predictMeasurement";
+  case 1375: return "SixAxisForceTorqueSensor_toString";
+  case 1376: return "new_AccelerometerSensor";
+  case 1377: return "delete_AccelerometerSensor";
+  case 1378: return "AccelerometerSensor_setName";
+  case 1379: return "AccelerometerSensor_setLinkSensorTransform";
+  case 1380: return "AccelerometerSensor_setParentLink";
+  case 1381: return "AccelerometerSensor_setParentLinkIndex";
+  case 1382: return "AccelerometerSensor_getName";
+  case 1383: return "AccelerometerSensor_getSensorType";
+  case 1384: return "AccelerometerSensor_getParentLink";
+  case 1385: return "AccelerometerSensor_getParentLinkIndex";
+  case 1386: return "AccelerometerSensor_getLinkSensorTransform";
+  case 1387: return "AccelerometerSensor_isValid";
+  case 1388: return "AccelerometerSensor_clone";
+  case 1389: return "AccelerometerSensor_updateIndices";
+  case 1390: return "AccelerometerSensor_predictMeasurement";
+  case 1391: return "new_GyroscopeSensor";
+  case 1392: return "delete_GyroscopeSensor";
+  case 1393: return "GyroscopeSensor_setName";
+  case 1394: return "GyroscopeSensor_setLinkSensorTransform";
+  case 1395: return "GyroscopeSensor_setParentLink";
+  case 1396: return "GyroscopeSensor_setParentLinkIndex";
+  case 1397: return "GyroscopeSensor_getName";
+  case 1398: return "GyroscopeSensor_getSensorType";
+  case 1399: return "GyroscopeSensor_getParentLink";
+  case 1400: return "GyroscopeSensor_getParentLinkIndex";
+  case 1401: return "GyroscopeSensor_getLinkSensorTransform";
+  case 1402: return "GyroscopeSensor_isValid";
+  case 1403: return "GyroscopeSensor_clone";
+  case 1404: return "GyroscopeSensor_updateIndices";
+  case 1405: return "GyroscopeSensor_predictMeasurement";
+  case 1406: return "new_ThreeAxisAngularAccelerometerSensor";
+  case 1407: return "delete_ThreeAxisAngularAccelerometerSensor";
+  case 1408: return "ThreeAxisAngularAccelerometerSensor_setName";
+  case 1409: return "ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform";
+  case 1410: return "ThreeAxisAngularAccelerometerSensor_setParentLink";
+  case 1411: return "ThreeAxisAngularAccelerometerSensor_setParentLinkIndex";
+  case 1412: return "ThreeAxisAngularAccelerometerSensor_getName";
+  case 1413: return "ThreeAxisAngularAccelerometerSensor_getSensorType";
+  case 1414: return "ThreeAxisAngularAccelerometerSensor_getParentLink";
+  case 1415: return "ThreeAxisAngularAccelerometerSensor_getParentLinkIndex";
+  case 1416: return "ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform";
+  case 1417: return "ThreeAxisAngularAccelerometerSensor_isValid";
+  case 1418: return "ThreeAxisAngularAccelerometerSensor_clone";
+  case 1419: return "ThreeAxisAngularAccelerometerSensor_updateIndices";
+  case 1420: return "ThreeAxisAngularAccelerometerSensor_predictMeasurement";
+  case 1421: return "new_ThreeAxisForceTorqueContactSensor";
+  case 1422: return "delete_ThreeAxisForceTorqueContactSensor";
+  case 1423: return "ThreeAxisForceTorqueContactSensor_setName";
+  case 1424: return "ThreeAxisForceTorqueContactSensor_setLinkSensorTransform";
+  case 1425: return "ThreeAxisForceTorqueContactSensor_setParentLink";
+  case 1426: return "ThreeAxisForceTorqueContactSensor_setParentLinkIndex";
+  case 1427: return "ThreeAxisForceTorqueContactSensor_getName";
+  case 1428: return "ThreeAxisForceTorqueContactSensor_getSensorType";
+  case 1429: return "ThreeAxisForceTorqueContactSensor_getParentLink";
+  case 1430: return "ThreeAxisForceTorqueContactSensor_getParentLinkIndex";
+  case 1431: return "ThreeAxisForceTorqueContactSensor_getLinkSensorTransform";
+  case 1432: return "ThreeAxisForceTorqueContactSensor_isValid";
+  case 1433: return "ThreeAxisForceTorqueContactSensor_clone";
+  case 1434: return "ThreeAxisForceTorqueContactSensor_updateIndices";
+  case 1435: return "ThreeAxisForceTorqueContactSensor_setLoadCellLocations";
+  case 1436: return "ThreeAxisForceTorqueContactSensor_getLoadCellLocations";
+  case 1437: return "ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements";
+  case 1438: return "ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements";
+  case 1439: return "_wrap_predictSensorsMeasurements";
+  case 1440: return "_wrap_predictSensorsMeasurementsFromRawBuffers";
+  case 1441: return "_wrap_dofsListFromURDF";
+  case 1442: return "_wrap_dofsListFromURDFString";
+  case 1443: return "ModelParserOptions_addSensorFramesAsAdditionalFrames_get";
+  case 1444: return "ModelParserOptions_addSensorFramesAsAdditionalFrames_set";
+  case 1445: return "ModelParserOptions_originalFilename_get";
+  case 1446: return "ModelParserOptions_originalFilename_set";
+  case 1447: return "new_ModelParserOptions";
+  case 1448: return "delete_ModelParserOptions";
+  case 1449: return "new_ModelLoader";
+  case 1450: return "delete_ModelLoader";
+  case 1451: return "ModelLoader_parsingOptions";
+  case 1452: return "ModelLoader_setParsingOptions";
+  case 1453: return "ModelLoader_loadModelFromString";
+  case 1454: return "ModelLoader_loadModelFromFile";
+  case 1455: return "ModelLoader_loadReducedModelFromFullModel";
+  case 1456: return "ModelLoader_loadReducedModelFromString";
+  case 1457: return "ModelLoader_loadReducedModelFromFile";
+  case 1458: return "ModelLoader_model";
+  case 1459: return "ModelLoader_sensors";
+  case 1460: return "ModelLoader_isValid";
+  case 1461: return "ModelExporterOptions_baseLink_get";
+  case 1462: return "ModelExporterOptions_baseLink_set";
+  case 1463: return "ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_get";
+  case 1464: return "ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_set";
+  case 1465: return "ModelExporterOptions_robotExportedName_get";
+  case 1466: return "ModelExporterOptions_robotExportedName_set";
+  case 1467: return "new_ModelExporterOptions";
+  case 1468: return "delete_ModelExporterOptions";
+  case 1469: return "new_ModelExporter";
+  case 1470: return "delete_ModelExporter";
+  case 1471: return "ModelExporter_exportingOptions";
+  case 1472: return "ModelExporter_setExportingOptions";
+  case 1473: return "ModelExporter_init";
+  case 1474: return "ModelExporter_model";
+  case 1475: return "ModelExporter_sensors";
+  case 1476: return "ModelExporter_isValid";
+  case 1477: return "ModelExporter_exportModelToString";
+  case 1478: return "ModelExporter_exportModelToFile";
+  case 1479: return "new_ModelCalibrationHelper";
+  case 1480: return "delete_ModelCalibrationHelper";
+  case 1481: return "ModelCalibrationHelper_loadModelFromString";
+  case 1482: return "ModelCalibrationHelper_loadModelFromFile";
+  case 1483: return "ModelCalibrationHelper_updateModelInertialParametersToString";
+  case 1484: return "ModelCalibrationHelper_updateModelInertialParametersToFile";
+  case 1485: return "ModelCalibrationHelper_model";
+  case 1486: return "ModelCalibrationHelper_sensors";
+  case 1487: return "ModelCalibrationHelper_isValid";
+  case 1488: return "new_UnknownWrenchContact";
+  case 1489: return "UnknownWrenchContact_unknownType_get";
+  case 1490: return "UnknownWrenchContact_unknownType_set";
+  case 1491: return "UnknownWrenchContact_contactPoint_get";
+  case 1492: return "UnknownWrenchContact_contactPoint_set";
+  case 1493: return "UnknownWrenchContact_forceDirection_get";
+  case 1494: return "UnknownWrenchContact_forceDirection_set";
+  case 1495: return "UnknownWrenchContact_knownWrench_get";
+  case 1496: return "UnknownWrenchContact_knownWrench_set";
+  case 1497: return "UnknownWrenchContact_contactId_get";
+  case 1498: return "UnknownWrenchContact_contactId_set";
+  case 1499: return "delete_UnknownWrenchContact";
+  case 1500: return "new_LinkUnknownWrenchContacts";
+  case 1501: return "LinkUnknownWrenchContacts_clear";
+  case 1502: return "LinkUnknownWrenchContacts_resize";
+  case 1503: return "LinkUnknownWrenchContacts_getNrOfContactsForLink";
+  case 1504: return "LinkUnknownWrenchContacts_setNrOfContactsForLink";
+  case 1505: return "LinkUnknownWrenchContacts_addNewContactForLink";
+  case 1506: return "LinkUnknownWrenchContacts_addNewContactInFrame";
+  case 1507: return "LinkUnknownWrenchContacts_addNewUnknownFullWrenchInFrameOrigin";
+  case 1508: return "LinkUnknownWrenchContacts_contactWrench";
+  case 1509: return "LinkUnknownWrenchContacts_toString";
+  case 1510: return "delete_LinkUnknownWrenchContacts";
+  case 1511: return "new_estimateExternalWrenchesBuffers";
+  case 1512: return "estimateExternalWrenchesBuffers_resize";
+  case 1513: return "estimateExternalWrenchesBuffers_getNrOfSubModels";
+  case 1514: return "estimateExternalWrenchesBuffers_getNrOfLinks";
+  case 1515: return "estimateExternalWrenchesBuffers_isConsistent";
+  case 1516: return "estimateExternalWrenchesBuffers_A_get";
+  case 1517: return "estimateExternalWrenchesBuffers_A_set";
+  case 1518: return "estimateExternalWrenchesBuffers_x_get";
+  case 1519: return "estimateExternalWrenchesBuffers_x_set";
+  case 1520: return "estimateExternalWrenchesBuffers_b_get";
+  case 1521: return "estimateExternalWrenchesBuffers_b_set";
+  case 1522: return "estimateExternalWrenchesBuffers_b_contacts_subtree_get";
+  case 1523: return "estimateExternalWrenchesBuffers_b_contacts_subtree_set";
+  case 1524: return "estimateExternalWrenchesBuffers_subModelBase_H_link_get";
+  case 1525: return "estimateExternalWrenchesBuffers_subModelBase_H_link_set";
+  case 1526: return "delete_estimateExternalWrenchesBuffers";
+  case 1527: return "_wrap_estimateExternalWrenchesWithoutInternalFT";
+  case 1528: return "_wrap_estimateExternalWrenches";
+  case 1529: return "_wrap_dynamicsEstimationForwardVelAccKinematics";
+  case 1530: return "_wrap_dynamicsEstimationForwardVelKinematics";
+  case 1531: return "_wrap_computeLinkNetWrenchesWithoutGravity";
+  case 1532: return "_wrap_estimateLinkContactWrenchesFromLinkNetExternalWrenches";
+  case 1533: return "new_ExtWrenchesAndJointTorquesEstimator";
+  case 1534: return "delete_ExtWrenchesAndJointTorquesEstimator";
+  case 1535: return "ExtWrenchesAndJointTorquesEstimator_setModelAndSensors";
+  case 1536: return "ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFile";
+  case 1537: return "ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFileWithSpecifiedDOFs";
+  case 1538: return "ExtWrenchesAndJointTorquesEstimator_model";
+  case 1539: return "ExtWrenchesAndJointTorquesEstimator_sensors";
+  case 1540: return "ExtWrenchesAndJointTorquesEstimator_submodels";
+  case 1541: return "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase";
+  case 1542: return "ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase";
+  case 1543: return "ExtWrenchesAndJointTorquesEstimator_computeExpectedFTSensorsMeasurements";
+  case 1544: return "ExtWrenchesAndJointTorquesEstimator_estimateExtWrenchesAndJointTorques";
+  case 1545: return "ExtWrenchesAndJointTorquesEstimator_checkThatTheModelIsStill";
+  case 1546: return "ExtWrenchesAndJointTorquesEstimator_estimateLinkNetWrenchesWithoutGravity";
+  case 1547: return "new_SimpleLeggedOdometry";
+  case 1548: return "delete_SimpleLeggedOdometry";
+  case 1549: return "SimpleLeggedOdometry_setModel";
+  case 1550: return "SimpleLeggedOdometry_model";
+  case 1551: return "SimpleLeggedOdometry_updateKinematics";
+  case 1552: return "SimpleLeggedOdometry_init";
+  case 1553: return "SimpleLeggedOdometry_changeFixedFrame";
+  case 1554: return "SimpleLeggedOdometry_getCurrentFixedLink";
+  case 1555: return "SimpleLeggedOdometry_getWorldLinkTransform";
+  case 1556: return "SimpleLeggedOdometry_getWorldFrameTransform";
+  case 1557: return "_wrap_isLinkBerdyDynamicVariable";
+  case 1558: return "_wrap_isJointBerdyDynamicVariable";
+  case 1559: return "_wrap_isDOFBerdyDynamicVariable";
+  case 1560: return "new_BerdyOptions";
+  case 1561: return "BerdyOptions_berdyVariant_get";
+  case 1562: return "BerdyOptions_berdyVariant_set";
+  case 1563: return "BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_get";
+  case 1564: return "BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_set";
+  case 1565: return "BerdyOptions_includeAllJointAccelerationsAsSensors_get";
+  case 1566: return "BerdyOptions_includeAllJointAccelerationsAsSensors_set";
+  case 1567: return "BerdyOptions_includeAllJointTorquesAsSensors_get";
+  case 1568: return "BerdyOptions_includeAllJointTorquesAsSensors_set";
+  case 1569: return "BerdyOptions_includeAllNetExternalWrenchesAsSensors_get";
+  case 1570: return "BerdyOptions_includeAllNetExternalWrenchesAsSensors_set";
+  case 1571: return "BerdyOptions_includeFixedBaseExternalWrench_get";
+  case 1572: return "BerdyOptions_includeFixedBaseExternalWrench_set";
+  case 1573: return "BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_get";
+  case 1574: return "BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_set";
+  case 1575: return "BerdyOptions_baseLink_get";
+  case 1576: return "BerdyOptions_baseLink_set";
+  case 1577: return "BerdyOptions_checkConsistency";
+  case 1578: return "delete_BerdyOptions";
+  case 1579: return "BerdySensor_type_get";
+  case 1580: return "BerdySensor_type_set";
+  case 1581: return "BerdySensor_id_get";
+  case 1582: return "BerdySensor_id_set";
+  case 1583: return "BerdySensor_range_get";
+  case 1584: return "BerdySensor_range_set";
+  case 1585: return "BerdySensor_eq";
+  case 1586: return "BerdySensor_lt";
+  case 1587: return "new_BerdySensor";
+  case 1588: return "delete_BerdySensor";
+  case 1589: return "BerdyDynamicVariable_type_get";
+  case 1590: return "BerdyDynamicVariable_type_set";
+  case 1591: return "BerdyDynamicVariable_id_get";
+  case 1592: return "BerdyDynamicVariable_id_set";
+  case 1593: return "BerdyDynamicVariable_range_get";
+  case 1594: return "BerdyDynamicVariable_range_set";
+  case 1595: return "BerdyDynamicVariable_eq";
+  case 1596: return "BerdyDynamicVariable_lt";
+  case 1597: return "new_BerdyDynamicVariable";
+  case 1598: return "delete_BerdyDynamicVariable";
+  case 1599: return "new_BerdyHelper";
+  case 1600: return "BerdyHelper_dynamicTraversal";
+  case 1601: return "BerdyHelper_model";
+  case 1602: return "BerdyHelper_sensors";
+  case 1603: return "BerdyHelper_isValid";
+  case 1604: return "BerdyHelper_init";
+  case 1605: return "BerdyHelper_getOptions";
+  case 1606: return "BerdyHelper_getNrOfDynamicVariables";
+  case 1607: return "BerdyHelper_getNrOfDynamicEquations";
+  case 1608: return "BerdyHelper_getNrOfSensorsMeasurements";
+  case 1609: return "BerdyHelper_resizeAndZeroBerdyMatrices";
+  case 1610: return "BerdyHelper_getBerdyMatrices";
+  case 1611: return "BerdyHelper_getSensorsOrdering";
+  case 1612: return "BerdyHelper_getRangeSensorVariable";
+  case 1613: return "BerdyHelper_getRangeDOFSensorVariable";
+  case 1614: return "BerdyHelper_getRangeJointSensorVariable";
+  case 1615: return "BerdyHelper_getRangeLinkSensorVariable";
+  case 1616: return "BerdyHelper_getRangeRCMSensorVariable";
+  case 1617: return "BerdyHelper_getRangeLinkVariable";
+  case 1618: return "BerdyHelper_getRangeJointVariable";
+  case 1619: return "BerdyHelper_getRangeDOFVariable";
+  case 1620: return "BerdyHelper_getDynamicVariablesOrdering";
+  case 1621: return "BerdyHelper_serializeDynamicVariables";
+  case 1622: return "BerdyHelper_serializeSensorVariables";
+  case 1623: return "BerdyHelper_serializeDynamicVariablesComputedFromFixedBaseRNEA";
+  case 1624: return "BerdyHelper_extractJointTorquesFromDynamicVariables";
+  case 1625: return "BerdyHelper_extractLinkNetExternalWrenchesFromDynamicVariables";
+  case 1626: return "BerdyHelper_updateKinematicsFromFloatingBase";
+  case 1627: return "BerdyHelper_updateKinematicsFromFixedBase";
+  case 1628: return "BerdyHelper_updateKinematicsFromTraversalFixedBase";
+  case 1629: return "BerdyHelper_setNetExternalWrenchMeasurementFrame";
+  case 1630: return "BerdyHelper_getNetExternalWrenchMeasurementFrame";
+  case 1631: return "delete_BerdyHelper";
+  case 1632: return "new_BerdySparseMAPSolver";
+  case 1633: return "delete_BerdySparseMAPSolver";
+  case 1634: return "BerdySparseMAPSolver_setDynamicsConstraintsPriorCovariance";
+  case 1635: return "BerdySparseMAPSolver_setDynamicsRegularizationPriorCovariance";
+  case 1636: return "BerdySparseMAPSolver_setDynamicsRegularizationPriorExpectedValue";
+  case 1637: return "BerdySparseMAPSolver_setMeasurementsPriorCovariance";
+  case 1638: return "BerdySparseMAPSolver_dynamicsConstraintsPriorCovarianceInverse";
+  case 1639: return "BerdySparseMAPSolver_dynamicsRegularizationPriorCovarianceInverse";
+  case 1640: return "BerdySparseMAPSolver_dynamicsRegularizationPriorExpectedValue";
+  case 1641: return "BerdySparseMAPSolver_measurementsPriorCovarianceInverse";
+  case 1642: return "BerdySparseMAPSolver_isValid";
+  case 1643: return "BerdySparseMAPSolver_initialize";
+  case 1644: return "BerdySparseMAPSolver_updateEstimateInformationFixedBase";
+  case 1645: return "BerdySparseMAPSolver_updateEstimateInformationFloatingBase";
+  case 1646: return "BerdySparseMAPSolver_doEstimate";
+  case 1647: return "BerdySparseMAPSolver_getLastEstimate";
+  case 1648: return "AttitudeEstimatorState_m_orientation_get";
+  case 1649: return "AttitudeEstimatorState_m_orientation_set";
+  case 1650: return "AttitudeEstimatorState_m_angular_velocity_get";
+  case 1651: return "AttitudeEstimatorState_m_angular_velocity_set";
+  case 1652: return "AttitudeEstimatorState_m_gyroscope_bias_get";
+  case 1653: return "AttitudeEstimatorState_m_gyroscope_bias_set";
+  case 1654: return "new_AttitudeEstimatorState";
+  case 1655: return "delete_AttitudeEstimatorState";
+  case 1656: return "delete_IAttitudeEstimator";
+  case 1657: return "IAttitudeEstimator_updateFilterWithMeasurements";
+  case 1658: return "IAttitudeEstimator_propagateStates";
+  case 1659: return "IAttitudeEstimator_getOrientationEstimateAsRotationMatrix";
+  case 1660: return "IAttitudeEstimator_getOrientationEstimateAsQuaternion";
+  case 1661: return "IAttitudeEstimator_getOrientationEstimateAsRPY";
+  case 1662: return "IAttitudeEstimator_getInternalStateSize";
+  case 1663: return "IAttitudeEstimator_getInternalState";
+  case 1664: return "IAttitudeEstimator_getDefaultInternalInitialState";
+  case 1665: return "IAttitudeEstimator_setInternalState";
+  case 1666: return "IAttitudeEstimator_setInternalStateInitialOrientation";
+  case 1667: return "AttitudeMahonyFilterParameters_time_step_in_seconds_get";
+  case 1668: return "AttitudeMahonyFilterParameters_time_step_in_seconds_set";
+  case 1669: return "AttitudeMahonyFilterParameters_kp_get";
+  case 1670: return "AttitudeMahonyFilterParameters_kp_set";
+  case 1671: return "AttitudeMahonyFilterParameters_ki_get";
+  case 1672: return "AttitudeMahonyFilterParameters_ki_set";
+  case 1673: return "AttitudeMahonyFilterParameters_use_magnetometer_measurements_get";
+  case 1674: return "AttitudeMahonyFilterParameters_use_magnetometer_measurements_set";
+  case 1675: return "AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_get";
+  case 1676: return "AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_set";
+  case 1677: return "new_AttitudeMahonyFilterParameters";
+  case 1678: return "delete_AttitudeMahonyFilterParameters";
+  case 1679: return "new_AttitudeMahonyFilter";
+  case 1680: return "AttitudeMahonyFilter_useMagnetoMeterMeasurements";
+  case 1681: return "AttitudeMahonyFilter_setConfidenceForMagnetometerMeasurements";
+  case 1682: return "AttitudeMahonyFilter_setGainkp";
+  case 1683: return "AttitudeMahonyFilter_setGainki";
+  case 1684: return "AttitudeMahonyFilter_setTimeStepInSeconds";
+  case 1685: return "AttitudeMahonyFilter_setGravityDirection";
+  case 1686: return "AttitudeMahonyFilter_setParameters";
+  case 1687: return "AttitudeMahonyFilter_getParameters";
+  case 1688: return "AttitudeMahonyFilter_updateFilterWithMeasurements";
+  case 1689: return "AttitudeMahonyFilter_propagateStates";
+  case 1690: return "AttitudeMahonyFilter_getOrientationEstimateAsRotationMatrix";
+  case 1691: return "AttitudeMahonyFilter_getOrientationEstimateAsQuaternion";
+  case 1692: return "AttitudeMahonyFilter_getOrientationEstimateAsRPY";
+  case 1693: return "AttitudeMahonyFilter_getInternalStateSize";
+  case 1694: return "AttitudeMahonyFilter_getInternalState";
+  case 1695: return "AttitudeMahonyFilter_getDefaultInternalInitialState";
+  case 1696: return "AttitudeMahonyFilter_setInternalState";
+  case 1697: return "AttitudeMahonyFilter_setInternalStateInitialOrientation";
+  case 1698: return "delete_AttitudeMahonyFilter";
+  case 1699: return "DiscreteExtendedKalmanFilterHelper_ekf_f";
+  case 1700: return "DiscreteExtendedKalmanFilterHelper_ekf_h";
+  case 1701: return "DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianF";
+  case 1702: return "DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianH";
+  case 1703: return "DiscreteExtendedKalmanFilterHelper_ekfPredict";
+  case 1704: return "DiscreteExtendedKalmanFilterHelper_ekfUpdate";
+  case 1705: return "DiscreteExtendedKalmanFilterHelper_ekfInit";
+  case 1706: return "DiscreteExtendedKalmanFilterHelper_ekfReset";
+  case 1707: return "DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementVector";
+  case 1708: return "DiscreteExtendedKalmanFilterHelper_ekfSetInputVector";
+  case 1709: return "DiscreteExtendedKalmanFilterHelper_ekfSetInitialState";
+  case 1710: return "DiscreteExtendedKalmanFilterHelper_ekfSetStateCovariance";
+  case 1711: return "DiscreteExtendedKalmanFilterHelper_ekfSetSystemNoiseCovariance";
+  case 1712: return "DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementNoiseCovariance";
+  case 1713: return "DiscreteExtendedKalmanFilterHelper_ekfSetStateSize";
+  case 1714: return "DiscreteExtendedKalmanFilterHelper_ekfSetInputSize";
+  case 1715: return "DiscreteExtendedKalmanFilterHelper_ekfSetOutputSize";
+  case 1716: return "DiscreteExtendedKalmanFilterHelper_ekfGetStates";
+  case 1717: return "DiscreteExtendedKalmanFilterHelper_ekfGetStateCovariance";
+  case 1718: return "delete_DiscreteExtendedKalmanFilterHelper";
+  case 1719: return "output_dimensions_with_magnetometer_get";
+  case 1720: return "output_dimensions_without_magnetometer_get";
+  case 1721: return "input_dimensions_get";
+  case 1722: return "AttitudeQuaternionEKFParameters_time_step_in_seconds_get";
+  case 1723: return "AttitudeQuaternionEKFParameters_time_step_in_seconds_set";
+  case 1724: return "AttitudeQuaternionEKFParameters_bias_correlation_time_factor_get";
+  case 1725: return "AttitudeQuaternionEKFParameters_bias_correlation_time_factor_set";
+  case 1726: return "AttitudeQuaternionEKFParameters_accelerometer_noise_variance_get";
+  case 1727: return "AttitudeQuaternionEKFParameters_accelerometer_noise_variance_set";
+  case 1728: return "AttitudeQuaternionEKFParameters_magnetometer_noise_variance_get";
+  case 1729: return "AttitudeQuaternionEKFParameters_magnetometer_noise_variance_set";
+  case 1730: return "AttitudeQuaternionEKFParameters_gyroscope_noise_variance_get";
+  case 1731: return "AttitudeQuaternionEKFParameters_gyroscope_noise_variance_set";
+  case 1732: return "AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_get";
+  case 1733: return "AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_set";
+  case 1734: return "AttitudeQuaternionEKFParameters_initial_orientation_error_variance_get";
+  case 1735: return "AttitudeQuaternionEKFParameters_initial_orientation_error_variance_set";
+  case 1736: return "AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_get";
+  case 1737: return "AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_set";
+  case 1738: return "AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_get";
+  case 1739: return "AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_set";
+  case 1740: return "AttitudeQuaternionEKFParameters_use_magnetometer_measurements_get";
+  case 1741: return "AttitudeQuaternionEKFParameters_use_magnetometer_measurements_set";
+  case 1742: return "new_AttitudeQuaternionEKFParameters";
+  case 1743: return "delete_AttitudeQuaternionEKFParameters";
+  case 1744: return "new_AttitudeQuaternionEKF";
+  case 1745: return "AttitudeQuaternionEKF_getParameters";
+  case 1746: return "AttitudeQuaternionEKF_setParameters";
+  case 1747: return "AttitudeQuaternionEKF_setGravityDirection";
+  case 1748: return "AttitudeQuaternionEKF_setTimeStepInSeconds";
+  case 1749: return "AttitudeQuaternionEKF_setBiasCorrelationTimeFactor";
+  case 1750: return "AttitudeQuaternionEKF_useMagnetometerMeasurements";
+  case 1751: return "AttitudeQuaternionEKF_setMeasurementNoiseVariance";
+  case 1752: return "AttitudeQuaternionEKF_setSystemNoiseVariance";
+  case 1753: return "AttitudeQuaternionEKF_setInitialStateCovariance";
+  case 1754: return "AttitudeQuaternionEKF_initializeFilter";
+  case 1755: return "AttitudeQuaternionEKF_updateFilterWithMeasurements";
+  case 1756: return "AttitudeQuaternionEKF_propagateStates";
+  case 1757: return "AttitudeQuaternionEKF_getOrientationEstimateAsRotationMatrix";
+  case 1758: return "AttitudeQuaternionEKF_getOrientationEstimateAsQuaternion";
+  case 1759: return "AttitudeQuaternionEKF_getOrientationEstimateAsRPY";
+  case 1760: return "AttitudeQuaternionEKF_getInternalStateSize";
+  case 1761: return "AttitudeQuaternionEKF_getInternalState";
+  case 1762: return "AttitudeQuaternionEKF_getDefaultInternalInitialState";
+  case 1763: return "AttitudeQuaternionEKF_setInternalState";
+  case 1764: return "AttitudeQuaternionEKF_setInternalStateInitialOrientation";
+  case 1765: return "delete_AttitudeQuaternionEKF";
+  case 1766: return "_wrap_estimateInertialParametersFromLinkBoundingBoxesAndTotalMass";
+  case 1767: return "_wrap_computeBoundingBoxFromShape";
+  case 1768: return "_wrap_computeBoxVertices";
+  case 1769: return "new_KinDynComputations";
+  case 1770: return "delete_KinDynComputations";
+  case 1771: return "KinDynComputations_loadRobotModel";
+  case 1772: return "KinDynComputations_isValid";
+  case 1773: return "KinDynComputations_setFrameVelocityRepresentation";
+  case 1774: return "KinDynComputations_getFrameVelocityRepresentation";
+  case 1775: return "KinDynComputations_getNrOfDegreesOfFreedom";
+  case 1776: return "KinDynComputations_getDescriptionOfDegreeOfFreedom";
+  case 1777: return "KinDynComputations_getDescriptionOfDegreesOfFreedom";
+  case 1778: return "KinDynComputations_getNrOfLinks";
+  case 1779: return "KinDynComputations_getNrOfFrames";
+  case 1780: return "KinDynComputations_getFloatingBase";
+  case 1781: return "KinDynComputations_setFloatingBase";
+  case 1782: return "KinDynComputations_model";
+  case 1783: return "KinDynComputations_getRobotModel";
+  case 1784: return "KinDynComputations_getRelativeJacobianSparsityPattern";
+  case 1785: return "KinDynComputations_getFrameFreeFloatingJacobianSparsityPattern";
+  case 1786: return "KinDynComputations_setJointPos";
+  case 1787: return "KinDynComputations_setRobotState";
+  case 1788: return "KinDynComputations_getRobotState";
+  case 1789: return "KinDynComputations_getWorldBaseTransform";
+  case 1790: return "KinDynComputations_getBaseTwist";
+  case 1791: return "KinDynComputations_getJointPos";
+  case 1792: return "KinDynComputations_getJointVel";
+  case 1793: return "KinDynComputations_getModelVel";
+  case 1794: return "KinDynComputations_getFrameIndex";
+  case 1795: return "KinDynComputations_getFrameName";
+  case 1796: return "KinDynComputations_getWorldTransform";
+  case 1797: return "KinDynComputations_getWorldTransformsAsHomogeneous";
+  case 1798: return "KinDynComputations_getRelativeTransformExplicit";
+  case 1799: return "KinDynComputations_getRelativeTransform";
+  case 1800: return "KinDynComputations_getFrameVel";
+  case 1801: return "KinDynComputations_getFrameAcc";
+  case 1802: return "KinDynComputations_getFrameFreeFloatingJacobian";
+  case 1803: return "KinDynComputations_getRelativeJacobian";
+  case 1804: return "KinDynComputations_getRelativeJacobianExplicit";
+  case 1805: return "KinDynComputations_getFrameBiasAcc";
+  case 1806: return "KinDynComputations_getCenterOfMassPosition";
+  case 1807: return "KinDynComputations_getCenterOfMassVelocity";
+  case 1808: return "KinDynComputations_getCenterOfMassJacobian";
+  case 1809: return "KinDynComputations_getCenterOfMassBiasAcc";
+  case 1810: return "KinDynComputations_getAverageVelocity";
+  case 1811: return "KinDynComputations_getAverageVelocityJacobian";
+  case 1812: return "KinDynComputations_getCentroidalAverageVelocity";
+  case 1813: return "KinDynComputations_getCentroidalAverageVelocityJacobian";
+  case 1814: return "KinDynComputations_getLinearAngularMomentum";
+  case 1815: return "KinDynComputations_getLinearAngularMomentumJacobian";
+  case 1816: return "KinDynComputations_getCentroidalTotalMomentum";
+  case 1817: return "KinDynComputations_getCentroidalTotalMomentumJacobian";
+  case 1818: return "KinDynComputations_getFreeFloatingMassMatrix";
+  case 1819: return "KinDynComputations_inverseDynamics";
+  case 1820: return "KinDynComputations_inverseDynamicsWithInternalJointForceTorques";
+  case 1821: return "KinDynComputations_generalizedBiasForces";
+  case 1822: return "KinDynComputations_generalizedGravityForces";
+  case 1823: return "KinDynComputations_generalizedExternalForces";
+  case 1824: return "KinDynComputations_inverseDynamicsInertialParametersRegressor";
+  case 1825: return "Matrix4x4Vector_pop";
+  case 1826: return "Matrix4x4Vector_brace";
+  case 1827: return "Matrix4x4Vector_setbrace";
+  case 1828: return "Matrix4x4Vector_append";
+  case 1829: return "Matrix4x4Vector_empty";
+  case 1830: return "Matrix4x4Vector_size";
+  case 1831: return "Matrix4x4Vector_swap";
+  case 1832: return "Matrix4x4Vector_begin";
+  case 1833: return "Matrix4x4Vector_end";
+  case 1834: return "Matrix4x4Vector_rbegin";
+  case 1835: return "Matrix4x4Vector_rend";
+  case 1836: return "Matrix4x4Vector_clear";
+  case 1837: return "Matrix4x4Vector_get_allocator";
+  case 1838: return "Matrix4x4Vector_pop_back";
+  case 1839: return "Matrix4x4Vector_erase";
+  case 1840: return "new_Matrix4x4Vector";
+  case 1841: return "Matrix4x4Vector_push_back";
+  case 1842: return "Matrix4x4Vector_front";
+  case 1843: return "Matrix4x4Vector_back";
+  case 1844: return "Matrix4x4Vector_assign";
+  case 1845: return "Matrix4x4Vector_resize";
+  case 1846: return "Matrix4x4Vector_insert";
+  case 1847: return "Matrix4x4Vector_reserve";
+  case 1848: return "Matrix4x4Vector_capacity";
+  case 1849: return "Matrix4x4Vector_toMatlab";
+  case 1850: return "delete_Matrix4x4Vector";
+  case 1851: return "ICameraAnimator_enableMouseControl";
+  case 1852: return "ICameraAnimator_getMoveSpeed";
+  case 1853: return "ICameraAnimator_setMoveSpeed";
+  case 1854: return "ICameraAnimator_getRotateSpeed";
+  case 1855: return "ICameraAnimator_setRotateSpeed";
+  case 1856: return "ICameraAnimator_getZoomSpeed";
+  case 1857: return "ICameraAnimator_setZoomSpeed";
+  case 1858: return "delete_ICameraAnimator";
+  case 1859: return "delete_ICamera";
+  case 1860: return "ICamera_setPosition";
+  case 1861: return "ICamera_setTarget";
+  case 1862: return "ICamera_getPosition";
+  case 1863: return "ICamera_getTarget";
+  case 1864: return "ICamera_setUpVector";
+  case 1865: return "ICamera_animator";
+  case 1866: return "ColorViz_r_get";
+  case 1867: return "ColorViz_r_set";
+  case 1868: return "ColorViz_g_get";
+  case 1869: return "ColorViz_g_set";
+  case 1870: return "ColorViz_b_get";
+  case 1871: return "ColorViz_b_set";
+  case 1872: return "ColorViz_a_get";
+  case 1873: return "ColorViz_a_set";
+  case 1874: return "new_ColorViz";
+  case 1875: return "delete_ColorViz";
+  case 1876: return "PixelViz_width_get";
+  case 1877: return "PixelViz_width_set";
+  case 1878: return "PixelViz_height_get";
+  case 1879: return "PixelViz_height_set";
+  case 1880: return "new_PixelViz";
+  case 1881: return "delete_PixelViz";
+  case 1882: return "delete_ILight";
+  case 1883: return "ILight_getName";
+  case 1884: return "ILight_setType";
+  case 1885: return "ILight_getType";
+  case 1886: return "ILight_setPosition";
+  case 1887: return "ILight_getPosition";
+  case 1888: return "ILight_setDirection";
+  case 1889: return "ILight_getDirection";
+  case 1890: return "ILight_setAmbientColor";
+  case 1891: return "ILight_getAmbientColor";
+  case 1892: return "ILight_setSpecularColor";
+  case 1893: return "ILight_getSpecularColor";
+  case 1894: return "ILight_setDiffuseColor";
+  case 1895: return "ILight_getDiffuseColor";
+  case 1896: return "delete_IEnvironment";
+  case 1897: return "IEnvironment_getElements";
+  case 1898: return "IEnvironment_setElementVisibility";
+  case 1899: return "IEnvironment_setBackgroundColor";
+  case 1900: return "IEnvironment_setFloorGridColor";
+  case 1901: return "IEnvironment_setAmbientLight";
+  case 1902: return "IEnvironment_getLights";
+  case 1903: return "IEnvironment_addLight";
+  case 1904: return "IEnvironment_lightViz";
+  case 1905: return "IEnvironment_removeLight";
+  case 1906: return "delete_IJetsVisualization";
+  case 1907: return "IJetsVisualization_setJetsFrames";
+  case 1908: return "IJetsVisualization_getNrOfJets";
+  case 1909: return "IJetsVisualization_getJetDirection";
+  case 1910: return "IJetsVisualization_setJetDirection";
+  case 1911: return "IJetsVisualization_setJetColor";
+  case 1912: return "IJetsVisualization_setJetsDimensions";
+  case 1913: return "IJetsVisualization_setJetsIntensity";
+  case 1914: return "delete_ILabel";
+  case 1915: return "ILabel_setText";
+  case 1916: return "ILabel_getText";
+  case 1917: return "ILabel_setSize";
+  case 1918: return "ILabel_width";
+  case 1919: return "ILabel_height";
+  case 1920: return "ILabel_setPosition";
+  case 1921: return "ILabel_getPosition";
+  case 1922: return "ILabel_setColor";
+  case 1923: return "ILabel_setVisible";
+  case 1924: return "delete_IVectorsVisualization";
+  case 1925: return "IVectorsVisualization_addVector";
+  case 1926: return "IVectorsVisualization_getNrOfVectors";
+  case 1927: return "IVectorsVisualization_getVector";
+  case 1928: return "IVectorsVisualization_updateVector";
+  case 1929: return "IVectorsVisualization_setVectorColor";
+  case 1930: return "IVectorsVisualization_setVectorsDefaultColor";
+  case 1931: return "IVectorsVisualization_setVectorsColor";
+  case 1932: return "IVectorsVisualization_setVectorsAspect";
+  case 1933: return "IVectorsVisualization_setVisible";
+  case 1934: return "IVectorsVisualization_getVectorLabel";
+  case 1935: return "delete_IFrameVisualization";
+  case 1936: return "IFrameVisualization_addFrame";
+  case 1937: return "IFrameVisualization_setVisible";
+  case 1938: return "IFrameVisualization_getNrOfFrames";
+  case 1939: return "IFrameVisualization_getFrameTransform";
+  case 1940: return "IFrameVisualization_updateFrame";
+  case 1941: return "IFrameVisualization_getFrameLabel";
+  case 1942: return "delete_IModelVisualization";
+  case 1943: return "IModelVisualization_setPositions";
+  case 1944: return "IModelVisualization_setLinkPositions";
+  case 1945: return "IModelVisualization_model";
+  case 1946: return "IModelVisualization_getInstanceName";
+  case 1947: return "IModelVisualization_setModelVisibility";
+  case 1948: return "IModelVisualization_setModelColor";
+  case 1949: return "IModelVisualization_resetModelColor";
+  case 1950: return "IModelVisualization_setLinkColor";
+  case 1951: return "IModelVisualization_resetLinkColor";
+  case 1952: return "IModelVisualization_getLinkNames";
+  case 1953: return "IModelVisualization_setLinkVisibility";
+  case 1954: return "IModelVisualization_getFeatures";
+  case 1955: return "IModelVisualization_setFeatureVisibility";
+  case 1956: return "IModelVisualization_jets";
+  case 1957: return "IModelVisualization_getWorldLinkTransform";
+  case 1958: return "IModelVisualization_getWorldFrameTransform";
+  case 1959: return "IModelVisualization_label";
+  case 1960: return "delete_ITexture";
+  case 1961: return "ITexture_environment";
+  case 1962: return "ITexture_getPixelColor";
+  case 1963: return "ITexture_getPixels";
+  case 1964: return "ITexture_drawToFile";
+  case 1965: return "ITexture_enableDraw";
+  case 1966: return "ITexture_width";
+  case 1967: return "ITexture_height";
+  case 1968: return "ITexture_setSubDrawArea";
+  case 1969: return "VisualizerOptions_verbose_get";
+  case 1970: return "VisualizerOptions_verbose_set";
+  case 1971: return "VisualizerOptions_winWidth_get";
+  case 1972: return "VisualizerOptions_winWidth_set";
+  case 1973: return "VisualizerOptions_winHeight_get";
+  case 1974: return "VisualizerOptions_winHeight_set";
+  case 1975: return "VisualizerOptions_rootFrameArrowsDimension_get";
+  case 1976: return "VisualizerOptions_rootFrameArrowsDimension_set";
+  case 1977: return "new_VisualizerOptions";
+  case 1978: return "delete_VisualizerOptions";
+  case 1979: return "delete_ITexturesHandler";
+  case 1980: return "ITexturesHandler_add";
+  case 1981: return "ITexturesHandler_get";
+  case 1982: return "new_Visualizer";
+  case 1983: return "delete_Visualizer";
+  case 1984: return "Visualizer_init";
+  case 1985: return "Visualizer_getNrOfVisualizedModels";
+  case 1986: return "Visualizer_getModelInstanceName";
+  case 1987: return "Visualizer_getModelInstanceIndex";
+  case 1988: return "Visualizer_addModel";
+  case 1989: return "Visualizer_modelViz";
+  case 1990: return "Visualizer_camera";
+  case 1991: return "Visualizer_enviroment";
+  case 1992: return "Visualizer_environment";
+  case 1993: return "Visualizer_vectors";
+  case 1994: return "Visualizer_frames";
+  case 1995: return "Visualizer_textures";
+  case 1996: return "Visualizer_getLabel";
+  case 1997: return "Visualizer_width";
+  case 1998: return "Visualizer_height";
+  case 1999: return "Visualizer_run";
+  case 2000: return "Visualizer_draw";
+  case 2001: return "Visualizer_subDraw";
+  case 2002: return "Visualizer_drawToFile";
+  case 2003: return "Visualizer_close";
+  case 2004: return "Visualizer_isWindowActive";
+  case 2005: return "Visualizer_setColorPalette";
+  case 2006: return "Polygon_m_vertices_get";
+  case 2007: return "Polygon_m_vertices_set";
+  case 2008: return "new_Polygon";
+  case 2009: return "Polygon_setNrOfVertices";
+  case 2010: return "Polygon_getNrOfVertices";
+  case 2011: return "Polygon_isValid";
+  case 2012: return "Polygon_applyTransform";
+  case 2013: return "Polygon_paren";
+  case 2014: return "Polygon_XYRectangleFromOffsets";
+  case 2015: return "delete_Polygon";
+  case 2016: return "Polygon2D_m_vertices_get";
+  case 2017: return "Polygon2D_m_vertices_set";
+  case 2018: return "new_Polygon2D";
+  case 2019: return "Polygon2D_setNrOfVertices";
+  case 2020: return "Polygon2D_getNrOfVertices";
+  case 2021: return "Polygon2D_isValid";
+  case 2022: return "Polygon2D_paren";
+  case 2023: return "delete_Polygon2D";
+  case 2024: return "ConvexHullProjectionConstraint_setActive";
+  case 2025: return "ConvexHullProjectionConstraint_isActive";
+  case 2026: return "ConvexHullProjectionConstraint_getNrOfConstraints";
+  case 2027: return "ConvexHullProjectionConstraint_projectedConvexHull_get";
+  case 2028: return "ConvexHullProjectionConstraint_projectedConvexHull_set";
+  case 2029: return "ConvexHullProjectionConstraint_A_get";
+  case 2030: return "ConvexHullProjectionConstraint_A_set";
+  case 2031: return "ConvexHullProjectionConstraint_b_get";
+  case 2032: return "ConvexHullProjectionConstraint_b_set";
+  case 2033: return "ConvexHullProjectionConstraint_P_get";
+  case 2034: return "ConvexHullProjectionConstraint_P_set";
+  case 2035: return "ConvexHullProjectionConstraint_Pdirection_get";
+  case 2036: return "ConvexHullProjectionConstraint_Pdirection_set";
+  case 2037: return "ConvexHullProjectionConstraint_AtimesP_get";
+  case 2038: return "ConvexHullProjectionConstraint_AtimesP_set";
+  case 2039: return "ConvexHullProjectionConstraint_o_get";
+  case 2040: return "ConvexHullProjectionConstraint_o_set";
+  case 2041: return "ConvexHullProjectionConstraint_buildConvexHull";
+  case 2042: return "ConvexHullProjectionConstraint_supportFrameIndices_get";
+  case 2043: return "ConvexHullProjectionConstraint_supportFrameIndices_set";
+  case 2044: return "ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_get";
+  case 2045: return "ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_set";
+  case 2046: return "ConvexHullProjectionConstraint_project";
+  case 2047: return "ConvexHullProjectionConstraint_computeMargin";
+  case 2048: return "ConvexHullProjectionConstraint_setProjectionAlongDirection";
+  case 2049: return "ConvexHullProjectionConstraint_projectAlongDirection";
+  case 2050: return "new_ConvexHullProjectionConstraint";
+  case 2051: return "delete_ConvexHullProjectionConstraint";
+  case 2052: return "_wrap_sizeOfRotationParametrization";
+  case 2053: return "new_InverseKinematics";
+  case 2054: return "delete_InverseKinematics";
+  case 2055: return "InverseKinematics_loadModelFromFile";
+  case 2056: return "InverseKinematics_setModel";
+  case 2057: return "InverseKinematics_setJointLimits";
+  case 2058: return "InverseKinematics_getJointLimits";
+  case 2059: return "InverseKinematics_clearProblem";
+  case 2060: return "InverseKinematics_setFloatingBaseOnFrameNamed";
+  case 2061: return "InverseKinematics_setCurrentRobotConfiguration";
+  case 2062: return "InverseKinematics_setJointConfiguration";
+  case 2063: return "InverseKinematics_setRotationParametrization";
+  case 2064: return "InverseKinematics_rotationParametrization";
+  case 2065: return "InverseKinematics_setMaxIterations";
+  case 2066: return "InverseKinematics_maxIterations";
+  case 2067: return "InverseKinematics_setMaxCPUTime";
+  case 2068: return "InverseKinematics_maxCPUTime";
+  case 2069: return "InverseKinematics_setCostTolerance";
+  case 2070: return "InverseKinematics_costTolerance";
+  case 2071: return "InverseKinematics_setConstraintsTolerance";
+  case 2072: return "InverseKinematics_constraintsTolerance";
+  case 2073: return "InverseKinematics_setVerbosity";
+  case 2074: return "InverseKinematics_linearSolverName";
+  case 2075: return "InverseKinematics_setLinearSolverName";
+  case 2076: return "InverseKinematics_addFrameConstraint";
+  case 2077: return "InverseKinematics_addFramePositionConstraint";
+  case 2078: return "InverseKinematics_addFrameRotationConstraint";
+  case 2079: return "InverseKinematics_activateFrameConstraint";
+  case 2080: return "InverseKinematics_deactivateFrameConstraint";
+  case 2081: return "InverseKinematics_isFrameConstraintActive";
+  case 2082: return "InverseKinematics_addCenterOfMassProjectionConstraint";
+  case 2083: return "InverseKinematics_getCenterOfMassProjectionMargin";
+  case 2084: return "InverseKinematics_getCenterOfMassProjectConstraintConvexHull";
+  case 2085: return "InverseKinematics_addTarget";
+  case 2086: return "InverseKinematics_addPositionTarget";
+  case 2087: return "InverseKinematics_addRotationTarget";
+  case 2088: return "InverseKinematics_updateTarget";
+  case 2089: return "InverseKinematics_updatePositionTarget";
+  case 2090: return "InverseKinematics_updateRotationTarget";
+  case 2091: return "InverseKinematics_setDefaultTargetResolutionMode";
+  case 2092: return "InverseKinematics_defaultTargetResolutionMode";
+  case 2093: return "InverseKinematics_setTargetResolutionMode";
+  case 2094: return "InverseKinematics_targetResolutionMode";
+  case 2095: return "InverseKinematics_setDesiredFullJointsConfiguration";
+  case 2096: return "InverseKinematics_setDesiredReducedJointConfiguration";
+  case 2097: return "InverseKinematics_setFullJointsInitialCondition";
+  case 2098: return "InverseKinematics_setReducedInitialCondition";
+  case 2099: return "InverseKinematics_solve";
+  case 2100: return "InverseKinematics_getFullJointsSolution";
+  case 2101: return "InverseKinematics_getReducedSolution";
+  case 2102: return "InverseKinematics_getPoseForFrame";
+  case 2103: return "InverseKinematics_fullModel";
+  case 2104: return "InverseKinematics_reducedModel";
+  case 2105: return "InverseKinematics_setCOMTarget";
+  case 2106: return "InverseKinematics_setCOMAsConstraint";
+  case 2107: return "InverseKinematics_setCOMAsConstraintTolerance";
+  case 2108: return "InverseKinematics_isCOMAConstraint";
+  case 2109: return "InverseKinematics_isCOMTargetActive";
+  case 2110: return "InverseKinematics_deactivateCOMTarget";
+  case 2111: return "InverseKinematics_setCOMConstraintProjectionDirection";
   default: return 0;
   }
 }
 
 SWIGINTERN int swigFunctionName(int resc, mxArray *resv[], int argc, mxArray *argv[]) {
   if (argc!=1 || !mxIsDouble(*argv) || mxGetNumberOfElements(*argv)!=1) {
     SWIG_Error(SWIG_RuntimeError, "This mex file should only be called from inside the .m files generated by SWIG. The input should be the function ID.");
@@ -117397,2137 +112961,2054 @@
   case 64: flag=_wrap_IntVector_back(resc,resv,argc,(mxArray**)(argv)); break;
   case 65: flag=_wrap_IntVector_assign(resc,resv,argc,(mxArray**)(argv)); break;
   case 66: flag=_wrap_IntVector_resize(resc,resv,argc,(mxArray**)(argv)); break;
   case 67: flag=_wrap_IntVector_insert(resc,resv,argc,(mxArray**)(argv)); break;
   case 68: flag=_wrap_IntVector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
   case 69: flag=_wrap_IntVector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
   case 70: flag=_wrap_delete_IntVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 71: flag=_wrap_MatrixDynSizeVector_pop(resc,resv,argc,(mxArray**)(argv)); break;
-  case 72: flag=_wrap_MatrixDynSizeVector_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 73: flag=_wrap_MatrixDynSizeVector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 74: flag=_wrap_MatrixDynSizeVector_append(resc,resv,argc,(mxArray**)(argv)); break;
-  case 75: flag=_wrap_MatrixDynSizeVector_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 76: flag=_wrap_MatrixDynSizeVector_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 77: flag=_wrap_MatrixDynSizeVector_swap(resc,resv,argc,(mxArray**)(argv)); break;
-  case 78: flag=_wrap_MatrixDynSizeVector_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 79: flag=_wrap_MatrixDynSizeVector_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 80: flag=_wrap_MatrixDynSizeVector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 81: flag=_wrap_MatrixDynSizeVector_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 82: flag=_wrap_MatrixDynSizeVector_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 83: flag=_wrap_MatrixDynSizeVector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 84: flag=_wrap_MatrixDynSizeVector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 85: flag=_wrap_MatrixDynSizeVector_erase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 86: flag=_wrap_new_MatrixDynSizeVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 87: flag=_wrap_MatrixDynSizeVector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 88: flag=_wrap_MatrixDynSizeVector_front(resc,resv,argc,(mxArray**)(argv)); break;
-  case 89: flag=_wrap_MatrixDynSizeVector_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 90: flag=_wrap_MatrixDynSizeVector_assign(resc,resv,argc,(mxArray**)(argv)); break;
-  case 91: flag=_wrap_MatrixDynSizeVector_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 92: flag=_wrap_MatrixDynSizeVector_insert(resc,resv,argc,(mxArray**)(argv)); break;
-  case 93: flag=_wrap_MatrixDynSizeVector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 94: flag=_wrap_MatrixDynSizeVector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 95: flag=_wrap_delete_MatrixDynSizeVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 96: flag=_wrap_VectorDynSizeVector_pop(resc,resv,argc,(mxArray**)(argv)); break;
-  case 97: flag=_wrap_VectorDynSizeVector_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 98: flag=_wrap_VectorDynSizeVector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 99: flag=_wrap_VectorDynSizeVector_append(resc,resv,argc,(mxArray**)(argv)); break;
-  case 100: flag=_wrap_VectorDynSizeVector_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 101: flag=_wrap_VectorDynSizeVector_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 102: flag=_wrap_VectorDynSizeVector_swap(resc,resv,argc,(mxArray**)(argv)); break;
-  case 103: flag=_wrap_VectorDynSizeVector_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 104: flag=_wrap_VectorDynSizeVector_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 105: flag=_wrap_VectorDynSizeVector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 106: flag=_wrap_VectorDynSizeVector_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 107: flag=_wrap_VectorDynSizeVector_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 108: flag=_wrap_VectorDynSizeVector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 109: flag=_wrap_VectorDynSizeVector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 110: flag=_wrap_VectorDynSizeVector_erase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 111: flag=_wrap_new_VectorDynSizeVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 112: flag=_wrap_VectorDynSizeVector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 113: flag=_wrap_VectorDynSizeVector_front(resc,resv,argc,(mxArray**)(argv)); break;
-  case 114: flag=_wrap_VectorDynSizeVector_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 115: flag=_wrap_VectorDynSizeVector_assign(resc,resv,argc,(mxArray**)(argv)); break;
-  case 116: flag=_wrap_VectorDynSizeVector_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 117: flag=_wrap_VectorDynSizeVector_insert(resc,resv,argc,(mxArray**)(argv)); break;
-  case 118: flag=_wrap_VectorDynSizeVector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 119: flag=_wrap_VectorDynSizeVector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 120: flag=_wrap_delete_VectorDynSizeVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 121: flag=_wrap_IndexVector_pop(resc,resv,argc,(mxArray**)(argv)); break;
-  case 122: flag=_wrap_IndexVector_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 123: flag=_wrap_IndexVector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 124: flag=_wrap_IndexVector_append(resc,resv,argc,(mxArray**)(argv)); break;
-  case 125: flag=_wrap_IndexVector_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 126: flag=_wrap_IndexVector_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 127: flag=_wrap_IndexVector_swap(resc,resv,argc,(mxArray**)(argv)); break;
-  case 128: flag=_wrap_IndexVector_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 129: flag=_wrap_IndexVector_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 130: flag=_wrap_IndexVector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 131: flag=_wrap_IndexVector_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 132: flag=_wrap_IndexVector_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 133: flag=_wrap_IndexVector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 134: flag=_wrap_IndexVector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 135: flag=_wrap_IndexVector_erase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 136: flag=_wrap_new_IndexVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 137: flag=_wrap_IndexVector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 138: flag=_wrap_IndexVector_front(resc,resv,argc,(mxArray**)(argv)); break;
-  case 139: flag=_wrap_IndexVector_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 140: flag=_wrap_IndexVector_assign(resc,resv,argc,(mxArray**)(argv)); break;
-  case 141: flag=_wrap_IndexVector_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 142: flag=_wrap_IndexVector_insert(resc,resv,argc,(mxArray**)(argv)); break;
-  case 143: flag=_wrap_IndexVector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 144: flag=_wrap_IndexVector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 145: flag=_wrap_delete_IndexVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 146: flag=_wrap_BerdySensors_pop(resc,resv,argc,(mxArray**)(argv)); break;
-  case 147: flag=_wrap_BerdySensors_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 148: flag=_wrap_BerdySensors_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 149: flag=_wrap_BerdySensors_append(resc,resv,argc,(mxArray**)(argv)); break;
-  case 150: flag=_wrap_BerdySensors_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 151: flag=_wrap_BerdySensors_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 152: flag=_wrap_BerdySensors_swap(resc,resv,argc,(mxArray**)(argv)); break;
-  case 153: flag=_wrap_BerdySensors_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 154: flag=_wrap_BerdySensors_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 155: flag=_wrap_BerdySensors_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 156: flag=_wrap_BerdySensors_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 157: flag=_wrap_BerdySensors_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 158: flag=_wrap_BerdySensors_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 159: flag=_wrap_BerdySensors_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 160: flag=_wrap_BerdySensors_erase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 161: flag=_wrap_new_BerdySensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 162: flag=_wrap_BerdySensors_push_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 163: flag=_wrap_BerdySensors_front(resc,resv,argc,(mxArray**)(argv)); break;
-  case 164: flag=_wrap_BerdySensors_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 165: flag=_wrap_BerdySensors_assign(resc,resv,argc,(mxArray**)(argv)); break;
-  case 166: flag=_wrap_BerdySensors_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 167: flag=_wrap_BerdySensors_insert(resc,resv,argc,(mxArray**)(argv)); break;
-  case 168: flag=_wrap_BerdySensors_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 169: flag=_wrap_BerdySensors_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 170: flag=_wrap_delete_BerdySensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 171: flag=_wrap_BerdyDynamicVariables_pop(resc,resv,argc,(mxArray**)(argv)); break;
-  case 172: flag=_wrap_BerdyDynamicVariables_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 173: flag=_wrap_BerdyDynamicVariables_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 174: flag=_wrap_BerdyDynamicVariables_append(resc,resv,argc,(mxArray**)(argv)); break;
-  case 175: flag=_wrap_BerdyDynamicVariables_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 176: flag=_wrap_BerdyDynamicVariables_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 177: flag=_wrap_BerdyDynamicVariables_swap(resc,resv,argc,(mxArray**)(argv)); break;
-  case 178: flag=_wrap_BerdyDynamicVariables_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 179: flag=_wrap_BerdyDynamicVariables_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 180: flag=_wrap_BerdyDynamicVariables_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 181: flag=_wrap_BerdyDynamicVariables_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 182: flag=_wrap_BerdyDynamicVariables_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 183: flag=_wrap_BerdyDynamicVariables_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 184: flag=_wrap_BerdyDynamicVariables_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 185: flag=_wrap_BerdyDynamicVariables_erase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 186: flag=_wrap_new_BerdyDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
-  case 187: flag=_wrap_BerdyDynamicVariables_push_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 188: flag=_wrap_BerdyDynamicVariables_front(resc,resv,argc,(mxArray**)(argv)); break;
-  case 189: flag=_wrap_BerdyDynamicVariables_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 190: flag=_wrap_BerdyDynamicVariables_assign(resc,resv,argc,(mxArray**)(argv)); break;
-  case 191: flag=_wrap_BerdyDynamicVariables_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 192: flag=_wrap_BerdyDynamicVariables_insert(resc,resv,argc,(mxArray**)(argv)); break;
-  case 193: flag=_wrap_BerdyDynamicVariables_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 194: flag=_wrap_BerdyDynamicVariables_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 195: flag=_wrap_delete_BerdyDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
-  case 196: flag=_wrap_reportInfo(resc,resv,argc,(mxArray**)(argv)); break;
-  case 197: flag=_wrap_reportDebug(resc,resv,argc,(mxArray**)(argv)); break;
-  case 198: flag=_wrap_IndexRange_offset_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 199: flag=_wrap_IndexRange_offset_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 200: flag=_wrap_IndexRange_size_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 201: flag=_wrap_IndexRange_size_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 202: flag=_wrap_IndexRange_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 203: flag=_wrap_IndexRange_InvalidRange(resc,resv,argc,(mxArray**)(argv)); break;
-  case 204: flag=_wrap_new_IndexRange(resc,resv,argc,(mxArray**)(argv)); break;
-  case 205: flag=_wrap_delete_IndexRange(resc,resv,argc,(mxArray**)(argv)); break;
-  case 206: flag=_wrap_checkDoublesAreEqual(resc,resv,argc,(mxArray**)(argv)); break;
-  case 207: flag=_wrap_new_MatrixDynSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 208: flag=_wrap_delete_MatrixDynSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 209: flag=_wrap_MatrixDynSize_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 210: flag=_wrap_MatrixDynSize_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 211: flag=_wrap_MatrixDynSize_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 212: flag=_wrap_MatrixDynSize_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 213: flag=_wrap_MatrixDynSize_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 214: flag=_wrap_MatrixDynSize_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 215: flag=_wrap_MatrixDynSize_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 216: flag=_wrap_MatrixDynSize_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 217: flag=_wrap_MatrixDynSize_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 218: flag=_wrap_MatrixDynSize_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 219: flag=_wrap_MatrixDynSize_shrink_to_fit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 220: flag=_wrap_MatrixDynSize_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 221: flag=_wrap_MatrixDynSize_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 222: flag=_wrap_MatrixDynSize_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 223: flag=_wrap_MatrixDynSize_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 224: flag=_wrap_MatrixDynSize_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 225: flag=_wrap_MatrixDynSize_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 226: flag=_wrap_new_SparseMatrixRowMajor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 227: flag=_wrap_delete_SparseMatrixRowMajor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 228: flag=_wrap_SparseMatrixRowMajor_numberOfNonZeros(resc,resv,argc,(mxArray**)(argv)); break;
-  case 229: flag=_wrap_SparseMatrixRowMajor_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 230: flag=_wrap_SparseMatrixRowMajor_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 231: flag=_wrap_SparseMatrixRowMajor_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 232: flag=_wrap_SparseMatrixRowMajor_setFromConstTriplets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 233: flag=_wrap_SparseMatrixRowMajor_setFromTriplets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 234: flag=_wrap_SparseMatrixRowMajor_sparseMatrixFromTriplets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 235: flag=_wrap_SparseMatrixRowMajor_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 236: flag=_wrap_SparseMatrixRowMajor_getValue(resc,resv,argc,(mxArray**)(argv)); break;
-  case 237: flag=_wrap_SparseMatrixRowMajor_setValue(resc,resv,argc,(mxArray**)(argv)); break;
-  case 238: flag=_wrap_SparseMatrixRowMajor_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 239: flag=_wrap_SparseMatrixRowMajor_columns(resc,resv,argc,(mxArray**)(argv)); break;
-  case 240: flag=_wrap_SparseMatrixRowMajor_description(resc,resv,argc,(mxArray**)(argv)); break;
-  case 241: flag=_wrap_SparseMatrixRowMajor_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 242: flag=_wrap_SparseMatrixRowMajor_toMatlabDense(resc,resv,argc,(mxArray**)(argv)); break;
-  case 243: flag=_wrap_SparseMatrixRowMajor_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 244: flag=_wrap_new_SparseMatrixColMajor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 245: flag=_wrap_delete_SparseMatrixColMajor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 246: flag=_wrap_SparseMatrixColMajor_numberOfNonZeros(resc,resv,argc,(mxArray**)(argv)); break;
-  case 247: flag=_wrap_SparseMatrixColMajor_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 248: flag=_wrap_SparseMatrixColMajor_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 249: flag=_wrap_SparseMatrixColMajor_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 250: flag=_wrap_SparseMatrixColMajor_setFromConstTriplets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 251: flag=_wrap_SparseMatrixColMajor_setFromTriplets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 252: flag=_wrap_SparseMatrixColMajor_sparseMatrixFromTriplets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 253: flag=_wrap_SparseMatrixColMajor_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 254: flag=_wrap_SparseMatrixColMajor_getValue(resc,resv,argc,(mxArray**)(argv)); break;
-  case 255: flag=_wrap_SparseMatrixColMajor_setValue(resc,resv,argc,(mxArray**)(argv)); break;
-  case 256: flag=_wrap_SparseMatrixColMajor_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 257: flag=_wrap_SparseMatrixColMajor_columns(resc,resv,argc,(mxArray**)(argv)); break;
-  case 258: flag=_wrap_SparseMatrixColMajor_description(resc,resv,argc,(mxArray**)(argv)); break;
-  case 259: flag=_wrap_SparseMatrixColMajor_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 260: flag=_wrap_SparseMatrixColMajor_toMatlabDense(resc,resv,argc,(mxArray**)(argv)); break;
-  case 261: flag=_wrap_SparseMatrixColMajor_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 262: flag=_wrap_new_VectorDynSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 263: flag=_wrap_delete_VectorDynSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 264: flag=_wrap_VectorDynSize_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 265: flag=_wrap_VectorDynSize_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 266: flag=_wrap_VectorDynSize_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 267: flag=_wrap_VectorDynSize_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 268: flag=_wrap_VectorDynSize_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 269: flag=_wrap_VectorDynSize_cend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 270: flag=_wrap_VectorDynSize_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 271: flag=_wrap_VectorDynSize_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 272: flag=_wrap_VectorDynSize_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 273: flag=_wrap_VectorDynSize_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 274: flag=_wrap_VectorDynSize_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 275: flag=_wrap_VectorDynSize_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 276: flag=_wrap_VectorDynSize_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 277: flag=_wrap_VectorDynSize_shrink_to_fit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 278: flag=_wrap_VectorDynSize_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 279: flag=_wrap_VectorDynSize_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 280: flag=_wrap_VectorDynSize_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 281: flag=_wrap_VectorDynSize_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 282: flag=_wrap_VectorDynSize_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 283: flag=_wrap_VectorDynSize_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 284: flag=_wrap_new_Matrix1x6(resc,resv,argc,(mxArray**)(argv)); break;
-  case 285: flag=_wrap_Matrix1x6_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 286: flag=_wrap_Matrix1x6_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 287: flag=_wrap_Matrix1x6_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 288: flag=_wrap_Matrix1x6_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 289: flag=_wrap_Matrix1x6_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 290: flag=_wrap_Matrix1x6_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 291: flag=_wrap_Matrix1x6_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 292: flag=_wrap_Matrix1x6_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 293: flag=_wrap_Matrix1x6_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 294: flag=_wrap_Matrix1x6_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 295: flag=_wrap_Matrix1x6_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 296: flag=_wrap_Matrix1x6_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 297: flag=_wrap_Matrix1x6_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 298: flag=_wrap_delete_Matrix1x6(resc,resv,argc,(mxArray**)(argv)); break;
-  case 299: flag=_wrap_new_Matrix2x3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 300: flag=_wrap_Matrix2x3_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 301: flag=_wrap_Matrix2x3_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 302: flag=_wrap_Matrix2x3_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 303: flag=_wrap_Matrix2x3_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 304: flag=_wrap_Matrix2x3_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 305: flag=_wrap_Matrix2x3_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 306: flag=_wrap_Matrix2x3_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 307: flag=_wrap_Matrix2x3_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 308: flag=_wrap_Matrix2x3_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 309: flag=_wrap_Matrix2x3_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 310: flag=_wrap_Matrix2x3_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 311: flag=_wrap_Matrix2x3_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 312: flag=_wrap_Matrix2x3_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 313: flag=_wrap_delete_Matrix2x3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 314: flag=_wrap_new_Matrix3x3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 315: flag=_wrap_Matrix3x3_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 316: flag=_wrap_Matrix3x3_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 317: flag=_wrap_Matrix3x3_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 318: flag=_wrap_Matrix3x3_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 319: flag=_wrap_Matrix3x3_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 320: flag=_wrap_Matrix3x3_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 321: flag=_wrap_Matrix3x3_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 322: flag=_wrap_Matrix3x3_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 323: flag=_wrap_Matrix3x3_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 324: flag=_wrap_Matrix3x3_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 325: flag=_wrap_Matrix3x3_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 326: flag=_wrap_Matrix3x3_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 327: flag=_wrap_Matrix3x3_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 328: flag=_wrap_delete_Matrix3x3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 329: flag=_wrap_new_Matrix4x4(resc,resv,argc,(mxArray**)(argv)); break;
-  case 330: flag=_wrap_Matrix4x4_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 331: flag=_wrap_Matrix4x4_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 332: flag=_wrap_Matrix4x4_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 333: flag=_wrap_Matrix4x4_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 334: flag=_wrap_Matrix4x4_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 335: flag=_wrap_Matrix4x4_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 336: flag=_wrap_Matrix4x4_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 337: flag=_wrap_Matrix4x4_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 338: flag=_wrap_Matrix4x4_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 339: flag=_wrap_Matrix4x4_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 340: flag=_wrap_Matrix4x4_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 341: flag=_wrap_Matrix4x4_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 342: flag=_wrap_Matrix4x4_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 343: flag=_wrap_delete_Matrix4x4(resc,resv,argc,(mxArray**)(argv)); break;
-  case 344: flag=_wrap_new_Matrix6x6(resc,resv,argc,(mxArray**)(argv)); break;
-  case 345: flag=_wrap_Matrix6x6_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 346: flag=_wrap_Matrix6x6_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 347: flag=_wrap_Matrix6x6_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 348: flag=_wrap_Matrix6x6_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 349: flag=_wrap_Matrix6x6_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 350: flag=_wrap_Matrix6x6_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 351: flag=_wrap_Matrix6x6_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 352: flag=_wrap_Matrix6x6_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 353: flag=_wrap_Matrix6x6_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 354: flag=_wrap_Matrix6x6_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 355: flag=_wrap_Matrix6x6_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 356: flag=_wrap_Matrix6x6_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 357: flag=_wrap_Matrix6x6_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 358: flag=_wrap_delete_Matrix6x6(resc,resv,argc,(mxArray**)(argv)); break;
-  case 359: flag=_wrap_new_Matrix6x10(resc,resv,argc,(mxArray**)(argv)); break;
-  case 360: flag=_wrap_Matrix6x10_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 361: flag=_wrap_Matrix6x10_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 362: flag=_wrap_Matrix6x10_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 363: flag=_wrap_Matrix6x10_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 364: flag=_wrap_Matrix6x10_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 365: flag=_wrap_Matrix6x10_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 366: flag=_wrap_Matrix6x10_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 367: flag=_wrap_Matrix6x10_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 368: flag=_wrap_Matrix6x10_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 369: flag=_wrap_Matrix6x10_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 370: flag=_wrap_Matrix6x10_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 371: flag=_wrap_Matrix6x10_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 372: flag=_wrap_Matrix6x10_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 373: flag=_wrap_delete_Matrix6x10(resc,resv,argc,(mxArray**)(argv)); break;
-  case 374: flag=_wrap_new_Matrix10x16(resc,resv,argc,(mxArray**)(argv)); break;
-  case 375: flag=_wrap_Matrix10x16_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 376: flag=_wrap_Matrix10x16_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 377: flag=_wrap_Matrix10x16_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 378: flag=_wrap_Matrix10x16_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 379: flag=_wrap_Matrix10x16_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 380: flag=_wrap_Matrix10x16_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 381: flag=_wrap_Matrix10x16_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 382: flag=_wrap_Matrix10x16_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 383: flag=_wrap_Matrix10x16_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 384: flag=_wrap_Matrix10x16_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 385: flag=_wrap_Matrix10x16_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 386: flag=_wrap_Matrix10x16_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 387: flag=_wrap_Matrix10x16_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 388: flag=_wrap_delete_Matrix10x16(resc,resv,argc,(mxArray**)(argv)); break;
-  case 389: flag=_wrap_new_Vector3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 390: flag=_wrap_Vector3_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 391: flag=_wrap_Vector3_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 392: flag=_wrap_Vector3_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 393: flag=_wrap_Vector3_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 394: flag=_wrap_Vector3_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 395: flag=_wrap_Vector3_cend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 396: flag=_wrap_Vector3_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 397: flag=_wrap_Vector3_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 398: flag=_wrap_Vector3_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 399: flag=_wrap_Vector3_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 400: flag=_wrap_Vector3_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 401: flag=_wrap_Vector3_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 402: flag=_wrap_Vector3_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 403: flag=_wrap_Vector3_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 404: flag=_wrap_Vector3_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 405: flag=_wrap_Vector3_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 406: flag=_wrap_delete_Vector3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 407: flag=_wrap_new_Vector4(resc,resv,argc,(mxArray**)(argv)); break;
-  case 408: flag=_wrap_Vector4_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 409: flag=_wrap_Vector4_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 410: flag=_wrap_Vector4_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 411: flag=_wrap_Vector4_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 412: flag=_wrap_Vector4_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 413: flag=_wrap_Vector4_cend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 414: flag=_wrap_Vector4_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 415: flag=_wrap_Vector4_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 416: flag=_wrap_Vector4_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 417: flag=_wrap_Vector4_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 418: flag=_wrap_Vector4_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 419: flag=_wrap_Vector4_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 420: flag=_wrap_Vector4_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 421: flag=_wrap_Vector4_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 422: flag=_wrap_Vector4_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 423: flag=_wrap_Vector4_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 424: flag=_wrap_delete_Vector4(resc,resv,argc,(mxArray**)(argv)); break;
-  case 425: flag=_wrap_new_Vector6(resc,resv,argc,(mxArray**)(argv)); break;
-  case 426: flag=_wrap_Vector6_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 427: flag=_wrap_Vector6_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 428: flag=_wrap_Vector6_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 429: flag=_wrap_Vector6_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 430: flag=_wrap_Vector6_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 431: flag=_wrap_Vector6_cend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 432: flag=_wrap_Vector6_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 433: flag=_wrap_Vector6_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 434: flag=_wrap_Vector6_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 435: flag=_wrap_Vector6_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 436: flag=_wrap_Vector6_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 437: flag=_wrap_Vector6_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 438: flag=_wrap_Vector6_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 439: flag=_wrap_Vector6_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 440: flag=_wrap_Vector6_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 441: flag=_wrap_Vector6_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 442: flag=_wrap_delete_Vector6(resc,resv,argc,(mxArray**)(argv)); break;
-  case 443: flag=_wrap_new_Vector10(resc,resv,argc,(mxArray**)(argv)); break;
-  case 444: flag=_wrap_Vector10_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 445: flag=_wrap_Vector10_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 446: flag=_wrap_Vector10_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 447: flag=_wrap_Vector10_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 448: flag=_wrap_Vector10_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 449: flag=_wrap_Vector10_cend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 450: flag=_wrap_Vector10_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 451: flag=_wrap_Vector10_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 452: flag=_wrap_Vector10_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 453: flag=_wrap_Vector10_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 454: flag=_wrap_Vector10_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 455: flag=_wrap_Vector10_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 456: flag=_wrap_Vector10_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 457: flag=_wrap_Vector10_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 458: flag=_wrap_Vector10_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 459: flag=_wrap_Vector10_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 460: flag=_wrap_delete_Vector10(resc,resv,argc,(mxArray**)(argv)); break;
-  case 461: flag=_wrap_new_Vector16(resc,resv,argc,(mxArray**)(argv)); break;
-  case 462: flag=_wrap_Vector16_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 463: flag=_wrap_Vector16_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 464: flag=_wrap_Vector16_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 465: flag=_wrap_Vector16_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 466: flag=_wrap_Vector16_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 467: flag=_wrap_Vector16_cend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 468: flag=_wrap_Vector16_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 469: flag=_wrap_Vector16_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 470: flag=_wrap_Vector16_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 471: flag=_wrap_Vector16_data(resc,resv,argc,(mxArray**)(argv)); break;
-  case 472: flag=_wrap_Vector16_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 473: flag=_wrap_Vector16_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 474: flag=_wrap_Vector16_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 475: flag=_wrap_Vector16_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 476: flag=_wrap_Vector16_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 477: flag=_wrap_Vector16_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 478: flag=_wrap_delete_Vector16(resc,resv,argc,(mxArray**)(argv)); break;
-  case 479: flag=_wrap_new_Position(resc,resv,argc,(mxArray**)(argv)); break;
-  case 480: flag=_wrap_Position_changePoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 481: flag=_wrap_Position_changeRefPoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 482: flag=_wrap_Position_changeCoordinateFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 483: flag=_wrap_Position_compose(resc,resv,argc,(mxArray**)(argv)); break;
-  case 484: flag=_wrap_Position_inverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 485: flag=_wrap_Position_changePointOf(resc,resv,argc,(mxArray**)(argv)); break;
-  case 486: flag=_wrap_Position_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 487: flag=_wrap_Position_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 488: flag=_wrap_Position_uminus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 489: flag=_wrap_Position_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 490: flag=_wrap_Position_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 491: flag=_wrap_Position_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 492: flag=_wrap_Position_Zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 493: flag=_wrap_delete_Position(resc,resv,argc,(mxArray**)(argv)); break;
-  case 494: flag=_wrap_new_GeomVector3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 495: flag=_wrap_GeomVector3_changeCoordFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 496: flag=_wrap_GeomVector3_compose(resc,resv,argc,(mxArray**)(argv)); break;
-  case 497: flag=_wrap_GeomVector3_inverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 498: flag=_wrap_GeomVector3_dot(resc,resv,argc,(mxArray**)(argv)); break;
-  case 499: flag=_wrap_GeomVector3_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 500: flag=_wrap_GeomVector3_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 501: flag=_wrap_GeomVector3_uminus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 502: flag=_wrap_GeomVector3_exp(resc,resv,argc,(mxArray**)(argv)); break;
-  case 503: flag=_wrap_GeomVector3_cross(resc,resv,argc,(mxArray**)(argv)); break;
-  case 504: flag=_wrap_delete_GeomVector3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 505: flag=_wrap_new_SpatialMotionVectorBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 506: flag=_wrap_SpatialMotionVectorBase_getLinearVec3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 507: flag=_wrap_SpatialMotionVectorBase_getAngularVec3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 508: flag=_wrap_SpatialMotionVectorBase_setLinearVec3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 509: flag=_wrap_SpatialMotionVectorBase_setAngularVec3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 510: flag=_wrap_SpatialMotionVectorBase_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 511: flag=_wrap_SpatialMotionVectorBase_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 512: flag=_wrap_SpatialMotionVectorBase_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 513: flag=_wrap_SpatialMotionVectorBase_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 514: flag=_wrap_SpatialMotionVectorBase_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 515: flag=_wrap_SpatialMotionVectorBase_changePoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 516: flag=_wrap_SpatialMotionVectorBase_changeCoordFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 517: flag=_wrap_SpatialMotionVectorBase_compose(resc,resv,argc,(mxArray**)(argv)); break;
-  case 518: flag=_wrap_SpatialMotionVectorBase_inverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 519: flag=_wrap_SpatialMotionVectorBase_dot(resc,resv,argc,(mxArray**)(argv)); break;
-  case 520: flag=_wrap_SpatialMotionVectorBase_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 521: flag=_wrap_SpatialMotionVectorBase_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 522: flag=_wrap_SpatialMotionVectorBase_uminus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 523: flag=_wrap_SpatialMotionVectorBase_Zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 524: flag=_wrap_SpatialMotionVectorBase_asVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 525: flag=_wrap_SpatialMotionVectorBase_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 526: flag=_wrap_SpatialMotionVectorBase_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 527: flag=_wrap_SpatialMotionVectorBase_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 528: flag=_wrap_SpatialMotionVectorBase_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 529: flag=_wrap_delete_SpatialMotionVectorBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 530: flag=_wrap_new_SpatialForceVectorBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 531: flag=_wrap_SpatialForceVectorBase_getLinearVec3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 532: flag=_wrap_SpatialForceVectorBase_getAngularVec3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 533: flag=_wrap_SpatialForceVectorBase_setLinearVec3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 534: flag=_wrap_SpatialForceVectorBase_setAngularVec3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 535: flag=_wrap_SpatialForceVectorBase_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 536: flag=_wrap_SpatialForceVectorBase_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 537: flag=_wrap_SpatialForceVectorBase_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 538: flag=_wrap_SpatialForceVectorBase_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 539: flag=_wrap_SpatialForceVectorBase_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 540: flag=_wrap_SpatialForceVectorBase_changePoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 541: flag=_wrap_SpatialForceVectorBase_changeCoordFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 542: flag=_wrap_SpatialForceVectorBase_compose(resc,resv,argc,(mxArray**)(argv)); break;
-  case 543: flag=_wrap_SpatialForceVectorBase_inverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 544: flag=_wrap_SpatialForceVectorBase_dot(resc,resv,argc,(mxArray**)(argv)); break;
-  case 545: flag=_wrap_SpatialForceVectorBase_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 546: flag=_wrap_SpatialForceVectorBase_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 547: flag=_wrap_SpatialForceVectorBase_uminus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 548: flag=_wrap_SpatialForceVectorBase_Zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 549: flag=_wrap_SpatialForceVectorBase_asVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 550: flag=_wrap_SpatialForceVectorBase_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 551: flag=_wrap_SpatialForceVectorBase_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 552: flag=_wrap_SpatialForceVectorBase_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 553: flag=_wrap_SpatialForceVectorBase_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 554: flag=_wrap_delete_SpatialForceVectorBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 555: flag=_wrap_new_Dummy(resc,resv,argc,(mxArray**)(argv)); break;
-  case 556: flag=_wrap_delete_Dummy(resc,resv,argc,(mxArray**)(argv)); break;
-  case 557: flag=_wrap_new_SpatialMotionVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 558: flag=_wrap_SpatialMotionVector_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 559: flag=_wrap_SpatialMotionVector_cross(resc,resv,argc,(mxArray**)(argv)); break;
-  case 560: flag=_wrap_SpatialMotionVector_asCrossProductMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 561: flag=_wrap_SpatialMotionVector_asCrossProductMatrixWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 562: flag=_wrap_SpatialMotionVector_exp(resc,resv,argc,(mxArray**)(argv)); break;
-  case 563: flag=_wrap_delete_SpatialMotionVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 564: flag=_wrap_new_SpatialForceVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 565: flag=_wrap_delete_SpatialForceVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 566: flag=_wrap_SpatialForceVector_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 567: flag=_wrap_new_Twist(resc,resv,argc,(mxArray**)(argv)); break;
-  case 568: flag=_wrap_Twist_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 569: flag=_wrap_Twist_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 570: flag=_wrap_Twist_uminus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 571: flag=_wrap_Twist_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 572: flag=_wrap_delete_Twist(resc,resv,argc,(mxArray**)(argv)); break;
-  case 573: flag=_wrap_new_Wrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 574: flag=_wrap_Wrench_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 575: flag=_wrap_Wrench_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 576: flag=_wrap_Wrench_uminus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 577: flag=_wrap_delete_Wrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 578: flag=_wrap_new_SpatialMomentum(resc,resv,argc,(mxArray**)(argv)); break;
-  case 579: flag=_wrap_SpatialMomentum_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 580: flag=_wrap_SpatialMomentum_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 581: flag=_wrap_SpatialMomentum_uminus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 582: flag=_wrap_delete_SpatialMomentum(resc,resv,argc,(mxArray**)(argv)); break;
-  case 583: flag=_wrap_new_SpatialAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 584: flag=_wrap_SpatialAcc_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 585: flag=_wrap_SpatialAcc_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 586: flag=_wrap_SpatialAcc_uminus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 587: flag=_wrap_delete_SpatialAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 588: flag=_wrap_new_ClassicalAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 589: flag=_wrap_ClassicalAcc_changeCoordFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 590: flag=_wrap_ClassicalAcc_Zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 591: flag=_wrap_ClassicalAcc_fromSpatial(resc,resv,argc,(mxArray**)(argv)); break;
-  case 592: flag=_wrap_ClassicalAcc_toSpatial(resc,resv,argc,(mxArray**)(argv)); break;
-  case 593: flag=_wrap_delete_ClassicalAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 594: flag=_wrap_new_Direction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 595: flag=_wrap_Direction_Normalize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 596: flag=_wrap_Direction_isParallel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 597: flag=_wrap_Direction_isPerpendicular(resc,resv,argc,(mxArray**)(argv)); break;
-  case 598: flag=_wrap_Direction_reverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 599: flag=_wrap_Direction_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 600: flag=_wrap_Direction_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 601: flag=_wrap_Direction_Default(resc,resv,argc,(mxArray**)(argv)); break;
-  case 602: flag=_wrap_delete_Direction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 603: flag=_wrap_new_Axis(resc,resv,argc,(mxArray**)(argv)); break;
-  case 604: flag=_wrap_Axis_getDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 605: flag=_wrap_Axis_getOrigin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 606: flag=_wrap_Axis_setDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 607: flag=_wrap_Axis_setOrigin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 608: flag=_wrap_Axis_getRotationTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 609: flag=_wrap_Axis_getRotationTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 610: flag=_wrap_Axis_getRotationTwist(resc,resv,argc,(mxArray**)(argv)); break;
-  case 611: flag=_wrap_Axis_getRotationSpatialAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 612: flag=_wrap_Axis_getTranslationTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 613: flag=_wrap_Axis_getTranslationTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 614: flag=_wrap_Axis_getTranslationTwist(resc,resv,argc,(mxArray**)(argv)); break;
-  case 615: flag=_wrap_Axis_getTranslationSpatialAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 616: flag=_wrap_Axis_isParallel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 617: flag=_wrap_Axis_reverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 618: flag=_wrap_Axis_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 619: flag=_wrap_Axis_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 620: flag=_wrap_delete_Axis(resc,resv,argc,(mxArray**)(argv)); break;
-  case 621: flag=_wrap_new_RotationalInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 622: flag=_wrap_RotationalInertia_Zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 623: flag=_wrap_delete_RotationalInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 624: flag=_wrap_new_SpatialInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 625: flag=_wrap_SpatialInertia_combine(resc,resv,argc,(mxArray**)(argv)); break;
-  case 626: flag=_wrap_SpatialInertia_fromRotationalInertiaWrtCenterOfMass(resc,resv,argc,(mxArray**)(argv)); break;
-  case 627: flag=_wrap_SpatialInertia_getMass(resc,resv,argc,(mxArray**)(argv)); break;
-  case 628: flag=_wrap_SpatialInertia_getCenterOfMass(resc,resv,argc,(mxArray**)(argv)); break;
-  case 629: flag=_wrap_SpatialInertia_getRotationalInertiaWrtFrameOrigin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 630: flag=_wrap_SpatialInertia_getRotationalInertiaWrtCenterOfMass(resc,resv,argc,(mxArray**)(argv)); break;
-  case 631: flag=_wrap_SpatialInertia_multiply(resc,resv,argc,(mxArray**)(argv)); break;
-  case 632: flag=_wrap_SpatialInertia_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 633: flag=_wrap_SpatialInertia_asMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 634: flag=_wrap_SpatialInertia_applyInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 635: flag=_wrap_SpatialInertia_getInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 636: flag=_wrap_SpatialInertia_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 637: flag=_wrap_SpatialInertia_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 638: flag=_wrap_SpatialInertia_biasWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 639: flag=_wrap_SpatialInertia_biasWrenchDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 640: flag=_wrap_SpatialInertia_Zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 641: flag=_wrap_SpatialInertia_asVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 642: flag=_wrap_SpatialInertia_fromVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 643: flag=_wrap_SpatialInertia_isPhysicallyConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 644: flag=_wrap_SpatialInertia_momentumRegressor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 645: flag=_wrap_SpatialInertia_momentumDerivativeRegressor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 646: flag=_wrap_SpatialInertia_momentumDerivativeSlotineLiRegressor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 647: flag=_wrap_delete_SpatialInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 648: flag=_wrap_new_ArticulatedBodyInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 649: flag=_wrap_ArticulatedBodyInertia_getLinearLinearSubmatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 650: flag=_wrap_ArticulatedBodyInertia_getLinearAngularSubmatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 651: flag=_wrap_ArticulatedBodyInertia_getAngularAngularSubmatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 652: flag=_wrap_ArticulatedBodyInertia_combine(resc,resv,argc,(mxArray**)(argv)); break;
-  case 653: flag=_wrap_ArticulatedBodyInertia_applyInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 654: flag=_wrap_ArticulatedBodyInertia_asMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 655: flag=_wrap_ArticulatedBodyInertia_getInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 656: flag=_wrap_ArticulatedBodyInertia_plus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 657: flag=_wrap_ArticulatedBodyInertia_minus(resc,resv,argc,(mxArray**)(argv)); break;
-  case 658: flag=_wrap_ArticulatedBodyInertia_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 659: flag=_wrap_ArticulatedBodyInertia_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 660: flag=_wrap_ArticulatedBodyInertia_ABADyadHelper(resc,resv,argc,(mxArray**)(argv)); break;
-  case 661: flag=_wrap_ArticulatedBodyInertia_ABADyadHelperLin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 662: flag=_wrap_delete_ArticulatedBodyInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 663: flag=_wrap_RigidBodyInertiaNonLinearParametrization_mass_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 664: flag=_wrap_RigidBodyInertiaNonLinearParametrization_mass_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 665: flag=_wrap_RigidBodyInertiaNonLinearParametrization_com_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 666: flag=_wrap_RigidBodyInertiaNonLinearParametrization_com_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 667: flag=_wrap_RigidBodyInertiaNonLinearParametrization_link_R_centroidal_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 668: flag=_wrap_RigidBodyInertiaNonLinearParametrization_link_R_centroidal_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 669: flag=_wrap_RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 670: flag=_wrap_RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 671: flag=_wrap_RigidBodyInertiaNonLinearParametrization_getLinkCentroidalTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 672: flag=_wrap_RigidBodyInertiaNonLinearParametrization_fromRigidBodyInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 673: flag=_wrap_RigidBodyInertiaNonLinearParametrization_fromInertialParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 674: flag=_wrap_RigidBodyInertiaNonLinearParametrization_toRigidBodyInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 675: flag=_wrap_RigidBodyInertiaNonLinearParametrization_isPhysicallyConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 676: flag=_wrap_RigidBodyInertiaNonLinearParametrization_asVectorWithRotationAsVec(resc,resv,argc,(mxArray**)(argv)); break;
-  case 677: flag=_wrap_RigidBodyInertiaNonLinearParametrization_fromVectorWithRotationAsVec(resc,resv,argc,(mxArray**)(argv)); break;
-  case 678: flag=_wrap_RigidBodyInertiaNonLinearParametrization_getGradientWithRotationAsVec(resc,resv,argc,(mxArray**)(argv)); break;
-  case 679: flag=_wrap_new_RigidBodyInertiaNonLinearParametrization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 680: flag=_wrap_delete_RigidBodyInertiaNonLinearParametrization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 681: flag=_wrap_new_Rotation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 682: flag=_wrap_Rotation_changeOrientFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 683: flag=_wrap_Rotation_changeRefOrientFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 684: flag=_wrap_Rotation_changeCoordinateFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 685: flag=_wrap_Rotation_compose(resc,resv,argc,(mxArray**)(argv)); break;
-  case 686: flag=_wrap_Rotation_inverse2(resc,resv,argc,(mxArray**)(argv)); break;
-  case 687: flag=_wrap_Rotation_changeCoordFrameOf(resc,resv,argc,(mxArray**)(argv)); break;
-  case 688: flag=_wrap_Rotation_inverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 689: flag=_wrap_Rotation_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 690: flag=_wrap_Rotation_log(resc,resv,argc,(mxArray**)(argv)); break;
-  case 691: flag=_wrap_Rotation_fromQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
-  case 692: flag=_wrap_Rotation_getRPY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 693: flag=_wrap_Rotation_asRPY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 694: flag=_wrap_Rotation_getQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
-  case 695: flag=_wrap_Rotation_asQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
-  case 696: flag=_wrap_Rotation_RotX(resc,resv,argc,(mxArray**)(argv)); break;
-  case 697: flag=_wrap_Rotation_RotY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 698: flag=_wrap_Rotation_RotZ(resc,resv,argc,(mxArray**)(argv)); break;
-  case 699: flag=_wrap_Rotation_RotAxis(resc,resv,argc,(mxArray**)(argv)); break;
-  case 700: flag=_wrap_Rotation_RotAxisDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 701: flag=_wrap_Rotation_RPY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 702: flag=_wrap_Rotation_RPYRightTrivializedDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 703: flag=_wrap_Rotation_RPYRightTrivializedDerivativeRateOfChange(resc,resv,argc,(mxArray**)(argv)); break;
-  case 704: flag=_wrap_Rotation_RPYRightTrivializedDerivativeInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 705: flag=_wrap_Rotation_RPYRightTrivializedDerivativeInverseRateOfChange(resc,resv,argc,(mxArray**)(argv)); break;
-  case 706: flag=_wrap_Rotation_QuaternionRightTrivializedDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 707: flag=_wrap_Rotation_QuaternionRightTrivializedDerivativeInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 708: flag=_wrap_Rotation_Identity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 709: flag=_wrap_Rotation_RotationFromQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
-  case 710: flag=_wrap_Rotation_leftJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 711: flag=_wrap_Rotation_leftJacobianInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 712: flag=_wrap_Rotation_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 713: flag=_wrap_Rotation_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 714: flag=_wrap_delete_Rotation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 715: flag=_wrap_new_Transform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 716: flag=_wrap_Transform_fromHomogeneousTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 717: flag=_wrap_Transform_getRotation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 718: flag=_wrap_Transform_getPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 719: flag=_wrap_Transform_setRotation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 720: flag=_wrap_Transform_setPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 721: flag=_wrap_Transform_compose(resc,resv,argc,(mxArray**)(argv)); break;
-  case 722: flag=_wrap_Transform_inverse2(resc,resv,argc,(mxArray**)(argv)); break;
-  case 723: flag=_wrap_Transform_inverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 724: flag=_wrap_Transform_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 725: flag=_wrap_Transform_Identity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 726: flag=_wrap_Transform_asHomogeneousTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 727: flag=_wrap_Transform_asAdjointTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 728: flag=_wrap_Transform_asAdjointTransformWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 729: flag=_wrap_Transform_log(resc,resv,argc,(mxArray**)(argv)); break;
-  case 730: flag=_wrap_Transform_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 731: flag=_wrap_Transform_display(resc,resv,argc,(mxArray**)(argv)); break;
-  case 732: flag=_wrap_delete_Transform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 733: flag=_wrap_new_TransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 734: flag=_wrap_delete_TransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 735: flag=_wrap_TransformDerivative_getRotationDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 736: flag=_wrap_TransformDerivative_getPositionDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 737: flag=_wrap_TransformDerivative_setRotationDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 738: flag=_wrap_TransformDerivative_setPositionDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 739: flag=_wrap_TransformDerivative_Zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 740: flag=_wrap_TransformDerivative_asHomogeneousTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 741: flag=_wrap_TransformDerivative_asAdjointTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 742: flag=_wrap_TransformDerivative_asAdjointTransformWrenchDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 743: flag=_wrap_TransformDerivative_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 744: flag=_wrap_TransformDerivative_derivativeOfInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 745: flag=_wrap_TransformDerivative_transform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 746: flag=_wrap_dynamic_extent_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 747: flag=_wrap_DynamicSpan_extent_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 748: flag=_wrap_new_DynamicSpan(resc,resv,argc,(mxArray**)(argv)); break;
-  case 749: flag=_wrap_delete_DynamicSpan(resc,resv,argc,(mxArray**)(argv)); break;
-  case 750: flag=_wrap_DynamicSpan_first(resc,resv,argc,(mxArray**)(argv)); break;
-  case 751: flag=_wrap_DynamicSpan_last(resc,resv,argc,(mxArray**)(argv)); break;
-  case 752: flag=_wrap_DynamicSpan_subspan(resc,resv,argc,(mxArray**)(argv)); break;
-  case 753: flag=_wrap_DynamicSpan_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 754: flag=_wrap_DynamicSpan_size_bytes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 755: flag=_wrap_DynamicSpan_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 756: flag=_wrap_DynamicSpan_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 757: flag=_wrap_DynamicSpan_getVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 758: flag=_wrap_DynamicSpan_setVal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 759: flag=_wrap_DynamicSpan_at(resc,resv,argc,(mxArray**)(argv)); break;
-  case 760: flag=_wrap_DynamicSpan_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 761: flag=_wrap_DynamicSpan_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 762: flag=_wrap_DynamicSpan_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 763: flag=_wrap_DynamicSpan_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 764: flag=_wrap_DynamicSpan_cend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 765: flag=_wrap_DynamicSpan_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 766: flag=_wrap_DynamicSpan_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 767: flag=_wrap_DynamicSpan_crbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 768: flag=_wrap_DynamicSpan_crend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 769: flag=_wrap_new_DynamicMatrixView(resc,resv,argc,(mxArray**)(argv)); break;
-  case 770: flag=_wrap_DynamicMatrixView_storageOrder(resc,resv,argc,(mxArray**)(argv)); break;
-  case 771: flag=_wrap_DynamicMatrixView_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 772: flag=_wrap_DynamicMatrixView_rows(resc,resv,argc,(mxArray**)(argv)); break;
-  case 773: flag=_wrap_DynamicMatrixView_cols(resc,resv,argc,(mxArray**)(argv)); break;
-  case 774: flag=_wrap_DynamicMatrixView_block(resc,resv,argc,(mxArray**)(argv)); break;
-  case 775: flag=_wrap_delete_DynamicMatrixView(resc,resv,argc,(mxArray**)(argv)); break;
-  case 776: flag=_wrap_LINK_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 777: flag=_wrap_LINK_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 778: flag=_wrap_LINK_INVALID_NAME_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 779: flag=_wrap_LINK_INVALID_NAME_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 780: flag=_wrap_JOINT_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 781: flag=_wrap_JOINT_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 782: flag=_wrap_JOINT_INVALID_NAME_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 783: flag=_wrap_JOINT_INVALID_NAME_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 784: flag=_wrap_DOF_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 785: flag=_wrap_DOF_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 786: flag=_wrap_DOF_INVALID_NAME_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 787: flag=_wrap_DOF_INVALID_NAME_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 788: flag=_wrap_FRAME_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 789: flag=_wrap_FRAME_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 790: flag=_wrap_FRAME_INVALID_NAME_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 791: flag=_wrap_FRAME_INVALID_NAME_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 792: flag=_wrap_TRAVERSAL_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 793: flag=_wrap_TRAVERSAL_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 794: flag=_wrap_new_LinkPositions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 795: flag=_wrap_LinkPositions_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 796: flag=_wrap_LinkPositions_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 797: flag=_wrap_LinkPositions_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 798: flag=_wrap_LinkPositions_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 799: flag=_wrap_LinkPositions_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 800: flag=_wrap_delete_LinkPositions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 801: flag=_wrap_new_LinkWrenches(resc,resv,argc,(mxArray**)(argv)); break;
-  case 802: flag=_wrap_LinkWrenches_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 803: flag=_wrap_LinkWrenches_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 804: flag=_wrap_LinkWrenches_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 805: flag=_wrap_LinkWrenches_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 806: flag=_wrap_LinkWrenches_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 807: flag=_wrap_LinkWrenches_zero(resc,resv,argc,(mxArray**)(argv)); break;
-  case 808: flag=_wrap_delete_LinkWrenches(resc,resv,argc,(mxArray**)(argv)); break;
-  case 809: flag=_wrap_new_LinkInertias(resc,resv,argc,(mxArray**)(argv)); break;
-  case 810: flag=_wrap_LinkInertias_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 811: flag=_wrap_LinkInertias_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 812: flag=_wrap_LinkInertias_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 813: flag=_wrap_delete_LinkInertias(resc,resv,argc,(mxArray**)(argv)); break;
-  case 814: flag=_wrap_new_LinkArticulatedBodyInertias(resc,resv,argc,(mxArray**)(argv)); break;
-  case 815: flag=_wrap_LinkArticulatedBodyInertias_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 816: flag=_wrap_LinkArticulatedBodyInertias_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 817: flag=_wrap_LinkArticulatedBodyInertias_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 818: flag=_wrap_delete_LinkArticulatedBodyInertias(resc,resv,argc,(mxArray**)(argv)); break;
-  case 819: flag=_wrap_new_LinkVelArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 820: flag=_wrap_LinkVelArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 821: flag=_wrap_LinkVelArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 822: flag=_wrap_LinkVelArray_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 823: flag=_wrap_LinkVelArray_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 824: flag=_wrap_LinkVelArray_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 825: flag=_wrap_delete_LinkVelArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 826: flag=_wrap_new_LinkAccArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 827: flag=_wrap_LinkAccArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 828: flag=_wrap_LinkAccArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 829: flag=_wrap_LinkAccArray_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 830: flag=_wrap_LinkAccArray_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 831: flag=_wrap_LinkAccArray_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 832: flag=_wrap_delete_LinkAccArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 833: flag=_wrap_new_Link(resc,resv,argc,(mxArray**)(argv)); break;
-  case 834: flag=_wrap_Link_inertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 835: flag=_wrap_Link_setInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 836: flag=_wrap_Link_getInertia(resc,resv,argc,(mxArray**)(argv)); break;
-  case 837: flag=_wrap_Link_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 838: flag=_wrap_Link_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 839: flag=_wrap_delete_Link(resc,resv,argc,(mxArray**)(argv)); break;
-  case 840: flag=_wrap_delete_IJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 841: flag=_wrap_IJoint_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 842: flag=_wrap_IJoint_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 843: flag=_wrap_IJoint_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 844: flag=_wrap_IJoint_setAttachedLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 845: flag=_wrap_IJoint_setRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 846: flag=_wrap_IJoint_getFirstAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 847: flag=_wrap_IJoint_getSecondAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 848: flag=_wrap_IJoint_getRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 849: flag=_wrap_IJoint_getTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 850: flag=_wrap_IJoint_getTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 851: flag=_wrap_IJoint_getMotionSubspaceVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 852: flag=_wrap_IJoint_computeChildPosVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 853: flag=_wrap_IJoint_computeChildVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 854: flag=_wrap_IJoint_computeChildVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 855: flag=_wrap_IJoint_computeChildAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 856: flag=_wrap_IJoint_computeChildBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 857: flag=_wrap_IJoint_computeJointTorque(resc,resv,argc,(mxArray**)(argv)); break;
-  case 858: flag=_wrap_IJoint_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 859: flag=_wrap_IJoint_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 860: flag=_wrap_IJoint_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 861: flag=_wrap_IJoint_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 862: flag=_wrap_IJoint_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 863: flag=_wrap_IJoint_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 864: flag=_wrap_IJoint_hasPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 865: flag=_wrap_IJoint_enablePosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 866: flag=_wrap_IJoint_getPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 867: flag=_wrap_IJoint_getMinPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 868: flag=_wrap_IJoint_getMaxPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 869: flag=_wrap_IJoint_setPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 870: flag=_wrap_IJoint_getJointDynamicsType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 871: flag=_wrap_IJoint_setJointDynamicsType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 872: flag=_wrap_IJoint_setDamping(resc,resv,argc,(mxArray**)(argv)); break;
-  case 873: flag=_wrap_IJoint_setStaticFriction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 874: flag=_wrap_IJoint_getDamping(resc,resv,argc,(mxArray**)(argv)); break;
-  case 875: flag=_wrap_IJoint_getStaticFriction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 876: flag=_wrap_IJoint_isRevoluteJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 877: flag=_wrap_IJoint_isFixedJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 878: flag=_wrap_IJoint_isPrismaticJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 879: flag=_wrap_IJoint_asRevoluteJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 880: flag=_wrap_IJoint_asFixedJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 881: flag=_wrap_IJoint_asPrismaticJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 882: flag=_wrap_new_FixedJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 883: flag=_wrap_delete_FixedJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 884: flag=_wrap_FixedJoint_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 885: flag=_wrap_FixedJoint_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 886: flag=_wrap_FixedJoint_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 887: flag=_wrap_FixedJoint_setAttachedLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 888: flag=_wrap_FixedJoint_setRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 889: flag=_wrap_FixedJoint_getFirstAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 890: flag=_wrap_FixedJoint_getSecondAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 891: flag=_wrap_FixedJoint_getRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 892: flag=_wrap_FixedJoint_getTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 893: flag=_wrap_FixedJoint_getTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 894: flag=_wrap_FixedJoint_getMotionSubspaceVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 895: flag=_wrap_FixedJoint_computeChildPosVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 896: flag=_wrap_FixedJoint_computeChildVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 897: flag=_wrap_FixedJoint_computeChildVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 898: flag=_wrap_FixedJoint_computeChildAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 899: flag=_wrap_FixedJoint_computeChildBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 900: flag=_wrap_FixedJoint_computeJointTorque(resc,resv,argc,(mxArray**)(argv)); break;
-  case 901: flag=_wrap_FixedJoint_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 902: flag=_wrap_FixedJoint_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 903: flag=_wrap_FixedJoint_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 904: flag=_wrap_FixedJoint_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 905: flag=_wrap_FixedJoint_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 906: flag=_wrap_FixedJoint_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 907: flag=_wrap_FixedJoint_hasPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 908: flag=_wrap_FixedJoint_enablePosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 909: flag=_wrap_FixedJoint_getPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 910: flag=_wrap_FixedJoint_getMinPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 911: flag=_wrap_FixedJoint_getMaxPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 912: flag=_wrap_FixedJoint_setPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 913: flag=_wrap_FixedJoint_getJointDynamicsType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 914: flag=_wrap_FixedJoint_setJointDynamicsType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 915: flag=_wrap_FixedJoint_getDamping(resc,resv,argc,(mxArray**)(argv)); break;
-  case 916: flag=_wrap_FixedJoint_getStaticFriction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 917: flag=_wrap_FixedJoint_setDamping(resc,resv,argc,(mxArray**)(argv)); break;
-  case 918: flag=_wrap_FixedJoint_setStaticFriction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 919: flag=_wrap_delete_MovableJointImpl1(resc,resv,argc,(mxArray**)(argv)); break;
-  case 920: flag=_wrap_MovableJointImpl1_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 921: flag=_wrap_MovableJointImpl1_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 922: flag=_wrap_MovableJointImpl1_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 923: flag=_wrap_MovableJointImpl1_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 924: flag=_wrap_MovableJointImpl1_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 925: flag=_wrap_MovableJointImpl1_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 926: flag=_wrap_MovableJointImpl1_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 927: flag=_wrap_MovableJointImpl1_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 928: flag=_wrap_delete_MovableJointImpl2(resc,resv,argc,(mxArray**)(argv)); break;
-  case 929: flag=_wrap_MovableJointImpl2_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 930: flag=_wrap_MovableJointImpl2_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 931: flag=_wrap_MovableJointImpl2_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 932: flag=_wrap_MovableJointImpl2_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 933: flag=_wrap_MovableJointImpl2_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 934: flag=_wrap_MovableJointImpl2_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 935: flag=_wrap_MovableJointImpl2_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 936: flag=_wrap_MovableJointImpl2_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 937: flag=_wrap_delete_MovableJointImpl3(resc,resv,argc,(mxArray**)(argv)); break;
-  case 938: flag=_wrap_MovableJointImpl3_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 939: flag=_wrap_MovableJointImpl3_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 940: flag=_wrap_MovableJointImpl3_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 941: flag=_wrap_MovableJointImpl3_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 942: flag=_wrap_MovableJointImpl3_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 943: flag=_wrap_MovableJointImpl3_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 944: flag=_wrap_MovableJointImpl3_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 945: flag=_wrap_MovableJointImpl3_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 946: flag=_wrap_delete_MovableJointImpl4(resc,resv,argc,(mxArray**)(argv)); break;
-  case 947: flag=_wrap_MovableJointImpl4_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 948: flag=_wrap_MovableJointImpl4_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 949: flag=_wrap_MovableJointImpl4_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 950: flag=_wrap_MovableJointImpl4_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 951: flag=_wrap_MovableJointImpl4_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 952: flag=_wrap_MovableJointImpl4_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 953: flag=_wrap_MovableJointImpl4_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 954: flag=_wrap_MovableJointImpl4_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 955: flag=_wrap_delete_MovableJointImpl5(resc,resv,argc,(mxArray**)(argv)); break;
-  case 956: flag=_wrap_MovableJointImpl5_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 957: flag=_wrap_MovableJointImpl5_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 958: flag=_wrap_MovableJointImpl5_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 959: flag=_wrap_MovableJointImpl5_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 960: flag=_wrap_MovableJointImpl5_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 961: flag=_wrap_MovableJointImpl5_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 962: flag=_wrap_MovableJointImpl5_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 963: flag=_wrap_MovableJointImpl5_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 964: flag=_wrap_delete_MovableJointImpl6(resc,resv,argc,(mxArray**)(argv)); break;
-  case 965: flag=_wrap_MovableJointImpl6_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 966: flag=_wrap_MovableJointImpl6_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 967: flag=_wrap_MovableJointImpl6_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 968: flag=_wrap_MovableJointImpl6_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 969: flag=_wrap_MovableJointImpl6_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 970: flag=_wrap_MovableJointImpl6_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 971: flag=_wrap_MovableJointImpl6_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 972: flag=_wrap_MovableJointImpl6_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 973: flag=_wrap_new_RevoluteJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 974: flag=_wrap_delete_RevoluteJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 975: flag=_wrap_RevoluteJoint_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 976: flag=_wrap_RevoluteJoint_setAttachedLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 977: flag=_wrap_RevoluteJoint_setRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 978: flag=_wrap_RevoluteJoint_setAxis(resc,resv,argc,(mxArray**)(argv)); break;
-  case 979: flag=_wrap_RevoluteJoint_getFirstAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 980: flag=_wrap_RevoluteJoint_getSecondAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 981: flag=_wrap_RevoluteJoint_getAxis(resc,resv,argc,(mxArray**)(argv)); break;
-  case 982: flag=_wrap_RevoluteJoint_getRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 983: flag=_wrap_RevoluteJoint_getTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 984: flag=_wrap_RevoluteJoint_getTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 985: flag=_wrap_RevoluteJoint_getMotionSubspaceVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 986: flag=_wrap_RevoluteJoint_computeChildPosVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 987: flag=_wrap_RevoluteJoint_computeChildVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 988: flag=_wrap_RevoluteJoint_computeChildVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 989: flag=_wrap_RevoluteJoint_computeChildAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 990: flag=_wrap_RevoluteJoint_computeChildBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 991: flag=_wrap_RevoluteJoint_computeJointTorque(resc,resv,argc,(mxArray**)(argv)); break;
-  case 992: flag=_wrap_RevoluteJoint_hasPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 993: flag=_wrap_RevoluteJoint_enablePosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 994: flag=_wrap_RevoluteJoint_getPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 995: flag=_wrap_RevoluteJoint_getMinPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 996: flag=_wrap_RevoluteJoint_getMaxPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 997: flag=_wrap_RevoluteJoint_setPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 998: flag=_wrap_RevoluteJoint_getJointDynamicsType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 999: flag=_wrap_RevoluteJoint_setJointDynamicsType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1000: flag=_wrap_RevoluteJoint_getDamping(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1001: flag=_wrap_RevoluteJoint_getStaticFriction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1002: flag=_wrap_RevoluteJoint_setDamping(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1003: flag=_wrap_RevoluteJoint_setStaticFriction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1004: flag=_wrap_new_PrismaticJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1005: flag=_wrap_delete_PrismaticJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1006: flag=_wrap_PrismaticJoint_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1007: flag=_wrap_PrismaticJoint_setAttachedLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1008: flag=_wrap_PrismaticJoint_setRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1009: flag=_wrap_PrismaticJoint_setAxis(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1010: flag=_wrap_PrismaticJoint_getFirstAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1011: flag=_wrap_PrismaticJoint_getSecondAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1012: flag=_wrap_PrismaticJoint_getAxis(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1013: flag=_wrap_PrismaticJoint_getRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1014: flag=_wrap_PrismaticJoint_getTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1015: flag=_wrap_PrismaticJoint_getTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1016: flag=_wrap_PrismaticJoint_getMotionSubspaceVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1017: flag=_wrap_PrismaticJoint_computeChildPosVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1018: flag=_wrap_PrismaticJoint_computeChildVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1019: flag=_wrap_PrismaticJoint_computeChildVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1020: flag=_wrap_PrismaticJoint_computeChildAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1021: flag=_wrap_PrismaticJoint_computeChildBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1022: flag=_wrap_PrismaticJoint_computeJointTorque(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1023: flag=_wrap_PrismaticJoint_hasPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1024: flag=_wrap_PrismaticJoint_enablePosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1025: flag=_wrap_PrismaticJoint_getPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1026: flag=_wrap_PrismaticJoint_getMinPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1027: flag=_wrap_PrismaticJoint_getMaxPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1028: flag=_wrap_PrismaticJoint_setPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1029: flag=_wrap_PrismaticJoint_getJointDynamicsType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1030: flag=_wrap_PrismaticJoint_setJointDynamicsType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1031: flag=_wrap_PrismaticJoint_getDamping(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1032: flag=_wrap_PrismaticJoint_getStaticFriction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1033: flag=_wrap_PrismaticJoint_setDamping(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1034: flag=_wrap_PrismaticJoint_setStaticFriction(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1035: flag=_wrap_new_Traversal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1036: flag=_wrap_delete_Traversal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1037: flag=_wrap_Traversal_getNrOfVisitedLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1038: flag=_wrap_Traversal_getLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1039: flag=_wrap_Traversal_getBaseLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1040: flag=_wrap_Traversal_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1041: flag=_wrap_Traversal_getParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1042: flag=_wrap_Traversal_getParentLinkFromLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1043: flag=_wrap_Traversal_getParentJointFromLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1044: flag=_wrap_Traversal_getTraversalIndexFromLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1045: flag=_wrap_Traversal_reset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1046: flag=_wrap_Traversal_addTraversalBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1047: flag=_wrap_Traversal_addTraversalElement(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1048: flag=_wrap_Traversal_isParentOf(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1049: flag=_wrap_Traversal_getChildLinkIndexFromJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1050: flag=_wrap_Traversal_getParentLinkIndexFromJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1051: flag=_wrap_Traversal_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1052: flag=_wrap_new_Material(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1053: flag=_wrap_Material_name(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1054: flag=_wrap_Material_hasColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1055: flag=_wrap_Material_color(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1056: flag=_wrap_Material_setColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1057: flag=_wrap_Material_hasTexture(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1058: flag=_wrap_Material_texture(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1059: flag=_wrap_Material_setTexture(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1060: flag=_wrap_delete_Material(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1061: flag=_wrap_delete_SolidShape(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1062: flag=_wrap_SolidShape_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1063: flag=_wrap_SolidShape_getName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1064: flag=_wrap_SolidShape_setName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1065: flag=_wrap_SolidShape_isNameValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1066: flag=_wrap_SolidShape_getLink_H_geometry(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1067: flag=_wrap_SolidShape_setLink_H_geometry(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1068: flag=_wrap_SolidShape_isMaterialSet(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1069: flag=_wrap_SolidShape_getMaterial(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1070: flag=_wrap_SolidShape_setMaterial(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1071: flag=_wrap_SolidShape_isSphere(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1072: flag=_wrap_SolidShape_isBox(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1073: flag=_wrap_SolidShape_isCylinder(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1074: flag=_wrap_SolidShape_isExternalMesh(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1075: flag=_wrap_SolidShape_asSphere(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1076: flag=_wrap_SolidShape_asBox(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1077: flag=_wrap_SolidShape_asCylinder(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1078: flag=_wrap_SolidShape_asExternalMesh(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1079: flag=_wrap_delete_Sphere(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1080: flag=_wrap_Sphere_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1081: flag=_wrap_Sphere_getRadius(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1082: flag=_wrap_Sphere_setRadius(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1083: flag=_wrap_new_Sphere(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1084: flag=_wrap_delete_Box(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1085: flag=_wrap_Box_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1086: flag=_wrap_Box_getX(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1087: flag=_wrap_Box_setX(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1088: flag=_wrap_Box_getY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1089: flag=_wrap_Box_setY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1090: flag=_wrap_Box_getZ(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1091: flag=_wrap_Box_setZ(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1092: flag=_wrap_new_Box(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1093: flag=_wrap_delete_Cylinder(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1094: flag=_wrap_Cylinder_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1095: flag=_wrap_Cylinder_getLength(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1096: flag=_wrap_Cylinder_setLength(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1097: flag=_wrap_Cylinder_getRadius(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1098: flag=_wrap_Cylinder_setRadius(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1099: flag=_wrap_new_Cylinder(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1100: flag=_wrap_delete_ExternalMesh(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1101: flag=_wrap_ExternalMesh_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1102: flag=_wrap_ExternalMesh_getFilename(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1103: flag=_wrap_ExternalMesh_getPackageDirs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1104: flag=_wrap_ExternalMesh_getFileLocationOnLocalFileSystem(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1105: flag=_wrap_ExternalMesh_setFilename(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1106: flag=_wrap_ExternalMesh_setPackageDirs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1107: flag=_wrap_ExternalMesh_getScale(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1108: flag=_wrap_ExternalMesh_setScale(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1109: flag=_wrap_new_ExternalMesh(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1110: flag=_wrap_delete_ModelSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1111: flag=_wrap_new_ModelSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1112: flag=_wrap_ModelSolidShapes_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1113: flag=_wrap_ModelSolidShapes_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1114: flag=_wrap_ModelSolidShapes_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1115: flag=_wrap_ModelSolidShapes_getLinkSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1116: flag=_wrap_NR_OF_SENSOR_TYPES_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1117: flag=_wrap_isLinkSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1118: flag=_wrap_isJointSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1119: flag=_wrap_getSensorTypeSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1120: flag=_wrap_delete_Sensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1121: flag=_wrap_Sensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1122: flag=_wrap_Sensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1123: flag=_wrap_Sensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1124: flag=_wrap_Sensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1125: flag=_wrap_Sensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1126: flag=_wrap_Sensor_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1127: flag=_wrap_Sensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1128: flag=_wrap_delete_JointSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1129: flag=_wrap_JointSensor_getParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1130: flag=_wrap_JointSensor_getParentJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1131: flag=_wrap_JointSensor_setParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1132: flag=_wrap_JointSensor_setParentJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1133: flag=_wrap_JointSensor_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1134: flag=_wrap_delete_LinkSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1135: flag=_wrap_LinkSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1136: flag=_wrap_LinkSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1137: flag=_wrap_LinkSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1138: flag=_wrap_LinkSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1139: flag=_wrap_LinkSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1140: flag=_wrap_LinkSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1141: flag=_wrap_LinkSensor_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1142: flag=_wrap_new_SensorsList(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1143: flag=_wrap_delete_SensorsList(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1144: flag=_wrap_SensorsList_addSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1145: flag=_wrap_SensorsList_setSerialization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1146: flag=_wrap_SensorsList_getSerialization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1147: flag=_wrap_SensorsList_getNrOfSensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1148: flag=_wrap_SensorsList_getSensorIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1149: flag=_wrap_SensorsList_getSizeOfAllSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1150: flag=_wrap_SensorsList_getSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1151: flag=_wrap_SensorsList_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1152: flag=_wrap_SensorsList_removeSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1153: flag=_wrap_SensorsList_removeAllSensorsOfType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1154: flag=_wrap_SensorsList_getSixAxisForceTorqueSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1155: flag=_wrap_SensorsList_getAccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1156: flag=_wrap_SensorsList_getGyroscopeSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1157: flag=_wrap_SensorsList_getThreeAxisAngularAccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1158: flag=_wrap_SensorsList_getThreeAxisForceTorqueContactSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1159: flag=_wrap_new_SensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1160: flag=_wrap_delete_SensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1161: flag=_wrap_SensorsMeasurements_setNrOfSensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1162: flag=_wrap_SensorsMeasurements_getNrOfSensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1163: flag=_wrap_SensorsMeasurements_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1164: flag=_wrap_SensorsMeasurements_toVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1165: flag=_wrap_SensorsMeasurements_setMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1166: flag=_wrap_SensorsMeasurements_getMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1167: flag=_wrap_SensorsMeasurements_getSizeOfAllSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1168: flag=_wrap_Neighbor_neighborLink_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1169: flag=_wrap_Neighbor_neighborLink_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1170: flag=_wrap_Neighbor_neighborJoint_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1171: flag=_wrap_Neighbor_neighborJoint_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1172: flag=_wrap_new_Neighbor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1173: flag=_wrap_delete_Neighbor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1174: flag=_wrap_new_Model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1175: flag=_wrap_Model_copy(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1176: flag=_wrap_delete_Model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1177: flag=_wrap_Model_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1178: flag=_wrap_Model_getPackageDirs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1179: flag=_wrap_Model_setPackageDirs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1180: flag=_wrap_Model_getLinkName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1181: flag=_wrap_Model_getLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1182: flag=_wrap_Model_isValidLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1183: flag=_wrap_Model_getLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1184: flag=_wrap_Model_addLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1185: flag=_wrap_Model_getNrOfJoints(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1186: flag=_wrap_Model_getJointName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1187: flag=_wrap_Model_getTotalMass(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1188: flag=_wrap_Model_getJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1189: flag=_wrap_Model_getJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1190: flag=_wrap_Model_isValidJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1191: flag=_wrap_Model_isLinkNameUsed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1192: flag=_wrap_Model_isJointNameUsed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1193: flag=_wrap_Model_isFrameNameUsed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1194: flag=_wrap_Model_addJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1195: flag=_wrap_Model_addJointAndLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1196: flag=_wrap_Model_insertLinkToExistingJointAndAddJointForDisplacedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1197: flag=_wrap_Model_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1198: flag=_wrap_Model_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1199: flag=_wrap_Model_getNrOfFrames(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1200: flag=_wrap_Model_addAdditionalFrameToLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1201: flag=_wrap_Model_getFrameName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1202: flag=_wrap_Model_getFrameIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1203: flag=_wrap_Model_isValidFrameIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1204: flag=_wrap_Model_getFrameTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1205: flag=_wrap_Model_getFrameLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1206: flag=_wrap_Model_getLinkAdditionalFrames(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1207: flag=_wrap_Model_getNrOfNeighbors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1208: flag=_wrap_Model_getNeighbor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1209: flag=_wrap_Model_setDefaultBaseLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1210: flag=_wrap_Model_getDefaultBaseLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1211: flag=_wrap_Model_computeFullTreeTraversal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1212: flag=_wrap_Model_getInertialParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1213: flag=_wrap_Model_updateInertialParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1214: flag=_wrap_Model_visualSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1215: flag=_wrap_Model_collisionSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1216: flag=_wrap_Model_sensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1217: flag=_wrap_Model_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1218: flag=_wrap_Model_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1219: flag=_wrap_new_JointPosDoubleArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1220: flag=_wrap_JointPosDoubleArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1221: flag=_wrap_JointPosDoubleArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1222: flag=_wrap_delete_JointPosDoubleArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1223: flag=_wrap_new_JointDOFsDoubleArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1224: flag=_wrap_JointDOFsDoubleArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1225: flag=_wrap_JointDOFsDoubleArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1226: flag=_wrap_delete_JointDOFsDoubleArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1227: flag=_wrap_new_DOFSpatialForceArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1228: flag=_wrap_DOFSpatialForceArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1229: flag=_wrap_DOFSpatialForceArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1230: flag=_wrap_DOFSpatialForceArray_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1231: flag=_wrap_delete_DOFSpatialForceArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1232: flag=_wrap_new_DOFSpatialMotionArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1233: flag=_wrap_DOFSpatialMotionArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1234: flag=_wrap_DOFSpatialMotionArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1235: flag=_wrap_DOFSpatialMotionArray_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1236: flag=_wrap_delete_DOFSpatialMotionArray(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1237: flag=_wrap_new_FrameFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1238: flag=_wrap_FrameFreeFloatingJacobian_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1239: flag=_wrap_FrameFreeFloatingJacobian_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1240: flag=_wrap_delete_FrameFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1241: flag=_wrap_new_MomentumFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1242: flag=_wrap_MomentumFreeFloatingJacobian_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1243: flag=_wrap_MomentumFreeFloatingJacobian_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1244: flag=_wrap_delete_MomentumFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1245: flag=_wrap_new_FreeFloatingMassMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1246: flag=_wrap_FreeFloatingMassMatrix_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1247: flag=_wrap_delete_FreeFloatingMassMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1248: flag=_wrap_new_FreeFloatingPos(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1249: flag=_wrap_FreeFloatingPos_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1250: flag=_wrap_FreeFloatingPos_worldBasePos(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1251: flag=_wrap_FreeFloatingPos_jointPos(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1252: flag=_wrap_FreeFloatingPos_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1253: flag=_wrap_delete_FreeFloatingPos(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1254: flag=_wrap_new_FreeFloatingGeneralizedTorques(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1255: flag=_wrap_FreeFloatingGeneralizedTorques_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1256: flag=_wrap_FreeFloatingGeneralizedTorques_baseWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1257: flag=_wrap_FreeFloatingGeneralizedTorques_jointTorques(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1258: flag=_wrap_FreeFloatingGeneralizedTorques_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1259: flag=_wrap_delete_FreeFloatingGeneralizedTorques(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1260: flag=_wrap_new_FreeFloatingVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1261: flag=_wrap_FreeFloatingVel_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1262: flag=_wrap_FreeFloatingVel_baseVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1263: flag=_wrap_FreeFloatingVel_jointVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1264: flag=_wrap_FreeFloatingVel_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1265: flag=_wrap_delete_FreeFloatingVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1266: flag=_wrap_new_FreeFloatingAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1267: flag=_wrap_FreeFloatingAcc_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1268: flag=_wrap_FreeFloatingAcc_baseAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1269: flag=_wrap_FreeFloatingAcc_jointAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1270: flag=_wrap_FreeFloatingAcc_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1271: flag=_wrap_delete_FreeFloatingAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1272: flag=_wrap_ContactWrench_contactId(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1273: flag=_wrap_ContactWrench_contactPoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1274: flag=_wrap_ContactWrench_contactWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1275: flag=_wrap_new_ContactWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1276: flag=_wrap_delete_ContactWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1277: flag=_wrap_new_LinkContactWrenches(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1278: flag=_wrap_LinkContactWrenches_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1279: flag=_wrap_LinkContactWrenches_getNrOfContactsForLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1280: flag=_wrap_LinkContactWrenches_setNrOfContactsForLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1281: flag=_wrap_LinkContactWrenches_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1282: flag=_wrap_LinkContactWrenches_contactWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1283: flag=_wrap_LinkContactWrenches_computeNetWrenches(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1284: flag=_wrap_LinkContactWrenches_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1285: flag=_wrap_delete_LinkContactWrenches(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1286: flag=_wrap_getRandomLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1287: flag=_wrap_addRandomLinkToModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1288: flag=_wrap_addRandomAdditionalFrameToModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1289: flag=_wrap_getRandomLinkIndexOfModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1290: flag=_wrap_getRandomLinkOfModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1291: flag=_wrap_int2string(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1292: flag=_wrap_getRandomModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1293: flag=_wrap_getRandomChain(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1294: flag=_wrap_getRandomJointPositions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1295: flag=_wrap_getRandomInverseDynamicsInputs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1296: flag=_wrap_removeFakeLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1297: flag=_wrap_createReducedModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1298: flag=_wrap_createModelWithNormalizedJointNumbering(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1299: flag=_wrap_extractSubModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1300: flag=_wrap_new_SubModelDecomposition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1301: flag=_wrap_delete_SubModelDecomposition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1302: flag=_wrap_SubModelDecomposition_splitModelAlongJoints(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1303: flag=_wrap_SubModelDecomposition_setNrOfSubModels(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1304: flag=_wrap_SubModelDecomposition_getNrOfSubModels(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1305: flag=_wrap_SubModelDecomposition_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1306: flag=_wrap_SubModelDecomposition_getTraversal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1307: flag=_wrap_SubModelDecomposition_getSubModelOfLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1308: flag=_wrap_SubModelDecomposition_getSubModelOfFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1309: flag=_wrap_computeTransformToTraversalBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1310: flag=_wrap_computeTransformToSubModelBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1311: flag=_wrap_new_SixAxisForceTorqueSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1312: flag=_wrap_delete_SixAxisForceTorqueSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1313: flag=_wrap_SixAxisForceTorqueSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1314: flag=_wrap_SixAxisForceTorqueSensor_setFirstLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1315: flag=_wrap_SixAxisForceTorqueSensor_setSecondLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1316: flag=_wrap_SixAxisForceTorqueSensor_getFirstLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1317: flag=_wrap_SixAxisForceTorqueSensor_getSecondLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1318: flag=_wrap_SixAxisForceTorqueSensor_setFirstLinkName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1319: flag=_wrap_SixAxisForceTorqueSensor_setSecondLinkName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1320: flag=_wrap_SixAxisForceTorqueSensor_getFirstLinkName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1321: flag=_wrap_SixAxisForceTorqueSensor_getSecondLinkName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1322: flag=_wrap_SixAxisForceTorqueSensor_setParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1323: flag=_wrap_SixAxisForceTorqueSensor_setParentJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1324: flag=_wrap_SixAxisForceTorqueSensor_setAppliedWrenchLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1325: flag=_wrap_SixAxisForceTorqueSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1326: flag=_wrap_SixAxisForceTorqueSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1327: flag=_wrap_SixAxisForceTorqueSensor_getParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1328: flag=_wrap_SixAxisForceTorqueSensor_getParentJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1329: flag=_wrap_SixAxisForceTorqueSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1330: flag=_wrap_SixAxisForceTorqueSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1331: flag=_wrap_SixAxisForceTorqueSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1332: flag=_wrap_SixAxisForceTorqueSensor_getAppliedWrenchLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1333: flag=_wrap_SixAxisForceTorqueSensor_isLinkAttachedToSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1334: flag=_wrap_SixAxisForceTorqueSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1335: flag=_wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1336: flag=_wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1337: flag=_wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1338: flag=_wrap_SixAxisForceTorqueSensor_predictMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1339: flag=_wrap_SixAxisForceTorqueSensor_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1340: flag=_wrap_new_AccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1341: flag=_wrap_delete_AccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1342: flag=_wrap_AccelerometerSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1343: flag=_wrap_AccelerometerSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1344: flag=_wrap_AccelerometerSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1345: flag=_wrap_AccelerometerSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1346: flag=_wrap_AccelerometerSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1347: flag=_wrap_AccelerometerSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1348: flag=_wrap_AccelerometerSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1349: flag=_wrap_AccelerometerSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1350: flag=_wrap_AccelerometerSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1351: flag=_wrap_AccelerometerSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1352: flag=_wrap_AccelerometerSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1353: flag=_wrap_AccelerometerSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1354: flag=_wrap_AccelerometerSensor_predictMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1355: flag=_wrap_new_GyroscopeSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1356: flag=_wrap_delete_GyroscopeSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1357: flag=_wrap_GyroscopeSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1358: flag=_wrap_GyroscopeSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1359: flag=_wrap_GyroscopeSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1360: flag=_wrap_GyroscopeSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1361: flag=_wrap_GyroscopeSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1362: flag=_wrap_GyroscopeSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1363: flag=_wrap_GyroscopeSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1364: flag=_wrap_GyroscopeSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1365: flag=_wrap_GyroscopeSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1366: flag=_wrap_GyroscopeSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1367: flag=_wrap_GyroscopeSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1368: flag=_wrap_GyroscopeSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1369: flag=_wrap_GyroscopeSensor_predictMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1370: flag=_wrap_new_ThreeAxisAngularAccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1371: flag=_wrap_delete_ThreeAxisAngularAccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1372: flag=_wrap_ThreeAxisAngularAccelerometerSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1373: flag=_wrap_ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1374: flag=_wrap_ThreeAxisAngularAccelerometerSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1375: flag=_wrap_ThreeAxisAngularAccelerometerSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1376: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1377: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1378: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1379: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1380: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1381: flag=_wrap_ThreeAxisAngularAccelerometerSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1382: flag=_wrap_ThreeAxisAngularAccelerometerSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1383: flag=_wrap_ThreeAxisAngularAccelerometerSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1384: flag=_wrap_ThreeAxisAngularAccelerometerSensor_predictMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1385: flag=_wrap_new_ThreeAxisForceTorqueContactSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1386: flag=_wrap_delete_ThreeAxisForceTorqueContactSensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1387: flag=_wrap_ThreeAxisForceTorqueContactSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1388: flag=_wrap_ThreeAxisForceTorqueContactSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1389: flag=_wrap_ThreeAxisForceTorqueContactSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1390: flag=_wrap_ThreeAxisForceTorqueContactSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1391: flag=_wrap_ThreeAxisForceTorqueContactSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1392: flag=_wrap_ThreeAxisForceTorqueContactSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1393: flag=_wrap_ThreeAxisForceTorqueContactSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1394: flag=_wrap_ThreeAxisForceTorqueContactSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1395: flag=_wrap_ThreeAxisForceTorqueContactSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1396: flag=_wrap_ThreeAxisForceTorqueContactSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1397: flag=_wrap_ThreeAxisForceTorqueContactSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1398: flag=_wrap_ThreeAxisForceTorqueContactSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1399: flag=_wrap_ThreeAxisForceTorqueContactSensor_setLoadCellLocations(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1400: flag=_wrap_ThreeAxisForceTorqueContactSensor_getLoadCellLocations(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1401: flag=_wrap_ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1402: flag=_wrap_ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1403: flag=_wrap_predictSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1404: flag=_wrap_predictSensorsMeasurementsFromRawBuffers(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1405: flag=_wrap_SolidShapesVector_pop(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1406: flag=_wrap_SolidShapesVector_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1407: flag=_wrap_SolidShapesVector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1408: flag=_wrap_SolidShapesVector_append(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1409: flag=_wrap_SolidShapesVector_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1410: flag=_wrap_SolidShapesVector_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1411: flag=_wrap_SolidShapesVector_swap(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1412: flag=_wrap_SolidShapesVector_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1413: flag=_wrap_SolidShapesVector_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1414: flag=_wrap_SolidShapesVector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1415: flag=_wrap_SolidShapesVector_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1416: flag=_wrap_SolidShapesVector_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1417: flag=_wrap_SolidShapesVector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1418: flag=_wrap_SolidShapesVector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1419: flag=_wrap_SolidShapesVector_erase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1420: flag=_wrap_new_SolidShapesVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1421: flag=_wrap_SolidShapesVector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1422: flag=_wrap_SolidShapesVector_front(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1423: flag=_wrap_SolidShapesVector_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1424: flag=_wrap_SolidShapesVector_assign(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1425: flag=_wrap_SolidShapesVector_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1426: flag=_wrap_SolidShapesVector_insert(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1427: flag=_wrap_SolidShapesVector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1428: flag=_wrap_SolidShapesVector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1429: flag=_wrap_delete_SolidShapesVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1430: flag=_wrap_LinksSolidShapesVector_pop(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1431: flag=_wrap_LinksSolidShapesVector_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1432: flag=_wrap_LinksSolidShapesVector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1433: flag=_wrap_LinksSolidShapesVector_append(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1434: flag=_wrap_LinksSolidShapesVector_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1435: flag=_wrap_LinksSolidShapesVector_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1436: flag=_wrap_LinksSolidShapesVector_swap(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1437: flag=_wrap_LinksSolidShapesVector_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1438: flag=_wrap_LinksSolidShapesVector_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1439: flag=_wrap_LinksSolidShapesVector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1440: flag=_wrap_LinksSolidShapesVector_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1441: flag=_wrap_LinksSolidShapesVector_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1442: flag=_wrap_LinksSolidShapesVector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1443: flag=_wrap_LinksSolidShapesVector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1444: flag=_wrap_LinksSolidShapesVector_erase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1445: flag=_wrap_new_LinksSolidShapesVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1446: flag=_wrap_LinksSolidShapesVector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1447: flag=_wrap_LinksSolidShapesVector_front(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1448: flag=_wrap_LinksSolidShapesVector_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1449: flag=_wrap_LinksSolidShapesVector_assign(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1450: flag=_wrap_LinksSolidShapesVector_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1451: flag=_wrap_LinksSolidShapesVector_insert(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1452: flag=_wrap_LinksSolidShapesVector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1453: flag=_wrap_LinksSolidShapesVector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1454: flag=_wrap_delete_LinksSolidShapesVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1455: flag=_wrap_ForwardPositionKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1456: flag=_wrap_ForwardVelAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1457: flag=_wrap_ForwardPosVelAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1458: flag=_wrap_ForwardPosVelKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1459: flag=_wrap_ForwardAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1460: flag=_wrap_ForwardBiasAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1461: flag=_wrap_ComputeLinearAndAngularMomentum(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1462: flag=_wrap_ComputeLinearAndAngularMomentumDerivativeBias(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1463: flag=_wrap_RNEADynamicPhase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1464: flag=_wrap_CompositeRigidBodyAlgorithm(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1465: flag=_wrap_new_ArticulatedBodyAlgorithmInternalBuffers(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1466: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1467: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1468: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_S_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1469: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_S_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1470: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_U_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1471: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_U_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1472: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_D_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1473: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_D_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1474: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_u_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1475: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_u_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1476: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksVel_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1477: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksVel_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1478: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1479: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1480: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1481: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1482: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1483: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1484: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1485: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1486: flag=_wrap_delete_ArticulatedBodyAlgorithmInternalBuffers(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1487: flag=_wrap_ArticulatedBodyAlgorithm(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1488: flag=_wrap_InverseDynamicsInertialParametersRegressor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1489: flag=_wrap_DHLink_A_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1490: flag=_wrap_DHLink_A_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1491: flag=_wrap_DHLink_D_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1492: flag=_wrap_DHLink_D_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1493: flag=_wrap_DHLink_Alpha_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1494: flag=_wrap_DHLink_Alpha_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1495: flag=_wrap_DHLink_Offset_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1496: flag=_wrap_DHLink_Offset_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1497: flag=_wrap_DHLink_Min_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1498: flag=_wrap_DHLink_Min_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1499: flag=_wrap_DHLink_Max_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1500: flag=_wrap_DHLink_Max_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1501: flag=_wrap_new_DHLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1502: flag=_wrap_delete_DHLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1503: flag=_wrap_DHChain_setNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1504: flag=_wrap_DHChain_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1505: flag=_wrap_DHChain_setH0(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1506: flag=_wrap_DHChain_getH0(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1507: flag=_wrap_DHChain_setHN(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1508: flag=_wrap_DHChain_getHN(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1509: flag=_wrap_DHChain_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1510: flag=_wrap_DHChain_getDOFName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1511: flag=_wrap_DHChain_setDOFName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1512: flag=_wrap_DHChain_toModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1513: flag=_wrap_DHChain_fromModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1514: flag=_wrap_new_DHChain(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1515: flag=_wrap_delete_DHChain(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1516: flag=_wrap_TransformFromDHCraig1989(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1517: flag=_wrap_TransformFromDH(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1518: flag=_wrap_ExtractDHChainFromModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1519: flag=_wrap_CreateModelFromDHChain(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1520: flag=_wrap_dofsListFromURDF(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1521: flag=_wrap_dofsListFromURDFString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1522: flag=_wrap_ModelParserOptions_addSensorFramesAsAdditionalFrames_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1523: flag=_wrap_ModelParserOptions_addSensorFramesAsAdditionalFrames_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1524: flag=_wrap_ModelParserOptions_originalFilename_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1525: flag=_wrap_ModelParserOptions_originalFilename_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1526: flag=_wrap_new_ModelParserOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1527: flag=_wrap_delete_ModelParserOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1528: flag=_wrap_new_ModelLoader(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1529: flag=_wrap_delete_ModelLoader(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1530: flag=_wrap_ModelLoader_parsingOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1531: flag=_wrap_ModelLoader_setParsingOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1532: flag=_wrap_ModelLoader_loadModelFromString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1533: flag=_wrap_ModelLoader_loadModelFromFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1534: flag=_wrap_ModelLoader_loadReducedModelFromFullModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1535: flag=_wrap_ModelLoader_loadReducedModelFromString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1536: flag=_wrap_ModelLoader_loadReducedModelFromFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1537: flag=_wrap_ModelLoader_model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1538: flag=_wrap_ModelLoader_sensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1539: flag=_wrap_ModelLoader_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1540: flag=_wrap_ModelExporterOptions_baseLink_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1541: flag=_wrap_ModelExporterOptions_baseLink_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1542: flag=_wrap_ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1543: flag=_wrap_ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1544: flag=_wrap_ModelExporterOptions_robotExportedName_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1545: flag=_wrap_ModelExporterOptions_robotExportedName_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1546: flag=_wrap_ModelExporterOptions_xmlBlobs_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1547: flag=_wrap_ModelExporterOptions_xmlBlobs_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1548: flag=_wrap_new_ModelExporterOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1549: flag=_wrap_delete_ModelExporterOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1550: flag=_wrap_new_ModelExporter(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1551: flag=_wrap_delete_ModelExporter(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1552: flag=_wrap_ModelExporter_exportingOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1553: flag=_wrap_ModelExporter_setExportingOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1554: flag=_wrap_ModelExporter_init(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1555: flag=_wrap_ModelExporter_model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1556: flag=_wrap_ModelExporter_sensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1557: flag=_wrap_ModelExporter_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1558: flag=_wrap_ModelExporter_exportModelToString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1559: flag=_wrap_ModelExporter_exportModelToFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1560: flag=_wrap_new_ModelCalibrationHelper(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1561: flag=_wrap_delete_ModelCalibrationHelper(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1562: flag=_wrap_ModelCalibrationHelper_loadModelFromString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1563: flag=_wrap_ModelCalibrationHelper_loadModelFromFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1564: flag=_wrap_ModelCalibrationHelper_updateModelInertialParametersToString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1565: flag=_wrap_ModelCalibrationHelper_updateModelInertialParametersToFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1566: flag=_wrap_ModelCalibrationHelper_model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1567: flag=_wrap_ModelCalibrationHelper_sensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1568: flag=_wrap_ModelCalibrationHelper_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1569: flag=_wrap_new_UnknownWrenchContact(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1570: flag=_wrap_UnknownWrenchContact_unknownType_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1571: flag=_wrap_UnknownWrenchContact_unknownType_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1572: flag=_wrap_UnknownWrenchContact_contactPoint_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1573: flag=_wrap_UnknownWrenchContact_contactPoint_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1574: flag=_wrap_UnknownWrenchContact_forceDirection_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1575: flag=_wrap_UnknownWrenchContact_forceDirection_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1576: flag=_wrap_UnknownWrenchContact_knownWrench_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1577: flag=_wrap_UnknownWrenchContact_knownWrench_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1578: flag=_wrap_UnknownWrenchContact_contactId_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1579: flag=_wrap_UnknownWrenchContact_contactId_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1580: flag=_wrap_delete_UnknownWrenchContact(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1581: flag=_wrap_new_LinkUnknownWrenchContacts(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1582: flag=_wrap_LinkUnknownWrenchContacts_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1583: flag=_wrap_LinkUnknownWrenchContacts_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1584: flag=_wrap_LinkUnknownWrenchContacts_getNrOfContactsForLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1585: flag=_wrap_LinkUnknownWrenchContacts_setNrOfContactsForLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1586: flag=_wrap_LinkUnknownWrenchContacts_addNewContactForLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1587: flag=_wrap_LinkUnknownWrenchContacts_addNewContactInFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1588: flag=_wrap_LinkUnknownWrenchContacts_addNewUnknownFullWrenchInFrameOrigin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1589: flag=_wrap_LinkUnknownWrenchContacts_contactWrench(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1590: flag=_wrap_LinkUnknownWrenchContacts_toString(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1591: flag=_wrap_delete_LinkUnknownWrenchContacts(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1592: flag=_wrap_new_estimateExternalWrenchesBuffers(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1593: flag=_wrap_estimateExternalWrenchesBuffers_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1594: flag=_wrap_estimateExternalWrenchesBuffers_getNrOfSubModels(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1595: flag=_wrap_estimateExternalWrenchesBuffers_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1596: flag=_wrap_estimateExternalWrenchesBuffers_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1597: flag=_wrap_estimateExternalWrenchesBuffers_A_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1598: flag=_wrap_estimateExternalWrenchesBuffers_A_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1599: flag=_wrap_estimateExternalWrenchesBuffers_x_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1600: flag=_wrap_estimateExternalWrenchesBuffers_x_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1601: flag=_wrap_estimateExternalWrenchesBuffers_b_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1602: flag=_wrap_estimateExternalWrenchesBuffers_b_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1603: flag=_wrap_estimateExternalWrenchesBuffers_b_contacts_subtree_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1604: flag=_wrap_estimateExternalWrenchesBuffers_b_contacts_subtree_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1605: flag=_wrap_estimateExternalWrenchesBuffers_subModelBase_H_link_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1606: flag=_wrap_estimateExternalWrenchesBuffers_subModelBase_H_link_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1607: flag=_wrap_delete_estimateExternalWrenchesBuffers(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1608: flag=_wrap_estimateExternalWrenchesWithoutInternalFT(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1609: flag=_wrap_estimateExternalWrenches(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1610: flag=_wrap_dynamicsEstimationForwardVelAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1611: flag=_wrap_dynamicsEstimationForwardVelKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1612: flag=_wrap_computeLinkNetWrenchesWithoutGravity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1613: flag=_wrap_estimateLinkContactWrenchesFromLinkNetExternalWrenches(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1614: flag=_wrap_new_ExtWrenchesAndJointTorquesEstimator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1615: flag=_wrap_delete_ExtWrenchesAndJointTorquesEstimator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1616: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_setModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1617: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_setModelAndSensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1618: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1619: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFileWithSpecifiedDOFs(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1620: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1621: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_sensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1622: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_submodels(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1623: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1624: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1625: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_computeExpectedFTSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1626: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1627: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_estimateExtWrenchesAndJointTorques(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1628: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_checkThatTheModelIsStill(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1629: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_estimateLinkNetWrenchesWithoutGravity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1630: flag=_wrap_new_SimpleLeggedOdometry(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1631: flag=_wrap_delete_SimpleLeggedOdometry(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1632: flag=_wrap_SimpleLeggedOdometry_setModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1633: flag=_wrap_SimpleLeggedOdometry_model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1634: flag=_wrap_SimpleLeggedOdometry_updateKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1635: flag=_wrap_SimpleLeggedOdometry_init(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1636: flag=_wrap_SimpleLeggedOdometry_changeFixedFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1637: flag=_wrap_SimpleLeggedOdometry_getCurrentFixedLink(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1638: flag=_wrap_SimpleLeggedOdometry_getWorldLinkTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1639: flag=_wrap_SimpleLeggedOdometry_getWorldFrameTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1640: flag=_wrap_isLinkBerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1641: flag=_wrap_isJointBerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1642: flag=_wrap_isDOFBerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1643: flag=_wrap_new_BerdyOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1644: flag=_wrap_BerdyOptions_berdyVariant_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1645: flag=_wrap_BerdyOptions_berdyVariant_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1646: flag=_wrap_BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1647: flag=_wrap_BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1648: flag=_wrap_BerdyOptions_includeAllJointAccelerationsAsSensors_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1649: flag=_wrap_BerdyOptions_includeAllJointAccelerationsAsSensors_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1650: flag=_wrap_BerdyOptions_includeAllJointTorquesAsSensors_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1651: flag=_wrap_BerdyOptions_includeAllJointTorquesAsSensors_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1652: flag=_wrap_BerdyOptions_includeAllNetExternalWrenchesAsSensors_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1653: flag=_wrap_BerdyOptions_includeAllNetExternalWrenchesAsSensors_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1654: flag=_wrap_BerdyOptions_includeFixedBaseExternalWrench_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1655: flag=_wrap_BerdyOptions_includeFixedBaseExternalWrench_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1656: flag=_wrap_BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1657: flag=_wrap_BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1658: flag=_wrap_BerdyOptions_baseLink_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1659: flag=_wrap_BerdyOptions_baseLink_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1660: flag=_wrap_BerdyOptions_checkConsistency(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1661: flag=_wrap_delete_BerdyOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1662: flag=_wrap_BerdySensor_type_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1663: flag=_wrap_BerdySensor_type_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1664: flag=_wrap_BerdySensor_id_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1665: flag=_wrap_BerdySensor_id_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1666: flag=_wrap_BerdySensor_range_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1667: flag=_wrap_BerdySensor_range_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1668: flag=_wrap_BerdySensor_eq(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1669: flag=_wrap_BerdySensor_lt(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1670: flag=_wrap_new_BerdySensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1671: flag=_wrap_delete_BerdySensor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1672: flag=_wrap_BerdyDynamicVariable_type_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1673: flag=_wrap_BerdyDynamicVariable_type_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1674: flag=_wrap_BerdyDynamicVariable_id_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1675: flag=_wrap_BerdyDynamicVariable_id_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1676: flag=_wrap_BerdyDynamicVariable_range_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1677: flag=_wrap_BerdyDynamicVariable_range_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1678: flag=_wrap_BerdyDynamicVariable_eq(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1679: flag=_wrap_BerdyDynamicVariable_lt(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1680: flag=_wrap_new_BerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1681: flag=_wrap_delete_BerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1682: flag=_wrap_new_BerdyHelper(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1683: flag=_wrap_BerdyHelper_dynamicTraversal(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1684: flag=_wrap_BerdyHelper_model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1685: flag=_wrap_BerdyHelper_sensors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1686: flag=_wrap_BerdyHelper_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1687: flag=_wrap_BerdyHelper_init(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1688: flag=_wrap_BerdyHelper_getOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1689: flag=_wrap_BerdyHelper_getNrOfDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1690: flag=_wrap_BerdyHelper_getNrOfDynamicEquations(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1691: flag=_wrap_BerdyHelper_getNrOfSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1692: flag=_wrap_BerdyHelper_resizeAndZeroBerdyMatrices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1693: flag=_wrap_BerdyHelper_getBerdyMatrices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1694: flag=_wrap_BerdyHelper_getSensorsOrdering(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1695: flag=_wrap_BerdyHelper_getRangeSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1696: flag=_wrap_BerdyHelper_getRangeDOFSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1697: flag=_wrap_BerdyHelper_getRangeJointSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1698: flag=_wrap_BerdyHelper_getRangeLinkSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1699: flag=_wrap_BerdyHelper_getRangeRCMSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1700: flag=_wrap_BerdyHelper_getRangeLinkVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1701: flag=_wrap_BerdyHelper_getRangeJointVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1702: flag=_wrap_BerdyHelper_getRangeDOFVariable(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1703: flag=_wrap_BerdyHelper_getDynamicVariablesOrdering(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1704: flag=_wrap_BerdyHelper_serializeDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1705: flag=_wrap_BerdyHelper_serializeSensorVariables(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1706: flag=_wrap_BerdyHelper_serializeDynamicVariablesComputedFromFixedBaseRNEA(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1707: flag=_wrap_BerdyHelper_extractJointTorquesFromDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1708: flag=_wrap_BerdyHelper_extractLinkNetExternalWrenchesFromDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1709: flag=_wrap_BerdyHelper_updateKinematicsFromFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1710: flag=_wrap_BerdyHelper_updateKinematicsFromFixedBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1711: flag=_wrap_BerdyHelper_updateKinematicsFromTraversalFixedBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1712: flag=_wrap_BerdyHelper_setNetExternalWrenchMeasurementFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1713: flag=_wrap_BerdyHelper_getNetExternalWrenchMeasurementFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1714: flag=_wrap_delete_BerdyHelper(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1715: flag=_wrap_new_BerdySparseMAPSolver(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1716: flag=_wrap_delete_BerdySparseMAPSolver(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1717: flag=_wrap_BerdySparseMAPSolver_setDynamicsConstraintsPriorCovariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1718: flag=_wrap_BerdySparseMAPSolver_setDynamicsRegularizationPriorCovariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1719: flag=_wrap_BerdySparseMAPSolver_setDynamicsRegularizationPriorExpectedValue(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1720: flag=_wrap_BerdySparseMAPSolver_setMeasurementsPriorCovariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1721: flag=_wrap_BerdySparseMAPSolver_dynamicsConstraintsPriorCovarianceInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1722: flag=_wrap_BerdySparseMAPSolver_dynamicsRegularizationPriorCovarianceInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1723: flag=_wrap_BerdySparseMAPSolver_dynamicsRegularizationPriorExpectedValue(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1724: flag=_wrap_BerdySparseMAPSolver_measurementsPriorCovarianceInverse(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1725: flag=_wrap_BerdySparseMAPSolver_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1726: flag=_wrap_BerdySparseMAPSolver_initialize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1727: flag=_wrap_BerdySparseMAPSolver_updateEstimateInformationFixedBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1728: flag=_wrap_BerdySparseMAPSolver_updateEstimateInformationFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1729: flag=_wrap_BerdySparseMAPSolver_doEstimate(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1730: flag=_wrap_BerdySparseMAPSolver_getLastEstimate(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1731: flag=_wrap_AttitudeEstimatorState_m_orientation_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1732: flag=_wrap_AttitudeEstimatorState_m_orientation_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1733: flag=_wrap_AttitudeEstimatorState_m_angular_velocity_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1734: flag=_wrap_AttitudeEstimatorState_m_angular_velocity_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1735: flag=_wrap_AttitudeEstimatorState_m_gyroscope_bias_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1736: flag=_wrap_AttitudeEstimatorState_m_gyroscope_bias_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1737: flag=_wrap_new_AttitudeEstimatorState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1738: flag=_wrap_delete_AttitudeEstimatorState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1739: flag=_wrap_delete_IAttitudeEstimator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1740: flag=_wrap_IAttitudeEstimator_updateFilterWithMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1741: flag=_wrap_IAttitudeEstimator_propagateStates(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1742: flag=_wrap_IAttitudeEstimator_getOrientationEstimateAsRotationMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1743: flag=_wrap_IAttitudeEstimator_getOrientationEstimateAsQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1744: flag=_wrap_IAttitudeEstimator_getOrientationEstimateAsRPY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1745: flag=_wrap_IAttitudeEstimator_getInternalStateSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1746: flag=_wrap_IAttitudeEstimator_getInternalState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1747: flag=_wrap_IAttitudeEstimator_getDefaultInternalInitialState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1748: flag=_wrap_IAttitudeEstimator_setInternalState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1749: flag=_wrap_IAttitudeEstimator_setInternalStateInitialOrientation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1750: flag=_wrap_AttitudeMahonyFilterParameters_time_step_in_seconds_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1751: flag=_wrap_AttitudeMahonyFilterParameters_time_step_in_seconds_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1752: flag=_wrap_AttitudeMahonyFilterParameters_kp_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1753: flag=_wrap_AttitudeMahonyFilterParameters_kp_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1754: flag=_wrap_AttitudeMahonyFilterParameters_ki_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1755: flag=_wrap_AttitudeMahonyFilterParameters_ki_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1756: flag=_wrap_AttitudeMahonyFilterParameters_use_magnetometer_measurements_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1757: flag=_wrap_AttitudeMahonyFilterParameters_use_magnetometer_measurements_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1758: flag=_wrap_AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1759: flag=_wrap_AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1760: flag=_wrap_new_AttitudeMahonyFilterParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1761: flag=_wrap_delete_AttitudeMahonyFilterParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1762: flag=_wrap_new_AttitudeMahonyFilter(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1763: flag=_wrap_AttitudeMahonyFilter_useMagnetoMeterMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1764: flag=_wrap_AttitudeMahonyFilter_setConfidenceForMagnetometerMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1765: flag=_wrap_AttitudeMahonyFilter_setGainkp(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1766: flag=_wrap_AttitudeMahonyFilter_setGainki(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1767: flag=_wrap_AttitudeMahonyFilter_setTimeStepInSeconds(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1768: flag=_wrap_AttitudeMahonyFilter_setGravityDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1769: flag=_wrap_AttitudeMahonyFilter_setParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1770: flag=_wrap_AttitudeMahonyFilter_getParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1771: flag=_wrap_AttitudeMahonyFilter_updateFilterWithMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1772: flag=_wrap_AttitudeMahonyFilter_propagateStates(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1773: flag=_wrap_AttitudeMahonyFilter_getOrientationEstimateAsRotationMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1774: flag=_wrap_AttitudeMahonyFilter_getOrientationEstimateAsQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1775: flag=_wrap_AttitudeMahonyFilter_getOrientationEstimateAsRPY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1776: flag=_wrap_AttitudeMahonyFilter_getInternalStateSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1777: flag=_wrap_AttitudeMahonyFilter_getInternalState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1778: flag=_wrap_AttitudeMahonyFilter_getDefaultInternalInitialState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1779: flag=_wrap_AttitudeMahonyFilter_setInternalState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1780: flag=_wrap_AttitudeMahonyFilter_setInternalStateInitialOrientation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1781: flag=_wrap_delete_AttitudeMahonyFilter(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1782: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekf_f(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1783: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekf_h(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1784: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianF(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1785: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianH(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1786: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfPredict(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1787: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfUpdate(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1788: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfInit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1789: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfReset(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1790: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1791: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetInputVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1792: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetInitialState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1793: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetStateCovariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1794: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetSystemNoiseCovariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1795: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementNoiseCovariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1796: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetStateSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1797: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetInputSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1798: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetOutputSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1799: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfGetStates(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1800: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfGetStateCovariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1801: flag=_wrap_delete_DiscreteExtendedKalmanFilterHelper(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1802: flag=_wrap_output_dimensions_with_magnetometer_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1803: flag=_wrap_output_dimensions_without_magnetometer_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1804: flag=_wrap_input_dimensions_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1805: flag=_wrap_AttitudeQuaternionEKFParameters_time_step_in_seconds_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1806: flag=_wrap_AttitudeQuaternionEKFParameters_time_step_in_seconds_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1807: flag=_wrap_AttitudeQuaternionEKFParameters_bias_correlation_time_factor_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1808: flag=_wrap_AttitudeQuaternionEKFParameters_bias_correlation_time_factor_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1809: flag=_wrap_AttitudeQuaternionEKFParameters_accelerometer_noise_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1810: flag=_wrap_AttitudeQuaternionEKFParameters_accelerometer_noise_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1811: flag=_wrap_AttitudeQuaternionEKFParameters_magnetometer_noise_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1812: flag=_wrap_AttitudeQuaternionEKFParameters_magnetometer_noise_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1813: flag=_wrap_AttitudeQuaternionEKFParameters_gyroscope_noise_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1814: flag=_wrap_AttitudeQuaternionEKFParameters_gyroscope_noise_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1815: flag=_wrap_AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1816: flag=_wrap_AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1817: flag=_wrap_AttitudeQuaternionEKFParameters_initial_orientation_error_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1818: flag=_wrap_AttitudeQuaternionEKFParameters_initial_orientation_error_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1819: flag=_wrap_AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1820: flag=_wrap_AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1821: flag=_wrap_AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1822: flag=_wrap_AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1823: flag=_wrap_AttitudeQuaternionEKFParameters_use_magnetometer_measurements_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1824: flag=_wrap_AttitudeQuaternionEKFParameters_use_magnetometer_measurements_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1825: flag=_wrap_new_AttitudeQuaternionEKFParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1826: flag=_wrap_delete_AttitudeQuaternionEKFParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1827: flag=_wrap_new_AttitudeQuaternionEKF(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1828: flag=_wrap_AttitudeQuaternionEKF_getParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1829: flag=_wrap_AttitudeQuaternionEKF_setParameters(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1830: flag=_wrap_AttitudeQuaternionEKF_setGravityDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1831: flag=_wrap_AttitudeQuaternionEKF_setTimeStepInSeconds(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1832: flag=_wrap_AttitudeQuaternionEKF_setBiasCorrelationTimeFactor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1833: flag=_wrap_AttitudeQuaternionEKF_useMagnetometerMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1834: flag=_wrap_AttitudeQuaternionEKF_setMeasurementNoiseVariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1835: flag=_wrap_AttitudeQuaternionEKF_setSystemNoiseVariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1836: flag=_wrap_AttitudeQuaternionEKF_setInitialStateCovariance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1837: flag=_wrap_AttitudeQuaternionEKF_initializeFilter(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1838: flag=_wrap_AttitudeQuaternionEKF_updateFilterWithMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1839: flag=_wrap_AttitudeQuaternionEKF_propagateStates(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1840: flag=_wrap_AttitudeQuaternionEKF_getOrientationEstimateAsRotationMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1841: flag=_wrap_AttitudeQuaternionEKF_getOrientationEstimateAsQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1842: flag=_wrap_AttitudeQuaternionEKF_getOrientationEstimateAsRPY(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1843: flag=_wrap_AttitudeQuaternionEKF_getInternalStateSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1844: flag=_wrap_AttitudeQuaternionEKF_getInternalState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1845: flag=_wrap_AttitudeQuaternionEKF_getDefaultInternalInitialState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1846: flag=_wrap_AttitudeQuaternionEKF_setInternalState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1847: flag=_wrap_AttitudeQuaternionEKF_setInternalStateInitialOrientation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1848: flag=_wrap_delete_AttitudeQuaternionEKF(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1849: flag=_wrap_estimateInertialParametersFromLinkBoundingBoxesAndTotalMass(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1850: flag=_wrap_computeBoundingBoxFromShape(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1851: flag=_wrap_computeBoxVertices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1852: flag=_wrap_new_KinDynComputations(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1853: flag=_wrap_delete_KinDynComputations(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1854: flag=_wrap_KinDynComputations_loadRobotModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1855: flag=_wrap_KinDynComputations_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1856: flag=_wrap_KinDynComputations_setFrameVelocityRepresentation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1857: flag=_wrap_KinDynComputations_getFrameVelocityRepresentation(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1858: flag=_wrap_KinDynComputations_getNrOfDegreesOfFreedom(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1859: flag=_wrap_KinDynComputations_getDescriptionOfDegreeOfFreedom(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1860: flag=_wrap_KinDynComputations_getDescriptionOfDegreesOfFreedom(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1861: flag=_wrap_KinDynComputations_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1862: flag=_wrap_KinDynComputations_getNrOfFrames(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1863: flag=_wrap_KinDynComputations_getFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1864: flag=_wrap_KinDynComputations_setFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1865: flag=_wrap_KinDynComputations_model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1866: flag=_wrap_KinDynComputations_getRobotModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1867: flag=_wrap_KinDynComputations_getRelativeJacobianSparsityPattern(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1868: flag=_wrap_KinDynComputations_getFrameFreeFloatingJacobianSparsityPattern(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1869: flag=_wrap_KinDynComputations_setJointPos(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1870: flag=_wrap_KinDynComputations_setRobotState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1871: flag=_wrap_KinDynComputations_getRobotState(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1872: flag=_wrap_KinDynComputations_getWorldBaseTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1873: flag=_wrap_KinDynComputations_getBaseTwist(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1874: flag=_wrap_KinDynComputations_getJointPos(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1875: flag=_wrap_KinDynComputations_getJointVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1876: flag=_wrap_KinDynComputations_getModelVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1877: flag=_wrap_KinDynComputations_getFrameIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1878: flag=_wrap_KinDynComputations_getFrameName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1879: flag=_wrap_KinDynComputations_getWorldTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1880: flag=_wrap_KinDynComputations_getWorldTransformsAsHomogeneous(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1881: flag=_wrap_KinDynComputations_getRelativeTransformExplicit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1882: flag=_wrap_KinDynComputations_getRelativeTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1883: flag=_wrap_KinDynComputations_getFrameVel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1884: flag=_wrap_KinDynComputations_getFrameAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1885: flag=_wrap_KinDynComputations_getFrameFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1886: flag=_wrap_KinDynComputations_getRelativeJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1887: flag=_wrap_KinDynComputations_getRelativeJacobianExplicit(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1888: flag=_wrap_KinDynComputations_getFrameBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1889: flag=_wrap_KinDynComputations_getCenterOfMassPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1890: flag=_wrap_KinDynComputations_getCenterOfMassVelocity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1891: flag=_wrap_KinDynComputations_getCenterOfMassJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1892: flag=_wrap_KinDynComputations_getCenterOfMassBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1893: flag=_wrap_KinDynComputations_getAverageVelocity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1894: flag=_wrap_KinDynComputations_getAverageVelocityJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1895: flag=_wrap_KinDynComputations_getCentroidalAverageVelocity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1896: flag=_wrap_KinDynComputations_getCentroidalAverageVelocityJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1897: flag=_wrap_KinDynComputations_getLinearAngularMomentum(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1898: flag=_wrap_KinDynComputations_getLinearAngularMomentumJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1899: flag=_wrap_KinDynComputations_getCentroidalTotalMomentum(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1900: flag=_wrap_KinDynComputations_getCentroidalTotalMomentumJacobian(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1901: flag=_wrap_KinDynComputations_getFreeFloatingMassMatrix(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1902: flag=_wrap_KinDynComputations_inverseDynamics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1903: flag=_wrap_KinDynComputations_inverseDynamicsWithInternalJointForceTorques(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1904: flag=_wrap_KinDynComputations_generalizedBiasForces(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1905: flag=_wrap_KinDynComputations_generalizedGravityForces(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1906: flag=_wrap_KinDynComputations_generalizedExternalForces(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1907: flag=_wrap_KinDynComputations_inverseDynamicsInertialParametersRegressor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1908: flag=_wrap_Matrix4x4Vector_pop(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1909: flag=_wrap_Matrix4x4Vector_brace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1910: flag=_wrap_Matrix4x4Vector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1911: flag=_wrap_Matrix4x4Vector_append(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1912: flag=_wrap_Matrix4x4Vector_empty(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1913: flag=_wrap_Matrix4x4Vector_size(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1914: flag=_wrap_Matrix4x4Vector_swap(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1915: flag=_wrap_Matrix4x4Vector_begin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1916: flag=_wrap_Matrix4x4Vector_end(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1917: flag=_wrap_Matrix4x4Vector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1918: flag=_wrap_Matrix4x4Vector_rend(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1919: flag=_wrap_Matrix4x4Vector_clear(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1920: flag=_wrap_Matrix4x4Vector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1921: flag=_wrap_Matrix4x4Vector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1922: flag=_wrap_Matrix4x4Vector_erase(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1923: flag=_wrap_new_Matrix4x4Vector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1924: flag=_wrap_Matrix4x4Vector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1925: flag=_wrap_Matrix4x4Vector_front(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1926: flag=_wrap_Matrix4x4Vector_back(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1927: flag=_wrap_Matrix4x4Vector_assign(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1928: flag=_wrap_Matrix4x4Vector_resize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1929: flag=_wrap_Matrix4x4Vector_insert(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1930: flag=_wrap_Matrix4x4Vector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1931: flag=_wrap_Matrix4x4Vector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1932: flag=_wrap_Matrix4x4Vector_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1933: flag=_wrap_delete_Matrix4x4Vector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1934: flag=_wrap_ICameraAnimator_enableMouseControl(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1935: flag=_wrap_ICameraAnimator_getMoveSpeed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1936: flag=_wrap_ICameraAnimator_setMoveSpeed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1937: flag=_wrap_ICameraAnimator_getRotateSpeed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1938: flag=_wrap_ICameraAnimator_setRotateSpeed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1939: flag=_wrap_ICameraAnimator_getZoomSpeed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1940: flag=_wrap_ICameraAnimator_setZoomSpeed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1941: flag=_wrap_delete_ICameraAnimator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1942: flag=_wrap_delete_ICamera(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1943: flag=_wrap_ICamera_setPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1944: flag=_wrap_ICamera_setTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1945: flag=_wrap_ICamera_getPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1946: flag=_wrap_ICamera_getTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1947: flag=_wrap_ICamera_setUpVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1948: flag=_wrap_ICamera_animator(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1949: flag=_wrap_ColorViz_r_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1950: flag=_wrap_ColorViz_r_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1951: flag=_wrap_ColorViz_g_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1952: flag=_wrap_ColorViz_g_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1953: flag=_wrap_ColorViz_b_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1954: flag=_wrap_ColorViz_b_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1955: flag=_wrap_ColorViz_a_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1956: flag=_wrap_ColorViz_a_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1957: flag=_wrap_new_ColorViz(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1958: flag=_wrap_delete_ColorViz(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1959: flag=_wrap_PixelViz_width_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1960: flag=_wrap_PixelViz_width_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1961: flag=_wrap_PixelViz_height_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1962: flag=_wrap_PixelViz_height_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1963: flag=_wrap_new_PixelViz(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1964: flag=_wrap_delete_PixelViz(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1965: flag=_wrap_delete_ILight(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1966: flag=_wrap_ILight_getName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1967: flag=_wrap_ILight_setType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1968: flag=_wrap_ILight_getType(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1969: flag=_wrap_ILight_setPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1970: flag=_wrap_ILight_getPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1971: flag=_wrap_ILight_setDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1972: flag=_wrap_ILight_getDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1973: flag=_wrap_ILight_setAmbientColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1974: flag=_wrap_ILight_getAmbientColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1975: flag=_wrap_ILight_setSpecularColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1976: flag=_wrap_ILight_getSpecularColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1977: flag=_wrap_ILight_setDiffuseColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1978: flag=_wrap_ILight_getDiffuseColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1979: flag=_wrap_delete_IEnvironment(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1980: flag=_wrap_IEnvironment_getElements(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1981: flag=_wrap_IEnvironment_setElementVisibility(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1982: flag=_wrap_IEnvironment_setBackgroundColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1983: flag=_wrap_IEnvironment_setFloorGridColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1984: flag=_wrap_IEnvironment_setAmbientLight(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1985: flag=_wrap_IEnvironment_getLights(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1986: flag=_wrap_IEnvironment_addLight(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1987: flag=_wrap_IEnvironment_lightViz(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1988: flag=_wrap_IEnvironment_removeLight(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1989: flag=_wrap_delete_IJetsVisualization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1990: flag=_wrap_IJetsVisualization_setJetsFrames(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1991: flag=_wrap_IJetsVisualization_getNrOfJets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1992: flag=_wrap_IJetsVisualization_getJetDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1993: flag=_wrap_IJetsVisualization_setJetDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1994: flag=_wrap_IJetsVisualization_setJetColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1995: flag=_wrap_IJetsVisualization_setJetsDimensions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1996: flag=_wrap_IJetsVisualization_setJetsIntensity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1997: flag=_wrap_delete_ILabel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1998: flag=_wrap_ILabel_setText(resc,resv,argc,(mxArray**)(argv)); break;
-  case 1999: flag=_wrap_ILabel_getText(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2000: flag=_wrap_ILabel_setSize(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2001: flag=_wrap_ILabel_width(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2002: flag=_wrap_ILabel_height(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2003: flag=_wrap_ILabel_setPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2004: flag=_wrap_ILabel_getPosition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2005: flag=_wrap_ILabel_setColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2006: flag=_wrap_ILabel_setVisible(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2007: flag=_wrap_delete_IVectorsVisualization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2008: flag=_wrap_IVectorsVisualization_addVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2009: flag=_wrap_IVectorsVisualization_getNrOfVectors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2010: flag=_wrap_IVectorsVisualization_getVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2011: flag=_wrap_IVectorsVisualization_updateVector(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2012: flag=_wrap_IVectorsVisualization_setVectorColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2013: flag=_wrap_IVectorsVisualization_setVectorsDefaultColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2014: flag=_wrap_IVectorsVisualization_setVectorsColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2015: flag=_wrap_IVectorsVisualization_setVectorsAspect(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2016: flag=_wrap_IVectorsVisualization_setVisible(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2017: flag=_wrap_IVectorsVisualization_getVectorLabel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2018: flag=_wrap_delete_IFrameVisualization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2019: flag=_wrap_IFrameVisualization_addFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2020: flag=_wrap_IFrameVisualization_setVisible(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2021: flag=_wrap_IFrameVisualization_getNrOfFrames(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2022: flag=_wrap_IFrameVisualization_getFrameTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2023: flag=_wrap_IFrameVisualization_updateFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2024: flag=_wrap_IFrameVisualization_getFrameLabel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2025: flag=_wrap_delete_IModelVisualization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2026: flag=_wrap_IModelVisualization_setPositions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2027: flag=_wrap_IModelVisualization_setLinkPositions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2028: flag=_wrap_IModelVisualization_model(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2029: flag=_wrap_IModelVisualization_getInstanceName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2030: flag=_wrap_IModelVisualization_setModelVisibility(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2031: flag=_wrap_IModelVisualization_setModelColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2032: flag=_wrap_IModelVisualization_resetModelColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2033: flag=_wrap_IModelVisualization_setLinkColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2034: flag=_wrap_IModelVisualization_resetLinkColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2035: flag=_wrap_IModelVisualization_getLinkNames(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2036: flag=_wrap_IModelVisualization_setLinkVisibility(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2037: flag=_wrap_IModelVisualization_getFeatures(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2038: flag=_wrap_IModelVisualization_setFeatureVisibility(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2039: flag=_wrap_IModelVisualization_jets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2040: flag=_wrap_IModelVisualization_getWorldLinkTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2041: flag=_wrap_IModelVisualization_getWorldFrameTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2042: flag=_wrap_IModelVisualization_label(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2043: flag=_wrap_delete_ITexture(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2044: flag=_wrap_ITexture_environment(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2045: flag=_wrap_ITexture_getPixelColor(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2046: flag=_wrap_ITexture_getPixels(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2047: flag=_wrap_ITexture_drawToFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2048: flag=_wrap_ITexture_enableDraw(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2049: flag=_wrap_ITexture_width(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2050: flag=_wrap_ITexture_height(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2051: flag=_wrap_ITexture_setSubDrawArea(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2052: flag=_wrap_VisualizerOptions_verbose_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2053: flag=_wrap_VisualizerOptions_verbose_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2054: flag=_wrap_VisualizerOptions_winWidth_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2055: flag=_wrap_VisualizerOptions_winWidth_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2056: flag=_wrap_VisualizerOptions_winHeight_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2057: flag=_wrap_VisualizerOptions_winHeight_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2058: flag=_wrap_VisualizerOptions_rootFrameArrowsDimension_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2059: flag=_wrap_VisualizerOptions_rootFrameArrowsDimension_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2060: flag=_wrap_new_VisualizerOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2061: flag=_wrap_delete_VisualizerOptions(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2062: flag=_wrap_delete_ITexturesHandler(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2063: flag=_wrap_ITexturesHandler_add(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2064: flag=_wrap_ITexturesHandler_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2065: flag=_wrap_new_Visualizer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2066: flag=_wrap_delete_Visualizer(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2067: flag=_wrap_Visualizer_init(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2068: flag=_wrap_Visualizer_getNrOfVisualizedModels(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2069: flag=_wrap_Visualizer_getModelInstanceName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2070: flag=_wrap_Visualizer_getModelInstanceIndex(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2071: flag=_wrap_Visualizer_addModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2072: flag=_wrap_Visualizer_modelViz(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2073: flag=_wrap_Visualizer_camera(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2074: flag=_wrap_Visualizer_enviroment(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2075: flag=_wrap_Visualizer_environment(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2076: flag=_wrap_Visualizer_vectors(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2077: flag=_wrap_Visualizer_frames(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2078: flag=_wrap_Visualizer_textures(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2079: flag=_wrap_Visualizer_getLabel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2080: flag=_wrap_Visualizer_width(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2081: flag=_wrap_Visualizer_height(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2082: flag=_wrap_Visualizer_run(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2083: flag=_wrap_Visualizer_draw(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2084: flag=_wrap_Visualizer_subDraw(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2085: flag=_wrap_Visualizer_drawToFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2086: flag=_wrap_Visualizer_close(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2087: flag=_wrap_Visualizer_isWindowActive(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2088: flag=_wrap_Visualizer_setColorPalette(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2089: flag=_wrap_Polygon_m_vertices_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2090: flag=_wrap_Polygon_m_vertices_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2091: flag=_wrap_new_Polygon(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2092: flag=_wrap_Polygon_setNrOfVertices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2093: flag=_wrap_Polygon_getNrOfVertices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2094: flag=_wrap_Polygon_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2095: flag=_wrap_Polygon_applyTransform(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2096: flag=_wrap_Polygon_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2097: flag=_wrap_Polygon_XYRectangleFromOffsets(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2098: flag=_wrap_delete_Polygon(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2099: flag=_wrap_Polygon2D_m_vertices_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2100: flag=_wrap_Polygon2D_m_vertices_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2101: flag=_wrap_new_Polygon2D(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2102: flag=_wrap_Polygon2D_setNrOfVertices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2103: flag=_wrap_Polygon2D_getNrOfVertices(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2104: flag=_wrap_Polygon2D_isValid(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2105: flag=_wrap_Polygon2D_paren(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2106: flag=_wrap_delete_Polygon2D(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2107: flag=_wrap_ConvexHullProjectionConstraint_setActive(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2108: flag=_wrap_ConvexHullProjectionConstraint_isActive(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2109: flag=_wrap_ConvexHullProjectionConstraint_getNrOfConstraints(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2110: flag=_wrap_ConvexHullProjectionConstraint_projectedConvexHull_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2111: flag=_wrap_ConvexHullProjectionConstraint_projectedConvexHull_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2112: flag=_wrap_ConvexHullProjectionConstraint_A_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2113: flag=_wrap_ConvexHullProjectionConstraint_A_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2114: flag=_wrap_ConvexHullProjectionConstraint_b_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2115: flag=_wrap_ConvexHullProjectionConstraint_b_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2116: flag=_wrap_ConvexHullProjectionConstraint_P_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2117: flag=_wrap_ConvexHullProjectionConstraint_P_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2118: flag=_wrap_ConvexHullProjectionConstraint_Pdirection_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2119: flag=_wrap_ConvexHullProjectionConstraint_Pdirection_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2120: flag=_wrap_ConvexHullProjectionConstraint_AtimesP_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2121: flag=_wrap_ConvexHullProjectionConstraint_AtimesP_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2122: flag=_wrap_ConvexHullProjectionConstraint_o_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2123: flag=_wrap_ConvexHullProjectionConstraint_o_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2124: flag=_wrap_ConvexHullProjectionConstraint_buildConvexHull(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2125: flag=_wrap_ConvexHullProjectionConstraint_supportFrameIndices_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2126: flag=_wrap_ConvexHullProjectionConstraint_supportFrameIndices_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2127: flag=_wrap_ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_get(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2128: flag=_wrap_ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_set(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2129: flag=_wrap_ConvexHullProjectionConstraint_project(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2130: flag=_wrap_ConvexHullProjectionConstraint_computeMargin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2131: flag=_wrap_ConvexHullProjectionConstraint_setProjectionAlongDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2132: flag=_wrap_ConvexHullProjectionConstraint_projectAlongDirection(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2133: flag=_wrap_new_ConvexHullProjectionConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2134: flag=_wrap_delete_ConvexHullProjectionConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2135: flag=_wrap_sizeOfRotationParametrization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2136: flag=_wrap_new_InverseKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2137: flag=_wrap_delete_InverseKinematics(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2138: flag=_wrap_InverseKinematics_loadModelFromFile(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2139: flag=_wrap_InverseKinematics_setModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2140: flag=_wrap_InverseKinematics_setJointLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2141: flag=_wrap_InverseKinematics_getJointLimits(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2142: flag=_wrap_InverseKinematics_clearProblem(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2143: flag=_wrap_InverseKinematics_setFloatingBaseOnFrameNamed(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2144: flag=_wrap_InverseKinematics_setCurrentRobotConfiguration(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2145: flag=_wrap_InverseKinematics_setJointConfiguration(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2146: flag=_wrap_InverseKinematics_setRotationParametrization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2147: flag=_wrap_InverseKinematics_rotationParametrization(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2148: flag=_wrap_InverseKinematics_setMaxIterations(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2149: flag=_wrap_InverseKinematics_maxIterations(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2150: flag=_wrap_InverseKinematics_setMaxCPUTime(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2151: flag=_wrap_InverseKinematics_maxCPUTime(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2152: flag=_wrap_InverseKinematics_setCostTolerance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2153: flag=_wrap_InverseKinematics_costTolerance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2154: flag=_wrap_InverseKinematics_setConstraintsTolerance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2155: flag=_wrap_InverseKinematics_constraintsTolerance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2156: flag=_wrap_InverseKinematics_setVerbosity(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2157: flag=_wrap_InverseKinematics_linearSolverName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2158: flag=_wrap_InverseKinematics_setLinearSolverName(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2159: flag=_wrap_InverseKinematics_addFrameConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2160: flag=_wrap_InverseKinematics_addFramePositionConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2161: flag=_wrap_InverseKinematics_addFrameRotationConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2162: flag=_wrap_InverseKinematics_activateFrameConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2163: flag=_wrap_InverseKinematics_deactivateFrameConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2164: flag=_wrap_InverseKinematics_isFrameConstraintActive(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2165: flag=_wrap_InverseKinematics_addCenterOfMassProjectionConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2166: flag=_wrap_InverseKinematics_getCenterOfMassProjectionMargin(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2167: flag=_wrap_InverseKinematics_getCenterOfMassProjectConstraintConvexHull(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2168: flag=_wrap_InverseKinematics_addTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2169: flag=_wrap_InverseKinematics_addPositionTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2170: flag=_wrap_InverseKinematics_addRotationTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2171: flag=_wrap_InverseKinematics_updateTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2172: flag=_wrap_InverseKinematics_updatePositionTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2173: flag=_wrap_InverseKinematics_updateRotationTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2174: flag=_wrap_InverseKinematics_setDefaultTargetResolutionMode(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2175: flag=_wrap_InverseKinematics_defaultTargetResolutionMode(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2176: flag=_wrap_InverseKinematics_setTargetResolutionMode(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2177: flag=_wrap_InverseKinematics_targetResolutionMode(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2178: flag=_wrap_InverseKinematics_setDesiredFullJointsConfiguration(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2179: flag=_wrap_InverseKinematics_setDesiredReducedJointConfiguration(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2180: flag=_wrap_InverseKinematics_setFullJointsInitialCondition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2181: flag=_wrap_InverseKinematics_setReducedInitialCondition(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2182: flag=_wrap_InverseKinematics_solve(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2183: flag=_wrap_InverseKinematics_getFullJointsSolution(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2184: flag=_wrap_InverseKinematics_getReducedSolution(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2185: flag=_wrap_InverseKinematics_getPoseForFrame(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2186: flag=_wrap_InverseKinematics_fullModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2187: flag=_wrap_InverseKinematics_reducedModel(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2188: flag=_wrap_InverseKinematics_setCOMTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2189: flag=_wrap_InverseKinematics_setCOMAsConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2190: flag=_wrap_InverseKinematics_setCOMAsConstraintTolerance(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2191: flag=_wrap_InverseKinematics_isCOMAConstraint(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2192: flag=_wrap_InverseKinematics_isCOMTargetActive(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2193: flag=_wrap_InverseKinematics_deactivateCOMTarget(resc,resv,argc,(mxArray**)(argv)); break;
-  case 2194: flag=_wrap_InverseKinematics_setCOMConstraintProjectionDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 71: flag=_wrap_BerdySensors_pop(resc,resv,argc,(mxArray**)(argv)); break;
+  case 72: flag=_wrap_BerdySensors_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 73: flag=_wrap_BerdySensors_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 74: flag=_wrap_BerdySensors_append(resc,resv,argc,(mxArray**)(argv)); break;
+  case 75: flag=_wrap_BerdySensors_empty(resc,resv,argc,(mxArray**)(argv)); break;
+  case 76: flag=_wrap_BerdySensors_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 77: flag=_wrap_BerdySensors_swap(resc,resv,argc,(mxArray**)(argv)); break;
+  case 78: flag=_wrap_BerdySensors_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 79: flag=_wrap_BerdySensors_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 80: flag=_wrap_BerdySensors_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 81: flag=_wrap_BerdySensors_rend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 82: flag=_wrap_BerdySensors_clear(resc,resv,argc,(mxArray**)(argv)); break;
+  case 83: flag=_wrap_BerdySensors_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 84: flag=_wrap_BerdySensors_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 85: flag=_wrap_BerdySensors_erase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 86: flag=_wrap_new_BerdySensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 87: flag=_wrap_BerdySensors_push_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 88: flag=_wrap_BerdySensors_front(resc,resv,argc,(mxArray**)(argv)); break;
+  case 89: flag=_wrap_BerdySensors_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 90: flag=_wrap_BerdySensors_assign(resc,resv,argc,(mxArray**)(argv)); break;
+  case 91: flag=_wrap_BerdySensors_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 92: flag=_wrap_BerdySensors_insert(resc,resv,argc,(mxArray**)(argv)); break;
+  case 93: flag=_wrap_BerdySensors_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 94: flag=_wrap_BerdySensors_capacity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 95: flag=_wrap_delete_BerdySensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 96: flag=_wrap_BerdyDynamicVariables_pop(resc,resv,argc,(mxArray**)(argv)); break;
+  case 97: flag=_wrap_BerdyDynamicVariables_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 98: flag=_wrap_BerdyDynamicVariables_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 99: flag=_wrap_BerdyDynamicVariables_append(resc,resv,argc,(mxArray**)(argv)); break;
+  case 100: flag=_wrap_BerdyDynamicVariables_empty(resc,resv,argc,(mxArray**)(argv)); break;
+  case 101: flag=_wrap_BerdyDynamicVariables_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 102: flag=_wrap_BerdyDynamicVariables_swap(resc,resv,argc,(mxArray**)(argv)); break;
+  case 103: flag=_wrap_BerdyDynamicVariables_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 104: flag=_wrap_BerdyDynamicVariables_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 105: flag=_wrap_BerdyDynamicVariables_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 106: flag=_wrap_BerdyDynamicVariables_rend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 107: flag=_wrap_BerdyDynamicVariables_clear(resc,resv,argc,(mxArray**)(argv)); break;
+  case 108: flag=_wrap_BerdyDynamicVariables_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 109: flag=_wrap_BerdyDynamicVariables_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 110: flag=_wrap_BerdyDynamicVariables_erase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 111: flag=_wrap_new_BerdyDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
+  case 112: flag=_wrap_BerdyDynamicVariables_push_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 113: flag=_wrap_BerdyDynamicVariables_front(resc,resv,argc,(mxArray**)(argv)); break;
+  case 114: flag=_wrap_BerdyDynamicVariables_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 115: flag=_wrap_BerdyDynamicVariables_assign(resc,resv,argc,(mxArray**)(argv)); break;
+  case 116: flag=_wrap_BerdyDynamicVariables_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 117: flag=_wrap_BerdyDynamicVariables_insert(resc,resv,argc,(mxArray**)(argv)); break;
+  case 118: flag=_wrap_BerdyDynamicVariables_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 119: flag=_wrap_BerdyDynamicVariables_capacity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 120: flag=_wrap_delete_BerdyDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
+  case 121: flag=_wrap_reportInfo(resc,resv,argc,(mxArray**)(argv)); break;
+  case 122: flag=_wrap_reportDebug(resc,resv,argc,(mxArray**)(argv)); break;
+  case 123: flag=_wrap_IndexRange_offset_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 124: flag=_wrap_IndexRange_offset_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 125: flag=_wrap_IndexRange_size_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 126: flag=_wrap_IndexRange_size_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 127: flag=_wrap_IndexRange_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 128: flag=_wrap_IndexRange_InvalidRange(resc,resv,argc,(mxArray**)(argv)); break;
+  case 129: flag=_wrap_new_IndexRange(resc,resv,argc,(mxArray**)(argv)); break;
+  case 130: flag=_wrap_delete_IndexRange(resc,resv,argc,(mxArray**)(argv)); break;
+  case 131: flag=_wrap_checkDoublesAreEqual(resc,resv,argc,(mxArray**)(argv)); break;
+  case 132: flag=_wrap_new_MatrixDynSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 133: flag=_wrap_delete_MatrixDynSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 134: flag=_wrap_MatrixDynSize_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 135: flag=_wrap_MatrixDynSize_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 136: flag=_wrap_MatrixDynSize_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 137: flag=_wrap_MatrixDynSize_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 138: flag=_wrap_MatrixDynSize_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 139: flag=_wrap_MatrixDynSize_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 140: flag=_wrap_MatrixDynSize_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 141: flag=_wrap_MatrixDynSize_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 142: flag=_wrap_MatrixDynSize_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 143: flag=_wrap_MatrixDynSize_capacity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 144: flag=_wrap_MatrixDynSize_shrink_to_fit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 145: flag=_wrap_MatrixDynSize_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 146: flag=_wrap_MatrixDynSize_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 147: flag=_wrap_MatrixDynSize_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 148: flag=_wrap_MatrixDynSize_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 149: flag=_wrap_MatrixDynSize_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 150: flag=_wrap_MatrixDynSize_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 151: flag=_wrap_new_SparseMatrixRowMajor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 152: flag=_wrap_delete_SparseMatrixRowMajor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 153: flag=_wrap_SparseMatrixRowMajor_numberOfNonZeros(resc,resv,argc,(mxArray**)(argv)); break;
+  case 154: flag=_wrap_SparseMatrixRowMajor_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 155: flag=_wrap_SparseMatrixRowMajor_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 156: flag=_wrap_SparseMatrixRowMajor_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 157: flag=_wrap_SparseMatrixRowMajor_setFromConstTriplets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 158: flag=_wrap_SparseMatrixRowMajor_setFromTriplets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 159: flag=_wrap_SparseMatrixRowMajor_sparseMatrixFromTriplets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 160: flag=_wrap_SparseMatrixRowMajor_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 161: flag=_wrap_SparseMatrixRowMajor_getValue(resc,resv,argc,(mxArray**)(argv)); break;
+  case 162: flag=_wrap_SparseMatrixRowMajor_setValue(resc,resv,argc,(mxArray**)(argv)); break;
+  case 163: flag=_wrap_SparseMatrixRowMajor_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 164: flag=_wrap_SparseMatrixRowMajor_columns(resc,resv,argc,(mxArray**)(argv)); break;
+  case 165: flag=_wrap_SparseMatrixRowMajor_description(resc,resv,argc,(mxArray**)(argv)); break;
+  case 166: flag=_wrap_SparseMatrixRowMajor_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 167: flag=_wrap_SparseMatrixRowMajor_toMatlabDense(resc,resv,argc,(mxArray**)(argv)); break;
+  case 168: flag=_wrap_SparseMatrixRowMajor_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 169: flag=_wrap_new_SparseMatrixColMajor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 170: flag=_wrap_delete_SparseMatrixColMajor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 171: flag=_wrap_SparseMatrixColMajor_numberOfNonZeros(resc,resv,argc,(mxArray**)(argv)); break;
+  case 172: flag=_wrap_SparseMatrixColMajor_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 173: flag=_wrap_SparseMatrixColMajor_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 174: flag=_wrap_SparseMatrixColMajor_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 175: flag=_wrap_SparseMatrixColMajor_setFromConstTriplets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 176: flag=_wrap_SparseMatrixColMajor_setFromTriplets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 177: flag=_wrap_SparseMatrixColMajor_sparseMatrixFromTriplets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 178: flag=_wrap_SparseMatrixColMajor_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 179: flag=_wrap_SparseMatrixColMajor_getValue(resc,resv,argc,(mxArray**)(argv)); break;
+  case 180: flag=_wrap_SparseMatrixColMajor_setValue(resc,resv,argc,(mxArray**)(argv)); break;
+  case 181: flag=_wrap_SparseMatrixColMajor_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 182: flag=_wrap_SparseMatrixColMajor_columns(resc,resv,argc,(mxArray**)(argv)); break;
+  case 183: flag=_wrap_SparseMatrixColMajor_description(resc,resv,argc,(mxArray**)(argv)); break;
+  case 184: flag=_wrap_SparseMatrixColMajor_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 185: flag=_wrap_SparseMatrixColMajor_toMatlabDense(resc,resv,argc,(mxArray**)(argv)); break;
+  case 186: flag=_wrap_SparseMatrixColMajor_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 187: flag=_wrap_new_VectorDynSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 188: flag=_wrap_delete_VectorDynSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 189: flag=_wrap_VectorDynSize_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 190: flag=_wrap_VectorDynSize_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 191: flag=_wrap_VectorDynSize_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 192: flag=_wrap_VectorDynSize_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 193: flag=_wrap_VectorDynSize_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 194: flag=_wrap_VectorDynSize_cend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 195: flag=_wrap_VectorDynSize_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 196: flag=_wrap_VectorDynSize_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 197: flag=_wrap_VectorDynSize_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 198: flag=_wrap_VectorDynSize_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 199: flag=_wrap_VectorDynSize_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 200: flag=_wrap_VectorDynSize_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 201: flag=_wrap_VectorDynSize_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 202: flag=_wrap_VectorDynSize_shrink_to_fit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 203: flag=_wrap_VectorDynSize_capacity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 204: flag=_wrap_VectorDynSize_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 205: flag=_wrap_VectorDynSize_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 206: flag=_wrap_VectorDynSize_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 207: flag=_wrap_VectorDynSize_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 208: flag=_wrap_VectorDynSize_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 209: flag=_wrap_new_Matrix1x6(resc,resv,argc,(mxArray**)(argv)); break;
+  case 210: flag=_wrap_Matrix1x6_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 211: flag=_wrap_Matrix1x6_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 212: flag=_wrap_Matrix1x6_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 213: flag=_wrap_Matrix1x6_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 214: flag=_wrap_Matrix1x6_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 215: flag=_wrap_Matrix1x6_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 216: flag=_wrap_Matrix1x6_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 217: flag=_wrap_Matrix1x6_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 218: flag=_wrap_Matrix1x6_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 219: flag=_wrap_Matrix1x6_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 220: flag=_wrap_Matrix1x6_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 221: flag=_wrap_Matrix1x6_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 222: flag=_wrap_Matrix1x6_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 223: flag=_wrap_delete_Matrix1x6(resc,resv,argc,(mxArray**)(argv)); break;
+  case 224: flag=_wrap_new_Matrix2x3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 225: flag=_wrap_Matrix2x3_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 226: flag=_wrap_Matrix2x3_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 227: flag=_wrap_Matrix2x3_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 228: flag=_wrap_Matrix2x3_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 229: flag=_wrap_Matrix2x3_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 230: flag=_wrap_Matrix2x3_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 231: flag=_wrap_Matrix2x3_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 232: flag=_wrap_Matrix2x3_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 233: flag=_wrap_Matrix2x3_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 234: flag=_wrap_Matrix2x3_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 235: flag=_wrap_Matrix2x3_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 236: flag=_wrap_Matrix2x3_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 237: flag=_wrap_Matrix2x3_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 238: flag=_wrap_delete_Matrix2x3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 239: flag=_wrap_new_Matrix3x3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 240: flag=_wrap_Matrix3x3_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 241: flag=_wrap_Matrix3x3_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 242: flag=_wrap_Matrix3x3_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 243: flag=_wrap_Matrix3x3_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 244: flag=_wrap_Matrix3x3_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 245: flag=_wrap_Matrix3x3_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 246: flag=_wrap_Matrix3x3_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 247: flag=_wrap_Matrix3x3_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 248: flag=_wrap_Matrix3x3_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 249: flag=_wrap_Matrix3x3_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 250: flag=_wrap_Matrix3x3_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 251: flag=_wrap_Matrix3x3_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 252: flag=_wrap_Matrix3x3_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 253: flag=_wrap_delete_Matrix3x3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 254: flag=_wrap_new_Matrix4x4(resc,resv,argc,(mxArray**)(argv)); break;
+  case 255: flag=_wrap_Matrix4x4_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 256: flag=_wrap_Matrix4x4_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 257: flag=_wrap_Matrix4x4_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 258: flag=_wrap_Matrix4x4_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 259: flag=_wrap_Matrix4x4_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 260: flag=_wrap_Matrix4x4_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 261: flag=_wrap_Matrix4x4_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 262: flag=_wrap_Matrix4x4_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 263: flag=_wrap_Matrix4x4_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 264: flag=_wrap_Matrix4x4_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 265: flag=_wrap_Matrix4x4_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 266: flag=_wrap_Matrix4x4_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 267: flag=_wrap_Matrix4x4_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 268: flag=_wrap_delete_Matrix4x4(resc,resv,argc,(mxArray**)(argv)); break;
+  case 269: flag=_wrap_new_Matrix6x6(resc,resv,argc,(mxArray**)(argv)); break;
+  case 270: flag=_wrap_Matrix6x6_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 271: flag=_wrap_Matrix6x6_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 272: flag=_wrap_Matrix6x6_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 273: flag=_wrap_Matrix6x6_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 274: flag=_wrap_Matrix6x6_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 275: flag=_wrap_Matrix6x6_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 276: flag=_wrap_Matrix6x6_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 277: flag=_wrap_Matrix6x6_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 278: flag=_wrap_Matrix6x6_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 279: flag=_wrap_Matrix6x6_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 280: flag=_wrap_Matrix6x6_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 281: flag=_wrap_Matrix6x6_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 282: flag=_wrap_Matrix6x6_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 283: flag=_wrap_delete_Matrix6x6(resc,resv,argc,(mxArray**)(argv)); break;
+  case 284: flag=_wrap_new_Matrix6x10(resc,resv,argc,(mxArray**)(argv)); break;
+  case 285: flag=_wrap_Matrix6x10_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 286: flag=_wrap_Matrix6x10_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 287: flag=_wrap_Matrix6x10_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 288: flag=_wrap_Matrix6x10_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 289: flag=_wrap_Matrix6x10_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 290: flag=_wrap_Matrix6x10_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 291: flag=_wrap_Matrix6x10_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 292: flag=_wrap_Matrix6x10_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 293: flag=_wrap_Matrix6x10_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 294: flag=_wrap_Matrix6x10_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 295: flag=_wrap_Matrix6x10_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 296: flag=_wrap_Matrix6x10_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 297: flag=_wrap_Matrix6x10_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 298: flag=_wrap_delete_Matrix6x10(resc,resv,argc,(mxArray**)(argv)); break;
+  case 299: flag=_wrap_new_Matrix10x16(resc,resv,argc,(mxArray**)(argv)); break;
+  case 300: flag=_wrap_Matrix10x16_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 301: flag=_wrap_Matrix10x16_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 302: flag=_wrap_Matrix10x16_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 303: flag=_wrap_Matrix10x16_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 304: flag=_wrap_Matrix10x16_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 305: flag=_wrap_Matrix10x16_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 306: flag=_wrap_Matrix10x16_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 307: flag=_wrap_Matrix10x16_fillRowMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 308: flag=_wrap_Matrix10x16_fillColMajorBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 309: flag=_wrap_Matrix10x16_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 310: flag=_wrap_Matrix10x16_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 311: flag=_wrap_Matrix10x16_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 312: flag=_wrap_Matrix10x16_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 313: flag=_wrap_delete_Matrix10x16(resc,resv,argc,(mxArray**)(argv)); break;
+  case 314: flag=_wrap_new_Vector3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 315: flag=_wrap_Vector3_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 316: flag=_wrap_Vector3_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 317: flag=_wrap_Vector3_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 318: flag=_wrap_Vector3_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 319: flag=_wrap_Vector3_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 320: flag=_wrap_Vector3_cend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 321: flag=_wrap_Vector3_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 322: flag=_wrap_Vector3_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 323: flag=_wrap_Vector3_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 324: flag=_wrap_Vector3_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 325: flag=_wrap_Vector3_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 326: flag=_wrap_Vector3_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 327: flag=_wrap_Vector3_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 328: flag=_wrap_Vector3_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 329: flag=_wrap_Vector3_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 330: flag=_wrap_Vector3_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 331: flag=_wrap_delete_Vector3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 332: flag=_wrap_new_Vector4(resc,resv,argc,(mxArray**)(argv)); break;
+  case 333: flag=_wrap_Vector4_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 334: flag=_wrap_Vector4_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 335: flag=_wrap_Vector4_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 336: flag=_wrap_Vector4_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 337: flag=_wrap_Vector4_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 338: flag=_wrap_Vector4_cend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 339: flag=_wrap_Vector4_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 340: flag=_wrap_Vector4_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 341: flag=_wrap_Vector4_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 342: flag=_wrap_Vector4_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 343: flag=_wrap_Vector4_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 344: flag=_wrap_Vector4_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 345: flag=_wrap_Vector4_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 346: flag=_wrap_Vector4_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 347: flag=_wrap_Vector4_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 348: flag=_wrap_Vector4_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 349: flag=_wrap_delete_Vector4(resc,resv,argc,(mxArray**)(argv)); break;
+  case 350: flag=_wrap_new_Vector6(resc,resv,argc,(mxArray**)(argv)); break;
+  case 351: flag=_wrap_Vector6_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 352: flag=_wrap_Vector6_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 353: flag=_wrap_Vector6_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 354: flag=_wrap_Vector6_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 355: flag=_wrap_Vector6_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 356: flag=_wrap_Vector6_cend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 357: flag=_wrap_Vector6_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 358: flag=_wrap_Vector6_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 359: flag=_wrap_Vector6_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 360: flag=_wrap_Vector6_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 361: flag=_wrap_Vector6_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 362: flag=_wrap_Vector6_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 363: flag=_wrap_Vector6_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 364: flag=_wrap_Vector6_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 365: flag=_wrap_Vector6_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 366: flag=_wrap_Vector6_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 367: flag=_wrap_delete_Vector6(resc,resv,argc,(mxArray**)(argv)); break;
+  case 368: flag=_wrap_new_Vector10(resc,resv,argc,(mxArray**)(argv)); break;
+  case 369: flag=_wrap_Vector10_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 370: flag=_wrap_Vector10_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 371: flag=_wrap_Vector10_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 372: flag=_wrap_Vector10_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 373: flag=_wrap_Vector10_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 374: flag=_wrap_Vector10_cend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 375: flag=_wrap_Vector10_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 376: flag=_wrap_Vector10_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 377: flag=_wrap_Vector10_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 378: flag=_wrap_Vector10_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 379: flag=_wrap_Vector10_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 380: flag=_wrap_Vector10_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 381: flag=_wrap_Vector10_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 382: flag=_wrap_Vector10_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 383: flag=_wrap_Vector10_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 384: flag=_wrap_Vector10_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 385: flag=_wrap_delete_Vector10(resc,resv,argc,(mxArray**)(argv)); break;
+  case 386: flag=_wrap_new_Vector16(resc,resv,argc,(mxArray**)(argv)); break;
+  case 387: flag=_wrap_Vector16_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 388: flag=_wrap_Vector16_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 389: flag=_wrap_Vector16_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 390: flag=_wrap_Vector16_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 391: flag=_wrap_Vector16_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 392: flag=_wrap_Vector16_cend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 393: flag=_wrap_Vector16_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 394: flag=_wrap_Vector16_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 395: flag=_wrap_Vector16_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 396: flag=_wrap_Vector16_data(resc,resv,argc,(mxArray**)(argv)); break;
+  case 397: flag=_wrap_Vector16_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 398: flag=_wrap_Vector16_fillBuffer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 399: flag=_wrap_Vector16_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 400: flag=_wrap_Vector16_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 401: flag=_wrap_Vector16_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 402: flag=_wrap_Vector16_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 403: flag=_wrap_delete_Vector16(resc,resv,argc,(mxArray**)(argv)); break;
+  case 404: flag=_wrap_new_PositionRaw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 405: flag=_wrap_PositionRaw_changePoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 406: flag=_wrap_PositionRaw_changeRefPoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 407: flag=_wrap_PositionRaw_compose(resc,resv,argc,(mxArray**)(argv)); break;
+  case 408: flag=_wrap_PositionRaw_inverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 409: flag=_wrap_PositionRaw_changePointOf(resc,resv,argc,(mxArray**)(argv)); break;
+  case 410: flag=_wrap_PositionRaw_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 411: flag=_wrap_PositionRaw_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 412: flag=_wrap_delete_PositionRaw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 413: flag=_wrap_new_Position(resc,resv,argc,(mxArray**)(argv)); break;
+  case 414: flag=_wrap_Position_changePoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 415: flag=_wrap_Position_changeRefPoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 416: flag=_wrap_Position_changeCoordinateFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 417: flag=_wrap_Position_compose(resc,resv,argc,(mxArray**)(argv)); break;
+  case 418: flag=_wrap_Position_inverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 419: flag=_wrap_Position_changePointOf(resc,resv,argc,(mxArray**)(argv)); break;
+  case 420: flag=_wrap_Position_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 421: flag=_wrap_Position_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 422: flag=_wrap_Position_uminus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 423: flag=_wrap_Position_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 424: flag=_wrap_Position_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 425: flag=_wrap_Position_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 426: flag=_wrap_Position_Zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 427: flag=_wrap_delete_Position(resc,resv,argc,(mxArray**)(argv)); break;
+  case 428: flag=_wrap_new_GeomVector3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 429: flag=_wrap_GeomVector3_changeCoordFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 430: flag=_wrap_GeomVector3_compose(resc,resv,argc,(mxArray**)(argv)); break;
+  case 431: flag=_wrap_GeomVector3_inverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 432: flag=_wrap_GeomVector3_dot(resc,resv,argc,(mxArray**)(argv)); break;
+  case 433: flag=_wrap_GeomVector3_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 434: flag=_wrap_GeomVector3_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 435: flag=_wrap_GeomVector3_uminus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 436: flag=_wrap_GeomVector3_exp(resc,resv,argc,(mxArray**)(argv)); break;
+  case 437: flag=_wrap_GeomVector3_cross(resc,resv,argc,(mxArray**)(argv)); break;
+  case 438: flag=_wrap_delete_GeomVector3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 439: flag=_wrap_new_SpatialMotionVectorBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 440: flag=_wrap_SpatialMotionVectorBase_getLinearVec3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 441: flag=_wrap_SpatialMotionVectorBase_getAngularVec3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 442: flag=_wrap_SpatialMotionVectorBase_setLinearVec3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 443: flag=_wrap_SpatialMotionVectorBase_setAngularVec3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 444: flag=_wrap_SpatialMotionVectorBase_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 445: flag=_wrap_SpatialMotionVectorBase_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 446: flag=_wrap_SpatialMotionVectorBase_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 447: flag=_wrap_SpatialMotionVectorBase_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 448: flag=_wrap_SpatialMotionVectorBase_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 449: flag=_wrap_SpatialMotionVectorBase_changePoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 450: flag=_wrap_SpatialMotionVectorBase_changeCoordFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 451: flag=_wrap_SpatialMotionVectorBase_compose(resc,resv,argc,(mxArray**)(argv)); break;
+  case 452: flag=_wrap_SpatialMotionVectorBase_inverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 453: flag=_wrap_SpatialMotionVectorBase_dot(resc,resv,argc,(mxArray**)(argv)); break;
+  case 454: flag=_wrap_SpatialMotionVectorBase_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 455: flag=_wrap_SpatialMotionVectorBase_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 456: flag=_wrap_SpatialMotionVectorBase_uminus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 457: flag=_wrap_SpatialMotionVectorBase_Zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 458: flag=_wrap_SpatialMotionVectorBase_asVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 459: flag=_wrap_SpatialMotionVectorBase_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 460: flag=_wrap_SpatialMotionVectorBase_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 461: flag=_wrap_SpatialMotionVectorBase_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 462: flag=_wrap_SpatialMotionVectorBase_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 463: flag=_wrap_delete_SpatialMotionVectorBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 464: flag=_wrap_new_SpatialForceVectorBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 465: flag=_wrap_SpatialForceVectorBase_getLinearVec3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 466: flag=_wrap_SpatialForceVectorBase_getAngularVec3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 467: flag=_wrap_SpatialForceVectorBase_setLinearVec3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 468: flag=_wrap_SpatialForceVectorBase_setAngularVec3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 469: flag=_wrap_SpatialForceVectorBase_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 470: flag=_wrap_SpatialForceVectorBase_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 471: flag=_wrap_SpatialForceVectorBase_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 472: flag=_wrap_SpatialForceVectorBase_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 473: flag=_wrap_SpatialForceVectorBase_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 474: flag=_wrap_SpatialForceVectorBase_changePoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 475: flag=_wrap_SpatialForceVectorBase_changeCoordFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 476: flag=_wrap_SpatialForceVectorBase_compose(resc,resv,argc,(mxArray**)(argv)); break;
+  case 477: flag=_wrap_SpatialForceVectorBase_inverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 478: flag=_wrap_SpatialForceVectorBase_dot(resc,resv,argc,(mxArray**)(argv)); break;
+  case 479: flag=_wrap_SpatialForceVectorBase_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 480: flag=_wrap_SpatialForceVectorBase_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 481: flag=_wrap_SpatialForceVectorBase_uminus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 482: flag=_wrap_SpatialForceVectorBase_Zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 483: flag=_wrap_SpatialForceVectorBase_asVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 484: flag=_wrap_SpatialForceVectorBase_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 485: flag=_wrap_SpatialForceVectorBase_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 486: flag=_wrap_SpatialForceVectorBase_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 487: flag=_wrap_SpatialForceVectorBase_fromMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 488: flag=_wrap_delete_SpatialForceVectorBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 489: flag=_wrap_new_Dummy(resc,resv,argc,(mxArray**)(argv)); break;
+  case 490: flag=_wrap_delete_Dummy(resc,resv,argc,(mxArray**)(argv)); break;
+  case 491: flag=_wrap_new_SpatialMotionVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 492: flag=_wrap_SpatialMotionVector_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 493: flag=_wrap_SpatialMotionVector_cross(resc,resv,argc,(mxArray**)(argv)); break;
+  case 494: flag=_wrap_SpatialMotionVector_asCrossProductMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 495: flag=_wrap_SpatialMotionVector_asCrossProductMatrixWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 496: flag=_wrap_SpatialMotionVector_exp(resc,resv,argc,(mxArray**)(argv)); break;
+  case 497: flag=_wrap_delete_SpatialMotionVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 498: flag=_wrap_new_SpatialForceVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 499: flag=_wrap_delete_SpatialForceVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 500: flag=_wrap_SpatialForceVector_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 501: flag=_wrap_new_Twist(resc,resv,argc,(mxArray**)(argv)); break;
+  case 502: flag=_wrap_Twist_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 503: flag=_wrap_Twist_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 504: flag=_wrap_Twist_uminus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 505: flag=_wrap_Twist_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 506: flag=_wrap_delete_Twist(resc,resv,argc,(mxArray**)(argv)); break;
+  case 507: flag=_wrap_new_Wrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 508: flag=_wrap_Wrench_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 509: flag=_wrap_Wrench_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 510: flag=_wrap_Wrench_uminus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 511: flag=_wrap_delete_Wrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 512: flag=_wrap_new_SpatialMomentum(resc,resv,argc,(mxArray**)(argv)); break;
+  case 513: flag=_wrap_SpatialMomentum_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 514: flag=_wrap_SpatialMomentum_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 515: flag=_wrap_SpatialMomentum_uminus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 516: flag=_wrap_delete_SpatialMomentum(resc,resv,argc,(mxArray**)(argv)); break;
+  case 517: flag=_wrap_new_SpatialAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 518: flag=_wrap_SpatialAcc_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 519: flag=_wrap_SpatialAcc_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 520: flag=_wrap_SpatialAcc_uminus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 521: flag=_wrap_delete_SpatialAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 522: flag=_wrap_new_ClassicalAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 523: flag=_wrap_ClassicalAcc_changeCoordFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 524: flag=_wrap_ClassicalAcc_Zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 525: flag=_wrap_ClassicalAcc_fromSpatial(resc,resv,argc,(mxArray**)(argv)); break;
+  case 526: flag=_wrap_ClassicalAcc_toSpatial(resc,resv,argc,(mxArray**)(argv)); break;
+  case 527: flag=_wrap_delete_ClassicalAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 528: flag=_wrap_new_Direction(resc,resv,argc,(mxArray**)(argv)); break;
+  case 529: flag=_wrap_Direction_Normalize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 530: flag=_wrap_Direction_isParallel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 531: flag=_wrap_Direction_isPerpendicular(resc,resv,argc,(mxArray**)(argv)); break;
+  case 532: flag=_wrap_Direction_reverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 533: flag=_wrap_Direction_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 534: flag=_wrap_Direction_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 535: flag=_wrap_Direction_Default(resc,resv,argc,(mxArray**)(argv)); break;
+  case 536: flag=_wrap_delete_Direction(resc,resv,argc,(mxArray**)(argv)); break;
+  case 537: flag=_wrap_new_Axis(resc,resv,argc,(mxArray**)(argv)); break;
+  case 538: flag=_wrap_Axis_getDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 539: flag=_wrap_Axis_getOrigin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 540: flag=_wrap_Axis_setDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 541: flag=_wrap_Axis_setOrigin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 542: flag=_wrap_Axis_getRotationTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 543: flag=_wrap_Axis_getRotationTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 544: flag=_wrap_Axis_getRotationTwist(resc,resv,argc,(mxArray**)(argv)); break;
+  case 545: flag=_wrap_Axis_getRotationSpatialAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 546: flag=_wrap_Axis_getTranslationTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 547: flag=_wrap_Axis_getTranslationTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 548: flag=_wrap_Axis_getTranslationTwist(resc,resv,argc,(mxArray**)(argv)); break;
+  case 549: flag=_wrap_Axis_getTranslationSpatialAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 550: flag=_wrap_Axis_isParallel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 551: flag=_wrap_Axis_reverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 552: flag=_wrap_Axis_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 553: flag=_wrap_Axis_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 554: flag=_wrap_delete_Axis(resc,resv,argc,(mxArray**)(argv)); break;
+  case 555: flag=_wrap_new_RotationalInertiaRaw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 556: flag=_wrap_RotationalInertiaRaw_Zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 557: flag=_wrap_delete_RotationalInertiaRaw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 558: flag=_wrap_new_SpatialInertiaRaw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 559: flag=_wrap_SpatialInertiaRaw_fromRotationalInertiaWrtCenterOfMass(resc,resv,argc,(mxArray**)(argv)); break;
+  case 560: flag=_wrap_SpatialInertiaRaw_getMass(resc,resv,argc,(mxArray**)(argv)); break;
+  case 561: flag=_wrap_SpatialInertiaRaw_getCenterOfMass(resc,resv,argc,(mxArray**)(argv)); break;
+  case 562: flag=_wrap_SpatialInertiaRaw_getRotationalInertiaWrtFrameOrigin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 563: flag=_wrap_SpatialInertiaRaw_getRotationalInertiaWrtCenterOfMass(resc,resv,argc,(mxArray**)(argv)); break;
+  case 564: flag=_wrap_SpatialInertiaRaw_combine(resc,resv,argc,(mxArray**)(argv)); break;
+  case 565: flag=_wrap_SpatialInertiaRaw_multiply(resc,resv,argc,(mxArray**)(argv)); break;
+  case 566: flag=_wrap_SpatialInertiaRaw_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 567: flag=_wrap_delete_SpatialInertiaRaw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 568: flag=_wrap_new_SpatialInertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 569: flag=_wrap_SpatialInertia_combine(resc,resv,argc,(mxArray**)(argv)); break;
+  case 570: flag=_wrap_SpatialInertia_asMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 571: flag=_wrap_SpatialInertia_applyInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 572: flag=_wrap_SpatialInertia_getInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 573: flag=_wrap_SpatialInertia_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 574: flag=_wrap_SpatialInertia_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 575: flag=_wrap_SpatialInertia_biasWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 576: flag=_wrap_SpatialInertia_biasWrenchDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 577: flag=_wrap_SpatialInertia_Zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 578: flag=_wrap_SpatialInertia_asVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 579: flag=_wrap_SpatialInertia_fromVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 580: flag=_wrap_SpatialInertia_isPhysicallyConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 581: flag=_wrap_SpatialInertia_momentumRegressor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 582: flag=_wrap_SpatialInertia_momentumDerivativeRegressor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 583: flag=_wrap_SpatialInertia_momentumDerivativeSlotineLiRegressor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 584: flag=_wrap_delete_SpatialInertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 585: flag=_wrap_new_ArticulatedBodyInertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 586: flag=_wrap_ArticulatedBodyInertia_getLinearLinearSubmatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 587: flag=_wrap_ArticulatedBodyInertia_getLinearAngularSubmatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 588: flag=_wrap_ArticulatedBodyInertia_getAngularAngularSubmatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 589: flag=_wrap_ArticulatedBodyInertia_combine(resc,resv,argc,(mxArray**)(argv)); break;
+  case 590: flag=_wrap_ArticulatedBodyInertia_applyInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 591: flag=_wrap_ArticulatedBodyInertia_asMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 592: flag=_wrap_ArticulatedBodyInertia_getInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 593: flag=_wrap_ArticulatedBodyInertia_plus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 594: flag=_wrap_ArticulatedBodyInertia_minus(resc,resv,argc,(mxArray**)(argv)); break;
+  case 595: flag=_wrap_ArticulatedBodyInertia_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 596: flag=_wrap_ArticulatedBodyInertia_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 597: flag=_wrap_ArticulatedBodyInertia_ABADyadHelper(resc,resv,argc,(mxArray**)(argv)); break;
+  case 598: flag=_wrap_ArticulatedBodyInertia_ABADyadHelperLin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 599: flag=_wrap_delete_ArticulatedBodyInertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 600: flag=_wrap_RigidBodyInertiaNonLinearParametrization_mass_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 601: flag=_wrap_RigidBodyInertiaNonLinearParametrization_mass_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 602: flag=_wrap_RigidBodyInertiaNonLinearParametrization_com_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 603: flag=_wrap_RigidBodyInertiaNonLinearParametrization_com_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 604: flag=_wrap_RigidBodyInertiaNonLinearParametrization_link_R_centroidal_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 605: flag=_wrap_RigidBodyInertiaNonLinearParametrization_link_R_centroidal_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 606: flag=_wrap_RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 607: flag=_wrap_RigidBodyInertiaNonLinearParametrization_centralSecondMomentOfMass_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 608: flag=_wrap_RigidBodyInertiaNonLinearParametrization_getLinkCentroidalTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 609: flag=_wrap_RigidBodyInertiaNonLinearParametrization_fromRigidBodyInertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 610: flag=_wrap_RigidBodyInertiaNonLinearParametrization_fromInertialParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 611: flag=_wrap_RigidBodyInertiaNonLinearParametrization_toRigidBodyInertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 612: flag=_wrap_RigidBodyInertiaNonLinearParametrization_isPhysicallyConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 613: flag=_wrap_RigidBodyInertiaNonLinearParametrization_asVectorWithRotationAsVec(resc,resv,argc,(mxArray**)(argv)); break;
+  case 614: flag=_wrap_RigidBodyInertiaNonLinearParametrization_fromVectorWithRotationAsVec(resc,resv,argc,(mxArray**)(argv)); break;
+  case 615: flag=_wrap_RigidBodyInertiaNonLinearParametrization_getGradientWithRotationAsVec(resc,resv,argc,(mxArray**)(argv)); break;
+  case 616: flag=_wrap_new_RigidBodyInertiaNonLinearParametrization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 617: flag=_wrap_delete_RigidBodyInertiaNonLinearParametrization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 618: flag=_wrap_new_RotationRaw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 619: flag=_wrap_RotationRaw_changeOrientFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 620: flag=_wrap_RotationRaw_changeRefOrientFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 621: flag=_wrap_RotationRaw_compose(resc,resv,argc,(mxArray**)(argv)); break;
+  case 622: flag=_wrap_RotationRaw_inverse2(resc,resv,argc,(mxArray**)(argv)); break;
+  case 623: flag=_wrap_RotationRaw_changeCoordFrameOf(resc,resv,argc,(mxArray**)(argv)); break;
+  case 624: flag=_wrap_RotationRaw_RotX(resc,resv,argc,(mxArray**)(argv)); break;
+  case 625: flag=_wrap_RotationRaw_RotY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 626: flag=_wrap_RotationRaw_RotZ(resc,resv,argc,(mxArray**)(argv)); break;
+  case 627: flag=_wrap_RotationRaw_RPY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 628: flag=_wrap_RotationRaw_Identity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 629: flag=_wrap_RotationRaw_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 630: flag=_wrap_RotationRaw_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 631: flag=_wrap_delete_RotationRaw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 632: flag=_wrap_new_Rotation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 633: flag=_wrap_Rotation_changeOrientFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 634: flag=_wrap_Rotation_changeRefOrientFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 635: flag=_wrap_Rotation_changeCoordinateFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 636: flag=_wrap_Rotation_compose(resc,resv,argc,(mxArray**)(argv)); break;
+  case 637: flag=_wrap_Rotation_inverse2(resc,resv,argc,(mxArray**)(argv)); break;
+  case 638: flag=_wrap_Rotation_changeCoordFrameOf(resc,resv,argc,(mxArray**)(argv)); break;
+  case 639: flag=_wrap_Rotation_inverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 640: flag=_wrap_Rotation_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 641: flag=_wrap_Rotation_log(resc,resv,argc,(mxArray**)(argv)); break;
+  case 642: flag=_wrap_Rotation_fromQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
+  case 643: flag=_wrap_Rotation_getRPY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 644: flag=_wrap_Rotation_asRPY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 645: flag=_wrap_Rotation_getQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
+  case 646: flag=_wrap_Rotation_asQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
+  case 647: flag=_wrap_Rotation_RotX(resc,resv,argc,(mxArray**)(argv)); break;
+  case 648: flag=_wrap_Rotation_RotY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 649: flag=_wrap_Rotation_RotZ(resc,resv,argc,(mxArray**)(argv)); break;
+  case 650: flag=_wrap_Rotation_RotAxis(resc,resv,argc,(mxArray**)(argv)); break;
+  case 651: flag=_wrap_Rotation_RotAxisDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 652: flag=_wrap_Rotation_RPY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 653: flag=_wrap_Rotation_RPYRightTrivializedDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 654: flag=_wrap_Rotation_RPYRightTrivializedDerivativeRateOfChange(resc,resv,argc,(mxArray**)(argv)); break;
+  case 655: flag=_wrap_Rotation_RPYRightTrivializedDerivativeInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 656: flag=_wrap_Rotation_RPYRightTrivializedDerivativeInverseRateOfChange(resc,resv,argc,(mxArray**)(argv)); break;
+  case 657: flag=_wrap_Rotation_QuaternionRightTrivializedDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 658: flag=_wrap_Rotation_QuaternionRightTrivializedDerivativeInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 659: flag=_wrap_Rotation_Identity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 660: flag=_wrap_Rotation_RotationFromQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
+  case 661: flag=_wrap_Rotation_leftJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 662: flag=_wrap_Rotation_leftJacobianInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 663: flag=_wrap_Rotation_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 664: flag=_wrap_Rotation_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 665: flag=_wrap_delete_Rotation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 666: flag=_wrap_new_Transform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 667: flag=_wrap_Transform_fromHomogeneousTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 668: flag=_wrap_Transform_getRotation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 669: flag=_wrap_Transform_getPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 670: flag=_wrap_Transform_setRotation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 671: flag=_wrap_Transform_setPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 672: flag=_wrap_Transform_compose(resc,resv,argc,(mxArray**)(argv)); break;
+  case 673: flag=_wrap_Transform_inverse2(resc,resv,argc,(mxArray**)(argv)); break;
+  case 674: flag=_wrap_Transform_inverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 675: flag=_wrap_Transform_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 676: flag=_wrap_Transform_Identity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 677: flag=_wrap_Transform_asHomogeneousTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 678: flag=_wrap_Transform_asAdjointTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 679: flag=_wrap_Transform_asAdjointTransformWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 680: flag=_wrap_Transform_log(resc,resv,argc,(mxArray**)(argv)); break;
+  case 681: flag=_wrap_Transform_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 682: flag=_wrap_Transform_display(resc,resv,argc,(mxArray**)(argv)); break;
+  case 683: flag=_wrap_delete_Transform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 684: flag=_wrap_new_TransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 685: flag=_wrap_delete_TransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 686: flag=_wrap_TransformDerivative_getRotationDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 687: flag=_wrap_TransformDerivative_getPositionDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 688: flag=_wrap_TransformDerivative_setRotationDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 689: flag=_wrap_TransformDerivative_setPositionDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 690: flag=_wrap_TransformDerivative_Zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 691: flag=_wrap_TransformDerivative_asHomogeneousTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 692: flag=_wrap_TransformDerivative_asAdjointTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 693: flag=_wrap_TransformDerivative_asAdjointTransformWrenchDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 694: flag=_wrap_TransformDerivative_mtimes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 695: flag=_wrap_TransformDerivative_derivativeOfInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 696: flag=_wrap_TransformDerivative_transform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 697: flag=_wrap_dynamic_extent_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 698: flag=_wrap_DynamicSpan_extent_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 699: flag=_wrap_new_DynamicSpan(resc,resv,argc,(mxArray**)(argv)); break;
+  case 700: flag=_wrap_delete_DynamicSpan(resc,resv,argc,(mxArray**)(argv)); break;
+  case 701: flag=_wrap_DynamicSpan_first(resc,resv,argc,(mxArray**)(argv)); break;
+  case 702: flag=_wrap_DynamicSpan_last(resc,resv,argc,(mxArray**)(argv)); break;
+  case 703: flag=_wrap_DynamicSpan_subspan(resc,resv,argc,(mxArray**)(argv)); break;
+  case 704: flag=_wrap_DynamicSpan_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 705: flag=_wrap_DynamicSpan_size_bytes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 706: flag=_wrap_DynamicSpan_empty(resc,resv,argc,(mxArray**)(argv)); break;
+  case 707: flag=_wrap_DynamicSpan_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 708: flag=_wrap_DynamicSpan_getVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 709: flag=_wrap_DynamicSpan_setVal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 710: flag=_wrap_DynamicSpan_at(resc,resv,argc,(mxArray**)(argv)); break;
+  case 711: flag=_wrap_DynamicSpan_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 712: flag=_wrap_DynamicSpan_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 713: flag=_wrap_DynamicSpan_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 714: flag=_wrap_DynamicSpan_cbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 715: flag=_wrap_DynamicSpan_cend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 716: flag=_wrap_DynamicSpan_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 717: flag=_wrap_DynamicSpan_rend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 718: flag=_wrap_DynamicSpan_crbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 719: flag=_wrap_DynamicSpan_crend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 720: flag=_wrap_new_DynamicMatrixView(resc,resv,argc,(mxArray**)(argv)); break;
+  case 721: flag=_wrap_DynamicMatrixView_storageOrder(resc,resv,argc,(mxArray**)(argv)); break;
+  case 722: flag=_wrap_DynamicMatrixView_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 723: flag=_wrap_DynamicMatrixView_rows(resc,resv,argc,(mxArray**)(argv)); break;
+  case 724: flag=_wrap_DynamicMatrixView_cols(resc,resv,argc,(mxArray**)(argv)); break;
+  case 725: flag=_wrap_DynamicMatrixView_block(resc,resv,argc,(mxArray**)(argv)); break;
+  case 726: flag=_wrap_delete_DynamicMatrixView(resc,resv,argc,(mxArray**)(argv)); break;
+  case 727: flag=_wrap_LINK_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 728: flag=_wrap_LINK_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 729: flag=_wrap_LINK_INVALID_NAME_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 730: flag=_wrap_LINK_INVALID_NAME_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 731: flag=_wrap_JOINT_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 732: flag=_wrap_JOINT_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 733: flag=_wrap_JOINT_INVALID_NAME_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 734: flag=_wrap_JOINT_INVALID_NAME_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 735: flag=_wrap_DOF_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 736: flag=_wrap_DOF_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 737: flag=_wrap_DOF_INVALID_NAME_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 738: flag=_wrap_DOF_INVALID_NAME_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 739: flag=_wrap_FRAME_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 740: flag=_wrap_FRAME_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 741: flag=_wrap_FRAME_INVALID_NAME_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 742: flag=_wrap_FRAME_INVALID_NAME_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 743: flag=_wrap_TRAVERSAL_INVALID_INDEX_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 744: flag=_wrap_TRAVERSAL_INVALID_INDEX_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 745: flag=_wrap_new_LinkPositions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 746: flag=_wrap_LinkPositions_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 747: flag=_wrap_LinkPositions_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 748: flag=_wrap_LinkPositions_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 749: flag=_wrap_LinkPositions_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 750: flag=_wrap_LinkPositions_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 751: flag=_wrap_delete_LinkPositions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 752: flag=_wrap_new_LinkWrenches(resc,resv,argc,(mxArray**)(argv)); break;
+  case 753: flag=_wrap_LinkWrenches_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 754: flag=_wrap_LinkWrenches_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 755: flag=_wrap_LinkWrenches_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 756: flag=_wrap_LinkWrenches_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 757: flag=_wrap_LinkWrenches_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 758: flag=_wrap_LinkWrenches_zero(resc,resv,argc,(mxArray**)(argv)); break;
+  case 759: flag=_wrap_delete_LinkWrenches(resc,resv,argc,(mxArray**)(argv)); break;
+  case 760: flag=_wrap_new_LinkInertias(resc,resv,argc,(mxArray**)(argv)); break;
+  case 761: flag=_wrap_LinkInertias_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 762: flag=_wrap_LinkInertias_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 763: flag=_wrap_LinkInertias_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 764: flag=_wrap_delete_LinkInertias(resc,resv,argc,(mxArray**)(argv)); break;
+  case 765: flag=_wrap_new_LinkArticulatedBodyInertias(resc,resv,argc,(mxArray**)(argv)); break;
+  case 766: flag=_wrap_LinkArticulatedBodyInertias_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 767: flag=_wrap_LinkArticulatedBodyInertias_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 768: flag=_wrap_LinkArticulatedBodyInertias_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 769: flag=_wrap_delete_LinkArticulatedBodyInertias(resc,resv,argc,(mxArray**)(argv)); break;
+  case 770: flag=_wrap_new_LinkVelArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 771: flag=_wrap_LinkVelArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 772: flag=_wrap_LinkVelArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 773: flag=_wrap_LinkVelArray_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 774: flag=_wrap_LinkVelArray_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 775: flag=_wrap_LinkVelArray_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 776: flag=_wrap_delete_LinkVelArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 777: flag=_wrap_new_LinkAccArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 778: flag=_wrap_LinkAccArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 779: flag=_wrap_LinkAccArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 780: flag=_wrap_LinkAccArray_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 781: flag=_wrap_LinkAccArray_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 782: flag=_wrap_LinkAccArray_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 783: flag=_wrap_delete_LinkAccArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 784: flag=_wrap_new_Link(resc,resv,argc,(mxArray**)(argv)); break;
+  case 785: flag=_wrap_Link_inertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 786: flag=_wrap_Link_setInertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 787: flag=_wrap_Link_getInertia(resc,resv,argc,(mxArray**)(argv)); break;
+  case 788: flag=_wrap_Link_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 789: flag=_wrap_Link_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 790: flag=_wrap_delete_Link(resc,resv,argc,(mxArray**)(argv)); break;
+  case 791: flag=_wrap_delete_IJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 792: flag=_wrap_IJoint_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 793: flag=_wrap_IJoint_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 794: flag=_wrap_IJoint_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 795: flag=_wrap_IJoint_setAttachedLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 796: flag=_wrap_IJoint_setRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 797: flag=_wrap_IJoint_getFirstAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 798: flag=_wrap_IJoint_getSecondAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 799: flag=_wrap_IJoint_getRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 800: flag=_wrap_IJoint_getTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 801: flag=_wrap_IJoint_getTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 802: flag=_wrap_IJoint_getMotionSubspaceVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 803: flag=_wrap_IJoint_computeChildPosVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 804: flag=_wrap_IJoint_computeChildVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 805: flag=_wrap_IJoint_computeChildVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 806: flag=_wrap_IJoint_computeChildAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 807: flag=_wrap_IJoint_computeChildBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 808: flag=_wrap_IJoint_computeJointTorque(resc,resv,argc,(mxArray**)(argv)); break;
+  case 809: flag=_wrap_IJoint_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 810: flag=_wrap_IJoint_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 811: flag=_wrap_IJoint_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 812: flag=_wrap_IJoint_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 813: flag=_wrap_IJoint_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 814: flag=_wrap_IJoint_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 815: flag=_wrap_IJoint_hasPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 816: flag=_wrap_IJoint_enablePosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 817: flag=_wrap_IJoint_getPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 818: flag=_wrap_IJoint_getMinPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 819: flag=_wrap_IJoint_getMaxPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 820: flag=_wrap_IJoint_setPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 821: flag=_wrap_IJoint_isRevoluteJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 822: flag=_wrap_IJoint_isFixedJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 823: flag=_wrap_IJoint_isPrismaticJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 824: flag=_wrap_IJoint_asRevoluteJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 825: flag=_wrap_IJoint_asFixedJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 826: flag=_wrap_IJoint_asPrismaticJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 827: flag=_wrap_new_FixedJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 828: flag=_wrap_delete_FixedJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 829: flag=_wrap_FixedJoint_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 830: flag=_wrap_FixedJoint_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 831: flag=_wrap_FixedJoint_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 832: flag=_wrap_FixedJoint_setAttachedLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 833: flag=_wrap_FixedJoint_setRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 834: flag=_wrap_FixedJoint_getFirstAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 835: flag=_wrap_FixedJoint_getSecondAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 836: flag=_wrap_FixedJoint_getRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 837: flag=_wrap_FixedJoint_getTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 838: flag=_wrap_FixedJoint_getTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 839: flag=_wrap_FixedJoint_getMotionSubspaceVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 840: flag=_wrap_FixedJoint_computeChildPosVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 841: flag=_wrap_FixedJoint_computeChildVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 842: flag=_wrap_FixedJoint_computeChildVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 843: flag=_wrap_FixedJoint_computeChildAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 844: flag=_wrap_FixedJoint_computeChildBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 845: flag=_wrap_FixedJoint_computeJointTorque(resc,resv,argc,(mxArray**)(argv)); break;
+  case 846: flag=_wrap_FixedJoint_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 847: flag=_wrap_FixedJoint_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 848: flag=_wrap_FixedJoint_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 849: flag=_wrap_FixedJoint_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 850: flag=_wrap_FixedJoint_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 851: flag=_wrap_FixedJoint_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 852: flag=_wrap_FixedJoint_hasPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 853: flag=_wrap_FixedJoint_enablePosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 854: flag=_wrap_FixedJoint_getPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 855: flag=_wrap_FixedJoint_getMinPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 856: flag=_wrap_FixedJoint_getMaxPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 857: flag=_wrap_FixedJoint_setPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 858: flag=_wrap_delete_MovableJointImpl1(resc,resv,argc,(mxArray**)(argv)); break;
+  case 859: flag=_wrap_MovableJointImpl1_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 860: flag=_wrap_MovableJointImpl1_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 861: flag=_wrap_MovableJointImpl1_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 862: flag=_wrap_MovableJointImpl1_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 863: flag=_wrap_MovableJointImpl1_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 864: flag=_wrap_MovableJointImpl1_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 865: flag=_wrap_MovableJointImpl1_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 866: flag=_wrap_MovableJointImpl1_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 867: flag=_wrap_delete_MovableJointImpl2(resc,resv,argc,(mxArray**)(argv)); break;
+  case 868: flag=_wrap_MovableJointImpl2_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 869: flag=_wrap_MovableJointImpl2_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 870: flag=_wrap_MovableJointImpl2_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 871: flag=_wrap_MovableJointImpl2_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 872: flag=_wrap_MovableJointImpl2_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 873: flag=_wrap_MovableJointImpl2_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 874: flag=_wrap_MovableJointImpl2_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 875: flag=_wrap_MovableJointImpl2_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 876: flag=_wrap_delete_MovableJointImpl3(resc,resv,argc,(mxArray**)(argv)); break;
+  case 877: flag=_wrap_MovableJointImpl3_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 878: flag=_wrap_MovableJointImpl3_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 879: flag=_wrap_MovableJointImpl3_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 880: flag=_wrap_MovableJointImpl3_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 881: flag=_wrap_MovableJointImpl3_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 882: flag=_wrap_MovableJointImpl3_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 883: flag=_wrap_MovableJointImpl3_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 884: flag=_wrap_MovableJointImpl3_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 885: flag=_wrap_delete_MovableJointImpl4(resc,resv,argc,(mxArray**)(argv)); break;
+  case 886: flag=_wrap_MovableJointImpl4_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 887: flag=_wrap_MovableJointImpl4_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 888: flag=_wrap_MovableJointImpl4_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 889: flag=_wrap_MovableJointImpl4_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 890: flag=_wrap_MovableJointImpl4_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 891: flag=_wrap_MovableJointImpl4_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 892: flag=_wrap_MovableJointImpl4_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 893: flag=_wrap_MovableJointImpl4_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 894: flag=_wrap_delete_MovableJointImpl5(resc,resv,argc,(mxArray**)(argv)); break;
+  case 895: flag=_wrap_MovableJointImpl5_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 896: flag=_wrap_MovableJointImpl5_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 897: flag=_wrap_MovableJointImpl5_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 898: flag=_wrap_MovableJointImpl5_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 899: flag=_wrap_MovableJointImpl5_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 900: flag=_wrap_MovableJointImpl5_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 901: flag=_wrap_MovableJointImpl5_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 902: flag=_wrap_MovableJointImpl5_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 903: flag=_wrap_delete_MovableJointImpl6(resc,resv,argc,(mxArray**)(argv)); break;
+  case 904: flag=_wrap_MovableJointImpl6_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 905: flag=_wrap_MovableJointImpl6_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 906: flag=_wrap_MovableJointImpl6_setIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 907: flag=_wrap_MovableJointImpl6_getIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 908: flag=_wrap_MovableJointImpl6_setPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 909: flag=_wrap_MovableJointImpl6_getPosCoordsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 910: flag=_wrap_MovableJointImpl6_setDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 911: flag=_wrap_MovableJointImpl6_getDOFsOffset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 912: flag=_wrap_new_RevoluteJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 913: flag=_wrap_delete_RevoluteJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 914: flag=_wrap_RevoluteJoint_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 915: flag=_wrap_RevoluteJoint_setAttachedLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 916: flag=_wrap_RevoluteJoint_setRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 917: flag=_wrap_RevoluteJoint_setAxis(resc,resv,argc,(mxArray**)(argv)); break;
+  case 918: flag=_wrap_RevoluteJoint_getFirstAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 919: flag=_wrap_RevoluteJoint_getSecondAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 920: flag=_wrap_RevoluteJoint_getAxis(resc,resv,argc,(mxArray**)(argv)); break;
+  case 921: flag=_wrap_RevoluteJoint_getRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 922: flag=_wrap_RevoluteJoint_getTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 923: flag=_wrap_RevoluteJoint_getTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 924: flag=_wrap_RevoluteJoint_getMotionSubspaceVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 925: flag=_wrap_RevoluteJoint_computeChildPosVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 926: flag=_wrap_RevoluteJoint_computeChildVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 927: flag=_wrap_RevoluteJoint_computeChildVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 928: flag=_wrap_RevoluteJoint_computeChildAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 929: flag=_wrap_RevoluteJoint_computeChildBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 930: flag=_wrap_RevoluteJoint_computeJointTorque(resc,resv,argc,(mxArray**)(argv)); break;
+  case 931: flag=_wrap_RevoluteJoint_hasPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 932: flag=_wrap_RevoluteJoint_enablePosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 933: flag=_wrap_RevoluteJoint_getPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 934: flag=_wrap_RevoluteJoint_getMinPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 935: flag=_wrap_RevoluteJoint_getMaxPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 936: flag=_wrap_RevoluteJoint_setPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 937: flag=_wrap_new_PrismaticJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 938: flag=_wrap_delete_PrismaticJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 939: flag=_wrap_PrismaticJoint_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 940: flag=_wrap_PrismaticJoint_setAttachedLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 941: flag=_wrap_PrismaticJoint_setRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 942: flag=_wrap_PrismaticJoint_setAxis(resc,resv,argc,(mxArray**)(argv)); break;
+  case 943: flag=_wrap_PrismaticJoint_getFirstAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 944: flag=_wrap_PrismaticJoint_getSecondAttachedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 945: flag=_wrap_PrismaticJoint_getAxis(resc,resv,argc,(mxArray**)(argv)); break;
+  case 946: flag=_wrap_PrismaticJoint_getRestTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 947: flag=_wrap_PrismaticJoint_getTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 948: flag=_wrap_PrismaticJoint_getTransformDerivative(resc,resv,argc,(mxArray**)(argv)); break;
+  case 949: flag=_wrap_PrismaticJoint_getMotionSubspaceVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 950: flag=_wrap_PrismaticJoint_computeChildPosVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 951: flag=_wrap_PrismaticJoint_computeChildVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 952: flag=_wrap_PrismaticJoint_computeChildVelAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 953: flag=_wrap_PrismaticJoint_computeChildAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 954: flag=_wrap_PrismaticJoint_computeChildBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 955: flag=_wrap_PrismaticJoint_computeJointTorque(resc,resv,argc,(mxArray**)(argv)); break;
+  case 956: flag=_wrap_PrismaticJoint_hasPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 957: flag=_wrap_PrismaticJoint_enablePosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 958: flag=_wrap_PrismaticJoint_getPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 959: flag=_wrap_PrismaticJoint_getMinPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 960: flag=_wrap_PrismaticJoint_getMaxPosLimit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 961: flag=_wrap_PrismaticJoint_setPosLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 962: flag=_wrap_new_Traversal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 963: flag=_wrap_delete_Traversal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 964: flag=_wrap_Traversal_getNrOfVisitedLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 965: flag=_wrap_Traversal_getLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 966: flag=_wrap_Traversal_getBaseLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 967: flag=_wrap_Traversal_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 968: flag=_wrap_Traversal_getParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 969: flag=_wrap_Traversal_getParentLinkFromLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 970: flag=_wrap_Traversal_getParentJointFromLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 971: flag=_wrap_Traversal_getTraversalIndexFromLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 972: flag=_wrap_Traversal_reset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 973: flag=_wrap_Traversal_addTraversalBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 974: flag=_wrap_Traversal_addTraversalElement(resc,resv,argc,(mxArray**)(argv)); break;
+  case 975: flag=_wrap_Traversal_isParentOf(resc,resv,argc,(mxArray**)(argv)); break;
+  case 976: flag=_wrap_Traversal_getChildLinkIndexFromJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 977: flag=_wrap_Traversal_getParentLinkIndexFromJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 978: flag=_wrap_Traversal_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 979: flag=_wrap_new_Material(resc,resv,argc,(mxArray**)(argv)); break;
+  case 980: flag=_wrap_Material_name(resc,resv,argc,(mxArray**)(argv)); break;
+  case 981: flag=_wrap_Material_hasColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 982: flag=_wrap_Material_color(resc,resv,argc,(mxArray**)(argv)); break;
+  case 983: flag=_wrap_Material_setColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 984: flag=_wrap_Material_hasTexture(resc,resv,argc,(mxArray**)(argv)); break;
+  case 985: flag=_wrap_Material_texture(resc,resv,argc,(mxArray**)(argv)); break;
+  case 986: flag=_wrap_Material_setTexture(resc,resv,argc,(mxArray**)(argv)); break;
+  case 987: flag=_wrap_delete_Material(resc,resv,argc,(mxArray**)(argv)); break;
+  case 988: flag=_wrap_delete_SolidShape(resc,resv,argc,(mxArray**)(argv)); break;
+  case 989: flag=_wrap_SolidShape_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 990: flag=_wrap_SolidShape_getName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 991: flag=_wrap_SolidShape_setName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 992: flag=_wrap_SolidShape_isNameValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 993: flag=_wrap_SolidShape_getLink_H_geometry(resc,resv,argc,(mxArray**)(argv)); break;
+  case 994: flag=_wrap_SolidShape_setLink_H_geometry(resc,resv,argc,(mxArray**)(argv)); break;
+  case 995: flag=_wrap_SolidShape_isMaterialSet(resc,resv,argc,(mxArray**)(argv)); break;
+  case 996: flag=_wrap_SolidShape_getMaterial(resc,resv,argc,(mxArray**)(argv)); break;
+  case 997: flag=_wrap_SolidShape_setMaterial(resc,resv,argc,(mxArray**)(argv)); break;
+  case 998: flag=_wrap_SolidShape_isSphere(resc,resv,argc,(mxArray**)(argv)); break;
+  case 999: flag=_wrap_SolidShape_isBox(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1000: flag=_wrap_SolidShape_isCylinder(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1001: flag=_wrap_SolidShape_isExternalMesh(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1002: flag=_wrap_SolidShape_asSphere(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1003: flag=_wrap_SolidShape_asBox(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1004: flag=_wrap_SolidShape_asCylinder(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1005: flag=_wrap_SolidShape_asExternalMesh(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1006: flag=_wrap_delete_Sphere(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1007: flag=_wrap_Sphere_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1008: flag=_wrap_Sphere_getRadius(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1009: flag=_wrap_Sphere_setRadius(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1010: flag=_wrap_new_Sphere(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1011: flag=_wrap_delete_Box(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1012: flag=_wrap_Box_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1013: flag=_wrap_Box_getX(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1014: flag=_wrap_Box_setX(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1015: flag=_wrap_Box_getY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1016: flag=_wrap_Box_setY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1017: flag=_wrap_Box_getZ(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1018: flag=_wrap_Box_setZ(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1019: flag=_wrap_new_Box(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1020: flag=_wrap_delete_Cylinder(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1021: flag=_wrap_Cylinder_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1022: flag=_wrap_Cylinder_getLength(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1023: flag=_wrap_Cylinder_setLength(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1024: flag=_wrap_Cylinder_getRadius(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1025: flag=_wrap_Cylinder_setRadius(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1026: flag=_wrap_new_Cylinder(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1027: flag=_wrap_delete_ExternalMesh(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1028: flag=_wrap_ExternalMesh_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1029: flag=_wrap_ExternalMesh_getFilename(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1030: flag=_wrap_ExternalMesh_getFileLocationOnLocalFileSystem(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1031: flag=_wrap_ExternalMesh_setFilename(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1032: flag=_wrap_ExternalMesh_getScale(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1033: flag=_wrap_ExternalMesh_setScale(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1034: flag=_wrap_new_ExternalMesh(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1035: flag=_wrap_delete_ModelSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1036: flag=_wrap_new_ModelSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1037: flag=_wrap_ModelSolidShapes_clear(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1038: flag=_wrap_ModelSolidShapes_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1039: flag=_wrap_ModelSolidShapes_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1040: flag=_wrap_ModelSolidShapes_getLinkSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1041: flag=_wrap_Neighbor_neighborLink_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1042: flag=_wrap_Neighbor_neighborLink_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1043: flag=_wrap_Neighbor_neighborJoint_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1044: flag=_wrap_Neighbor_neighborJoint_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1045: flag=_wrap_new_Neighbor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1046: flag=_wrap_delete_Neighbor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1047: flag=_wrap_new_Model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1048: flag=_wrap_Model_copy(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1049: flag=_wrap_delete_Model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1050: flag=_wrap_Model_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1051: flag=_wrap_Model_getLinkName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1052: flag=_wrap_Model_getLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1053: flag=_wrap_Model_isValidLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1054: flag=_wrap_Model_getLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1055: flag=_wrap_Model_addLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1056: flag=_wrap_Model_getNrOfJoints(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1057: flag=_wrap_Model_getJointName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1058: flag=_wrap_Model_getTotalMass(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1059: flag=_wrap_Model_getJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1060: flag=_wrap_Model_getJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1061: flag=_wrap_Model_isValidJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1062: flag=_wrap_Model_isLinkNameUsed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1063: flag=_wrap_Model_isJointNameUsed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1064: flag=_wrap_Model_isFrameNameUsed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1065: flag=_wrap_Model_addJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1066: flag=_wrap_Model_addJointAndLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1067: flag=_wrap_Model_insertLinkToExistingJointAndAddJointForDisplacedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1068: flag=_wrap_Model_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1069: flag=_wrap_Model_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1070: flag=_wrap_Model_getNrOfFrames(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1071: flag=_wrap_Model_addAdditionalFrameToLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1072: flag=_wrap_Model_getFrameName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1073: flag=_wrap_Model_getFrameIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1074: flag=_wrap_Model_isValidFrameIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1075: flag=_wrap_Model_getFrameTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1076: flag=_wrap_Model_getFrameLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1077: flag=_wrap_Model_getLinkAdditionalFrames(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1078: flag=_wrap_Model_getNrOfNeighbors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1079: flag=_wrap_Model_getNeighbor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1080: flag=_wrap_Model_setDefaultBaseLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1081: flag=_wrap_Model_getDefaultBaseLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1082: flag=_wrap_Model_computeFullTreeTraversal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1083: flag=_wrap_Model_getInertialParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1084: flag=_wrap_Model_updateInertialParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1085: flag=_wrap_Model_visualSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1086: flag=_wrap_Model_collisionSolidShapes(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1087: flag=_wrap_Model_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1088: flag=_wrap_new_JointPosDoubleArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1089: flag=_wrap_JointPosDoubleArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1090: flag=_wrap_JointPosDoubleArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1091: flag=_wrap_delete_JointPosDoubleArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1092: flag=_wrap_new_JointDOFsDoubleArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1093: flag=_wrap_JointDOFsDoubleArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1094: flag=_wrap_JointDOFsDoubleArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1095: flag=_wrap_delete_JointDOFsDoubleArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1096: flag=_wrap_new_DOFSpatialForceArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1097: flag=_wrap_DOFSpatialForceArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1098: flag=_wrap_DOFSpatialForceArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1099: flag=_wrap_DOFSpatialForceArray_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1100: flag=_wrap_delete_DOFSpatialForceArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1101: flag=_wrap_new_DOFSpatialMotionArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1102: flag=_wrap_DOFSpatialMotionArray_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1103: flag=_wrap_DOFSpatialMotionArray_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1104: flag=_wrap_DOFSpatialMotionArray_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1105: flag=_wrap_delete_DOFSpatialMotionArray(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1106: flag=_wrap_new_FrameFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1107: flag=_wrap_FrameFreeFloatingJacobian_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1108: flag=_wrap_FrameFreeFloatingJacobian_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1109: flag=_wrap_delete_FrameFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1110: flag=_wrap_new_MomentumFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1111: flag=_wrap_MomentumFreeFloatingJacobian_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1112: flag=_wrap_MomentumFreeFloatingJacobian_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1113: flag=_wrap_delete_MomentumFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1114: flag=_wrap_new_FreeFloatingMassMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1115: flag=_wrap_FreeFloatingMassMatrix_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1116: flag=_wrap_delete_FreeFloatingMassMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1117: flag=_wrap_new_FreeFloatingPos(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1118: flag=_wrap_FreeFloatingPos_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1119: flag=_wrap_FreeFloatingPos_worldBasePos(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1120: flag=_wrap_FreeFloatingPos_jointPos(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1121: flag=_wrap_FreeFloatingPos_getNrOfPosCoords(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1122: flag=_wrap_delete_FreeFloatingPos(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1123: flag=_wrap_new_FreeFloatingGeneralizedTorques(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1124: flag=_wrap_FreeFloatingGeneralizedTorques_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1125: flag=_wrap_FreeFloatingGeneralizedTorques_baseWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1126: flag=_wrap_FreeFloatingGeneralizedTorques_jointTorques(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1127: flag=_wrap_FreeFloatingGeneralizedTorques_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1128: flag=_wrap_delete_FreeFloatingGeneralizedTorques(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1129: flag=_wrap_new_FreeFloatingVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1130: flag=_wrap_FreeFloatingVel_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1131: flag=_wrap_FreeFloatingVel_baseVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1132: flag=_wrap_FreeFloatingVel_jointVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1133: flag=_wrap_FreeFloatingVel_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1134: flag=_wrap_delete_FreeFloatingVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1135: flag=_wrap_new_FreeFloatingAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1136: flag=_wrap_FreeFloatingAcc_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1137: flag=_wrap_FreeFloatingAcc_baseAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1138: flag=_wrap_FreeFloatingAcc_jointAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1139: flag=_wrap_FreeFloatingAcc_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1140: flag=_wrap_delete_FreeFloatingAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1141: flag=_wrap_ContactWrench_contactId(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1142: flag=_wrap_ContactWrench_contactPoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1143: flag=_wrap_ContactWrench_contactWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1144: flag=_wrap_new_ContactWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1145: flag=_wrap_delete_ContactWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1146: flag=_wrap_new_LinkContactWrenches(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1147: flag=_wrap_LinkContactWrenches_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1148: flag=_wrap_LinkContactWrenches_getNrOfContactsForLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1149: flag=_wrap_LinkContactWrenches_setNrOfContactsForLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1150: flag=_wrap_LinkContactWrenches_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1151: flag=_wrap_LinkContactWrenches_contactWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1152: flag=_wrap_LinkContactWrenches_computeNetWrenches(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1153: flag=_wrap_LinkContactWrenches_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1154: flag=_wrap_delete_LinkContactWrenches(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1155: flag=_wrap_getRandomLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1156: flag=_wrap_addRandomLinkToModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1157: flag=_wrap_addRandomAdditionalFrameToModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1158: flag=_wrap_getRandomLinkIndexOfModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1159: flag=_wrap_getRandomLinkOfModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1160: flag=_wrap_int2string(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1161: flag=_wrap_getRandomModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1162: flag=_wrap_getRandomChain(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1163: flag=_wrap_getRandomJointPositions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1164: flag=_wrap_getRandomInverseDynamicsInputs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1165: flag=_wrap_removeFakeLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1166: flag=_wrap_createReducedModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1167: flag=_wrap_createModelWithNormalizedJointNumbering(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1168: flag=_wrap_extractSubModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1169: flag=_wrap_new_SubModelDecomposition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1170: flag=_wrap_delete_SubModelDecomposition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1171: flag=_wrap_SubModelDecomposition_splitModelAlongJoints(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1172: flag=_wrap_SubModelDecomposition_setNrOfSubModels(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1173: flag=_wrap_SubModelDecomposition_getNrOfSubModels(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1174: flag=_wrap_SubModelDecomposition_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1175: flag=_wrap_SubModelDecomposition_getTraversal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1176: flag=_wrap_SubModelDecomposition_getSubModelOfLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1177: flag=_wrap_SubModelDecomposition_getSubModelOfFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1178: flag=_wrap_computeTransformToTraversalBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1179: flag=_wrap_computeTransformToSubModelBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1180: flag=_wrap_SolidShapesVector_pop(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1181: flag=_wrap_SolidShapesVector_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1182: flag=_wrap_SolidShapesVector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1183: flag=_wrap_SolidShapesVector_append(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1184: flag=_wrap_SolidShapesVector_empty(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1185: flag=_wrap_SolidShapesVector_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1186: flag=_wrap_SolidShapesVector_swap(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1187: flag=_wrap_SolidShapesVector_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1188: flag=_wrap_SolidShapesVector_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1189: flag=_wrap_SolidShapesVector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1190: flag=_wrap_SolidShapesVector_rend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1191: flag=_wrap_SolidShapesVector_clear(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1192: flag=_wrap_SolidShapesVector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1193: flag=_wrap_SolidShapesVector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1194: flag=_wrap_SolidShapesVector_erase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1195: flag=_wrap_new_SolidShapesVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1196: flag=_wrap_SolidShapesVector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1197: flag=_wrap_SolidShapesVector_front(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1198: flag=_wrap_SolidShapesVector_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1199: flag=_wrap_SolidShapesVector_assign(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1200: flag=_wrap_SolidShapesVector_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1201: flag=_wrap_SolidShapesVector_insert(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1202: flag=_wrap_SolidShapesVector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1203: flag=_wrap_SolidShapesVector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1204: flag=_wrap_delete_SolidShapesVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1205: flag=_wrap_LinksSolidShapesVector_pop(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1206: flag=_wrap_LinksSolidShapesVector_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1207: flag=_wrap_LinksSolidShapesVector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1208: flag=_wrap_LinksSolidShapesVector_append(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1209: flag=_wrap_LinksSolidShapesVector_empty(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1210: flag=_wrap_LinksSolidShapesVector_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1211: flag=_wrap_LinksSolidShapesVector_swap(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1212: flag=_wrap_LinksSolidShapesVector_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1213: flag=_wrap_LinksSolidShapesVector_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1214: flag=_wrap_LinksSolidShapesVector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1215: flag=_wrap_LinksSolidShapesVector_rend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1216: flag=_wrap_LinksSolidShapesVector_clear(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1217: flag=_wrap_LinksSolidShapesVector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1218: flag=_wrap_LinksSolidShapesVector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1219: flag=_wrap_LinksSolidShapesVector_erase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1220: flag=_wrap_new_LinksSolidShapesVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1221: flag=_wrap_LinksSolidShapesVector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1222: flag=_wrap_LinksSolidShapesVector_front(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1223: flag=_wrap_LinksSolidShapesVector_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1224: flag=_wrap_LinksSolidShapesVector_assign(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1225: flag=_wrap_LinksSolidShapesVector_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1226: flag=_wrap_LinksSolidShapesVector_insert(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1227: flag=_wrap_LinksSolidShapesVector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1228: flag=_wrap_LinksSolidShapesVector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1229: flag=_wrap_delete_LinksSolidShapesVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1230: flag=_wrap_ForwardPositionKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1231: flag=_wrap_ForwardVelAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1232: flag=_wrap_ForwardPosVelAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1233: flag=_wrap_ForwardPosVelKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1234: flag=_wrap_ForwardAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1235: flag=_wrap_ForwardBiasAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1236: flag=_wrap_ComputeLinearAndAngularMomentum(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1237: flag=_wrap_ComputeLinearAndAngularMomentumDerivativeBias(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1238: flag=_wrap_RNEADynamicPhase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1239: flag=_wrap_CompositeRigidBodyAlgorithm(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1240: flag=_wrap_new_ArticulatedBodyAlgorithmInternalBuffers(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1241: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1242: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1243: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_S_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1244: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_S_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1245: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_U_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1246: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_U_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1247: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_D_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1248: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_D_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1249: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_u_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1250: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_u_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1251: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksVel_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1252: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksVel_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1253: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1254: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasAcceleration_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1255: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1256: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksAccelerations_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1257: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linkABIs_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1258: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linkABIs_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1259: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1260: flag=_wrap_ArticulatedBodyAlgorithmInternalBuffers_linksBiasWrench_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1261: flag=_wrap_delete_ArticulatedBodyAlgorithmInternalBuffers(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1262: flag=_wrap_ArticulatedBodyAlgorithm(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1263: flag=_wrap_InverseDynamicsInertialParametersRegressor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1264: flag=_wrap_DHLink_A_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1265: flag=_wrap_DHLink_A_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1266: flag=_wrap_DHLink_D_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1267: flag=_wrap_DHLink_D_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1268: flag=_wrap_DHLink_Alpha_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1269: flag=_wrap_DHLink_Alpha_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1270: flag=_wrap_DHLink_Offset_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1271: flag=_wrap_DHLink_Offset_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1272: flag=_wrap_DHLink_Min_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1273: flag=_wrap_DHLink_Min_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1274: flag=_wrap_DHLink_Max_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1275: flag=_wrap_DHLink_Max_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1276: flag=_wrap_new_DHLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1277: flag=_wrap_delete_DHLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1278: flag=_wrap_DHChain_setNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1279: flag=_wrap_DHChain_getNrOfDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1280: flag=_wrap_DHChain_setH0(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1281: flag=_wrap_DHChain_getH0(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1282: flag=_wrap_DHChain_setHN(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1283: flag=_wrap_DHChain_getHN(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1284: flag=_wrap_DHChain_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1285: flag=_wrap_DHChain_getDOFName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1286: flag=_wrap_DHChain_setDOFName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1287: flag=_wrap_DHChain_toModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1288: flag=_wrap_DHChain_fromModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1289: flag=_wrap_new_DHChain(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1290: flag=_wrap_delete_DHChain(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1291: flag=_wrap_TransformFromDHCraig1989(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1292: flag=_wrap_TransformFromDH(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1293: flag=_wrap_ExtractDHChainFromModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1294: flag=_wrap_CreateModelFromDHChain(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1295: flag=_wrap_NR_OF_SENSOR_TYPES_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1296: flag=_wrap_isLinkSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1297: flag=_wrap_isJointSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1298: flag=_wrap_getSensorTypeSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1299: flag=_wrap_delete_Sensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1300: flag=_wrap_Sensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1301: flag=_wrap_Sensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1302: flag=_wrap_Sensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1303: flag=_wrap_Sensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1304: flag=_wrap_Sensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1305: flag=_wrap_Sensor_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1306: flag=_wrap_Sensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1307: flag=_wrap_delete_JointSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1308: flag=_wrap_JointSensor_getParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1309: flag=_wrap_JointSensor_getParentJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1310: flag=_wrap_JointSensor_setParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1311: flag=_wrap_JointSensor_setParentJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1312: flag=_wrap_JointSensor_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1313: flag=_wrap_delete_LinkSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1314: flag=_wrap_LinkSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1315: flag=_wrap_LinkSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1316: flag=_wrap_LinkSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1317: flag=_wrap_LinkSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1318: flag=_wrap_LinkSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1319: flag=_wrap_LinkSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1320: flag=_wrap_LinkSensor_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1321: flag=_wrap_new_SensorsList(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1322: flag=_wrap_delete_SensorsList(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1323: flag=_wrap_SensorsList_addSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1324: flag=_wrap_SensorsList_setSerialization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1325: flag=_wrap_SensorsList_getSerialization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1326: flag=_wrap_SensorsList_getNrOfSensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1327: flag=_wrap_SensorsList_getSensorIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1328: flag=_wrap_SensorsList_getSizeOfAllSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1329: flag=_wrap_SensorsList_getSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1330: flag=_wrap_SensorsList_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1331: flag=_wrap_SensorsList_removeSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1332: flag=_wrap_SensorsList_removeAllSensorsOfType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1333: flag=_wrap_SensorsList_getSixAxisForceTorqueSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1334: flag=_wrap_SensorsList_getAccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1335: flag=_wrap_SensorsList_getGyroscopeSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1336: flag=_wrap_SensorsList_getThreeAxisAngularAccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1337: flag=_wrap_SensorsList_getThreeAxisForceTorqueContactSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1338: flag=_wrap_new_SensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1339: flag=_wrap_delete_SensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1340: flag=_wrap_SensorsMeasurements_setNrOfSensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1341: flag=_wrap_SensorsMeasurements_getNrOfSensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1342: flag=_wrap_SensorsMeasurements_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1343: flag=_wrap_SensorsMeasurements_toVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1344: flag=_wrap_SensorsMeasurements_setMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1345: flag=_wrap_SensorsMeasurements_getMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1346: flag=_wrap_SensorsMeasurements_getSizeOfAllSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1347: flag=_wrap_new_SixAxisForceTorqueSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1348: flag=_wrap_delete_SixAxisForceTorqueSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1349: flag=_wrap_SixAxisForceTorqueSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1350: flag=_wrap_SixAxisForceTorqueSensor_setFirstLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1351: flag=_wrap_SixAxisForceTorqueSensor_setSecondLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1352: flag=_wrap_SixAxisForceTorqueSensor_getFirstLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1353: flag=_wrap_SixAxisForceTorqueSensor_getSecondLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1354: flag=_wrap_SixAxisForceTorqueSensor_setFirstLinkName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1355: flag=_wrap_SixAxisForceTorqueSensor_setSecondLinkName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1356: flag=_wrap_SixAxisForceTorqueSensor_getFirstLinkName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1357: flag=_wrap_SixAxisForceTorqueSensor_getSecondLinkName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1358: flag=_wrap_SixAxisForceTorqueSensor_setParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1359: flag=_wrap_SixAxisForceTorqueSensor_setParentJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1360: flag=_wrap_SixAxisForceTorqueSensor_setAppliedWrenchLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1361: flag=_wrap_SixAxisForceTorqueSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1362: flag=_wrap_SixAxisForceTorqueSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1363: flag=_wrap_SixAxisForceTorqueSensor_getParentJoint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1364: flag=_wrap_SixAxisForceTorqueSensor_getParentJointIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1365: flag=_wrap_SixAxisForceTorqueSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1366: flag=_wrap_SixAxisForceTorqueSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1367: flag=_wrap_SixAxisForceTorqueSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1368: flag=_wrap_SixAxisForceTorqueSensor_getAppliedWrenchLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1369: flag=_wrap_SixAxisForceTorqueSensor_isLinkAttachedToSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1370: flag=_wrap_SixAxisForceTorqueSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1371: flag=_wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1372: flag=_wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLinkMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1373: flag=_wrap_SixAxisForceTorqueSensor_getWrenchAppliedOnLinkInverseMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1374: flag=_wrap_SixAxisForceTorqueSensor_predictMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1375: flag=_wrap_SixAxisForceTorqueSensor_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1376: flag=_wrap_new_AccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1377: flag=_wrap_delete_AccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1378: flag=_wrap_AccelerometerSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1379: flag=_wrap_AccelerometerSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1380: flag=_wrap_AccelerometerSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1381: flag=_wrap_AccelerometerSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1382: flag=_wrap_AccelerometerSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1383: flag=_wrap_AccelerometerSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1384: flag=_wrap_AccelerometerSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1385: flag=_wrap_AccelerometerSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1386: flag=_wrap_AccelerometerSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1387: flag=_wrap_AccelerometerSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1388: flag=_wrap_AccelerometerSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1389: flag=_wrap_AccelerometerSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1390: flag=_wrap_AccelerometerSensor_predictMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1391: flag=_wrap_new_GyroscopeSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1392: flag=_wrap_delete_GyroscopeSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1393: flag=_wrap_GyroscopeSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1394: flag=_wrap_GyroscopeSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1395: flag=_wrap_GyroscopeSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1396: flag=_wrap_GyroscopeSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1397: flag=_wrap_GyroscopeSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1398: flag=_wrap_GyroscopeSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1399: flag=_wrap_GyroscopeSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1400: flag=_wrap_GyroscopeSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1401: flag=_wrap_GyroscopeSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1402: flag=_wrap_GyroscopeSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1403: flag=_wrap_GyroscopeSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1404: flag=_wrap_GyroscopeSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1405: flag=_wrap_GyroscopeSensor_predictMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1406: flag=_wrap_new_ThreeAxisAngularAccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1407: flag=_wrap_delete_ThreeAxisAngularAccelerometerSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1408: flag=_wrap_ThreeAxisAngularAccelerometerSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1409: flag=_wrap_ThreeAxisAngularAccelerometerSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1410: flag=_wrap_ThreeAxisAngularAccelerometerSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1411: flag=_wrap_ThreeAxisAngularAccelerometerSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1412: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1413: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1414: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1415: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1416: flag=_wrap_ThreeAxisAngularAccelerometerSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1417: flag=_wrap_ThreeAxisAngularAccelerometerSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1418: flag=_wrap_ThreeAxisAngularAccelerometerSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1419: flag=_wrap_ThreeAxisAngularAccelerometerSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1420: flag=_wrap_ThreeAxisAngularAccelerometerSensor_predictMeasurement(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1421: flag=_wrap_new_ThreeAxisForceTorqueContactSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1422: flag=_wrap_delete_ThreeAxisForceTorqueContactSensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1423: flag=_wrap_ThreeAxisForceTorqueContactSensor_setName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1424: flag=_wrap_ThreeAxisForceTorqueContactSensor_setLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1425: flag=_wrap_ThreeAxisForceTorqueContactSensor_setParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1426: flag=_wrap_ThreeAxisForceTorqueContactSensor_setParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1427: flag=_wrap_ThreeAxisForceTorqueContactSensor_getName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1428: flag=_wrap_ThreeAxisForceTorqueContactSensor_getSensorType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1429: flag=_wrap_ThreeAxisForceTorqueContactSensor_getParentLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1430: flag=_wrap_ThreeAxisForceTorqueContactSensor_getParentLinkIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1431: flag=_wrap_ThreeAxisForceTorqueContactSensor_getLinkSensorTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1432: flag=_wrap_ThreeAxisForceTorqueContactSensor_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1433: flag=_wrap_ThreeAxisForceTorqueContactSensor_clone(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1434: flag=_wrap_ThreeAxisForceTorqueContactSensor_updateIndices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1435: flag=_wrap_ThreeAxisForceTorqueContactSensor_setLoadCellLocations(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1436: flag=_wrap_ThreeAxisForceTorqueContactSensor_getLoadCellLocations(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1437: flag=_wrap_ThreeAxisForceTorqueContactSensor_computeThreeAxisForceTorqueFromLoadCellMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1438: flag=_wrap_ThreeAxisForceTorqueContactSensor_computeCenterOfPressureFromLoadCellMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1439: flag=_wrap_predictSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1440: flag=_wrap_predictSensorsMeasurementsFromRawBuffers(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1441: flag=_wrap_dofsListFromURDF(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1442: flag=_wrap_dofsListFromURDFString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1443: flag=_wrap_ModelParserOptions_addSensorFramesAsAdditionalFrames_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1444: flag=_wrap_ModelParserOptions_addSensorFramesAsAdditionalFrames_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1445: flag=_wrap_ModelParserOptions_originalFilename_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1446: flag=_wrap_ModelParserOptions_originalFilename_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1447: flag=_wrap_new_ModelParserOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1448: flag=_wrap_delete_ModelParserOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1449: flag=_wrap_new_ModelLoader(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1450: flag=_wrap_delete_ModelLoader(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1451: flag=_wrap_ModelLoader_parsingOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1452: flag=_wrap_ModelLoader_setParsingOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1453: flag=_wrap_ModelLoader_loadModelFromString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1454: flag=_wrap_ModelLoader_loadModelFromFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1455: flag=_wrap_ModelLoader_loadReducedModelFromFullModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1456: flag=_wrap_ModelLoader_loadReducedModelFromString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1457: flag=_wrap_ModelLoader_loadReducedModelFromFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1458: flag=_wrap_ModelLoader_model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1459: flag=_wrap_ModelLoader_sensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1460: flag=_wrap_ModelLoader_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1461: flag=_wrap_ModelExporterOptions_baseLink_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1462: flag=_wrap_ModelExporterOptions_baseLink_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1463: flag=_wrap_ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1464: flag=_wrap_ModelExporterOptions_exportFirstBaseLinkAdditionalFrameAsFakeURDFBase_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1465: flag=_wrap_ModelExporterOptions_robotExportedName_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1466: flag=_wrap_ModelExporterOptions_robotExportedName_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1467: flag=_wrap_new_ModelExporterOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1468: flag=_wrap_delete_ModelExporterOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1469: flag=_wrap_new_ModelExporter(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1470: flag=_wrap_delete_ModelExporter(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1471: flag=_wrap_ModelExporter_exportingOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1472: flag=_wrap_ModelExporter_setExportingOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1473: flag=_wrap_ModelExporter_init(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1474: flag=_wrap_ModelExporter_model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1475: flag=_wrap_ModelExporter_sensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1476: flag=_wrap_ModelExporter_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1477: flag=_wrap_ModelExporter_exportModelToString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1478: flag=_wrap_ModelExporter_exportModelToFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1479: flag=_wrap_new_ModelCalibrationHelper(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1480: flag=_wrap_delete_ModelCalibrationHelper(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1481: flag=_wrap_ModelCalibrationHelper_loadModelFromString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1482: flag=_wrap_ModelCalibrationHelper_loadModelFromFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1483: flag=_wrap_ModelCalibrationHelper_updateModelInertialParametersToString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1484: flag=_wrap_ModelCalibrationHelper_updateModelInertialParametersToFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1485: flag=_wrap_ModelCalibrationHelper_model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1486: flag=_wrap_ModelCalibrationHelper_sensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1487: flag=_wrap_ModelCalibrationHelper_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1488: flag=_wrap_new_UnknownWrenchContact(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1489: flag=_wrap_UnknownWrenchContact_unknownType_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1490: flag=_wrap_UnknownWrenchContact_unknownType_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1491: flag=_wrap_UnknownWrenchContact_contactPoint_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1492: flag=_wrap_UnknownWrenchContact_contactPoint_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1493: flag=_wrap_UnknownWrenchContact_forceDirection_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1494: flag=_wrap_UnknownWrenchContact_forceDirection_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1495: flag=_wrap_UnknownWrenchContact_knownWrench_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1496: flag=_wrap_UnknownWrenchContact_knownWrench_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1497: flag=_wrap_UnknownWrenchContact_contactId_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1498: flag=_wrap_UnknownWrenchContact_contactId_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1499: flag=_wrap_delete_UnknownWrenchContact(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1500: flag=_wrap_new_LinkUnknownWrenchContacts(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1501: flag=_wrap_LinkUnknownWrenchContacts_clear(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1502: flag=_wrap_LinkUnknownWrenchContacts_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1503: flag=_wrap_LinkUnknownWrenchContacts_getNrOfContactsForLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1504: flag=_wrap_LinkUnknownWrenchContacts_setNrOfContactsForLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1505: flag=_wrap_LinkUnknownWrenchContacts_addNewContactForLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1506: flag=_wrap_LinkUnknownWrenchContacts_addNewContactInFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1507: flag=_wrap_LinkUnknownWrenchContacts_addNewUnknownFullWrenchInFrameOrigin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1508: flag=_wrap_LinkUnknownWrenchContacts_contactWrench(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1509: flag=_wrap_LinkUnknownWrenchContacts_toString(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1510: flag=_wrap_delete_LinkUnknownWrenchContacts(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1511: flag=_wrap_new_estimateExternalWrenchesBuffers(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1512: flag=_wrap_estimateExternalWrenchesBuffers_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1513: flag=_wrap_estimateExternalWrenchesBuffers_getNrOfSubModels(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1514: flag=_wrap_estimateExternalWrenchesBuffers_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1515: flag=_wrap_estimateExternalWrenchesBuffers_isConsistent(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1516: flag=_wrap_estimateExternalWrenchesBuffers_A_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1517: flag=_wrap_estimateExternalWrenchesBuffers_A_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1518: flag=_wrap_estimateExternalWrenchesBuffers_x_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1519: flag=_wrap_estimateExternalWrenchesBuffers_x_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1520: flag=_wrap_estimateExternalWrenchesBuffers_b_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1521: flag=_wrap_estimateExternalWrenchesBuffers_b_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1522: flag=_wrap_estimateExternalWrenchesBuffers_b_contacts_subtree_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1523: flag=_wrap_estimateExternalWrenchesBuffers_b_contacts_subtree_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1524: flag=_wrap_estimateExternalWrenchesBuffers_subModelBase_H_link_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1525: flag=_wrap_estimateExternalWrenchesBuffers_subModelBase_H_link_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1526: flag=_wrap_delete_estimateExternalWrenchesBuffers(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1527: flag=_wrap_estimateExternalWrenchesWithoutInternalFT(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1528: flag=_wrap_estimateExternalWrenches(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1529: flag=_wrap_dynamicsEstimationForwardVelAccKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1530: flag=_wrap_dynamicsEstimationForwardVelKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1531: flag=_wrap_computeLinkNetWrenchesWithoutGravity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1532: flag=_wrap_estimateLinkContactWrenchesFromLinkNetExternalWrenches(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1533: flag=_wrap_new_ExtWrenchesAndJointTorquesEstimator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1534: flag=_wrap_delete_ExtWrenchesAndJointTorquesEstimator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1535: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_setModelAndSensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1536: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1537: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_loadModelAndSensorsFromFileWithSpecifiedDOFs(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1538: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1539: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_sensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1540: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_submodels(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1541: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1542: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_updateKinematicsFromFixedBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1543: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_computeExpectedFTSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1544: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_estimateExtWrenchesAndJointTorques(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1545: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_checkThatTheModelIsStill(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1546: flag=_wrap_ExtWrenchesAndJointTorquesEstimator_estimateLinkNetWrenchesWithoutGravity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1547: flag=_wrap_new_SimpleLeggedOdometry(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1548: flag=_wrap_delete_SimpleLeggedOdometry(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1549: flag=_wrap_SimpleLeggedOdometry_setModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1550: flag=_wrap_SimpleLeggedOdometry_model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1551: flag=_wrap_SimpleLeggedOdometry_updateKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1552: flag=_wrap_SimpleLeggedOdometry_init(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1553: flag=_wrap_SimpleLeggedOdometry_changeFixedFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1554: flag=_wrap_SimpleLeggedOdometry_getCurrentFixedLink(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1555: flag=_wrap_SimpleLeggedOdometry_getWorldLinkTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1556: flag=_wrap_SimpleLeggedOdometry_getWorldFrameTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1557: flag=_wrap_isLinkBerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1558: flag=_wrap_isJointBerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1559: flag=_wrap_isDOFBerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1560: flag=_wrap_new_BerdyOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1561: flag=_wrap_BerdyOptions_berdyVariant_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1562: flag=_wrap_BerdyOptions_berdyVariant_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1563: flag=_wrap_BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1564: flag=_wrap_BerdyOptions_includeAllNetExternalWrenchesAsDynamicVariables_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1565: flag=_wrap_BerdyOptions_includeAllJointAccelerationsAsSensors_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1566: flag=_wrap_BerdyOptions_includeAllJointAccelerationsAsSensors_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1567: flag=_wrap_BerdyOptions_includeAllJointTorquesAsSensors_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1568: flag=_wrap_BerdyOptions_includeAllJointTorquesAsSensors_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1569: flag=_wrap_BerdyOptions_includeAllNetExternalWrenchesAsSensors_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1570: flag=_wrap_BerdyOptions_includeAllNetExternalWrenchesAsSensors_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1571: flag=_wrap_BerdyOptions_includeFixedBaseExternalWrench_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1572: flag=_wrap_BerdyOptions_includeFixedBaseExternalWrench_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1573: flag=_wrap_BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1574: flag=_wrap_BerdyOptions_jointOnWhichTheInternalWrenchIsMeasured_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1575: flag=_wrap_BerdyOptions_baseLink_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1576: flag=_wrap_BerdyOptions_baseLink_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1577: flag=_wrap_BerdyOptions_checkConsistency(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1578: flag=_wrap_delete_BerdyOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1579: flag=_wrap_BerdySensor_type_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1580: flag=_wrap_BerdySensor_type_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1581: flag=_wrap_BerdySensor_id_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1582: flag=_wrap_BerdySensor_id_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1583: flag=_wrap_BerdySensor_range_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1584: flag=_wrap_BerdySensor_range_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1585: flag=_wrap_BerdySensor_eq(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1586: flag=_wrap_BerdySensor_lt(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1587: flag=_wrap_new_BerdySensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1588: flag=_wrap_delete_BerdySensor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1589: flag=_wrap_BerdyDynamicVariable_type_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1590: flag=_wrap_BerdyDynamicVariable_type_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1591: flag=_wrap_BerdyDynamicVariable_id_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1592: flag=_wrap_BerdyDynamicVariable_id_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1593: flag=_wrap_BerdyDynamicVariable_range_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1594: flag=_wrap_BerdyDynamicVariable_range_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1595: flag=_wrap_BerdyDynamicVariable_eq(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1596: flag=_wrap_BerdyDynamicVariable_lt(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1597: flag=_wrap_new_BerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1598: flag=_wrap_delete_BerdyDynamicVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1599: flag=_wrap_new_BerdyHelper(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1600: flag=_wrap_BerdyHelper_dynamicTraversal(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1601: flag=_wrap_BerdyHelper_model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1602: flag=_wrap_BerdyHelper_sensors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1603: flag=_wrap_BerdyHelper_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1604: flag=_wrap_BerdyHelper_init(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1605: flag=_wrap_BerdyHelper_getOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1606: flag=_wrap_BerdyHelper_getNrOfDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1607: flag=_wrap_BerdyHelper_getNrOfDynamicEquations(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1608: flag=_wrap_BerdyHelper_getNrOfSensorsMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1609: flag=_wrap_BerdyHelper_resizeAndZeroBerdyMatrices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1610: flag=_wrap_BerdyHelper_getBerdyMatrices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1611: flag=_wrap_BerdyHelper_getSensorsOrdering(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1612: flag=_wrap_BerdyHelper_getRangeSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1613: flag=_wrap_BerdyHelper_getRangeDOFSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1614: flag=_wrap_BerdyHelper_getRangeJointSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1615: flag=_wrap_BerdyHelper_getRangeLinkSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1616: flag=_wrap_BerdyHelper_getRangeRCMSensorVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1617: flag=_wrap_BerdyHelper_getRangeLinkVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1618: flag=_wrap_BerdyHelper_getRangeJointVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1619: flag=_wrap_BerdyHelper_getRangeDOFVariable(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1620: flag=_wrap_BerdyHelper_getDynamicVariablesOrdering(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1621: flag=_wrap_BerdyHelper_serializeDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1622: flag=_wrap_BerdyHelper_serializeSensorVariables(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1623: flag=_wrap_BerdyHelper_serializeDynamicVariablesComputedFromFixedBaseRNEA(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1624: flag=_wrap_BerdyHelper_extractJointTorquesFromDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1625: flag=_wrap_BerdyHelper_extractLinkNetExternalWrenchesFromDynamicVariables(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1626: flag=_wrap_BerdyHelper_updateKinematicsFromFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1627: flag=_wrap_BerdyHelper_updateKinematicsFromFixedBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1628: flag=_wrap_BerdyHelper_updateKinematicsFromTraversalFixedBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1629: flag=_wrap_BerdyHelper_setNetExternalWrenchMeasurementFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1630: flag=_wrap_BerdyHelper_getNetExternalWrenchMeasurementFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1631: flag=_wrap_delete_BerdyHelper(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1632: flag=_wrap_new_BerdySparseMAPSolver(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1633: flag=_wrap_delete_BerdySparseMAPSolver(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1634: flag=_wrap_BerdySparseMAPSolver_setDynamicsConstraintsPriorCovariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1635: flag=_wrap_BerdySparseMAPSolver_setDynamicsRegularizationPriorCovariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1636: flag=_wrap_BerdySparseMAPSolver_setDynamicsRegularizationPriorExpectedValue(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1637: flag=_wrap_BerdySparseMAPSolver_setMeasurementsPriorCovariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1638: flag=_wrap_BerdySparseMAPSolver_dynamicsConstraintsPriorCovarianceInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1639: flag=_wrap_BerdySparseMAPSolver_dynamicsRegularizationPriorCovarianceInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1640: flag=_wrap_BerdySparseMAPSolver_dynamicsRegularizationPriorExpectedValue(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1641: flag=_wrap_BerdySparseMAPSolver_measurementsPriorCovarianceInverse(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1642: flag=_wrap_BerdySparseMAPSolver_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1643: flag=_wrap_BerdySparseMAPSolver_initialize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1644: flag=_wrap_BerdySparseMAPSolver_updateEstimateInformationFixedBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1645: flag=_wrap_BerdySparseMAPSolver_updateEstimateInformationFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1646: flag=_wrap_BerdySparseMAPSolver_doEstimate(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1647: flag=_wrap_BerdySparseMAPSolver_getLastEstimate(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1648: flag=_wrap_AttitudeEstimatorState_m_orientation_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1649: flag=_wrap_AttitudeEstimatorState_m_orientation_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1650: flag=_wrap_AttitudeEstimatorState_m_angular_velocity_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1651: flag=_wrap_AttitudeEstimatorState_m_angular_velocity_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1652: flag=_wrap_AttitudeEstimatorState_m_gyroscope_bias_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1653: flag=_wrap_AttitudeEstimatorState_m_gyroscope_bias_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1654: flag=_wrap_new_AttitudeEstimatorState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1655: flag=_wrap_delete_AttitudeEstimatorState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1656: flag=_wrap_delete_IAttitudeEstimator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1657: flag=_wrap_IAttitudeEstimator_updateFilterWithMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1658: flag=_wrap_IAttitudeEstimator_propagateStates(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1659: flag=_wrap_IAttitudeEstimator_getOrientationEstimateAsRotationMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1660: flag=_wrap_IAttitudeEstimator_getOrientationEstimateAsQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1661: flag=_wrap_IAttitudeEstimator_getOrientationEstimateAsRPY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1662: flag=_wrap_IAttitudeEstimator_getInternalStateSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1663: flag=_wrap_IAttitudeEstimator_getInternalState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1664: flag=_wrap_IAttitudeEstimator_getDefaultInternalInitialState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1665: flag=_wrap_IAttitudeEstimator_setInternalState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1666: flag=_wrap_IAttitudeEstimator_setInternalStateInitialOrientation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1667: flag=_wrap_AttitudeMahonyFilterParameters_time_step_in_seconds_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1668: flag=_wrap_AttitudeMahonyFilterParameters_time_step_in_seconds_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1669: flag=_wrap_AttitudeMahonyFilterParameters_kp_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1670: flag=_wrap_AttitudeMahonyFilterParameters_kp_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1671: flag=_wrap_AttitudeMahonyFilterParameters_ki_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1672: flag=_wrap_AttitudeMahonyFilterParameters_ki_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1673: flag=_wrap_AttitudeMahonyFilterParameters_use_magnetometer_measurements_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1674: flag=_wrap_AttitudeMahonyFilterParameters_use_magnetometer_measurements_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1675: flag=_wrap_AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1676: flag=_wrap_AttitudeMahonyFilterParameters_confidence_magnetometer_measurements_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1677: flag=_wrap_new_AttitudeMahonyFilterParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1678: flag=_wrap_delete_AttitudeMahonyFilterParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1679: flag=_wrap_new_AttitudeMahonyFilter(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1680: flag=_wrap_AttitudeMahonyFilter_useMagnetoMeterMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1681: flag=_wrap_AttitudeMahonyFilter_setConfidenceForMagnetometerMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1682: flag=_wrap_AttitudeMahonyFilter_setGainkp(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1683: flag=_wrap_AttitudeMahonyFilter_setGainki(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1684: flag=_wrap_AttitudeMahonyFilter_setTimeStepInSeconds(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1685: flag=_wrap_AttitudeMahonyFilter_setGravityDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1686: flag=_wrap_AttitudeMahonyFilter_setParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1687: flag=_wrap_AttitudeMahonyFilter_getParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1688: flag=_wrap_AttitudeMahonyFilter_updateFilterWithMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1689: flag=_wrap_AttitudeMahonyFilter_propagateStates(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1690: flag=_wrap_AttitudeMahonyFilter_getOrientationEstimateAsRotationMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1691: flag=_wrap_AttitudeMahonyFilter_getOrientationEstimateAsQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1692: flag=_wrap_AttitudeMahonyFilter_getOrientationEstimateAsRPY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1693: flag=_wrap_AttitudeMahonyFilter_getInternalStateSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1694: flag=_wrap_AttitudeMahonyFilter_getInternalState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1695: flag=_wrap_AttitudeMahonyFilter_getDefaultInternalInitialState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1696: flag=_wrap_AttitudeMahonyFilter_setInternalState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1697: flag=_wrap_AttitudeMahonyFilter_setInternalStateInitialOrientation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1698: flag=_wrap_delete_AttitudeMahonyFilter(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1699: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekf_f(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1700: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekf_h(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1701: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianF(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1702: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfComputeJacobianH(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1703: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfPredict(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1704: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfUpdate(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1705: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfInit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1706: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfReset(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1707: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1708: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetInputVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1709: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetInitialState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1710: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetStateCovariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1711: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetSystemNoiseCovariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1712: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetMeasurementNoiseCovariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1713: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetStateSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1714: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetInputSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1715: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfSetOutputSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1716: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfGetStates(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1717: flag=_wrap_DiscreteExtendedKalmanFilterHelper_ekfGetStateCovariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1718: flag=_wrap_delete_DiscreteExtendedKalmanFilterHelper(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1719: flag=_wrap_output_dimensions_with_magnetometer_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1720: flag=_wrap_output_dimensions_without_magnetometer_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1721: flag=_wrap_input_dimensions_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1722: flag=_wrap_AttitudeQuaternionEKFParameters_time_step_in_seconds_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1723: flag=_wrap_AttitudeQuaternionEKFParameters_time_step_in_seconds_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1724: flag=_wrap_AttitudeQuaternionEKFParameters_bias_correlation_time_factor_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1725: flag=_wrap_AttitudeQuaternionEKFParameters_bias_correlation_time_factor_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1726: flag=_wrap_AttitudeQuaternionEKFParameters_accelerometer_noise_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1727: flag=_wrap_AttitudeQuaternionEKFParameters_accelerometer_noise_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1728: flag=_wrap_AttitudeQuaternionEKFParameters_magnetometer_noise_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1729: flag=_wrap_AttitudeQuaternionEKFParameters_magnetometer_noise_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1730: flag=_wrap_AttitudeQuaternionEKFParameters_gyroscope_noise_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1731: flag=_wrap_AttitudeQuaternionEKFParameters_gyroscope_noise_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1732: flag=_wrap_AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1733: flag=_wrap_AttitudeQuaternionEKFParameters_gyro_bias_noise_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1734: flag=_wrap_AttitudeQuaternionEKFParameters_initial_orientation_error_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1735: flag=_wrap_AttitudeQuaternionEKFParameters_initial_orientation_error_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1736: flag=_wrap_AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1737: flag=_wrap_AttitudeQuaternionEKFParameters_initial_ang_vel_error_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1738: flag=_wrap_AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1739: flag=_wrap_AttitudeQuaternionEKFParameters_initial_gyro_bias_error_variance_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1740: flag=_wrap_AttitudeQuaternionEKFParameters_use_magnetometer_measurements_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1741: flag=_wrap_AttitudeQuaternionEKFParameters_use_magnetometer_measurements_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1742: flag=_wrap_new_AttitudeQuaternionEKFParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1743: flag=_wrap_delete_AttitudeQuaternionEKFParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1744: flag=_wrap_new_AttitudeQuaternionEKF(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1745: flag=_wrap_AttitudeQuaternionEKF_getParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1746: flag=_wrap_AttitudeQuaternionEKF_setParameters(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1747: flag=_wrap_AttitudeQuaternionEKF_setGravityDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1748: flag=_wrap_AttitudeQuaternionEKF_setTimeStepInSeconds(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1749: flag=_wrap_AttitudeQuaternionEKF_setBiasCorrelationTimeFactor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1750: flag=_wrap_AttitudeQuaternionEKF_useMagnetometerMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1751: flag=_wrap_AttitudeQuaternionEKF_setMeasurementNoiseVariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1752: flag=_wrap_AttitudeQuaternionEKF_setSystemNoiseVariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1753: flag=_wrap_AttitudeQuaternionEKF_setInitialStateCovariance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1754: flag=_wrap_AttitudeQuaternionEKF_initializeFilter(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1755: flag=_wrap_AttitudeQuaternionEKF_updateFilterWithMeasurements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1756: flag=_wrap_AttitudeQuaternionEKF_propagateStates(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1757: flag=_wrap_AttitudeQuaternionEKF_getOrientationEstimateAsRotationMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1758: flag=_wrap_AttitudeQuaternionEKF_getOrientationEstimateAsQuaternion(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1759: flag=_wrap_AttitudeQuaternionEKF_getOrientationEstimateAsRPY(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1760: flag=_wrap_AttitudeQuaternionEKF_getInternalStateSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1761: flag=_wrap_AttitudeQuaternionEKF_getInternalState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1762: flag=_wrap_AttitudeQuaternionEKF_getDefaultInternalInitialState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1763: flag=_wrap_AttitudeQuaternionEKF_setInternalState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1764: flag=_wrap_AttitudeQuaternionEKF_setInternalStateInitialOrientation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1765: flag=_wrap_delete_AttitudeQuaternionEKF(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1766: flag=_wrap_estimateInertialParametersFromLinkBoundingBoxesAndTotalMass(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1767: flag=_wrap_computeBoundingBoxFromShape(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1768: flag=_wrap_computeBoxVertices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1769: flag=_wrap_new_KinDynComputations(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1770: flag=_wrap_delete_KinDynComputations(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1771: flag=_wrap_KinDynComputations_loadRobotModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1772: flag=_wrap_KinDynComputations_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1773: flag=_wrap_KinDynComputations_setFrameVelocityRepresentation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1774: flag=_wrap_KinDynComputations_getFrameVelocityRepresentation(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1775: flag=_wrap_KinDynComputations_getNrOfDegreesOfFreedom(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1776: flag=_wrap_KinDynComputations_getDescriptionOfDegreeOfFreedom(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1777: flag=_wrap_KinDynComputations_getDescriptionOfDegreesOfFreedom(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1778: flag=_wrap_KinDynComputations_getNrOfLinks(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1779: flag=_wrap_KinDynComputations_getNrOfFrames(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1780: flag=_wrap_KinDynComputations_getFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1781: flag=_wrap_KinDynComputations_setFloatingBase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1782: flag=_wrap_KinDynComputations_model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1783: flag=_wrap_KinDynComputations_getRobotModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1784: flag=_wrap_KinDynComputations_getRelativeJacobianSparsityPattern(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1785: flag=_wrap_KinDynComputations_getFrameFreeFloatingJacobianSparsityPattern(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1786: flag=_wrap_KinDynComputations_setJointPos(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1787: flag=_wrap_KinDynComputations_setRobotState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1788: flag=_wrap_KinDynComputations_getRobotState(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1789: flag=_wrap_KinDynComputations_getWorldBaseTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1790: flag=_wrap_KinDynComputations_getBaseTwist(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1791: flag=_wrap_KinDynComputations_getJointPos(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1792: flag=_wrap_KinDynComputations_getJointVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1793: flag=_wrap_KinDynComputations_getModelVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1794: flag=_wrap_KinDynComputations_getFrameIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1795: flag=_wrap_KinDynComputations_getFrameName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1796: flag=_wrap_KinDynComputations_getWorldTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1797: flag=_wrap_KinDynComputations_getWorldTransformsAsHomogeneous(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1798: flag=_wrap_KinDynComputations_getRelativeTransformExplicit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1799: flag=_wrap_KinDynComputations_getRelativeTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1800: flag=_wrap_KinDynComputations_getFrameVel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1801: flag=_wrap_KinDynComputations_getFrameAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1802: flag=_wrap_KinDynComputations_getFrameFreeFloatingJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1803: flag=_wrap_KinDynComputations_getRelativeJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1804: flag=_wrap_KinDynComputations_getRelativeJacobianExplicit(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1805: flag=_wrap_KinDynComputations_getFrameBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1806: flag=_wrap_KinDynComputations_getCenterOfMassPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1807: flag=_wrap_KinDynComputations_getCenterOfMassVelocity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1808: flag=_wrap_KinDynComputations_getCenterOfMassJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1809: flag=_wrap_KinDynComputations_getCenterOfMassBiasAcc(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1810: flag=_wrap_KinDynComputations_getAverageVelocity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1811: flag=_wrap_KinDynComputations_getAverageVelocityJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1812: flag=_wrap_KinDynComputations_getCentroidalAverageVelocity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1813: flag=_wrap_KinDynComputations_getCentroidalAverageVelocityJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1814: flag=_wrap_KinDynComputations_getLinearAngularMomentum(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1815: flag=_wrap_KinDynComputations_getLinearAngularMomentumJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1816: flag=_wrap_KinDynComputations_getCentroidalTotalMomentum(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1817: flag=_wrap_KinDynComputations_getCentroidalTotalMomentumJacobian(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1818: flag=_wrap_KinDynComputations_getFreeFloatingMassMatrix(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1819: flag=_wrap_KinDynComputations_inverseDynamics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1820: flag=_wrap_KinDynComputations_inverseDynamicsWithInternalJointForceTorques(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1821: flag=_wrap_KinDynComputations_generalizedBiasForces(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1822: flag=_wrap_KinDynComputations_generalizedGravityForces(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1823: flag=_wrap_KinDynComputations_generalizedExternalForces(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1824: flag=_wrap_KinDynComputations_inverseDynamicsInertialParametersRegressor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1825: flag=_wrap_Matrix4x4Vector_pop(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1826: flag=_wrap_Matrix4x4Vector_brace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1827: flag=_wrap_Matrix4x4Vector_setbrace(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1828: flag=_wrap_Matrix4x4Vector_append(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1829: flag=_wrap_Matrix4x4Vector_empty(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1830: flag=_wrap_Matrix4x4Vector_size(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1831: flag=_wrap_Matrix4x4Vector_swap(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1832: flag=_wrap_Matrix4x4Vector_begin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1833: flag=_wrap_Matrix4x4Vector_end(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1834: flag=_wrap_Matrix4x4Vector_rbegin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1835: flag=_wrap_Matrix4x4Vector_rend(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1836: flag=_wrap_Matrix4x4Vector_clear(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1837: flag=_wrap_Matrix4x4Vector_get_allocator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1838: flag=_wrap_Matrix4x4Vector_pop_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1839: flag=_wrap_Matrix4x4Vector_erase(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1840: flag=_wrap_new_Matrix4x4Vector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1841: flag=_wrap_Matrix4x4Vector_push_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1842: flag=_wrap_Matrix4x4Vector_front(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1843: flag=_wrap_Matrix4x4Vector_back(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1844: flag=_wrap_Matrix4x4Vector_assign(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1845: flag=_wrap_Matrix4x4Vector_resize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1846: flag=_wrap_Matrix4x4Vector_insert(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1847: flag=_wrap_Matrix4x4Vector_reserve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1848: flag=_wrap_Matrix4x4Vector_capacity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1849: flag=_wrap_Matrix4x4Vector_toMatlab(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1850: flag=_wrap_delete_Matrix4x4Vector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1851: flag=_wrap_ICameraAnimator_enableMouseControl(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1852: flag=_wrap_ICameraAnimator_getMoveSpeed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1853: flag=_wrap_ICameraAnimator_setMoveSpeed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1854: flag=_wrap_ICameraAnimator_getRotateSpeed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1855: flag=_wrap_ICameraAnimator_setRotateSpeed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1856: flag=_wrap_ICameraAnimator_getZoomSpeed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1857: flag=_wrap_ICameraAnimator_setZoomSpeed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1858: flag=_wrap_delete_ICameraAnimator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1859: flag=_wrap_delete_ICamera(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1860: flag=_wrap_ICamera_setPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1861: flag=_wrap_ICamera_setTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1862: flag=_wrap_ICamera_getPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1863: flag=_wrap_ICamera_getTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1864: flag=_wrap_ICamera_setUpVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1865: flag=_wrap_ICamera_animator(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1866: flag=_wrap_ColorViz_r_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1867: flag=_wrap_ColorViz_r_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1868: flag=_wrap_ColorViz_g_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1869: flag=_wrap_ColorViz_g_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1870: flag=_wrap_ColorViz_b_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1871: flag=_wrap_ColorViz_b_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1872: flag=_wrap_ColorViz_a_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1873: flag=_wrap_ColorViz_a_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1874: flag=_wrap_new_ColorViz(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1875: flag=_wrap_delete_ColorViz(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1876: flag=_wrap_PixelViz_width_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1877: flag=_wrap_PixelViz_width_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1878: flag=_wrap_PixelViz_height_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1879: flag=_wrap_PixelViz_height_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1880: flag=_wrap_new_PixelViz(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1881: flag=_wrap_delete_PixelViz(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1882: flag=_wrap_delete_ILight(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1883: flag=_wrap_ILight_getName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1884: flag=_wrap_ILight_setType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1885: flag=_wrap_ILight_getType(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1886: flag=_wrap_ILight_setPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1887: flag=_wrap_ILight_getPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1888: flag=_wrap_ILight_setDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1889: flag=_wrap_ILight_getDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1890: flag=_wrap_ILight_setAmbientColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1891: flag=_wrap_ILight_getAmbientColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1892: flag=_wrap_ILight_setSpecularColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1893: flag=_wrap_ILight_getSpecularColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1894: flag=_wrap_ILight_setDiffuseColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1895: flag=_wrap_ILight_getDiffuseColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1896: flag=_wrap_delete_IEnvironment(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1897: flag=_wrap_IEnvironment_getElements(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1898: flag=_wrap_IEnvironment_setElementVisibility(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1899: flag=_wrap_IEnvironment_setBackgroundColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1900: flag=_wrap_IEnvironment_setFloorGridColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1901: flag=_wrap_IEnvironment_setAmbientLight(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1902: flag=_wrap_IEnvironment_getLights(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1903: flag=_wrap_IEnvironment_addLight(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1904: flag=_wrap_IEnvironment_lightViz(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1905: flag=_wrap_IEnvironment_removeLight(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1906: flag=_wrap_delete_IJetsVisualization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1907: flag=_wrap_IJetsVisualization_setJetsFrames(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1908: flag=_wrap_IJetsVisualization_getNrOfJets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1909: flag=_wrap_IJetsVisualization_getJetDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1910: flag=_wrap_IJetsVisualization_setJetDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1911: flag=_wrap_IJetsVisualization_setJetColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1912: flag=_wrap_IJetsVisualization_setJetsDimensions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1913: flag=_wrap_IJetsVisualization_setJetsIntensity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1914: flag=_wrap_delete_ILabel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1915: flag=_wrap_ILabel_setText(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1916: flag=_wrap_ILabel_getText(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1917: flag=_wrap_ILabel_setSize(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1918: flag=_wrap_ILabel_width(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1919: flag=_wrap_ILabel_height(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1920: flag=_wrap_ILabel_setPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1921: flag=_wrap_ILabel_getPosition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1922: flag=_wrap_ILabel_setColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1923: flag=_wrap_ILabel_setVisible(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1924: flag=_wrap_delete_IVectorsVisualization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1925: flag=_wrap_IVectorsVisualization_addVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1926: flag=_wrap_IVectorsVisualization_getNrOfVectors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1927: flag=_wrap_IVectorsVisualization_getVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1928: flag=_wrap_IVectorsVisualization_updateVector(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1929: flag=_wrap_IVectorsVisualization_setVectorColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1930: flag=_wrap_IVectorsVisualization_setVectorsDefaultColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1931: flag=_wrap_IVectorsVisualization_setVectorsColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1932: flag=_wrap_IVectorsVisualization_setVectorsAspect(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1933: flag=_wrap_IVectorsVisualization_setVisible(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1934: flag=_wrap_IVectorsVisualization_getVectorLabel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1935: flag=_wrap_delete_IFrameVisualization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1936: flag=_wrap_IFrameVisualization_addFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1937: flag=_wrap_IFrameVisualization_setVisible(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1938: flag=_wrap_IFrameVisualization_getNrOfFrames(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1939: flag=_wrap_IFrameVisualization_getFrameTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1940: flag=_wrap_IFrameVisualization_updateFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1941: flag=_wrap_IFrameVisualization_getFrameLabel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1942: flag=_wrap_delete_IModelVisualization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1943: flag=_wrap_IModelVisualization_setPositions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1944: flag=_wrap_IModelVisualization_setLinkPositions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1945: flag=_wrap_IModelVisualization_model(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1946: flag=_wrap_IModelVisualization_getInstanceName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1947: flag=_wrap_IModelVisualization_setModelVisibility(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1948: flag=_wrap_IModelVisualization_setModelColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1949: flag=_wrap_IModelVisualization_resetModelColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1950: flag=_wrap_IModelVisualization_setLinkColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1951: flag=_wrap_IModelVisualization_resetLinkColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1952: flag=_wrap_IModelVisualization_getLinkNames(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1953: flag=_wrap_IModelVisualization_setLinkVisibility(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1954: flag=_wrap_IModelVisualization_getFeatures(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1955: flag=_wrap_IModelVisualization_setFeatureVisibility(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1956: flag=_wrap_IModelVisualization_jets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1957: flag=_wrap_IModelVisualization_getWorldLinkTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1958: flag=_wrap_IModelVisualization_getWorldFrameTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1959: flag=_wrap_IModelVisualization_label(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1960: flag=_wrap_delete_ITexture(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1961: flag=_wrap_ITexture_environment(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1962: flag=_wrap_ITexture_getPixelColor(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1963: flag=_wrap_ITexture_getPixels(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1964: flag=_wrap_ITexture_drawToFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1965: flag=_wrap_ITexture_enableDraw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1966: flag=_wrap_ITexture_width(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1967: flag=_wrap_ITexture_height(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1968: flag=_wrap_ITexture_setSubDrawArea(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1969: flag=_wrap_VisualizerOptions_verbose_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1970: flag=_wrap_VisualizerOptions_verbose_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1971: flag=_wrap_VisualizerOptions_winWidth_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1972: flag=_wrap_VisualizerOptions_winWidth_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1973: flag=_wrap_VisualizerOptions_winHeight_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1974: flag=_wrap_VisualizerOptions_winHeight_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1975: flag=_wrap_VisualizerOptions_rootFrameArrowsDimension_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1976: flag=_wrap_VisualizerOptions_rootFrameArrowsDimension_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1977: flag=_wrap_new_VisualizerOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1978: flag=_wrap_delete_VisualizerOptions(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1979: flag=_wrap_delete_ITexturesHandler(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1980: flag=_wrap_ITexturesHandler_add(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1981: flag=_wrap_ITexturesHandler_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1982: flag=_wrap_new_Visualizer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1983: flag=_wrap_delete_Visualizer(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1984: flag=_wrap_Visualizer_init(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1985: flag=_wrap_Visualizer_getNrOfVisualizedModels(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1986: flag=_wrap_Visualizer_getModelInstanceName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1987: flag=_wrap_Visualizer_getModelInstanceIndex(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1988: flag=_wrap_Visualizer_addModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1989: flag=_wrap_Visualizer_modelViz(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1990: flag=_wrap_Visualizer_camera(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1991: flag=_wrap_Visualizer_enviroment(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1992: flag=_wrap_Visualizer_environment(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1993: flag=_wrap_Visualizer_vectors(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1994: flag=_wrap_Visualizer_frames(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1995: flag=_wrap_Visualizer_textures(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1996: flag=_wrap_Visualizer_getLabel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1997: flag=_wrap_Visualizer_width(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1998: flag=_wrap_Visualizer_height(resc,resv,argc,(mxArray**)(argv)); break;
+  case 1999: flag=_wrap_Visualizer_run(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2000: flag=_wrap_Visualizer_draw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2001: flag=_wrap_Visualizer_subDraw(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2002: flag=_wrap_Visualizer_drawToFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2003: flag=_wrap_Visualizer_close(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2004: flag=_wrap_Visualizer_isWindowActive(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2005: flag=_wrap_Visualizer_setColorPalette(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2006: flag=_wrap_Polygon_m_vertices_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2007: flag=_wrap_Polygon_m_vertices_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2008: flag=_wrap_new_Polygon(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2009: flag=_wrap_Polygon_setNrOfVertices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2010: flag=_wrap_Polygon_getNrOfVertices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2011: flag=_wrap_Polygon_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2012: flag=_wrap_Polygon_applyTransform(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2013: flag=_wrap_Polygon_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2014: flag=_wrap_Polygon_XYRectangleFromOffsets(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2015: flag=_wrap_delete_Polygon(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2016: flag=_wrap_Polygon2D_m_vertices_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2017: flag=_wrap_Polygon2D_m_vertices_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2018: flag=_wrap_new_Polygon2D(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2019: flag=_wrap_Polygon2D_setNrOfVertices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2020: flag=_wrap_Polygon2D_getNrOfVertices(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2021: flag=_wrap_Polygon2D_isValid(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2022: flag=_wrap_Polygon2D_paren(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2023: flag=_wrap_delete_Polygon2D(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2024: flag=_wrap_ConvexHullProjectionConstraint_setActive(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2025: flag=_wrap_ConvexHullProjectionConstraint_isActive(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2026: flag=_wrap_ConvexHullProjectionConstraint_getNrOfConstraints(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2027: flag=_wrap_ConvexHullProjectionConstraint_projectedConvexHull_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2028: flag=_wrap_ConvexHullProjectionConstraint_projectedConvexHull_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2029: flag=_wrap_ConvexHullProjectionConstraint_A_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2030: flag=_wrap_ConvexHullProjectionConstraint_A_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2031: flag=_wrap_ConvexHullProjectionConstraint_b_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2032: flag=_wrap_ConvexHullProjectionConstraint_b_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2033: flag=_wrap_ConvexHullProjectionConstraint_P_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2034: flag=_wrap_ConvexHullProjectionConstraint_P_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2035: flag=_wrap_ConvexHullProjectionConstraint_Pdirection_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2036: flag=_wrap_ConvexHullProjectionConstraint_Pdirection_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2037: flag=_wrap_ConvexHullProjectionConstraint_AtimesP_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2038: flag=_wrap_ConvexHullProjectionConstraint_AtimesP_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2039: flag=_wrap_ConvexHullProjectionConstraint_o_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2040: flag=_wrap_ConvexHullProjectionConstraint_o_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2041: flag=_wrap_ConvexHullProjectionConstraint_buildConvexHull(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2042: flag=_wrap_ConvexHullProjectionConstraint_supportFrameIndices_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2043: flag=_wrap_ConvexHullProjectionConstraint_supportFrameIndices_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2044: flag=_wrap_ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_get(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2045: flag=_wrap_ConvexHullProjectionConstraint_absoluteFrame_X_supportFrame_set(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2046: flag=_wrap_ConvexHullProjectionConstraint_project(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2047: flag=_wrap_ConvexHullProjectionConstraint_computeMargin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2048: flag=_wrap_ConvexHullProjectionConstraint_setProjectionAlongDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2049: flag=_wrap_ConvexHullProjectionConstraint_projectAlongDirection(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2050: flag=_wrap_new_ConvexHullProjectionConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2051: flag=_wrap_delete_ConvexHullProjectionConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2052: flag=_wrap_sizeOfRotationParametrization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2053: flag=_wrap_new_InverseKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2054: flag=_wrap_delete_InverseKinematics(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2055: flag=_wrap_InverseKinematics_loadModelFromFile(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2056: flag=_wrap_InverseKinematics_setModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2057: flag=_wrap_InverseKinematics_setJointLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2058: flag=_wrap_InverseKinematics_getJointLimits(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2059: flag=_wrap_InverseKinematics_clearProblem(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2060: flag=_wrap_InverseKinematics_setFloatingBaseOnFrameNamed(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2061: flag=_wrap_InverseKinematics_setCurrentRobotConfiguration(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2062: flag=_wrap_InverseKinematics_setJointConfiguration(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2063: flag=_wrap_InverseKinematics_setRotationParametrization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2064: flag=_wrap_InverseKinematics_rotationParametrization(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2065: flag=_wrap_InverseKinematics_setMaxIterations(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2066: flag=_wrap_InverseKinematics_maxIterations(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2067: flag=_wrap_InverseKinematics_setMaxCPUTime(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2068: flag=_wrap_InverseKinematics_maxCPUTime(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2069: flag=_wrap_InverseKinematics_setCostTolerance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2070: flag=_wrap_InverseKinematics_costTolerance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2071: flag=_wrap_InverseKinematics_setConstraintsTolerance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2072: flag=_wrap_InverseKinematics_constraintsTolerance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2073: flag=_wrap_InverseKinematics_setVerbosity(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2074: flag=_wrap_InverseKinematics_linearSolverName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2075: flag=_wrap_InverseKinematics_setLinearSolverName(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2076: flag=_wrap_InverseKinematics_addFrameConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2077: flag=_wrap_InverseKinematics_addFramePositionConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2078: flag=_wrap_InverseKinematics_addFrameRotationConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2079: flag=_wrap_InverseKinematics_activateFrameConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2080: flag=_wrap_InverseKinematics_deactivateFrameConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2081: flag=_wrap_InverseKinematics_isFrameConstraintActive(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2082: flag=_wrap_InverseKinematics_addCenterOfMassProjectionConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2083: flag=_wrap_InverseKinematics_getCenterOfMassProjectionMargin(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2084: flag=_wrap_InverseKinematics_getCenterOfMassProjectConstraintConvexHull(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2085: flag=_wrap_InverseKinematics_addTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2086: flag=_wrap_InverseKinematics_addPositionTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2087: flag=_wrap_InverseKinematics_addRotationTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2088: flag=_wrap_InverseKinematics_updateTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2089: flag=_wrap_InverseKinematics_updatePositionTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2090: flag=_wrap_InverseKinematics_updateRotationTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2091: flag=_wrap_InverseKinematics_setDefaultTargetResolutionMode(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2092: flag=_wrap_InverseKinematics_defaultTargetResolutionMode(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2093: flag=_wrap_InverseKinematics_setTargetResolutionMode(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2094: flag=_wrap_InverseKinematics_targetResolutionMode(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2095: flag=_wrap_InverseKinematics_setDesiredFullJointsConfiguration(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2096: flag=_wrap_InverseKinematics_setDesiredReducedJointConfiguration(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2097: flag=_wrap_InverseKinematics_setFullJointsInitialCondition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2098: flag=_wrap_InverseKinematics_setReducedInitialCondition(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2099: flag=_wrap_InverseKinematics_solve(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2100: flag=_wrap_InverseKinematics_getFullJointsSolution(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2101: flag=_wrap_InverseKinematics_getReducedSolution(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2102: flag=_wrap_InverseKinematics_getPoseForFrame(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2103: flag=_wrap_InverseKinematics_fullModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2104: flag=_wrap_InverseKinematics_reducedModel(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2105: flag=_wrap_InverseKinematics_setCOMTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2106: flag=_wrap_InverseKinematics_setCOMAsConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2107: flag=_wrap_InverseKinematics_setCOMAsConstraintTolerance(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2108: flag=_wrap_InverseKinematics_isCOMAConstraint(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2109: flag=_wrap_InverseKinematics_isCOMTargetActive(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2110: flag=_wrap_InverseKinematics_deactivateCOMTarget(resc,resv,argc,(mxArray**)(argv)); break;
+  case 2111: flag=_wrap_InverseKinematics_setCOMConstraintProjectionDirection(resc,resv,argc,(mxArray**)(argv)); break;
   default: flag=1, SWIG_Error(SWIG_RuntimeError, "No function id %d.", fcn_id);
   }
   if (flag) {
     mexErrMsgIdAndTxt(SWIG_ErrorType(SWIG_lasterror_code), SWIG_lasterror_msg);
   }
 }
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/autogenerated/iDynTreeSwigRef.m` & `idyntree-9.1.1.dev7/bindings/matlab/autogenerated/iDynTreeSwigRef.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/fix_generic_names_in_autogenerated_files.sh` & `idyntree-9.1.1.dev7/bindings/matlab/fix_generic_names_in_autogenerated_files.sh`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/matlab_mat4x4vec.i` & `idyntree-9.1.1.dev7/bindings/matlab/matlab_mat4x4vec.i`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/matlab_matvec.i` & `idyntree-9.1.1.dev7/bindings/matlab/matlab_matvec.i`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/matlab_spatialvec.i` & `idyntree-9.1.1.dev7/bindings/matlab/matlab_spatialvec.i`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/tests/CMakeLists.txt` & `idyntree-9.1.1.dev7/bindings/matlab/tests/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/tests/EKFTest.m` & `idyntree-9.1.1.dev7/bindings/matlab/tests/EKFTest.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/tests/InertiaUnitTest.m` & `idyntree-9.1.1.dev7/bindings/matlab/tests/InertiaUnitTest.m`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,15 @@
     twistInFrame1.setVal(0,twistInFrame1_m(1));
     twistInFrame1.setVal(1,twistInFrame1_m(2));
     twistInFrame1.setVal(2,twistInFrame1_m(3));
     twistInFrame1.setVal(3,twistInFrame1_m(4));
     twistInFrame1.setVal(4,twistInFrame1_m(5));
     twistInFrame1.setVal(5,twistInFrame1_m(6));
 
-    angularInertia = iDynTree.RotationalInertia();
+    angularInertia = iDynTree.RotationalInertiaRaw();
     angularInertia.setVal(0,0,1.0);
     angularInertia.setVal(1,1,2.0);
     angularInertia.setVal(2,2,3.0);
     angularInertia.setVal(0,1,0.0);
     angularInertia.setVal(0,2,0.0);
     angularInertia.setVal(1,0,0.0);
     angularInertia.setVal(1,2,0.0);
```

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/tests/PositionUnitTest.m` & `idyntree-9.1.1.dev7/bindings/matlab/tests/PositionUnitTest.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/tests/TransformUnitTest.m` & `idyntree-9.1.1.dev7/bindings/matlab/tests/TransformUnitTest.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/tests/highLevelWrappersSmokeTest.m` & `idyntree-9.1.1.dev7/bindings/matlab/tests/highLevelWrappersSmokeTest.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/matlab/tests/model.urdf` & `idyntree-9.1.1.dev7/bindings/matlab/tests/model.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/CMakeLists.txt` & `idyntree-9.1.1.dev7/bindings/pybind11/CMakeLists.txt`

 * *Files 2% similar despite different names*

```diff
@@ -5,14 +5,15 @@
                                     idyntree_model.h idyntree_model.cpp
                                     idyntree_sensors.h idyntree_sensors.cpp
                                     idyntree_modelio_urdf.h idyntree_modelio_urdf.cpp
                                     idyntree_high_level.h idyntree_high_level.cpp)
 
 target_link_libraries(pybind11_idyntree PUBLIC idyntree-core
                                                idyntree-model
+                                               idyntree-sensors
                                                idyntree-modelio)
 
 # The generated Python dynamic module must have the same name as the pybind11
 # module, i.e. `bindings`.
 set_target_properties(pybind11_idyntree PROPERTIES
     LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/idyntree
     OUTPUT_NAME "pybind")
```

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/idyntree.cpp` & `idyntree-9.1.1.dev7/bindings/pybind11/idyntree.cpp`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/idyntree_core.cpp` & `idyntree-9.1.1.dev7/bindings/pybind11/idyntree_core.cpp`

 * *Files 13% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 #include "idyntree_core.h"
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/Direction.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/MatrixFixSize.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Rotation.h>
-#include <iDynTree/RotationalInertia.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/VectorFixSize.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixFixSize.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/PositionRaw.h>
+#include <iDynTree/Core/Rotation.h>
+#include <iDynTree/Core/RotationRaw.h>
+#include <iDynTree/Core/RotationalInertiaRaw.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
 #include <pybind11/operators.h>
 #include <pybind11/pybind11.h>
 #include <pybind11/stl.h>
 
 #include <array>
 #include <cstddef>
 
@@ -191,40 +193,45 @@
                                        py::buffer_protocol());
   matrixDynSizeClassDefinition(matrix_dyn);
   createFixSizeMatrix<3, 3>(module, "Matrix3x3");
   createFixSizeMatrix<4, 4>(module, "Matrix4x4");
   createFixSizeMatrix<6, 6>(module, "Matrix6x6");
 
   // Positions, Rotations and Transforms.
-  py::class_<Position, VectorFixSize<3>>(module, "Position")
+  py::class_<PositionRaw, VectorFixSize<3>>(module, "_PositionRaw")
+      // Do not expose constructor as we do not want users to use this class.
+      .def("__repr__", &PositionRaw::toString);
+
+  py::class_<Position, PositionRaw>(module, "Position")
       .def(py::init())
       .def(py::init<double, double, double>())
       .def(py::self + py::self)
       .def(py::self - py::self)
       .def(-py::self)
-      .def("__repr__", &Position::toString)
       .def_static("Zero", &Position::Zero);
 
+  py::class_<RotationRaw, MatrixFixSize<3, 3>>(module, "_RotationRaw")
+      // Do not expose constructor as we do not want users to use this class.
+      .def("__repr__", &RotationRaw::toString);
 
-  py::class_<Rotation, MatrixFixSize<3, 3>>(module, "Rotation")
+  py::class_<Rotation, RotationRaw>(module, "Rotation")
       .def(py::init())
       .def(py::init<double, double, double,  //
                     double, double, double,  //
                     double, double, double>())
       .def("inverse", &Rotation::inverse)
       .def(py::self * py::self)
       .def(
           "__mul__",
           [](const Rotation& r, const Position& p) -> Position {
             return r * p;
           },
           py::is_operator())
       .def("as_rpy", &Rotation::asRPY)
       .def("as_quaternion", &Rotation::asQuaternion)
-      .def("__repr__", &Rotation::toString)
       .def_static("Identity", &Rotation::Identity)
       .def_static("RotX", &Rotation::RotX)
       .def_static("RotY", &Rotation::RotY)
       .def_static("RotZ", &Rotation::RotZ)
       .def_static("RPY", &Rotation::RPY)
       .def_static("Quaternion", &Rotation::RotationFromQuaternion);
 
@@ -237,29 +244,31 @@
 
   py::class_<Axis>(module, "Axis")
       .def(py::init<const Direction&, const Position&>())
       .def_property("direction", &Axis::getDirection, &Axis::setDirection)
       .def_property("origin", &Axis::getOrigin, &Axis::setOrigin)
       .def("__repr__", &Axis::toString);
 
-  py::class_<RotationalInertia, MatrixFixSize<3, 3>>(module,
-                                                     "RotationalInertia")
+  py::class_<RotationalInertiaRaw, MatrixFixSize<3, 3>>(module,
+                                                        "RotationalInertia")
       .def(py::init());
 
-  py::class_<SpatialInertia>(module, "SpatialInertia")
-      .def(py::init())
-      .def(py::init<double, const Position&, const RotationalInertia&>())
+  py::class_<SpatialInertiaRaw>(module, "_SpatialInertiaRaw")
       .def("from_rotational_inertia_wrt_center_of_mass",
-           &SpatialInertia::fromRotationalInertiaWrtCenterOfMass)
-      .def("get_mass", &SpatialInertia::getMass)
-      .def("get_center_of_mass", &SpatialInertia::getCenterOfMass)
+           &SpatialInertiaRaw::fromRotationalInertiaWrtCenterOfMass)
+      .def("get_mass", &SpatialInertiaRaw::getMass)
+      .def("get_center_of_mass", &SpatialInertiaRaw::getCenterOfMass)
       .def("get_rotational_inertia_wrt_frame_origin",
-           &SpatialInertia::getRotationalInertiaWrtFrameOrigin)
+           &SpatialInertiaRaw::getRotationalInertiaWrtFrameOrigin)
       .def("get_rotational_inertia_wrt_center_of_mass",
-           &SpatialInertia::getRotationalInertiaWrtCenterOfMass)
+           &SpatialInertiaRaw::getRotationalInertiaWrtCenterOfMass);
+
+  py::class_<SpatialInertia, SpatialInertiaRaw>(module, "SpatialInertia")
+      .def(py::init())
+      .def(py::init<double, const PositionRaw&, const RotationalInertiaRaw&>())
       .def_static("Zero", &SpatialInertia::Zero)
       .def("as_matrix", &SpatialInertia::asMatrix)
       .def(py::self + py::self)
       .def("__repr__", [](const SpatialInertia& inertia) {
         return inertia.asMatrix().toString();
       });
```

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/idyntree_high_level.cpp` & `idyntree-9.1.1.dev7/bindings/pybind11/idyntree_high_level.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,13 @@
-#include <iDynTree/Transform.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/VectorFixSize.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
 #include <iDynTree/KinDynComputations.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Model.h>
 #include <pybind11/operators.h>
 #include <pybind11/pybind11.h>
 #include <pybind11/stl.h>
 
 namespace iDynTree {
 namespace bindings {
 namespace {
```

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/idyntree_model.cpp` & `idyntree-9.1.1.dev7/bindings/pybind11/idyntree_model.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #include "idyntree_model.h"
 
 #include "error_utilities.h"
 
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/IJoint.h>
-#include <iDynTree/Indices.h>
-#include <iDynTree/Link.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/PrismaticJoint.h>
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/SolidShapes.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/ModelTestUtils.h>
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/IJoint.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/Link.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/PrismaticJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/Model/SolidShapes.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/ModelTestUtils.h>
 
 #include <pybind11/operators.h>
 #include <pybind11/pybind11.h>
 #include <pybind11/stl.h>
 
 namespace iDynTree {
 namespace bindings {
```

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/idyntree_modelio_urdf.cpp` & `idyntree-9.1.1.dev7/bindings/pybind11/idyntree_modelio_urdf.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 #include "idyntree_modelio_urdf.h"
 
 #include "error_utilities.h"
 
 #include <string>
 #include <vector>
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelExporter.h>
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/ModelExporter.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 #include <pybind11/operators.h>
 #include <pybind11/pybind11.h>
 #include <pybind11/stl.h>
 
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/idyntree_sensors.cpp` & `idyntree-9.1.1.dev7/bindings/pybind11/idyntree_sensors.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 #include "idyntree_sensors.h"
 #include "error_utilities.h"
 
 #include <pybind11/operators.h>
 #include <pybind11/pybind11.h>
 #include <pybind11/stl.h>
 
-#include <iDynTree/AccelerometerSensor.h>
-#include <iDynTree/Sensors.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Sensors/AccelerometerSensor.h>
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
 
 namespace iDynTree {
 namespace bindings {
 namespace {
 
 class SensorsListHelper {
  public:
```

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_core.py` & `idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_core.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_high_level.py` & `idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_high_level.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-"""Tests for idyntree-high-level Python bindings."""
+"""Tests for idyntree-sensors Python bindings."""
 import itertools
 import math
 import unittest
 
 import idyntree.pybind as iDynTree
 import numpy as np
```

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_model.py` & `idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_model.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_modelio_urdf.py` & `idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_modelio_urdf.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/pybind11/tests/test_idyntree_sensors.py` & `idyntree-9.1.1.dev7/bindings/pybind11/tests/test_idyntree_sensors.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-"""Tests for sensors-related Python bindings."""
+"""Tests for idyntree-sensors Python bindings."""
 import itertools
 import unittest
 
 import idyntree.pybind as iDynTree
 
 
 class IDynTreeSensorsTest(unittest.TestCase):
```

### Comparing `idyntree-9.1.1.dev66/bindings/python/CMakeLists.txt` & `idyntree-9.1.1.dev7/bindings/python/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/python/numpy.i` & `idyntree-9.1.1.dev7/bindings/python/numpy.i`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/python/python.i` & `idyntree-9.1.1.dev7/bindings/python/python.i`

 * *Files 5% similar despite different names*

```diff
@@ -320,51 +320,51 @@
 };
 
 %extend iDynTree::Rotation {
     static iDynTree::Rotation FromPython(double* in, int i, int j) {
         if (i != 3 || j != 3)
             throw std::runtime_error("Wrong size of input matrix");
 
-        return iDynTree::Rotation(in, static_cast<unsigned>(i), static_cast<unsigned>(j));
+        return iDynTree::RotationRaw(in, static_cast<unsigned>(i), static_cast<unsigned>(j));
     }
 
     Rotation(const double* in_data, const std::ptrdiff_t in_rows, const std::ptrdiff_t in_cols) {
-        iDynTree::Rotation* rot = new iDynTree::Rotation(in_data,
-                                                         static_cast<unsigned>(in_rows),
-                                                         static_cast<unsigned>(in_cols));
+        iDynTree::Rotation* rot = new iDynTree::Rotation(iDynTree::RotationRaw(in_data,
+                                                                               static_cast<unsigned>(in_rows),
+                                                                               static_cast<unsigned>(in_cols)));
         return rot;
     }
 };
 
 %extend iDynTree::Position {
     static iDynTree::Position FromPython(double* in, int size) {
         if (size != 3)
             throw std::runtime_error("Wrong size of input array");
 
-        return iDynTree::Position(in, static_cast<unsigned>(size));
+        return iDynTree::PositionRaw(in, static_cast<unsigned>(size));
     }
 
     Position(const double* in_data, const unsigned in_size) {
-        iDynTree::Position* pos = new iDynTree::Position(in_data, in_size);
+        iDynTree::Position* pos = new iDynTree::Position(iDynTree::PositionRaw(in_data, in_size));
         return pos;
     }
 };
 
 %extend iDynTree::Transform {
 
     void setPosition(const double* in_data, const unsigned in_size) {
-        $self->setPosition(iDynTree::Position(in_data, static_cast<unsigned>(in_size)));
+        $self->setPosition(iDynTree::PositionRaw(in_data, static_cast<unsigned>(in_size)));
     }
 
     void setRotation(const double* in_data,
                      const std::ptrdiff_t in_rows,
                      const std::ptrdiff_t in_cols) {
-        $self->setRotation(iDynTree::Rotation(in_data,
-                                              static_cast<unsigned>(in_rows),
-                                              static_cast<unsigned>(in_cols)));
+        $self->setRotation(iDynTree::RotationRaw(in_data,
+                                                 static_cast<unsigned>(in_rows),
+                                                 static_cast<unsigned>(in_cols)));
     }
 };
 
 
 %attributeref(iDynTree::FreeFloatingPos, iDynTree::Transform&, worldBasePos)
 %attributeref(iDynTree::FreeFloatingPos, iDynTree::JointPosDoubleArray&, jointPos)
 %attributeref(iDynTree::FreeFloatingVel, iDynTree::Twist&, baseVel)
```

### Comparing `idyntree-9.1.1.dev66/bindings/python/tests/dyncomp.py` & `idyntree-9.1.1.dev7/bindings/python/tests/dyncomp.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/python/tests/geometry.py` & `idyntree-9.1.1.dev7/bindings/python/tests/geometry.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/python/tests/helpers.py` & `idyntree-9.1.1.dev7/bindings/python/tests/helpers.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/python/tests/joints.py` & `idyntree-9.1.1.dev7/bindings/python/tests/joints.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/python/tests/model.urdf` & `idyntree-9.1.1.dev7/bindings/python/tests/model.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/python/tests/modelloader.py` & `idyntree-9.1.1.dev7/bindings/python/tests/modelloader.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/bindings/python/visualize/meshcat_visualizer.py` & `idyntree-9.1.1.dev7/bindings/python/visualize/meshcat_visualizer.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+"""
+Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+
+Licensed under either the GNU Lesser General Public License v3.0 :
+https://www.gnu.org/licenses/lgpl-3.0.html
+or the GNU Lesser General Public License v2.1 :
+https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+at your option.
+"""
 
 import os
 import idyntree.bindings as idyn
 import numpy as np
 import warnings
 from pathlib import Path
```

### Comparing `idyntree-9.1.1.dev66/bindings/sensors.i` & `idyntree-9.1.1.dev7/bindings/sensors.i`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/AddInstallRPATHSupport.cmake` & `idyntree-9.1.1.dev7/cmake/AddInstallRPATHSupport.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/AddUninstallTarget.cmake` & `idyntree-9.1.1.dev7/cmake/AddUninstallTarget.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/ECMEnableSanitizers.cmake` & `idyntree-9.1.1.dev7/cmake/ECMEnableSanitizers.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/ExtractVersion.cmake` & `idyntree-9.1.1.dev7/cmake/ExtractVersion.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/FindIPOPT.cmake` & `idyntree-9.1.1.dev7/cmake/FindIPOPT.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/FindIrrlicht.cmake` & `idyntree-9.1.1.dev7/cmake/FindIrrlicht.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/FindMatlab.cmake` & `idyntree-9.1.1.dev7/cmake/FindMatlab.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/FindOctave.cmake` & `idyntree-9.1.1.dev7/cmake/FindOctave.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/FindTinyXML.cmake` & `idyntree-9.1.1.dev7/cmake/FindTinyXML.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/FindValgrind.cmake` & `idyntree-9.1.1.dev7/cmake/FindValgrind.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/FindWORHP.cmake` & `idyntree-9.1.1.dev7/cmake/FindWORHP.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/InstallBasicPackageFiles.cmake` & `idyntree-9.1.1.dev7/cmake/InstallBasicPackageFiles.cmake`

 * *Files 0% similar despite different names*

```diff
@@ -504,17 +504,15 @@
     # Generate the compatibility code
     unset(_compatibility_vars)
     if(_IBPF_ENABLE_COMPATIBILITY_VARS)
       unset(_get_include_dir_code)
       unset(_set_include_dir_code)
       unset(_target_list)
       foreach(_target ${_targets})
-        if(NOT ${_target} STREQUAL "idyntree-sensors")
-          list(APPEND _target_list ${_IBPF_NAMESPACE}${_target})
-        endif()
+        list(APPEND _target_list ${_IBPF_NAMESPACE}${_target})
       endforeach()
       if(DEFINED ${_IBPF_VARS_PREFIX}_BUILD_INCLUDEDIR OR
          DEFINED BUILD_${_IBPF_VARS_PREFIX}_INCLUDEDIR OR
          DEFINED ${_IBPF_VARS_PREFIX}_INSTALL_INCLUDEDIR OR
          DEFINED INSTALL_${_IBPF_VARS_PREFIX}_INCLUDEDIR)
         list(APPEND _include_dir_list "\"\@PACKAGE_${_IBPF_VARS_PREFIX}_INCLUDEDIR\@\"")
       elseif(DEFINED ${_IBPF_VARS_PREFIX}_BUILD_INCLUDE_DIR OR
```

### Comparing `idyntree-9.1.1.dev66/cmake/OrocosKDLFindLogic.cmake` & `idyntree-9.1.1.dev7/cmake/OrocosKDLFindLogic.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/StandardFindModule.cmake` & `idyntree-9.1.1.dev7/cmake/StandardFindModule.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/iDynTreeDependencies.cmake` & `idyntree-9.1.1.dev7/cmake/iDynTreeDependencies.cmake`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright: (C) 2017 Fondazione Istituto Italiano di Tecnologia
+# Authors: Silvio Traversaro
+# CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
 
 #########################################################################
 # Enable/disable dependencies
 # Positional argument: CMake package name
 # Options:
 # MINIMUM_VERSION <version> : Minimum version required for the package
 # COMPONENTS <comp1> ...    : Components that needs to be find for the dependency
```

### Comparing `idyntree-9.1.1.dev66/cmake/iDynTreeOptions.cmake` & `idyntree-9.1.1.dev7/cmake/iDynTreeOptions.cmake`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/cmake/valgrind-macos.supp` & `idyntree-9.1.1.dev7/cmake/valgrind-macos.supp`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/doc/CMakeLists.txt` & `idyntree-9.1.1.dev7/doc/CMakeLists.txt`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,10 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+# Copyright: (C) 2009 RobotCub Consortium
+# Authors: Paul Fitzpatrick
+# CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
 
 find_package(Doxygen)
 
 if(DOXYGEN_FOUND)
     set(DOX_GENERATE_HTML YES)
     set(DOX_GENERATE_XML NO)
```

### Comparing `idyntree-9.1.1.dev66/doc/Doxyfile.in` & `idyntree-9.1.1.dev7/doc/Doxyfile.in`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/doc/build-from-source.md` & `idyntree-9.1.1.dev7/doc/build-from-source.md`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/doc/dcTutorialCpp.md` & `idyntree-9.1.1.dev7/doc/dcTutorialCpp.md`

 * *Files 0% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 For this tutorial we also use the appropriate `using` definitions to 
 avoid having to type the `iDynTree` namespace.
 
 ~~~cpp
 #include <iostream>
 
 #include <iDynTree/KinDynComputations.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 using namespace iDynTree;
 ~~~
 
 The first thing that we have to do 
 is to initialize the class by providing a model of the robot. Currently 
 iDynTree supports only URDF models to specify the model.
```

### Comparing `idyntree-9.1.1.dev66/doc/dev/faqs.md` & `idyntree-9.1.1.dev7/doc/dev/faqs.md`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 ## What are best entry points to understand iDynTree structure? 
 The best way to understand iDynTree is probably to read directly the source code. 
 
 Some classes extremly used are the following:
 
 | Class name | Description |  Doxygen docs | Headers (`.h`) | Source Code (`.cpp`) | Relevant Tests | 
 |:----------:|:-----------:|:------------:|:--------------:|:-----------:|:-----:|
-| `iDynTree::Transform` | Generic transform between two different frames. | [link](http://wiki.icub.org/codyco/dox/html/idyntree/html/classiDynTree_1_1Transform.html) | [ src/core/include/iDynTree/Transform.h](../../src/core/include/iDynTree/Transform.h) | [ src/core/src/Transform.cpp](../../src/core/src/Transform.cpp) | [src/core/tests](../../src/core/tests) | 
-| `iDynTree::Model` | Generic undirected (i.e. with no "base") multibody model. | [link](http://wiki.icub.org/codyco/dox/html/idyntree/html/classiDynTree_1_1Model.html) | [ src/model/include/iDynTree/Model.h](../../src/model/include/iDynTree/Model.h) | [ src/model/src/Model.cpp](../../src/model/src/Model.cpp) | [src/model/tests/ModelUnitTest.cpp](../../src/model/tests/ModelUnitTest.cpp) | 
-| `iDynTree::Traversal` | Class describing a order in which link are visited once a "base link" is choosen |  [link](http://wiki.icub.org/codyco/dox/html/idyntree/html/classiDynTree_1_1Traversal.html) | [ src/model/include/iDynTree/Traversal.h](../../src/model/include/iDynTree/Traversal.h) | [ src/model/src/Traversal.cpp](../../src/model/src/Traversal.cpp) | [src/model/tests/ModelUnitTest.cpp](../../src/model/tests/ModelUnitTest.cpp) | 
+| `iDynTree::Transform` | Generic transform between two different frames. | [link](http://wiki.icub.org/codyco/dox/html/idyntree/html/classiDynTree_1_1Transform.html) | [ src/core/include/iDynTree/Core/Transform.h](../../src/core/include/iDynTree/Core/Transform.h) | [ src/core/src/Transform.cpp](../../src/core/src/Transform.cpp) | [src/core/tests](../../src/core/tests) | 
+| `iDynTree::Model` | Generic undirected (i.e. with no "base") multibody model. | [link](http://wiki.icub.org/codyco/dox/html/idyntree/html/classiDynTree_1_1Model.html) | [ src/model/include/iDynTree/Model/Model.h](../../src/model/include/iDynTree/Model/Model.h) | [ src/model/src/Model.cpp](../../src/model/src/Model.cpp) | [src/model/tests/ModelUnitTest.cpp](../../src/model/tests/ModelUnitTest.cpp) | 
+| `iDynTree::Traversal` | Class describing a order in which link are visited once a "base link" is choosen |  [link](http://wiki.icub.org/codyco/dox/html/idyntree/html/classiDynTree_1_1Traversal.html) | [ src/model/include/iDynTree/Model/Traversal.h](../../src/model/include/iDynTree/Model/Traversal.h) | [ src/model/src/Traversal.cpp](../../src/model/src/Traversal.cpp) | [src/model/tests/ModelUnitTest.cpp](../../src/model/tests/ModelUnitTest.cpp) | 
  
 
 If you need any additional doxygen comments, please [open an issue](https://github.com/robotology/idyntree/issues/new) detailing which point of the code you find difficul to understand. 
 
 Internally iDynTree uses a lot the [`Eigen` C++ template vector library](https://eigen.tuxfamily.org/dox/index.html), and in particularly the [`Eigen::Map`](https://eigen.tuxfamily.org/dox/group__TutorialMapClass.html)
 class is used a lot. Please check [Eigen documentation](https://eigen.tuxfamily.org/dox/index.html) for more details.
```

### Comparing `idyntree-9.1.1.dev66/doc/generating-idyntree-matlab-bindings.md` & `idyntree-9.1.1.dev7/doc/generating-idyntree-matlab-bindings.md`

 * *Files 3% similar despite different names*

```diff
@@ -9,28 +9,28 @@
 - Install the required dependencies for SWIG listed in the **Required Tools** section of the [Swig page](http://www.swig.org/svn.html).
 - Follow the installation instructions in [http://www.swig.org/Doc3.0/SWIGDocumentation.html#Preface_unix_installation](http://www.swig.org/Doc3.0/SWIGDocumentation.html#Preface_unix_installation) to install Swig locally. By default SWIG installs itself in `/usr/local`, in Unix environment. However, it is preferable to install Swig in a different location so as to avoid conflicts with other installed versions of SWIG.
 - Proper installation of SWIG will generate a `swig` executable in `<swig_install_dir>/bin`.
 
 This executable will be used to generate the iDynTree Matlab/Octave bindings for custom classes.
 
 ## Including the custom classes for bindings generations
-In this section, as a toy example, let us consider a custom class `DiscreteKalmanFilterHelper` for which the bindings need to be generated. Let's assume the class `DiscreteKalmanFilterHelper` exists in the header file `iDynTree/KalmanFilter.h`.
+In this section, as a toy example, let us consider a custom class `DiscreteKalmanFilterHelper` for which the bindings need to be generated. Let's assume the class `DiscreteKalmanFilterHelper` exists in the header file `iDynTree/Estimation/KalmanFilter.h`.
 
 - Take a glance at `bindings/iDynTree.i`. It follows a particular structure, adding the necessary header files twice for the desired classes, one using the prefix `#` and another using the prefix `%`.
     - It is also important to notice the order in which these headers are added, which ensures that the dependent header file is compiled after the dependee header file.
     - There are also sections for adding library specific data-structure; sensors-related, estimation-related, etc.
     - Templatized classes are explicitly specialized, so that the bindings are generated for the template specializations.
 
 - Coming back to our toy example, we will add the header file in the section related to the `Estimation related classes`, in two different places
 ```
-#include "iDynTree/KalmanFilter.h"
+#include "iDynTree/Estimation/KalmanFilter.h"
 ```
 and
 ```
-%include "iDynTree/KalmanFilter.h"
+%include "iDynTree/Estimation/KalmanFilter.h"
 ```
 
 Now, all is left is to compile and generate the bindings.
 
 ## Generating the bindings
 - In the build folder of `iDynTree`, run `ccmake` to open the CMake Gui.
     - Set the CMake option `SWIG_EXECUTABLE` to `<swig_install_dir>/bin/swig`.
```

### Comparing `idyntree-9.1.1.dev66/doc/images/position.svg` & `idyntree-9.1.1.dev7/doc/images/position.svg`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/doc/images/transform.svg` & `idyntree-9.1.1.dev7/doc/images/transform.svg`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/doc/main.dox` & `idyntree-9.1.1.dev7/doc/main.dox`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,14 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+
+/*
+ * Copyright (C) 2015-2021 Fondazione Istituto Italiano di Tecnologia
+ * Authors: See AUTHORS file.
+ * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ *
+ */
 
 // Definition of doxygen groups
 /**
  * \defgroup iDynTreeCore %iDynTree core data structures
  *
  * iDynTree provides basic data structures to implement kinemanics and dynamics
  * algorithms.
```

### Comparing `idyntree-9.1.1.dev66/doc/matlab_visualization.md` & `idyntree-9.1.1.dev7/doc/matlab_visualization.md`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/doc/model_loading.md` & `idyntree-9.1.1.dev7/doc/model_loading.md`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/doc/symbolic/RPYExpressionReference.py` & `idyntree-9.1.1.dev7/doc/symbolic/RPYExpressionReference.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/docs/Doxyfile.in` & `idyntree-9.1.1.dev7/docs/Doxyfile.in`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/docs/conf.py.in` & `idyntree-9.1.1.dev7/docs/conf.py.in`

 * *Files 14% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 DOXYFILE = 'Doxyfile-mcss-@BLF_TAG@'
 
 MAIN_PROJECT_URL = '@BLF_DOCUMENTATION_ROOT@/index.html'
 SHOW_UNDOCUMENTED = True
 
 
-FINE_PRINT = """<p>iDynTree documentation. Licensed under the <a href="https://spdx.org/licenses/BSD-3-Clause.html">BSD-3-Clause</a>. Project maintained by the <a href="https://www.iit.it/web/ami/">Artificial and Mechanical Intelligence Lab</a>. Contact the team via <a href="https://github.com/robotology/idyntree/issues/new">GitHub</a>.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> {doxygen_version} and <a href="https://mcss.mosra.cz/">m.css</a>."""
+FINE_PRINT = """<p>iDynTree documentation. Licensed under the <a href="https://www.gnu.org/licenses/lgpl-3.0.en.html">GNU Lesser General Public License v3.0</a>. Project maintained by the <a href="https://www.iit.it/web/ami/">Artificial and Mechanical Intelligence Lab</a>. Contact the team via <a href="https://github.com/robotology/idyntree/issues/new">GitHub</a>.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> {doxygen_version} and <a href="https://mcss.mosra.cz/">m.css</a>."""
 
 
 versions = [('<a href=\"@BLF_DOCUMENTATION_ROOT@/' + path + '/index.html\">' + path + '</a>', ) for path in next(os.walk('site'))[1] if path != 'xml']
 
 versions.insert(0, ('<a href=\"@BLF_DOCUMENTATION_ROOT@/index.html\">Master</a>', ))
 
 LINKS_NAVBAR1 = [
```

#### html2text {}

```diff
@@ -1,11 +1,12 @@
 import os DOXYFILE = 'Doxyfile-mcss-@BLF_TAG@' MAIN_PROJECT_URL =
 '@BLF_DOCUMENTATION_ROOT@/index.html' SHOW_UNDOCUMENTED = True FINE_PRINT = """
-iDynTree documentation. Licensed under the _B_S_D_-_3_-_C_l_a_u_s_e. Project maintained by
-the _A_r_t_i_f_i_c_i_a_l_ _a_n_d_ _M_e_c_h_a_n_i_c_a_l_ _I_n_t_e_l_l_i_g_e_n_c_e_ _L_a_b. Contact the team via _G_i_t_H_u_b.
+iDynTree documentation. Licensed under the _G_N_U_ _L_e_s_s_e_r_ _G_e_n_e_r_a_l_ _P_u_b_l_i_c_ _L_i_c_e_n_s_e
+_v_3_._0. Project maintained by the _A_r_t_i_f_i_c_i_a_l_ _a_n_d_ _M_e_c_h_a_n_i_c_a_l_ _I_n_t_e_l_l_i_g_e_n_c_e_ _L_a_b.
+Contact the team via _G_i_t_H_u_b.
 Generated by _D_o_x_y_g_e_n {doxygen_version} and _m_._c_s_s.""" versions = [(' path + '/
 index.html\">' + path + '
 ', ) for path in next(os.walk('site'))[1] if path != 'xml'] versions.insert(0,
 ('_M_a_s_t_e_r', )) LINKS_NAVBAR1 = [ ('Pages', 'pages', []), ('Classes',
 'annotated', []), ('Files', 'files', []), ] LINKS_NAVBAR2 = [ ('Versions',
 'pages', versions), ("Contacts", 'pages', [ ("_G_i_t_H_u_b", ), ("_L_a_b_ _w_e_b_s_i_t_e", ),
 ]), ]
```

### Comparing `idyntree-9.1.1.dev66/docs/generate_documentation_files.py` & `idyntree-9.1.1.dev7/docs/generate_documentation_files.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 #!/usr/bin/env python3
 
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+# Copyright (C) 2020 Istituto Italiano di Tecnologia (IIT)
+# This software may be modified and distributed under the terms of the
+# LGPL-2.1+ license. See the accompanying LICENSE file for details.
 
 import argparse
 import os
 
 
 def generate_documentation_files(tag: str, input_files_path: str, output_files_path: str,
                                  src_folder: str, main_page: str, additional_pages=[]):
```

### Comparing `idyntree-9.1.1.dev66/docs/generate_website.py` & `idyntree-9.1.1.dev7/docs/generate_website.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 #!/bin/python3
 
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+# Copyright (C) 2021 Istituto Italiano di Tecnologia (IIT)
+# This software may be modified and distributed under the terms of the
+# LGPL-2.1+ license. See the accompanying LICENSE file for details.
 
 import toml
 import subprocess
 import os
 import argparse
 
 from generate_documentation_files import generate_documentation_files
```

### Comparing `idyntree-9.1.1.dev66/examples/cxx/InverseKinematics/CMakeLists.txt` & `idyntree-9.1.1.dev7/examples/cxx/InverseKinematics/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/cxx/InverseKinematics/README.md` & `idyntree-9.1.1.dev7/examples/cxx/InverseKinematics/README.md`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/cxx/InverseKinematics/iDynTreeExampleInverseKinematics.cpp` & `idyntree-9.1.1.dev7/examples/cxx/InverseKinematics/iDynTreeExampleInverseKinematics.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
 /**
 * @ingroup idyntree_tutorials
 *
 * A tutorial on how to use the InverseKinematics class in iDynTree
 *
+* \author Silvio Traversaro
+*
+* CopyPolicy: Released under the terms of LGPL 2.0+ or later
 */
 
 // C headers
 #include <cmath>
 #include <cstdlib>
 
 // C++ headers
 #include <string>
 #include <vector>
 
 // iDynTree headers
 #include <iDynTree/KinDynComputations.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 #include <iDynTree/InverseKinematics.h>
 
 int main(int argc, char *argv[])
 {
     // Assume that the model is found in the current working directory
     // In production code, the model is tipical found using some strategy
     std::string modelFile = "kr16_2.urdf";
```

### Comparing `idyntree-9.1.1.dev66/examples/cxx/KinDynComputationsWithEigen/CMakeLists.txt` & `idyntree-9.1.1.dev7/examples/cxx/KinDynComputationsWithEigen/CMakeLists.txt`

 * *Files 23% similar despite different names*

```diff
@@ -1,9 +1,11 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+# Copyright: 2017 Fondazione Istituto Italiano di Tecnologia
+# Author: Silvio Traversaro
+# CopyPolicy: Released under the terms of the GNU LGPL v2.0+.
+#
 
 cmake_minimum_required(VERSION 3.5)
 
 project(KinDynComputationsWithEigen)
 
 find_package(iDynTree REQUIRED)
```

### Comparing `idyntree-9.1.1.dev66/examples/cxx/KinDynComputationsWithEigen/main.cpp` & `idyntree-9.1.1.dev7/examples/cxx/KinDynComputationsWithEigen/main.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,33 +1,32 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
 /**
 * @ingroup idyntree_tutorials
 *
 * A tutorial on how to use the KinDynComputations class
 * with Eigen data structures.
 *
+* \author Silvio Traversaro
 *
+* CopyPolicy: Released under the terms of LGPL 2.0+ or later
 */
 
 // C headers
 #include <cstdlib>
 
 // Eigen headers
 #include <Eigen/Core>
 
 // iDynTree headers
-#include <iDynTree/FreeFloatingState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
 #include <iDynTree/KinDynComputations.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 // Helpers function to convert between
 // iDynTree datastructures
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 
 /**
  * Struct containing the floating robot state
  * using Eigen data structures.
  */
 struct EigenRobotState
```

### Comparing `idyntree-9.1.1.dev66/examples/matlab/GetJointAxesInWorldFrame.m` & `idyntree-9.1.1.dev7/examples/matlab/GetJointAxesInWorldFrame.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/matlab/SensorsListParsing/SensorsListParsing.m` & `idyntree-9.1.1.dev7/examples/matlab/SensorsListParsing/SensorsListParsing.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/matlab/SensorsListParsing/icub.urdf` & `idyntree-9.1.1.dev7/examples/matlab/SensorsListParsing/icub.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m` & `idyntree-9.1.1.dev7/examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/matlab/SixAxisFTOffsetEstimation/iCubGenova02.urdf` & `idyntree-9.1.1.dev7/examples/matlab/SixAxisFTOffsetEstimation/iCubGenova02.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/matlab/iDynTreeWrappers/visualizeRobot.m` & `idyntree-9.1.1.dev7/examples/matlab/iDynTreeWrappers/visualizeRobot.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/models/iCubGenova02.urdf` & `idyntree-9.1.1.dev7/examples/models/iCubGenova02.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/python/KinDynComputationsTutorial.py` & `idyntree-9.1.1.dev7/examples/python/KinDynComputationsTutorial.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/examples/python/MeshcatVisualizerExample.ipynb` & `idyntree-9.1.1.dev7/examples/python/MeshcatVisualizerExample.ipynb`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/CMakeLists.txt` & `idyntree-9.1.1.dev7/extern/CMakeLists.txt`

 * *Files 7% similar despite different names*

```diff
@@ -1,9 +1,13 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+#  iDynTree
+#  Copyright: (C) 2016 iCub Facility, Istituto Italiano di Tecnologia
+#  Authors: Silvio Traversaro <silvio.traversaro@iit.it>
+#
+#  Copy Policy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+#
 
 # MOxUnit ( https://github.com/MOxUnit/MOxUnit ) is an xUnit testing
 # framework for Matlab and Octave, it is only included if testing
 # is enabled in Matlab or Octave
 if( (IDYNTREE_USES_OCTAVE OR IDYNTREE_USES_MATLAB OR IDYNTREE_GENERATE_MATLAB) AND
     IDYNTREE_COMPILE_TESTS )
     # We save the location of MOxUnit in a variable that is then accessible to the test
```

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/.github/workflows/CI.yml` & `idyntree-9.1.1.dev7/extern/MOxUnit/.github/workflows/CI.yml`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/.travis.yml` & `idyntree-9.1.1.dev7/extern/MOxUnit/.travis.yml`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/COPYING` & `idyntree-9.1.1.dev7/extern/MOxUnit/COPYING`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/MOxUnitErroredTestOutcome.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitErroredTestOutcome/MOxUnitErroredTestOutcome.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/MOxUnitFailedTestOutcome.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFailedTestOutcome/MOxUnitFailedTestOutcome.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/MOxUnitFunctionHandleTestCase.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/MOxUnitFunctionHandleTestCase.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/run.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitFunctionHandleTestCase/run.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/MOxUnitMatlabUnitWrapperTestCase.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/MOxUnitMatlabUnitWrapperTestCase.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/run.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitMatlabUnitWrapperTestCase/run.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/MOxUnitPassedTestOutcome.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitPassedTestOutcome/MOxUnitPassedTestOutcome.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/MOxUnitSkippedTestOutcome.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitSkippedTestOutcome/MOxUnitSkippedTestOutcome.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/MOxUnitTestCase.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/MOxUnitTestCase.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/subsref.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestCase/subsref.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getProgressStr.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getProgressStr.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getSummaryStr.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestOutcome/getSummaryStr.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/MOxUnitTestReport.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/MOxUnitTestReport.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getStatisticsStr.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getStatisticsStr.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getSummaryStr.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getSummaryStr.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getTestOutputStatistics.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/getTestOutputStatistics.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/reportTestOutcome.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/reportTestOutcome.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/wasSuccessful.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/wasSuccessful.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/writeXML.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestReport/writeXML.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/MOxUnitTestSuite.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/MOxUnitTestSuite.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromDirectory.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromDirectory.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromFile.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromFile.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromSuite.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addFromSuite.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addTest.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/addTest.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/run.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/run.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/setTestNode.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/@MOxUnitTestSuite/setTestNode.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertElementsAlmostEqual.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertElementsAlmostEqual.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertEqual.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertEqual.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertExceptionThrown.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertExceptionThrown.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertFalse.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertFalse.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertGreaterThan.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertGreaterThan.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertLessThan.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertLessThan.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertNotEqual.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertNotEqual.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertTrue.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertTrue.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertVectorsAlmostEqual.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertVectorsAlmostEqual.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/assertWarning.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/assertWarning.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/initTestSuite.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/initTestSuite.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/moxunit_runtests.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/moxunit_runtests.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/moxunit_set_path.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/moxunit_set_path.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_isa_test_skipped_exception.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_isa_test_skipped_exception.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_throw_test_skipped_exception.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_throw_test_skipped_exception.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_elem2str.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_elem2str.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_escape_xml.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_escape_xml.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_find_files.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_find_files.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_floats_almost_equal.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_floats_almost_equal.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_input2str.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_input2str.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_is_message_identifier.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_is_message_identifier.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_isfolder.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_isfolder.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_mfile_subfunctions.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_mfile_subfunctions.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_supports.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_supports.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_version.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_platform_version.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_regexp_matches.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_regexp_matches.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_remove_matlab_anchor_tag.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_remove_matlab_anchor_tag.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_stack2str.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_stack2str.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/MOxUnit/util/moxunit_util_strjoin.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/MOxUnit/util/moxunit_util_strjoin.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/Makefile` & `idyntree-9.1.1.dev7/extern/MOxUnit/Makefile`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/README.md` & `idyntree-9.1.1.dev7/extern/MOxUnit/README.md`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_elements_almost_equal.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_elements_almost_equal.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_equal.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_equal.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_exception_thrown.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_exception_thrown.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_false.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_false.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_greater_than.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_greater_than.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_less_than.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_less_than.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_not_equal.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_not_equal.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_true.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_true.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_vectors_almost_equal.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_vectors_almost_equal.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_assert_warning.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_assert_warning.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_function_handle_test_case.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_function_handle_test_case.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_matlab_unittest_test_wrapper_suite.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_matlab_unittest_test_wrapper_suite.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_isa_test_skipped_exception.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_isa_test_skipped_exception.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_runtests.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_runtests.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_set_path.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_set_path.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_elem2str.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_elem2str.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_escape_xml.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_escape_xml.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_find_files.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_find_files.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_get_test_name_regexp.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_get_test_name_regexp.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_input2str.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_input2str.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_is_message_identifier.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_is_message_identifier.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_isfolder.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_isfolder.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_mfile_subfunctions.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_mfile_subfunctions.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_platform_supports.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_platform_supports.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_platform_version.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_platform_version.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_regexp_matches.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_regexp_matches.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_remove_matlab_anchor_tag.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_remove_matlab_anchor_tag.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_stack2str.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_stack2str.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_moxunit_util_strjoin.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_moxunit_util_strjoin.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_case.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_case.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_outcome.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_outcome.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_report.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_report.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_test_suite.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_test_suite.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tests/test_testcase_class.m` & `idyntree-9.1.1.dev7/extern/MOxUnit/tests/test_testcase_class.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tools/fix_mfile_test_init.py` & `idyntree-9.1.1.dev7/extern/MOxUnit/tools/fix_mfile_test_init.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/MOxUnit/tools/matlab_tokenizer.py` & `idyntree-9.1.1.dev7/extern/MOxUnit/tools/matlab_tokenizer.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/fpconv/fpconv.c` & `idyntree-9.1.1.dev7/extern/fpconv/fpconv.c`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/fpconv/fpconv.h` & `idyntree-9.1.1.dev7/extern/fpconv/fpconv.h`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/fpconv/powers.h` & `idyntree-9.1.1.dev7/extern/fpconv/powers.h`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/extern/mesh2tri/mesh2tri.m` & `idyntree-9.1.1.dev7/extern/mesh2tri/mesh2tri.m`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/idyntree.egg-info/PKG-INFO` & `idyntree-9.1.1.dev7/idyntree.egg-info/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 Metadata-Version: 2.1
 Name: idyntree
-Version: 9.1.1.dev66
+Version: 9.1.1.dev7
 Summary: Multibody Dynamics Library designed for Free Floating Robots.
 Home-page: https://github.com/robotology/idyntree
 Author: Diego Ferigo
 Author-email: dgferigo@gmail.com
-License: BSD-3-Clause
+License: LGPL
 Project-URL: Tracker, https://github.com/robotology/idyntree/issues
 Project-URL: Documentation, https://robotology.github.io/idyntree/master/
 Project-URL: Source, https://github.com/robotology/idyntree
 Keywords: robotics,dynamics,free-floating,floating-base,robot,robotic-library,multibody-dynamics
 Platform: any
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Operating System :: POSIX :: Linux
@@ -22,32 +22,32 @@
 Classifier: Programming Language :: C++
 Classifier: Programming Language :: Python :: 3.6
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: License :: OSI Approved :: BSD License
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: numpy
+License-File: LICENSE.LGPL2
+License-File: LICENSE.LGPL3
 
-iDynTree  [![License](https://img.shields.io/badge/License-BSD_3--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause) [![ZenHub](https://img.shields.io/badge/Shipping_faster_with-ZenHub-435198.svg)](https://zenhub.com)
+iDynTree [![License: LGPL v3](https://img.shields.io/badge/License-LGPL%20v3-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0) [![License: LGPL v2](https://img.shields.io/badge/License-LGPL%20v2-blue.svg)](https://www.gnu.org/licenses/lgpl-2.1)  [![ZenHub](https://img.shields.io/badge/Shipping_faster_with-ZenHub-435198.svg)](https://zenhub.com)
 ===========
 
 iDynTree is a library of robots dynamics algorithms for control, estimation and simulation. It is specifically designed for free-floating robots, but it is possible to use it also  with fixed-base robots.
 
 The **major characteristic features** of iDynTree are:
 * It is written in **C++**, with **Python** and **MATLAB** bindings.
 * It uses an  **undirected graph data structure** (`iDynTree::Model`) that is used to represent robots, to easily change the **base link** that you are using for your kinematics and dynamics computations without the need to reload your model or change your joint or link serializations. This is done as iDynTree was developed for floating-base robots such as humanoids, in which the most convenient choice of **base link** can change.
 * It contains support for **reading and writing URDF files** from a `iDynTree::Model`, making it useful to write tools that modify robot models and saves them back to file. This is done as iDynTree was meant to develop **tools for identification of kinematics and dynamics parameters**.
 * It defaults to use the **mixed representation** to represent link quantities (including the velocity and acceleration of the base link), but it can optionally use also **body (left-trivialized)** or **inertial (right-trivialized)** representation if requested. This is done because iDynTree was developed to satisfy the needs of **research in synthesis of floating-base whole-body controllers**. If you are not familiar with the different representation for 6D quantities, check  [Section 6 of "Multibody dynamics notation (version 2)"](
 https://pure.tue.nl/ws/portalfiles/portal/139293126/A_Multibody_Dynamics_Notation_Revision_2_.pdf).
-* It contains an implementation of the algorithm used in the iCub humanoid robot to **estimate the joint torques without the need of collocated joint torque sensors**, exploting the specific **undirected graph data structure** . This is done as this was one of the originally goal for the implementation of iDynTree. See the class [`iDynTree::ExtWrenchesAndJointTorquesEstimator`](https://github.com/robotology/idyntree/blob/master/src/estimation/include/iDynTree/ExtWrenchesAndJointTorquesEstimator.h) and [Chapter 6 of "Modelling, Estimation and Identification of Humanoid Robots Dynamics"](https://traversaro.github.io/traversaro-phd-thesis/traversaro-phd-thesis.pdf).
+* It contains an implementation of the algorithm used in the iCub humanoid robot to **estimate the joint torques without the need of collocated joint torque sensors**, exploting the specific **undirected graph data structure** . This is done as this was one of the originally goal for the implementation of iDynTree. See the class [`iDynTree::ExtWrenchesAndJointTorquesEstimator`](https://github.com/robotology/idyntree/blob/master/src/estimation/include/iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h) and [Chapter 6 of "Modelling, Estimation and Identification of Humanoid Robots Dynamics"](https://traversaro.github.io/traversaro-phd-thesis/traversaro-phd-thesis.pdf).
 
 To avoid confusion, it is also useful to clarify what **iDynTree is not**:
 * It is not the **fastest C++ library** for kinematics and dynamics multibody computations for robotics. It is not slow, but if have an application in which you need the absolute fastest library, check out [Pinocchio](https://github.com/stack-of-tasks/pinocchio).
 * It is not a **multibody simulator** library. It provides the building blocks that you could use to build a multibody simulator, but it is not a multibody simulator per se. If you need a simulator library in C++, check out [DART](https://dartsim.github.io/), [Simbody](https://github.com/simbody/simbody), [Drake](https://drake.mit.edu/), [MuJoCo](https://mujoco.org/) or the abstraction layer [`Gazebo Physics`](https://github.com/gazebosim/gz-physics). If you need a simulator implemented in MATLAB/Simulink (built on iDynTree), check [`matlab-whole-body-simulator`](https://github.com/ami-iit/matlab-whole-body-simulator).
 
 
 ##  Contents
@@ -74,15 +74,15 @@
 conda install -c conda-forge -c robotology idyntree-matlab-bindings
 ~~~
 
 If you are not familiar with conda or conda-forge, you can read an introduction document in [conda-forge overview](https://github.com/robotology/robotology-superbuild/blob/master/doc/conda-forge.md#conda-forge-overview).
 
 ### robotology-superbuild (advanced)
 
-If you are installing iDynTree for use as part of [iCub humanoid robot software installation](https://icub-tech-iit.github.io/documentation/sw_installation/), you may want to install iDynTree through the [robotology-superbuild](https://github.com/robotology/robotology-superbuild), an easy way to download, compile and install the robotology software on multiple operating systems, using the [CMake](https://www.cmake.org) build system and its extension [YCM](http://robotology.github.io/ycm). To get iDynTree when using the `robotology-superbuild`, please enable the `ROBOTOLOGY_ENABLE_DYNAMICS` CMake option of the superbuild. If you want to install also iDynTree Python or MATLAB bindings, remember to enable the `ROBOTOLOGY_USES_PYTHON` or `ROBOTOLOGY_USES_MATLAB` options. 
+If you are installing iDynTree for use as part of [iCub humanoid robot software installation](https://icub-tech-iit.github.io/documentation/sw_installation/), you may want to install iDynTree through the [robotology-superbuild](https://github.com/robotology/robotology-superbuild), an easy way to download, compile and install the robotology software on multiple operating systems, using the [CMake](www.cmake.org) build system and its extension [YCM](http://robotology.github.io/ycm). To get iDynTree when using the `robotology-superbuild`, please enable the `ROBOTOLOGY_ENABLE_DYNAMICS` CMake option of the superbuild. If you want to install also iDynTree Python or MATLAB bindings, remember to enable the `ROBOTOLOGY_USES_PYTHON` or `ROBOTOLOGY_USES_MATLAB` options. 
 
 ### Build from source (advanced)
 
 If you want to build iDynTree directly from source, you can check the documentation in [`doc/build-from-source.md`](doc/build-from-source.md).
 
 ## Library Usage
 
@@ -103,23 +103,24 @@
 
 If this is not working, make sure that you are launching `matlab` after having activated the conda environment (if you installed iDynTree via conda) or after having sourced por executed the correct setup script (if you installed iDynTree via the robotology-superbuild).
 
 ### Tutorials
 
 These tutorials describe how to use specific parts of iDynTree. Are you interested in a tutorial on a specific feature or algorithm that you can't find in this list? Just [request it on an enhancement issue](https://github.com/robotology/idyntree/issues/new).
 
+
 | Topic  | Location | Language  |
 |:------:|:--------:|:---------:|
-| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html) together with the [[Eigen](http://eigen.tuxfamily.org) C++ Matrix library to compute kinematics and dynamics quantities such as forward kinematics, inverse dynamics, mass matrix. | [examples/cxx/KinDynComputationsWithEigen/main.cpp](examples/cxx/KinDynComputationsWithEigen/main.cpp) | C++ |
-| How to use the [InverseKinematics class](https://robotology.github.io/idyntree/classiDynTree_1_1InverseKinematics.html) for the IK of an industrial fixed-base manipulator. | [examples/cxx/InverseKinematics/README.md](examples/cxx/InverseKinematics/README.md) | C++ |
-| Use of the [ExtWrenchesAndJointTorquesEstimator class](https://robotology.github.io/idyntree/classiDynTree_1_1ExtWrenchesAndJointTorquesEstimator.html) for computing offset for FT sensors |  [examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m](examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m) | MATLAB |
-| How to get the axis of a revolute joint expressed in a arbitary frame using the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html) | [examples/matlab/SensorsListParsing/SensorsListParsing.m](examples/matlab/SensorsListParsing/SensorsListParsing.m) | MATLAB |
+| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html) together with the [[Eigen](http://eigen.tuxfamily.org) C++ Matrix library to compute kinematics and dynamics quantities such as forward kinematics, inverse dynamics, mass matrix. | [examples/cxx/KinDynComputationsWithEigen/main.cpp](examples/cxx/KinDynComputationsWithEigen/main.cpp) | C++ |
+| How to use the [InverseKinematics class](https://robotology.github.io/docs/idyntree/master/classiDynTree_1_1InverseKinematics.html) for the IK of an industrial fixed-base manipulator. | [examples/cxx/InverseKinematics/README.md](examples/cxx/InverseKinematics/README.md) | C++ |
+| Use of the [ExtWrenchesAndJointTorquesEstimator class](https://robotology.github.io/idyntree/master/classiDynTree_1_1ExtWrenchesAndJointTorquesEstimator.html) for computing offset for FT sensors |  [examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m](examples/matlab/SixAxisFTOffsetEstimation/SixAxisFTOffsetEstimation.m) | MATLAB |
+| How to get the axis of a revolute joint expressed in a arbitary frame using the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html) | [examples/matlab/SensorsListParsing/SensorsListParsing.m](examples/matlab/SensorsListParsing/SensorsListParsing.m) | MATLAB |
 | How to read the Six Axis Force Torque sensors information contained in a URDF model. | [examples/matlab/GetJointAxesInWorldFrame.m](examples/matlab/GetJointAxesInWorldFrame.m) | MATLAB |
 | Usage of the MATLAB-native visualizer using the [MATLAB high-level wrappers](bindings/matlab/+iDynTreeWrappers/README.md). | [examples/matlab/iDynTreeWrappers/visualizeRobot.m](examples/matlab/iDynTreeWrappers/visualizeRobot.m) | MATLAB |
-| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/classiDynTree_1_1KinDynComputations.html). | [examples/python/KinDynComputationsTutorial.py](examples/python/KinDynComputationsTutorial.py) | Python |
+| Basic usage of the [KinDynComputations class](https://robotology.github.io/idyntree/master/classiDynTree_1_1KinDynComputations.html). | [examples/python/KinDynComputationsTutorial.py](examples/python/KinDynComputationsTutorial.py) | Python |
 | Basic usage of the [MeshcatVisualizer class](bindings/python/visualize/meshcat_visualizer.py). | [examples/python/MeshcatVisualizerExample.ipynb](examples/python/MeshcatVisualizerExample.ipynb) | Python |
 
 ## Tools Usage 
 
 iDynTree also includes some command line tools to use some of the functionality of the library without writing any line of code. The available command line tools are listed in the following, and each tool also includes an online help that is tipically available by passing the `-h` flag.
 
 ### `idyntree-model-info`
@@ -181,14 +182,21 @@
   NUMBER={6},
   URL={http://www.frontiersin.org/humanoid_robotics/10.3389/frobt.2015.00006/abstract},
   DOI={10.3389/frobt.2015.00006},
   ISSN={2296-9144}}
 ~~~
 
 ## Acknowledgments
-The initial development of iDynTree was supported by the FP7 EU projects [CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics)](http://www.codyco.eu/)  and [Koroibot (No. 611909 ICT- 2013.2.1 Cognitive Systems and Robotics)](https://cordis.europa.eu/project/id/611909/).
+The initial development of iDynTree was supported by the FP7 EU projects [CoDyCo (No. 600716 ICT 2011.2.1 Cognitive Systems and Robotics)](http://www.codyco.eu/)  and [Koroibot (No. 611909 ICT- 2013.2.1 Cognitive Systems and Robotics)](http://koroibot.eu/).
 
 The development is now supported by the [Artificial Mechanical Intelligence research line](https://ami.iit.it/) at the [Italian Institute of Technology](https://www.iit.it/).
 
 ## License
+iDynTree is licensed under either the GNU Lesser General Public License v3.0 :
+
+https://www.gnu.org/licenses/lgpl-3.0.html
+
+or the GNU Lesser General Public License v2.1 :
+
+https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
 
-iDynTree is licensed under either the BSD-3-Clause license : https://spdx.org/licenses/BSD-3-Clause.html .
+at your option.
```

### Comparing `idyntree-9.1.1.dev66/idyntree.egg-info/SOURCES.txt` & `idyntree-9.1.1.dev7/idyntree.egg-info/SOURCES.txt`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 .gitignore
 CHANGELOG.md
 CMakeLists.txt
 CONTRIBUTING.md
-LICENSE
+LICENSE.LGPL2
+LICENSE.LGPL3
 README.md
 ci_env.yml
 pyproject.toml
 setup.cfg
 setup.py
 .github/workflows/ci.yml
 .github/workflows/gh-pages.yml
@@ -154,15 +155,14 @@
 bindings/matlab/autogenerated/+iDynTree/ILight.m
 bindings/matlab/autogenerated/+iDynTree/IModelVisualization.m
 bindings/matlab/autogenerated/+iDynTree/INERTIAL_FIXED_REPRESENTATION.m
 bindings/matlab/autogenerated/+iDynTree/ITexture.m
 bindings/matlab/autogenerated/+iDynTree/ITexturesHandler.m
 bindings/matlab/autogenerated/+iDynTree/IVectorsVisualization.m
 bindings/matlab/autogenerated/+iDynTree/IndexRange.m
-bindings/matlab/autogenerated/+iDynTree/IndexVector.m
 bindings/matlab/autogenerated/+iDynTree/IntVector.m
 bindings/matlab/autogenerated/+iDynTree/InverseDynamicsInertialParametersRegressor.m
 bindings/matlab/autogenerated/+iDynTree/InverseKinematics.m
 bindings/matlab/autogenerated/+iDynTree/InverseKinematicsRotationParametrizationQuaternion.m
 bindings/matlab/autogenerated/+iDynTree/InverseKinematicsRotationParametrizationRollPitchYaw.m
 bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintFull.m
 bindings/matlab/autogenerated/+iDynTree/InverseKinematicsTreatTargetAsConstraintNone.m
@@ -199,15 +199,14 @@
 bindings/matlab/autogenerated/+iDynTree/Matrix2x3.m
 bindings/matlab/autogenerated/+iDynTree/Matrix3x3.m
 bindings/matlab/autogenerated/+iDynTree/Matrix4x4.m
 bindings/matlab/autogenerated/+iDynTree/Matrix4x4Vector.m
 bindings/matlab/autogenerated/+iDynTree/Matrix6x10.m
 bindings/matlab/autogenerated/+iDynTree/Matrix6x6.m
 bindings/matlab/autogenerated/+iDynTree/MatrixDynSize.m
-bindings/matlab/autogenerated/+iDynTree/MatrixDynSizeVector.m
 bindings/matlab/autogenerated/+iDynTree/Model.m
 bindings/matlab/autogenerated/+iDynTree/ModelCalibrationHelper.m
 bindings/matlab/autogenerated/+iDynTree/ModelExporter.m
 bindings/matlab/autogenerated/+iDynTree/ModelExporterOptions.m
 bindings/matlab/autogenerated/+iDynTree/ModelLoader.m
 bindings/matlab/autogenerated/+iDynTree/ModelParserOptions.m
 bindings/matlab/autogenerated/+iDynTree/ModelSolidShapes.m
@@ -220,30 +219,31 @@
 bindings/matlab/autogenerated/+iDynTree/MovableJointImpl6.m
 bindings/matlab/autogenerated/+iDynTree/NET_EXT_WRENCH.m
 bindings/matlab/autogenerated/+iDynTree/NET_EXT_WRENCH_SENSOR.m
 bindings/matlab/autogenerated/+iDynTree/NET_INT_AND_EXT_WRENCHES_ON_LINK_WITHOUT_GRAV.m
 bindings/matlab/autogenerated/+iDynTree/NO_UNKNOWNS.m
 bindings/matlab/autogenerated/+iDynTree/NR_OF_SENSOR_TYPES.m
 bindings/matlab/autogenerated/+iDynTree/Neighbor.m
-bindings/matlab/autogenerated/+iDynTree/NoJointDynamics.m
 bindings/matlab/autogenerated/+iDynTree/ORIGINAL_BERDY_FIXED_BASE.m
 bindings/matlab/autogenerated/+iDynTree/POINT_LIGHT.m
 bindings/matlab/autogenerated/+iDynTree/PURE_FORCE.m
 bindings/matlab/autogenerated/+iDynTree/PURE_FORCE_WITH_KNOWN_DIRECTION.m
 bindings/matlab/autogenerated/+iDynTree/PixelViz.m
 bindings/matlab/autogenerated/+iDynTree/Polygon.m
 bindings/matlab/autogenerated/+iDynTree/Polygon2D.m
 bindings/matlab/autogenerated/+iDynTree/Position.m
+bindings/matlab/autogenerated/+iDynTree/PositionRaw.m
 bindings/matlab/autogenerated/+iDynTree/PrismaticJoint.m
 bindings/matlab/autogenerated/+iDynTree/RCM_SENSOR.m
 bindings/matlab/autogenerated/+iDynTree/RNEADynamicPhase.m
 bindings/matlab/autogenerated/+iDynTree/RevoluteJoint.m
 bindings/matlab/autogenerated/+iDynTree/RigidBodyInertiaNonLinearParametrization.m
 bindings/matlab/autogenerated/+iDynTree/Rotation.m
-bindings/matlab/autogenerated/+iDynTree/RotationalInertia.m
+bindings/matlab/autogenerated/+iDynTree/RotationRaw.m
+bindings/matlab/autogenerated/+iDynTree/RotationalInertiaRaw.m
 bindings/matlab/autogenerated/+iDynTree/RowMajor.m
 bindings/matlab/autogenerated/+iDynTree/SIX_AXIS_FORCE_TORQUE.m
 bindings/matlab/autogenerated/+iDynTree/SIX_AXIS_FORCE_TORQUE_SENSOR.m
 bindings/matlab/autogenerated/+iDynTree/Sensor.m
 bindings/matlab/autogenerated/+iDynTree/SensorsList.m
 bindings/matlab/autogenerated/+iDynTree/SensorsMeasurements.m
 bindings/matlab/autogenerated/+iDynTree/SimpleLeggedOdometry.m
@@ -252,14 +252,15 @@
 bindings/matlab/autogenerated/+iDynTree/SolidShapesVector.m
 bindings/matlab/autogenerated/+iDynTree/SparseMatrixColMajor.m
 bindings/matlab/autogenerated/+iDynTree/SparseMatrixRowMajor.m
 bindings/matlab/autogenerated/+iDynTree/SpatialAcc.m
 bindings/matlab/autogenerated/+iDynTree/SpatialForceVector.m
 bindings/matlab/autogenerated/+iDynTree/SpatialForceVectorBase.m
 bindings/matlab/autogenerated/+iDynTree/SpatialInertia.m
+bindings/matlab/autogenerated/+iDynTree/SpatialInertiaRaw.m
 bindings/matlab/autogenerated/+iDynTree/SpatialMomentum.m
 bindings/matlab/autogenerated/+iDynTree/SpatialMotionVector.m
 bindings/matlab/autogenerated/+iDynTree/SpatialMotionVectorBase.m
 bindings/matlab/autogenerated/+iDynTree/Sphere.m
 bindings/matlab/autogenerated/+iDynTree/StringVector.m
 bindings/matlab/autogenerated/+iDynTree/SubModelDecomposition.m
 bindings/matlab/autogenerated/+iDynTree/THREE_AXIS_ANGULAR_ACCELEROMETER.m
@@ -271,23 +272,21 @@
 bindings/matlab/autogenerated/+iDynTree/ThreeAxisForceTorqueContactSensor.m
 bindings/matlab/autogenerated/+iDynTree/Transform.m
 bindings/matlab/autogenerated/+iDynTree/TransformDerivative.m
 bindings/matlab/autogenerated/+iDynTree/TransformFromDH.m
 bindings/matlab/autogenerated/+iDynTree/TransformFromDHCraig1989.m
 bindings/matlab/autogenerated/+iDynTree/Traversal.m
 bindings/matlab/autogenerated/+iDynTree/Twist.m
-bindings/matlab/autogenerated/+iDynTree/URDFJointDynamics.m
 bindings/matlab/autogenerated/+iDynTree/UnknownWrenchContact.m
 bindings/matlab/autogenerated/+iDynTree/Vector10.m
 bindings/matlab/autogenerated/+iDynTree/Vector16.m
 bindings/matlab/autogenerated/+iDynTree/Vector3.m
 bindings/matlab/autogenerated/+iDynTree/Vector4.m
 bindings/matlab/autogenerated/+iDynTree/Vector6.m
 bindings/matlab/autogenerated/+iDynTree/VectorDynSize.m
-bindings/matlab/autogenerated/+iDynTree/VectorDynSizeVector.m
 bindings/matlab/autogenerated/+iDynTree/Visualizer.m
 bindings/matlab/autogenerated/+iDynTree/VisualizerOptions.m
 bindings/matlab/autogenerated/+iDynTree/Wrench.m
 bindings/matlab/autogenerated/+iDynTree/addRandomAdditionalFrameToModel.m
 bindings/matlab/autogenerated/+iDynTree/addRandomLinkToModel.m
 bindings/matlab/autogenerated/+iDynTree/checkDoublesAreEqual.m
 bindings/matlab/autogenerated/+iDynTree/computeBoundingBoxFromShape.m
@@ -364,15 +363,14 @@
 bindings/pybind11/tests/test_idyntree_sensors.py
 bindings/python/CMakeLists.txt
 bindings/python/numpy.i
 bindings/python/python.i
 bindings/python/scripts/CMakeLists.txt
 bindings/python/scripts/idyntree-model-view-meshcat.py
 bindings/python/tests/CMakeLists.txt
-bindings/python/tests/ExtWrenchesAndJointTorquesEstimatorUnitTest.py
 bindings/python/tests/dyncomp.py
 bindings/python/tests/geometry.py
 bindings/python/tests/helpers.py
 bindings/python/tests/joints.py
 bindings/python/tests/model.urdf
 bindings/python/tests/modelloader.py
 bindings/python/visualize/__init__.py
@@ -584,54 +582,14 @@
 idyntree.egg-info/dependency_links.txt
 idyntree.egg-info/entry_points.txt
 idyntree.egg-info/not-zip-safe
 idyntree.egg-info/requires.txt
 idyntree.egg-info/top_level.txt
 src/CMakeLists.txt
 src/core/CMakeLists.txt
-src/core/include/iDynTree/ArticulatedBodyInertia.h
-src/core/include/iDynTree/Axis.h
-src/core/include/iDynTree/ClassicalAcc.h
-src/core/include/iDynTree/CubicSpline.h
-src/core/include/iDynTree/Direction.h
-src/core/include/iDynTree/EigenHelpers.h
-src/core/include/iDynTree/EigenMathHelpers.h
-src/core/include/iDynTree/EigenSparseHelpers.h
-src/core/include/iDynTree/GeomVector3.h
-src/core/include/iDynTree/InertiaNonLinearParametrization.h
-src/core/include/iDynTree/MatrixDynSize.h
-src/core/include/iDynTree/MatrixFixSize.h
-src/core/include/iDynTree/MatrixView.h
-src/core/include/iDynTree/Position.h
-src/core/include/iDynTree/PositionRaw.h
-src/core/include/iDynTree/PrivatePreProcessorUtils.h
-src/core/include/iDynTree/PrivateUtils.h
-src/core/include/iDynTree/Rotation.h
-src/core/include/iDynTree/RotationRaw.h
-src/core/include/iDynTree/RotationalInertia.h
-src/core/include/iDynTree/RotationalInertiaRaw.h
-src/core/include/iDynTree/SO3Utils.h
-src/core/include/iDynTree/Span.h
-src/core/include/iDynTree/SparseMatrix.h
-src/core/include/iDynTree/SpatialAcc.h
-src/core/include/iDynTree/SpatialForceVector.h
-src/core/include/iDynTree/SpatialInertia.h
-src/core/include/iDynTree/SpatialInertiaRaw.h
-src/core/include/iDynTree/SpatialMomentum.h
-src/core/include/iDynTree/SpatialMotionVector.h
-src/core/include/iDynTree/SpatialVector.h
-src/core/include/iDynTree/TestUtils.h
-src/core/include/iDynTree/Transform.h
-src/core/include/iDynTree/TransformDerivative.h
-src/core/include/iDynTree/Triplets.h
-src/core/include/iDynTree/Twist.h
-src/core/include/iDynTree/Utils.h
-src/core/include/iDynTree/VectorDynSize.h
-src/core/include/iDynTree/VectorFixSize.h
-src/core/include/iDynTree/Wrench.h
 src/core/include/iDynTree/Core/ArticulatedBodyInertia.h
 src/core/include/iDynTree/Core/Axis.h
 src/core/include/iDynTree/Core/ClassicalAcc.h
 src/core/include/iDynTree/Core/CubicSpline.h
 src/core/include/iDynTree/Core/Direction.h
 src/core/include/iDynTree/Core/EigenHelpers.h
 src/core/include/iDynTree/Core/EigenMathHelpers.h
@@ -672,22 +630,25 @@
 src/core/src/ClassicalAcc.cpp
 src/core/src/CubicSpline.cpp
 src/core/src/Direction.cpp
 src/core/src/GeomVector3.cpp
 src/core/src/InertiaNonLinearParametrization.cpp
 src/core/src/MatrixDynSize.cpp
 src/core/src/Position.cpp
+src/core/src/PositionRaw.cpp
 src/core/src/PrivateUtils.cpp
 src/core/src/Rotation.cpp
-src/core/src/RotationalInertia.cpp
+src/core/src/RotationRaw.cpp
+src/core/src/RotationalInertiaRaw.cpp
 src/core/src/SO3Utils.cpp
 src/core/src/SparseMatrix.cpp
 src/core/src/SpatialAcc.cpp
 src/core/src/SpatialForceVector.cpp
 src/core/src/SpatialInertia.cpp
+src/core/src/SpatialInertiaRaw.cpp
 src/core/src/SpatialMomentum.cpp
 src/core/src/SpatialMotionVector.cpp
 src/core/src/TestUtils.cpp
 src/core/src/Transform.cpp
 src/core/src/TransformDerivative.cpp
 src/core/src/Triplets.cpp
 src/core/src/Twist.cpp
@@ -713,29 +674,14 @@
 src/core/tests/SpatialInertiaUnitTest.cpp
 src/core/tests/SpatialToEigenCompilationErrorTest.cpp
 src/core/tests/TransformFromMatrix4x4UnitTest.cpp
 src/core/tests/TwistUnitTest.cpp
 src/core/tests/VectorDynSizeUnitTest.cpp
 src/core/tests/WrenchUnitTest.cpp
 src/estimation/CMakeLists.txt
-src/estimation/include/iDynTree/AttitudeEstimator.h
-src/estimation/include/iDynTree/AttitudeEstimatorUtils.h
-src/estimation/include/iDynTree/AttitudeMahonyFilter.h
-src/estimation/include/iDynTree/AttitudeQuaternionEKF.h
-src/estimation/include/iDynTree/BerdyHelper.h
-src/estimation/include/iDynTree/BerdySparseMAPSolver.h
-src/estimation/include/iDynTree/BipedFootContactClassifier.h
-src/estimation/include/iDynTree/ContactStateMachine.h
-src/estimation/include/iDynTree/ExtWrenchesAndJointTorquesEstimator.h
-src/estimation/include/iDynTree/ExtendedKalmanFilter.h
-src/estimation/include/iDynTree/ExternalWrenchesEstimation.h
-src/estimation/include/iDynTree/GravityCompensationHelpers.h
-src/estimation/include/iDynTree/KalmanFilter.h
-src/estimation/include/iDynTree/SchmittTrigger.h
-src/estimation/include/iDynTree/SimpleLeggedOdometry.h
 src/estimation/include/iDynTree/Estimation/AttitudeEstimator.h
 src/estimation/include/iDynTree/Estimation/AttitudeEstimatorUtils.h
 src/estimation/include/iDynTree/Estimation/AttitudeMahonyFilter.h
 src/estimation/include/iDynTree/Estimation/AttitudeQuaternionEKF.h
 src/estimation/include/iDynTree/Estimation/BerdyHelper.h
 src/estimation/include/iDynTree/Estimation/BerdySparseMAPSolver.h
 src/estimation/include/iDynTree/Estimation/BipedFootContactClassifier.h
@@ -796,50 +742,14 @@
 src/inverse-kinematics/src/TransformConstraint.cpp
 src/inverse-kinematics/tests/CMakeLists.txt
 src/inverse-kinematics/tests/ConvexHullHelpersUnitTest.cpp
 src/inverse-kinematics/tests/InverseKinematicsMatrixViewAndSpanUnitTest.cpp
 src/inverse-kinematics/tests/InverseKinematicsUnitTest.cpp
 src/inverse-kinematics/tests/iKinVersusLegacyTest.cpp
 src/model/CMakeLists.txt
-src/model/include/iDynTree/AccelerometerSensor.h
-src/model/include/iDynTree/AllSensorsTypes.h
-src/model/include/iDynTree/Centroidal.h
-src/model/include/iDynTree/ContactWrench.h
-src/model/include/iDynTree/DenavitHartenberg.h
-src/model/include/iDynTree/Dynamics.h
-src/model/include/iDynTree/DynamicsLinearization.h
-src/model/include/iDynTree/DynamicsLinearizationHelpers.h
-src/model/include/iDynTree/DynamicsUtils.h
-src/model/include/iDynTree/FixedJoint.h
-src/model/include/iDynTree/ForwardKinematics.h
-src/model/include/iDynTree/FreeFloatingMatrices.h
-src/model/include/iDynTree/FreeFloatingState.h
-src/model/include/iDynTree/GyroscopeSensor.h
-src/model/include/iDynTree/IJoint.h
-src/model/include/iDynTree/Indices.h
-src/model/include/iDynTree/Jacobians.h
-src/model/include/iDynTree/JointState.h
-src/model/include/iDynTree/Link.h
-src/model/include/iDynTree/LinkState.h
-src/model/include/iDynTree/LinkTraversalsCache.h
-src/model/include/iDynTree/Model.h
-src/model/include/iDynTree/ModelSensorsTransformers.h
-src/model/include/iDynTree/ModelTestUtils.h
-src/model/include/iDynTree/ModelTransformers.h
-src/model/include/iDynTree/MovableJointImpl.h
-src/model/include/iDynTree/PredictSensorsMeasurements.h
-src/model/include/iDynTree/PrismaticJoint.h
-src/model/include/iDynTree/RevoluteJoint.h
-src/model/include/iDynTree/Sensors.h
-src/model/include/iDynTree/SixAxisForceTorqueSensor.h
-src/model/include/iDynTree/SolidShapes.h
-src/model/include/iDynTree/SubModel.h
-src/model/include/iDynTree/ThreeAxisAngularAccelerometerSensor.h
-src/model/include/iDynTree/ThreeAxisForceTorqueContactSensor.h
-src/model/include/iDynTree/Traversal.h
 src/model/include/iDynTree/Model/Centroidal.h
 src/model/include/iDynTree/Model/ContactWrench.h
 src/model/include/iDynTree/Model/DenavitHartenberg.h
 src/model/include/iDynTree/Model/Dynamics.h
 src/model/include/iDynTree/Model/DynamicsLinearization.h
 src/model/include/iDynTree/Model/DynamicsLinearizationHelpers.h
 src/model/include/iDynTree/Model/DynamicsUtils.h
@@ -859,66 +769,44 @@
 src/model/include/iDynTree/Model/ModelTransformers.h
 src/model/include/iDynTree/Model/MovableJointImpl.h
 src/model/include/iDynTree/Model/PrismaticJoint.h
 src/model/include/iDynTree/Model/RevoluteJoint.h
 src/model/include/iDynTree/Model/SolidShapes.h
 src/model/include/iDynTree/Model/SubModel.h
 src/model/include/iDynTree/Model/Traversal.h
-src/model/include/iDynTree/Sensors/AccelerometerSensor.h
-src/model/include/iDynTree/Sensors/AllSensorsTypes.h
-src/model/include/iDynTree/Sensors/GyroscopeSensor.h
-src/model/include/iDynTree/Sensors/ModelSensorsTransformers.h
-src/model/include/iDynTree/Sensors/PredictSensorsMeasurements.h
-src/model/include/iDynTree/Sensors/Sensors.h
-src/model/include/iDynTree/Sensors/SixAxisForceTorqueSensor.h
-src/model/include/iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h
-src/model/include/iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h
-src/model/src/AccelerometerSensor.cpp
 src/model/src/ContactWrench.cpp
 src/model/src/DenavitHartenberg.cpp
 src/model/src/Dynamics.cpp
 src/model/src/DynamicsLinearization.cpp
 src/model/src/DynamicsLinearizationHelpers.cpp
 src/model/src/FixedJoint.cpp
 src/model/src/ForwardKinematics.cpp
 src/model/src/FreeFloatingMatrices.cpp
 src/model/src/FreeFloatingState.cpp
-src/model/src/GyroscopeSensor.cpp
 src/model/src/Indices.cpp
 src/model/src/Jacobians.cpp
 src/model/src/JointState.cpp
 src/model/src/Link.cpp
 src/model/src/LinkState.cpp
 src/model/src/LinkTraversalsCache.cpp
 src/model/src/Model.cpp
 src/model/src/ModelInterfaceDestructors.cpp
-src/model/src/ModelSensorsTransformers.cpp
 src/model/src/ModelTransformers.cpp
-src/model/src/PredictSensorsMeasurements.cpp
 src/model/src/PrismaticJoint.cpp
 src/model/src/RevoluteJoint.cpp
-src/model/src/Sensors.cpp
-src/model/src/SixAxisForceTorqueSensor.cpp
 src/model/src/SolidShapes.cpp
 src/model/src/SubModel.cpp
-src/model/src/ThreeAxisAngularAccelerometerSensor.cpp
-src/model/src/ThreeAxisForceTorqueContactSensor.cpp
 src/model/src/Traversal.cpp
 src/model/tests/CMakeLists.txt
+src/model/tests/ForwardKinematicsUnitTest.cpp
 src/model/tests/JointUnitTest.cpp
 src/model/tests/LinkUnitTest.cpp
 src/model/tests/ModelUnitTest.cpp
-src/model/tests/SensorsListUnitTest.cpp
-src/model/tests/ThreeAxisForceTorqueContactSensorUnitTest.cpp
 src/model_io/CMakeLists.txt
 src/model_io/codecs/CMakeLists.txt
-src/model_io/codecs/include/iDynTree/ModelCalibrationHelper.h
-src/model_io/codecs/include/iDynTree/ModelExporter.h
-src/model_io/codecs/include/iDynTree/ModelLoader.h
-src/model_io/codecs/include/iDynTree/URDFDofsImport.h
 src/model_io/codecs/include/iDynTree/ModelIO/ModelCalibrationHelper.h
 src/model_io/codecs/include/iDynTree/ModelIO/ModelExporter.h
 src/model_io/codecs/include/iDynTree/ModelIO/ModelLoader.h
 src/model_io/codecs/include/iDynTree/ModelIO/URDFDofsImport.h
 src/model_io/codecs/include/private/ForceTorqueSensorElement.h
 src/model_io/codecs/include/private/GeometryElement.h
 src/model_io/codecs/include/private/InertialElement.h
@@ -1051,14 +939,36 @@
 src/optimalcontrol/tests/L2NormTest.cpp
 src/optimalcontrol/tests/LinearOCOsqpTest.cpp
 src/optimalcontrol/tests/MultipleShootingTest.cpp
 src/optimalcontrol/tests/OCProblemTest.cpp
 src/optimalcontrol/tests/OptimalControlIpoptTest.cpp
 src/optimalcontrol/tests/OptimalControlTest.cpp
 src/optimalcontrol/tests/WorhpInterfaceTest.cpp
+src/sensors/CMakeLists.txt
+src/sensors/include/iDynTree/Sensors/AccelerometerSensor.h
+src/sensors/include/iDynTree/Sensors/AllSensorsTypes.h
+src/sensors/include/iDynTree/Sensors/GyroscopeSensor.h
+src/sensors/include/iDynTree/Sensors/ModelSensorsTransformers.h
+src/sensors/include/iDynTree/Sensors/PredictSensorsMeasurements.h
+src/sensors/include/iDynTree/Sensors/Sensors.h
+src/sensors/include/iDynTree/Sensors/SixAxisForceTorqueSensor.h
+src/sensors/include/iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h
+src/sensors/include/iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h
+src/sensors/src/AccelerometerSensor.cpp
+src/sensors/src/GyroscopeSensor.cpp
+src/sensors/src/ModelSensorsTransformers.cpp
+src/sensors/src/PredictSensorsMeasurements.cpp
+src/sensors/src/Sensors.cpp
+src/sensors/src/SixAxisForceTorqueSensor.cpp
+src/sensors/src/ThreeAxisAngularAccelerometerSensor.cpp
+src/sensors/src/ThreeAxisForceTorqueContactSensor.cpp
+src/sensors/tests/CMakeLists.txt
+src/sensors/tests/ReducedModelWithFTUnitTest.cpp
+src/sensors/tests/SensorsListUnitTest.cpp
+src/sensors/tests/ThreeAxisForceTorqueContactSensorUnitTest.cpp
 src/solid-shapes/CMakeLists.txt
 src/solid-shapes/include/iDynTree/InertialParametersSolidShapesHelpers.h
 src/solid-shapes/include/iDynTree/ModelTransformersSolidShapes.h
 src/solid-shapes/src/InertialParametersSolidShapesHelpers.cpp
 src/solid-shapes/src/ModelTransformersSolidShapes.cpp
 src/solid-shapes/tests/CMakeLists.txt
 src/solid-shapes/tests/InertialParametersSolidShapesHelpersIntegrationTest.cpp
@@ -1092,15 +1002,14 @@
 src/tests/icub_consistency/iCubExternalWrenchesEstimationConsistencyTest.cpp
 src/tests/icub_consistency/iKinConsistencyTest.cpp
 src/tests/integration/CMakeLists.txt
 src/tests/integration/DenavitHartenbergIntegrationTest.cpp
 src/tests/integration/DynamicsIntegrationTest.cpp
 src/tests/integration/DynamicsLinearizationIntegrationTest.cpp
 src/tests/integration/InertialParametersSolidShapesHelpersIntegrationTest.cpp
-src/tests/integration/ReducedModelWithFTIntegrationTest.cpp
 src/tests/integration/iCubTorqueEstimationIntegrationTest.cpp
 src/tests/yarp_benchmark/CMakeLists.txt
 src/tests/yarp_benchmark/PseudoInverseBenchmark.cpp
 src/tools/CMakeLists.txt
 src/tools/cmdline.h
 src/tools/idyntree-model-info.cpp
 src/tools/idyntree-model-simplify-shapes.cpp
@@ -1136,17 +1045,12 @@
 src/visualization/src/TexturesHandler.h
 src/visualization/src/VectorsVisualization.cpp
 src/visualization/src/VectorsVisualization.h
 src/visualization/src/Visualizer.cpp
 src/visualization/tests/CMakeLists.txt
 src/visualization/tests/VisualizerUnitTest.cpp
 src/yarp/CMakeLists.txt
-src/yarp/include/iDynTree/YARPConfigurationsLoader.h
-src/yarp/include/iDynTree/YARPConfigurationsLoaderImplementation.h
-src/yarp/include/iDynTree/YARPConversions.h
-src/yarp/include/iDynTree/YARPConversionsImplementation.h
-src/yarp/include/iDynTree/YARPEigenConversions.h
 src/yarp/include/iDynTree/yarp/YARPConfigurationsLoader.h
 src/yarp/include/iDynTree/yarp/YARPConfigurationsLoaderImplementation.h
 src/yarp/include/iDynTree/yarp/YARPConversions.h
 src/yarp/include/iDynTree/yarp/YARPConversionsImplementation.h
 src/yarp/include/iDynTree/yarp/YARPEigenConversions.h
```

### Comparing `idyntree-9.1.1.dev66/setup.cfg` & `idyntree-9.1.1.dev7/setup.cfg`

 * *Files 16% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 [metadata]
 name = idyntree
 description = Multibody Dynamics Library designed for Free Floating Robots.
 long_description = file: README.md
 long_description_content_type = text/markdown
 author = Diego Ferigo
 author_email = dgferigo@gmail.com
-license = BSD-3-Clause
+license = LGPL
 platforms = any
 url = https://github.com/robotology/idyntree
 project_urls = 
 	Tracker = https://github.com/robotology/idyntree/issues
 	Documentation = https://robotology.github.io/idyntree/master/
 	Source = https://github.com/robotology/idyntree
 keywords = 
@@ -32,15 +32,15 @@
 	Programming Language :: C++
 	Programming Language :: Python :: 3.6
 	Programming Language :: Python :: 3.7
 	Programming Language :: Python :: 3.8
 	Programming Language :: Python :: 3.9
 	Programming Language :: Python :: 3 :: Only
 	Programming Language :: Python :: Implementation :: CPython
-	License :: OSI Approved :: BSD License
+	License :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)
 
 [options]
 zip_safe = False
 python_requires = >=3.6
 install_requires = 
 	numpy
```

### Comparing `idyntree-9.1.1.dev66/setup.py` & `idyntree-9.1.1.dev7/setup.py`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/CMakeLists.txt`

 * *Files 22% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+# Copyright (C) 2013-2018 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 # include test data before everything,
 # to be sure that is available to test
 # of all components
 if(IDYNTREE_COMPILE_TESTS)
     add_subdirectory(tests/data)
 endif()
 
 add_subdirectory(core)
 add_subdirectory(model)
+add_subdirectory(sensors)
 add_subdirectory(model_io)
 add_subdirectory(estimation)
 add_subdirectory(solid-shapes)
 add_subdirectory(high-level)
 add_subdirectory(inverse-kinematics)
 
 if (IDYNTREE_USES_IPOPT)
```

### Comparing `idyntree-9.1.1.dev66/src/core/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/core/CMakeLists.txt`

 * *Files 8% similar despite different names*

```diff
@@ -1,66 +1,73 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
-set(IDYNTREE_CORE_EXP_HEADERS include/iDynTree/Axis.h
-                              include/iDynTree/ArticulatedBodyInertia.h
-                              include/iDynTree/ClassicalAcc.h
-                              include/iDynTree/Direction.h
-                              include/iDynTree/EigenSparseHelpers.h
-                              include/iDynTree/EigenMathHelpers.h
-                              include/iDynTree/EigenHelpers.h
-                              include/iDynTree/InertiaNonLinearParametrization.h
-                              include/iDynTree/MatrixDynSize.h
-                              include/iDynTree/MatrixFixSize.h
-                              include/iDynTree/Position.h
-                              include/iDynTree/PositionRaw.h
-                              include/iDynTree/Rotation.h
-                              include/iDynTree/RotationRaw.h
-                              include/iDynTree/RotationalInertia.h
-                              include/iDynTree/RotationalInertiaRaw.h
-                              include/iDynTree/SpatialAcc.h
-                              include/iDynTree/SpatialForceVector.h
-                              include/iDynTree/SpatialInertiaRaw.h
-                              include/iDynTree/SpatialInertia.h
-                              include/iDynTree/SpatialMomentum.h
-                              include/iDynTree/SpatialMotionVector.h
-                              include/iDynTree/TestUtils.h
-                              include/iDynTree/Transform.h
-                              include/iDynTree/TransformDerivative.h
-                              include/iDynTree/Twist.h
-                              include/iDynTree/Utils.h
-                              include/iDynTree/VectorFixSize.h
-                              include/iDynTree/VectorDynSize.h
-                              include/iDynTree/Wrench.h
-                              include/iDynTree/PrivateUtils.h
-                              include/iDynTree/PrivatePreProcessorUtils.h
-                              include/iDynTree/GeomVector3.h
-                              include/iDynTree/SpatialVector.h
-                              include/iDynTree/SparseMatrix.h
-                              include/iDynTree/Triplets.h
-                              include/iDynTree/CubicSpline.h
-                              include/iDynTree/Span.h
-                              include/iDynTree/SO3Utils.h
-                              include/iDynTree/MatrixView.h)
+# Copyright (C) Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
+
+set(IDYNTREE_CORE_EXP_HEADERS include/iDynTree/Core/Axis.h
+                              include/iDynTree/Core/ArticulatedBodyInertia.h
+                              include/iDynTree/Core/ClassicalAcc.h
+                              include/iDynTree/Core/Direction.h
+                              include/iDynTree/Core/EigenSparseHelpers.h
+                              include/iDynTree/Core/EigenMathHelpers.h
+                              include/iDynTree/Core/EigenHelpers.h
+                              include/iDynTree/Core/InertiaNonLinearParametrization.h
+                              include/iDynTree/Core/MatrixDynSize.h
+                              include/iDynTree/Core/MatrixFixSize.h
+                              include/iDynTree/Core/Position.h
+                              include/iDynTree/Core/PositionRaw.h
+                              include/iDynTree/Core/Rotation.h
+                              include/iDynTree/Core/RotationRaw.h
+                              include/iDynTree/Core/RotationalInertiaRaw.h
+                              include/iDynTree/Core/SpatialAcc.h
+                              include/iDynTree/Core/SpatialForceVector.h
+                              include/iDynTree/Core/SpatialInertiaRaw.h
+                              include/iDynTree/Core/SpatialInertia.h
+                              include/iDynTree/Core/SpatialMomentum.h
+                              include/iDynTree/Core/SpatialMotionVector.h
+                              include/iDynTree/Core/TestUtils.h
+                              include/iDynTree/Core/Transform.h
+                              include/iDynTree/Core/TransformDerivative.h
+                              include/iDynTree/Core/Twist.h
+                              include/iDynTree/Core/Utils.h
+                              include/iDynTree/Core/VectorFixSize.h
+                              include/iDynTree/Core/VectorDynSize.h
+                              include/iDynTree/Core/Wrench.h
+                              include/iDynTree/Core/PrivateUtils.h
+                              include/iDynTree/Core/PrivatePreProcessorUtils.h
+                              include/iDynTree/Core/GeomVector3.h
+                              include/iDynTree/Core/SpatialVector.h
+                              include/iDynTree/Core/SparseMatrix.h
+                              include/iDynTree/Core/Triplets.h
+                              include/iDynTree/Core/CubicSpline.h
+                              include/iDynTree/Core/Span.h
+                              include/iDynTree/Core/SO3Utils.h
+                              include/iDynTree/Core/MatrixView.h)
 
 
 set(IDYNTREE_CORE_EXP_SOURCES src/Axis.cpp
                               src/ArticulatedBodyInertia.cpp
                               src/ClassicalAcc.cpp
                               src/Direction.cpp
                               src/InertiaNonLinearParametrization.cpp
                               src/MatrixDynSize.cpp
                               src/GeomVector3.cpp
                               src/Position.cpp
+                              src/PositionRaw.cpp
                               src/Rotation.cpp
-                              src/RotationalInertia.cpp
+                              src/RotationRaw.cpp
+                              src/RotationalInertiaRaw.cpp
                               src/SpatialAcc.cpp
                               src/SpatialForceVector.cpp
                               src/SpatialMomentum.cpp
                               src/SpatialMotionVector.cpp
+                              src/SpatialInertiaRaw.cpp
                               src/SpatialInertia.cpp
                               src/TestUtils.cpp
                               src/Transform.cpp
                               src/TransformDerivative.cpp
                               src/Twist.cpp
                               src/Utils.cpp
                               src/VectorDynSize.cpp
@@ -71,17 +78,17 @@
                               src/CubicSpline.cpp
                               src/SO3Utils.cpp)
 
 SOURCE_GROUP("Source Files" FILES ${IDYNTREE_CORE_EXP_SOURCES})
 SOURCE_GROUP("Header Files" FILES ${IDYNTREE_CORE_EXP_HEADERS})
 
 # Check if this does not break existing build
-# reason: avoid including with <iDynTree/**> inside .cpp but using directly
+# reason: avoid including with <iDynTree/Core/**> inside .cpp but using directly
 # "**" which clearly states the difference between in-library files and external files
-include_directories(include/iDynTree)
+include_directories(include/iDynTree/Core)
 
 set(libraryname idyntree-core)
 
 add_library(${libraryname} ${IDYNTREE_CORE_EXP_SOURCES} ${IDYNTREE_CORE_EXP_HEADERS})
 add_library(iDynTree::${libraryname} ALIAS ${libraryname})
 
 if (DEFINED CMAKE_COMPILER_IS_GNUCXX)
@@ -124,19 +131,15 @@
 
 install(TARGETS ${libraryname}
         EXPORT iDynTree
         COMPONENT runtime
         RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}" COMPONENT bin
         LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}" COMPONENT shlib
         ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}" COMPONENT lib
-        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree
-        PRIVATE_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree/impl)
+        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree/Core
+        PRIVATE_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree/Core/impl)
 
 set_property(GLOBAL APPEND PROPERTY ${VARS_PREFIX}_TARGETS ${libraryname})
 
-# Install deprecated headers
-install(DIRECTORY include/iDynTree/Core
-        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree)
-
 if(IDYNTREE_COMPILE_TESTS)
     add_subdirectory(tests)
 endif(IDYNTREE_COMPILE_TESTS)
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/ArticulatedBodyInertia.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/ArticulatedBodyInertia.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_ARTICULATED_BODY_INERTIA_H
 #define IDYNTREE_ARTICULATED_BODY_INERTIA_H
 
-#include <iDynTree/MatrixFixSize.h>
+#include <iDynTree/Core/MatrixFixSize.h>
 #include <string>
 
 namespace iDynTree
 {
     class SpatialInertia;
     class SpatialForceVector;
     class SpatialMotionVector;
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Axis.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Axis.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_AXIS_H
 #define IDYNTREE_AXIS_H
 
 #include <string>
 
-#include <iDynTree/Direction.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Utils.h>
 
 namespace iDynTree
 {
     class Transform;
     class TransformDerivative;
     class Twist;
     class SpatialAcc;
@@ -50,19 +57,14 @@
         Axis(const Direction & _direction, const Position & _origin);
 
         /**
          * Copy constructor: create a Axis from another Axis
          */
         Axis(const Axis & other);
 
-        /**
-         * Assignment operator: assign a Axis from another Axis
-         */
-        Axis& operator=(const Axis& other);
-
          /**
          * Get the direction of the axis
          */
         const Direction & getDirection() const;
 
         /**
          * Get the origin of the axis
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/ClassicalAcc.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/ClassicalAcc.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_CLASSICAL_ACC_H
 #define IDYNTREE_CLASSICAL_ACC_H
 
-#include <iDynTree/VectorFixSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
 
 namespace iDynTree
 {
-    class Rotation;
+    class RotationRaw;
     class SpatialAcc;
     class Twist;
 
     /**
      * Class representing a classical 6D acceleration, i.e. the concatenation
      * of the 3d vector of the acceleration of a point and of the 3d vector
      * of the derivative of an angular velocity.
@@ -40,15 +47,15 @@
          * Please initialize the data in the class before any use.
          */
         inline ClassicalAcc() {}
         ClassicalAcc(const double* in_data, const unsigned int in_size);
         ClassicalAcc(const ClassicalAcc& other);
 
         /* Geometric operations */
-        const ClassicalAcc & changeCoordFrame(const Rotation & newCoordFrame);
+        const ClassicalAcc & changeCoordFrame(const RotationRaw & newCoordFrame);
 
         /** constructor helpers */
         static ClassicalAcc Zero();
 
         Vector3 getLinearVec3() const;
         Vector3 getAngularVec3() const;
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/CubicSpline.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/CubicSpline.h`

 * *Files 14% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef IDYNTREE_CUBIC_SPLINE_H
 #define IDYNTREE_CUBIC_SPLINE_H
 
 #include <vector>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
 namespace iDynTree
 {
     class CubicSpline {
         std::vector< iDynTree::Vector4 > m_coefficients;
         iDynTree::VectorDynSize m_velocities;
         iDynTree::VectorDynSize m_time;
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Direction.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Direction.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_DIRECTION_H
 #define IDYNTREE_DIRECTION_H
 
 #include <string>
 
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/Utils.h>
 
 
 namespace iDynTree
 {
     /**
      * Class representing the coordinates of a direction in the 3D space
      *
@@ -47,19 +54,14 @@
 
         /**
          * Copy constructor: create a Direction from a 3 double buffer
          */
         Direction(const double* in_data, const unsigned int in_size);
 
         /**
-         * Assignment operator: assign a Direction from another Direction
-         */
-        Direction& operator=(const Direction& other);
-
-        /**
          * Normalize the representation of the direction, useful if
          * the coordinates of the direction has been manually setted
          * and you want to be sure that this direction is actually
          * a unit vector.
          *
          * @param tol if the norm of the vector < tol, set the direction to 1,0,0
          */
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/EigenHelpers.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/EigenHelpers.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,34 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_EIGEN_HELPERS_H
 #define IDYNTREE_EIGEN_HELPERS_H
 
 #include <cstddef>
 
 #include <Eigen/Dense>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/MatrixFixSize.h>
-#include <iDynTree/SpatialMotionVector.h>
-#include <iDynTree/SpatialForceVector.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixFixSize.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
+#include <iDynTree/Core/SpatialForceVector.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Utils.h>
 
 #if __cplusplus > 199711L
-#include <iDynTree/SparseMatrix.h>
+#include <iDynTree/Core/SparseMatrix.h>
 #endif
 
 
 namespace iDynTree
 {
     //Useful typedefs
     //TODO: change methods below to use these typedefs
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/EigenMathHelpers.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/EigenMathHelpers.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_EIGEN_MATH_HELPERS_H
 #define IDYNTREE_EIGEN_MATH_HELPERS_H
 
 #include <Eigen/Dense>
 
 namespace iDynTree
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/EigenSparseHelpers.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/EigenSparseHelpers.h`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_EIGEN_SPARSE_HELPERS_H
 #define IDYNTREE_EIGEN_SPARSE_HELPERS_H
 
 #include <Eigen/SparseCore>
-#include <iDynTree/SparseMatrix.h>
+#include <iDynTree/Core/SparseMatrix.h>
 
 namespace iDynTree
 {
 
 //SparseMatrix helpers
 inline Eigen::Map< Eigen::SparseMatrix<double, Eigen::RowMajor> > toEigen(iDynTree::SparseMatrix<iDynTree::RowMajor> & mat)
 {
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/GeomVector3.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/GeomVector3.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_GEOM_VECTOR_3_H
 #define IDYNTREE_GEOM_VECTOR_3_H
 
-#include <iDynTree/VectorFixSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
 
 namespace iDynTree
 {
 	class Rotation;
 
 	class GeomVector3 : public Vector3 {
 	public:
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/InertiaNonLinearParametrization.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/InertiaNonLinearParametrization.h`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_INERTIA_NON_LINEAR_PARAMETRIZATION_H
 #define IDYNTREE_INERTIA_NON_LINEAR_PARAMETRIZATION_H
 
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/Rotation.h>
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/Rotation.h>
+#include <iDynTree/Core/Transform.h>
 
 namespace iDynTree
 {
     class RigidBodyInertiaNonLinearParametrization
     {
     public:
         double mass;
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/MatrixDynSize.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/MatrixDynSize.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MATRIX_DYN_SIZE_H
 #define IDYNTREE_MATRIX_DYN_SIZE_H
 
 
 #include <string>
 
-#include <iDynTree/MatrixView.h>
+#include <iDynTree/Core/MatrixView.h>
 
 namespace iDynTree
 {
     /**
      * Class providing a simple form of matrix with dynamic size.
      *
      * \ingroup iDynTreeCore
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/MatrixFixSize.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/MatrixFixSize.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MATRIX_FIX_SIZE_H
 #define IDYNTREE_MATRIX_FIX_SIZE_H
 
 
-#include <iDynTree/Utils.h>
-#include <iDynTree/MatrixView.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/MatrixView.h>
 
 #include <cassert>
 #include <cstring>
 #include <string>
 #include <iostream>
 #include <sstream>
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/MatrixView.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/MatrixView.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2020 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MATRIX_VIEW_H
 #define IDYNTREE_MATRIX_VIEW_H
 
 #include <cassert>
 
 #include <type_traits>
 
-#include <iDynTree/Span.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Span.h>
+#include <iDynTree/Core/Utils.h>
 
 // constexpr workaround for SWIG
 #ifdef SWIG
 #define IDYNTREE_CONSTEXPR
 #else
 #define IDYNTREE_CONSTEXPR constexpr
 #endif
@@ -88,26 +95,14 @@
 
         MatrixView()
             : MatrixView(nullptr, 0, 0, MatrixStorageOrdering::RowMajor)
         {}
         MatrixView(const MatrixView& other)
             : MatrixView(other.m_storage, other.m_rows, other.m_cols, other.m_storageOrder)
         {
-            this->m_innerStride = other.m_innerStride;
-            this->m_outerStride = other.m_outerStride;
-        }
-        MatrixView& operator=(const MatrixView& other)
-        {
-            this->m_storage = other.m_storage;
-            this->m_rows = other.m_rows;
-            this->m_cols = other.m_cols;
-            this->m_storageOrder = other.m_storageOrder;
-            this->m_innerStride = other.m_innerStride;
-            this->m_outerStride = other.m_outerStride;
-            return *this;
         }
 
 #ifndef SWIG
         template <
             class OtherElementType,
             class = std::enable_if_t<
                 details::is_allowed_element_type_conversion<typename MatrixView<OtherElementType>::value_type,
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Position.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Position.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_POSITION_H
 #define IDYNTREE_POSITION_H
 
-#include <iDynTree/Rotation.h>
+#include <iDynTree/Core/PositionRaw.h>
+#include <iDynTree/Core/Rotation.h>
 
 #include <string>
 
 namespace iDynTree
 {
     class Rotation;
     class Twist;
@@ -27,15 +35,15 @@
      * \image html position.svg
      *
      * The Position object can briefly described as the position
      * of a *point* with respect to a *refPoint*, expressed with
      * respect to an orientation given by *orientFrame* .
      *
      */
-    class Position: public Vector3
+    class Position: public PositionRaw
     {
     public:
         /**
          * Default constructor.
          * The data is not initialized, please initialize the data in the created object before use.
          */
         Position();
@@ -47,22 +55,17 @@
 
         /**
          * Copy constructor: create a Position from another Position
          */
         Position(const Position & other);
 
         /**
-         * Assignment operator: assign a Position from another Position
+         * Copy constructor: create a Position from a PositionRaw
          */
-        Position& operator=(const Position& other);
-
-        /**
-         * Constructor from a raw buffer of 3 doubles.
-         */
-        Position(const double* in_data, const unsigned int in_size);
+        Position(const PositionRaw & other);
 
         /**
          * Create a Position from a span
          */
         Position(iDynTree::Span<const double> other);
 
         /**
@@ -101,13 +104,10 @@
         std::string reservedToString() const;
         ///@}
 
         friend Position Rotation::changeCoordFrameOf(const Position & op) const;
 
         static Position Zero();
     };
-
-    IDYNTREE_DEPRECATED_WITH_MSG("iDynTree::PositionRaw is deprecated, use iDynTree::Position") typedef Position PositionRaw;
-
 }
 
 #endif
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/PrivateUtils.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/PrivateUtils.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_PRIVATE_UTILS_H
 #define IDYNTREE_PRIVATE_UTILS_H
 
 
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree
 {
 
     /**
      * Maps a 3d vector to the square of the cross product matrix:
      * v --> (v\times)^2
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Rotation.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Rotation.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,31 +1,37 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_ROTATION_H
 #define IDYNTREE_ROTATION_H
 
 #include <string>
-#include <iDynTree/GeomVector3.h>
-#include <iDynTree/MatrixFixSize.h>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/GeomVector3.h>
+#include <iDynTree/Core/RotationRaw.h>
+#include <iDynTree/Core/VectorFixSize.h>
 
 namespace iDynTree
 {
     class Position;
     class Twist;
     class SpatialAcc;
     class Wrench;
     class Direction;
     class Axis;
     class SpatialAcc;
     class SpatialMomentum;
     class ClassicalAcc;
-    class RotationalInertia;
+    class RotationalInertiaRaw;
     class SpatialMotionVector;
     class SpatialForceVector;
     class ArticulatedBodyInertia;
 
     /**
      * Class representation the rotation of an orientation frame
      * with respect to a reference orientation frame, expressed as a Rotation matrix.
@@ -35,24 +41,22 @@
      * The semantics for this class is based on the OrientationCoord in:
      *
      * De Laet T, Bellens S, Smits R, Aertbelin E, Bruyninckx H, and De Schutter J
      * (2013), Geometric Relations between Rigid Bodies: Semantics for Standardization,
      * IEEE Robotics & Automation Magazine, Vol. 20, No. 1, pp. 84-93.
      * URL : http://people.mech.kuleuven.be/~tdelaet/geometric_relations_semantics/geometric_relations_semantics_theory.pdf
      *
-     * Storage for the Orientation:
-     *
-     * The rotation matrix representation of the orientation, stored in row major order,
-     * inside a Matrix3x3 parent object.
-     *
-     * \warning This class uses for convenience the Matrix3x3 as a public parent.
-     *          Notice that using this methods you can damage the underlyng rotation matrix.
-     *          In doubt, don't use them and rely on more high level functions.
+     * Given that this class uses the rotation matrix to represent orientation, some operation
+     * are disable because there is a semantic constraint induced by choice of representation, i.e.
+     * that the coordinate frame is always the reference orientation frame. Thus, some semantic operation
+     * are not enabled, namely:
+     *  * the generic inverse, that does not change the coordinate frame.
+     *  * changeCoordFrame, because CoordFrame is always the same of RefOrientFrame.
      */
-    class Rotation : public Matrix3x3
+    class Rotation: public RotationRaw
     {
     public:
         /**
          * Default constructor.
          * The data is not reset to the identity matrix for perfomance reason.
          * Please initialize the data in the vector before any use.
          */
@@ -62,32 +66,29 @@
          * Constructor from 9 doubles: initialize elements of the rotation matrix.
          */
         Rotation(double xx, double xy, double xz,
                  double yx, double yy, double yz,
                  double zx, double zy, double zz);
 
         /**
+         * Copy constructor: create a Rotation from another RotationRaw.
+         */
+        Rotation(const RotationRaw & other);
+
+        /**
          * Copy constructor: create a Rotation from another Rotation.
          */
         Rotation(const Rotation & other);
 
         /**
          * Create a Rotation from a MatrixView.
          */
         Rotation(iDynTree::MatrixView<const double> other);
 
         /**
-         * Constructor from a buffer of 9 doubles,
-         * stored as a C-style array (i.e. row major).
-         *
-         */
-        Rotation(const double* in_data,
-                 const unsigned int in_rows,
-                 const unsigned int in_cols);
-        /**
          * Geometric operations.
          * For the inverse2() operation, both the forward and the inverse geometric relations have to
          * be expressed in the reference orientation frame!!
          *
          */
         const Rotation & changeOrientFrame(const Rotation & newOrientFrame);
         const Rotation & changeRefOrientFrame(const Rotation & newRefOrientFrame);
@@ -100,33 +101,32 @@
         Twist changeCoordFrameOf(const Twist & other) const;
         SpatialAcc changeCoordFrameOf(const SpatialAcc & other) const;
         SpatialMomentum changeCoordFrameOf(const SpatialMomentum & other) const;
         Wrench changeCoordFrameOf(const Wrench & other) const;
         Direction changeCoordFrameOf(const Direction & other) const;
         Axis      changeCoordFrameOf(const Axis & other) const;
         ClassicalAcc changeCoordFrameOf(const ClassicalAcc & other) const;
-        RotationalInertia changeCoordFrameOf(const RotationalInertia & other) const;
+        RotationalInertiaRaw changeCoordFrameOf(const RotationalInertiaRaw & other) const;
 
 
         /**
           * overloaded operators
           */
-        Rotation& operator=(const Rotation & other);
         Rotation operator*(const Rotation & other) const;
         Rotation inverse() const;
         Position operator*(const Position & other) const;
         SpatialForceVector operator*(const SpatialForceVector & other) const;
         Twist    operator*(const Twist    & other) const;
         Wrench   operator*(const Wrench   & other) const;
         Direction operator*(const Direction & other) const;
         Axis      operator*(const Axis    & other) const;
         SpatialAcc      operator*(const SpatialAcc    & other) const;
         SpatialMomentum operator*(const SpatialMomentum   & other) const;
         ClassicalAcc    operator*(const ClassicalAcc    & other) const;
-        RotationalInertia    operator*(const RotationalInertia    & other) const;
+        RotationalInertiaRaw    operator*(const RotationalInertiaRaw    & other) const;
 
         /**
          * Log mapping between a  generic element of SO(3) (iDynTree::Rotation)
          * to the corresponding element of so(3) (iDynTree::AngularMotionVector).
          */
         AngularMotionVector3 log() const;
 
@@ -471,12 +471,10 @@
          */
         ///@{
         std::string toString() const;
 
         std::string reservedToString() const;
         ///@}
     };
-
-    IDYNTREE_DEPRECATED_WITH_MSG("iDynTree::RotationRaw is deprecated, use iDynTree::Rotation") typedef Rotation RotationRaw;
 }
 
 #endif
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/RotationalInertia.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialAcc.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,50 +1,49 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#ifndef IDYNTREE_ROTATIONAL_INERTIA_H
-#define IDYNTREE_ROTATIONAL_INERTIA_H
+#ifndef IDYNTREE_SPATIAL_ACC_H
+#define IDYNTREE_SPATIAL_ACC_H
 
-#include <iDynTree/MatrixFixSize.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
 
 namespace iDynTree
 {
-    class Position;
-
     /**
-     * Class providing the coordinates for a 3d inertia matrix.
+     * Class representing a spatial acceleration, i.e. the representation
+     * of the time derivative of the twist.
      *
-     * \ingroup iDynTreeCore
+     * \note The linear part of this spatial vector **is not** the acceleration
+     *       of a point.
      *
-     * \note in iDynTree, the spatial vector follows this serialization: the first three elements are
-     *       the linear part and the second three elements are the angular part.
      *
-     *  We use a parent Matrix3x3 for storage of the rotational inertia matrix:
-     *  given that the inertia matrix is a 3x3 symmetric matrix,
-     *                             the ordering (row order or column order) is not influencing
-     *                             the storage of the matrix.
+     * \ingroup iDynTreeCore
      */
-    class RotationalInertia: public Matrix3x3
+    class SpatialAcc: public SpatialMotionVector
     {
-
     public:
         /**
          * Default constructor.
          * The data is not reset to zero for perfomance reason.
-         * Please initialize the data in the vector before any use.
+         * Please initialize the data in the class before any use.
          */
-        RotationalInertia();
-        RotationalInertia(const double * in_data, const unsigned int in_rows, const unsigned int in_cols);
-        RotationalInertia(const RotationalInertia & other);
-        RotationalInertia& operator=(const RotationalInertia& other);
-
-        /**
-         * Initializer helper: return a zero matrix.
-         */
-        static RotationalInertia Zero();
+        inline SpatialAcc() {}
+        SpatialAcc(const LinAcceleration & _linearVec3, const AngAcceleration & _angularVec3);
+        SpatialAcc(const SpatialMotionVector& other);
+        SpatialAcc(const SpatialAcc& other);
+
+        // overloaded operator
+        SpatialAcc operator+(const SpatialAcc &other) const;
+        SpatialAcc operator-(const SpatialAcc &other) const;
+        SpatialAcc operator-() const;
 
     };
-
-    IDYNTREE_DEPRECATED_WITH_MSG("iDynTree::RotationalInertiaRaw is deprecated, use iDynTree::RotationalInertia") typedef RotationalInertia RotationalInertiaRaw;
 }
 
-#endif /* IDYNTREE_ROTATIONAL_INERTIA_RAW_H */
+#endif
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/SO3Utils.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SO3Utils.h`

 * *Files 13% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2020 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef IDYNTREE_SO3UTILS_H
 #define IDYNTREE_SO3UTILS_H
 
-#include <iDynTree/Rotation.h>
-#include <iDynTree/GeomVector3.h>
+#include <iDynTree/Core/Rotation.h>
+#include <iDynTree/Core/GeomVector3.h>
 #include <vector>
 
 namespace iDynTree
 {
     /**
      * @brief Struct containing the options for geodesicL2MeanRotation and geodesicL2WeightedMeanRotation.
      */
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Span.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Span.h`

 * *Files 2% similar despite different names*

```diff
@@ -14,16 +14,23 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 //Most of this file has been taken from https://github.com/Microsoft/GSL/blob/master/include/gsl/span
 
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #include <cassert>
 
 #include <algorithm> // for lexicographical_compare
 #include <array>     // for array
 #include <cstddef>   // for ptrdiff_t, size_t, nullptr_t
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/SparseMatrix.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SparseMatrix.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SPARSE_MATRIX_H
 #define IDYNTREE_SPARSE_MATRIX_H
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/Triplets.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/Triplets.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <vector>
 
 namespace iDynTree {
 
     template <MatrixStorageOrdering ordering>
     class SparseMatrix;
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialAcc.h` & `idyntree-9.1.1.dev7/src/core/src/SpatialAcc.cpp`

 * *Files 19% similar despite different names*

```diff
@@ -1,43 +1,51 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#ifndef IDYNTREE_SPATIAL_ACC_H
-#define IDYNTREE_SPATIAL_ACC_H
-
-#include <iDynTree/SpatialMotionVector.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/PrivateUtils.h>
 
 namespace iDynTree
 {
-    /**
-     * Class representing a spatial acceleration, i.e. the representation
-     * of the time derivative of the twist.
-     *
-     * \note The linear part of this spatial vector **is not** the acceleration
-     *       of a point.
-     *
-     *
-     * \ingroup iDynTreeCore
-     */
-    class SpatialAcc: public SpatialMotionVector
-    {
-    public:
-        /**
-         * Default constructor.
-         * The data is not reset to zero for perfomance reason.
-         * Please initialize the data in the class before any use.
-         */
-        inline SpatialAcc() {}
-        SpatialAcc(const LinAcceleration & _linearVec3, const AngAcceleration & _angularVec3);
-        SpatialAcc(const SpatialMotionVector& other);
-        SpatialAcc(const SpatialAcc& other);
-
-        // overloaded operator
-        SpatialAcc& operator=(const SpatialAcc &other);
-        SpatialAcc operator+(const SpatialAcc &other) const;
-        SpatialAcc operator-(const SpatialAcc &other) const;
-        SpatialAcc operator-() const;
+SpatialAcc::SpatialAcc(const LinAcceleration & _linearVec3,
+                       const AngAcceleration & _angularVec3):
+                       SpatialMotionVector(_linearVec3, _angularVec3)
+{
+
+}
+
+SpatialAcc::SpatialAcc(const SpatialMotionVector& other):
+                       SpatialMotionVector(other)
+{
+
+}
+
+
+SpatialAcc::SpatialAcc(const SpatialAcc& other):
+                       SpatialMotionVector(other)
+{
 
-    };
 }
 
-#endif
+SpatialAcc SpatialAcc::operator+(const SpatialAcc& other) const
+{
+    return efficient6dSum(*this,other);
+}
+
+SpatialAcc SpatialAcc::operator-() const
+{
+    return inverse(*this);
+}
+
+SpatialAcc SpatialAcc::operator-(const SpatialAcc& other) const
+{
+    return efficient6ddifference(*this,other);
+}
+
+}
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialForceVector.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialForceVector.h`

 * *Files 22% similar despite different names*

```diff
@@ -1,32 +1,39 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#ifndef IDYNTREE_SPATIAL_FORCE_VECTOR_H
-#define IDYNTREE_SPATIAL_FORCE_VECTOR_H
-
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/GeomVector3.h>
-#include <iDynTree/SpatialVector.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#ifndef IDYNTREE_SPATIAL_FORCE_RAW_H
+#define IDYNTREE_SPATIAL_FORCE_RAW_H
+
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/GeomVector3.h>
+#include <iDynTree/Core/SpatialVector.h>
 
 namespace iDynTree
 {
     /**
      * Class providing the raw coordinates for any spatial force vector,
      * (i.e. vector form of an element of se*(3)).
      *
      * \ingroup iDynTreeCore
      *
      * A force spatial vector can be used to to described spatial momentum, wrench,
      * or their derivatives.
      *
      * This is just a basic vector, used to implement the adjoint transformations in
      * a general way. The relative adjoint transformation is contained in
-     * Transform::apply(SpatialForce),
-     * for consistency with the iDynTree::Position class.
+     * TransformRaw::apply(SpatialForceRaw),
+     * for consistency with the iDynTree::PositionRaw class.
      *
      * \note in iDynTree, the spatial vector follows this serialization: the first three elements are
      *       the linear part and the second three elements are the angular part.
      */
     class SpatialForceVector: public SpatialVector<SpatialForceVector>
     {
     public:
@@ -49,8 +56,8 @@
         virtual ~SpatialForceVector();
 
 
         SpatialForceVector operator*(const double scalar) const;
     };
 }
 
-#endif /* IDYNTREE_SPATIAL_FORCE_VECTOR_H */
+#endif /* IDYNTREE_SPATIAL_FORCE_RAW_H */
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialInertia.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialInertia.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,89 +1,55 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SPATIAL_INERTIA_H
 #define IDYNTREE_SPATIAL_INERTIA_H
 
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/RotationalInertia.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/Wrench.h>
+#include <iDynTree/Core/SpatialInertiaRaw.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/Wrench.h>
 
 namespace iDynTree
 {
     /**
      * @brief Class representing a six dimensional inertia.
      *
      *
      * \ingroup iDynTreeCore
      */
-    class SpatialInertia
+    class SpatialInertia: public SpatialInertiaRaw
     {
-    protected:
-        double m_mass; ///< Mass.
-        double m_mcom[3]; ///< First moment of mass (i.e. mass * center of mass).
-        RotationalInertia m_rotInertia; ///< Three dimensional rotational inertia.
     public:
         /**
          * Default constructor.
          * The data is not reset to zero for perfomance reason.
          * Please initialize the data in the vector before any use.
          */
         inline SpatialInertia() {}
         SpatialInertia(const double mass,
-                       const Position& com,
-                       const RotationalInertia & rotInertia);
+                       const PositionRaw & com,
+                       const RotationalInertiaRaw & rotInertia);
+        SpatialInertia(const SpatialInertiaRaw& other);
         SpatialInertia(const SpatialInertia& other);
 
         // Operations on SpatialInertia
         static SpatialInertia combine(const SpatialInertia & op1,
                                       const SpatialInertia & op2);
 
         /**
-         * Helper constructor-like function that takes mass, center of mass
-         * and the rotational inertia expressed in the center of mass.
-         *
-         */
-        void fromRotationalInertiaWrtCenterOfMass(const double mass, const Position& com, const RotationalInertia & rotInertia);
-
-
-        /** multiplication operator
-         *
-         * overloading happens on proper classes
-         *
-         */
-
-
-        /**
-         * Getter functions
-         *
-         * \note for preserving consistency, no setters are implemented..
-         *       if you want to modify a spatial inertia create a new one,
-         *       and assign it to the spatial inertia that you want modify.
-         *       Given that no memory allocation happens it should be still
-         *       efficient.
-         */
-        double getMass() const;
-        Position getCenterOfMass() const;
-        const RotationalInertia& getRotationalInertiaWrtFrameOrigin() const;
-        RotationalInertia getRotationalInertiaWrtCenterOfMass() const;
-
-        /**
-         * Multiplication function
-         *
-         */
-        SpatialForceVector multiply(const SpatialMotionVector & op) const;
-
-        /** reset to zero (i.e. the inertia of body with zero mass) the SpatialInertia */
-        void zero();
-
-        /**
          * @brief Get the SpatialInertia as a 6x6 matrix
          *
          * If \f$ m \in \mathbb{R} \f$ is the mass,
          * \f$ c \in \mathbb{R}^3 \f$ is the center of mass,
          * \f$ I \in \mathbb{R}^{3 \times 3} \f$ is the 3d inertia, and
          * \f$ 1_3 \in \mathbb{R}^{3 \times 3} \f$ is the 3d identity matrix this
          * method returns the \f$ \mathbb{M} \in \mathbb{R}^{6 \times 6} \f$ matrix such that:
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialMomentum.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialMomentum.h`

 * *Files 15% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SPATIALMOMENTUM_H
 #define IDYNTREE_SPATIALMOMENTUM_H
 
 
-#include <iDynTree/SpatialForceVector.h>
+#include <iDynTree/Core/SpatialForceVector.h>
 
 namespace iDynTree
 {
     /**
      * Class representing a spatial momentum,
      * i.e. a 6D combination of linear and angular momentum.
      *
@@ -26,15 +33,14 @@
          */
         inline SpatialMomentum() {}
         SpatialMomentum(const LinMomentum & _linearVec3, const AngMomentum & _angularVec3);
         SpatialMomentum(const SpatialForceVector & other);
         SpatialMomentum(const SpatialMomentum & other);
 
         // overloaded operators
-        SpatialMomentum& operator=(const SpatialMomentum &other);
         SpatialMomentum operator+(const SpatialMomentum &other) const;
         SpatialMomentum operator-(const SpatialMomentum &other) const;
         SpatialMomentum operator-() const;
     };
 }
 
 #endif
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialMotionVector.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialMotionVector.h`

 * *Files 20% similar despite different names*

```diff
@@ -1,39 +1,46 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#ifndef IDYNTREE_SPATIAL_MOTION_VECTOR_H
-#define IDYNTREE_SPATIAL_MOTION_VECTOR_H
+#ifndef IDYNTREE_SPATIAL_MOTION_RAW_H
+#define IDYNTREE_SPATIAL_MOTION_RAW_H
 
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/GeomVector3.h>
-#include <iDynTree/SpatialVector.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/GeomVector3.h>
+#include <iDynTree/Core/SpatialVector.h>
 
 namespace iDynTree
 {
     class SpatialForceVector;
     class Transform;
     class Dummy {};
 
     /**
-     * Class providing the coordinates for any motion spatial vector
+     * Class providing the raw coordinates for any motion spatial vector
      * (i.e. vector form of an element of se(3)).
      *
      * \ingroup iDynTreeCore
      *
      * A motion spatial vector can be used to to describe a twist, twist acceleration
      * or their derivatives.
      *
      * A generic motion spatial vector can also be used to store the logarithm of
      * an iDynTree::Transform (i.e. an element of SE(3)).
      *
      * This is just a basic vector, used to implement the adjoint transformations in
      * a general way. The relative adjoint transformation is contained in
-     * Transform::apply(SpatialMotion),
-     * for consistency with the iDynTree::Position class.
+     * TransformRaw::apply(SpatialMotionRaw),
+     * for consistency with the iDynTree::PositionRaw class.
      *
      * \note in iDynTree, the spatial vector follows this serialization: the first three elements are
      *       the linear part and the second three elements are the angular part.
      */
 
     class SpatialMotionVector: public SpatialVector<SpatialMotionVector>
     {
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/SpatialVector.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/SpatialVector.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SPATIAL_VECTOR_H
 #define IDYNTREE_SPATIAL_VECTOR_H
 
 #include "Position.h"
 #include "Rotation.h"
 #include "Utils.h"
-#include <iDynTree/GeomVector3.h>
+#include <iDynTree/Core/GeomVector3.h>
 
 
 #include <iostream>
 #include <sstream>
 
 namespace iDynTree
 {
@@ -128,15 +135,14 @@
          * dot product
          */
         double dot(const DualVectorT & other) const;
 
         /**
          * overloaded operators
          */
-        DerivedSpatialVecT& operator=(const DerivedSpatialVecT &other);
         DerivedSpatialVecT operator+(const DerivedSpatialVecT &other) const;
         DerivedSpatialVecT operator-(const DerivedSpatialVecT &other) const;
         DerivedSpatialVecT operator-() const;
 
         /**
          * constructor helpers
          */
@@ -332,22 +338,14 @@
     {
         return (this->getLinearVec3().dot(other.getLinearVec3())
              + this->getAngularVec3().dot(other.getAngularVec3()));
     }
 
     // overloaded operators
     SPATIALVECTOR_TEMPLATE_HDR
-    DerivedSpatialVecT& SPATIALVECTOR_INSTANCE_HDR::operator=(const DerivedSpatialVecT &other)
-    {
-        this->getLinearVec3() = other.getLinearVec3();
-        this->getAngularVec3() = other.getAngularVec3();
-        return &this;
-    }
-
-    SPATIALVECTOR_TEMPLATE_HDR
     DerivedSpatialVecT SPATIALVECTOR_INSTANCE_HDR::operator+(const DerivedSpatialVecT &other) const
     {
         return compose(*this, other);
     }
 
     SPATIALVECTOR_TEMPLATE_HDR
     DerivedSpatialVecT SPATIALVECTOR_INSTANCE_HDR::operator-(const DerivedSpatialVecT &other) const
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/TestUtils.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/TestUtils.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_TEST_UTILS_H
 #define IDYNTREE_TEST_UTILS_H
 
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <algorithm>
 #include <iomanip>
 #include <iostream>
 #include <string>
 #include <vector>
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Transform.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Transform.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_TRANSFORM_H
 #define IDYNTREE_TRANSFORM_H
 
-#include <iDynTree/Position.h>
-#include <iDynTree/Rotation.h>
-#include <iDynTree/MatrixFixSize.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Rotation.h>
+#include <iDynTree/Core/MatrixFixSize.h>
 
 #include <string>
 
 namespace iDynTree
 {
     class Position;
     class Rotation;
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/TransformDerivative.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/TransformDerivative.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_TRANSFORM_DERIVATIVE_H
 #define IDYNTREE_TRANSFORM_DERIVATIVE_H
 
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/MatrixFixSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/MatrixFixSize.h>
 
 namespace iDynTree
 {
     class Transform;
     class ArticulatedBodyInertia;
     class SpatialForceVector;
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Triplets.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Triplets.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_TRIPLETS_H
 #define IDYNTREE_TRIPLETS_H
 
-#include <iDynTree/MatrixFixSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/MatrixFixSize.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <iterator>
 #include <string>
 #include <vector>
 
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Twist.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Twist.h`

 * *Files 19% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_TWIST_H
 #define IDYNTREE_TWIST_H
 
 
-#include  <iDynTree/SpatialMotionVector.h>
+#include  <iDynTree/Core/SpatialMotionVector.h>
 
 namespace iDynTree
 {
     class SpatialAcc;
     class SpatialMomentum;
     class Wrench;
 
@@ -24,15 +31,14 @@
     public:
         Twist();
         Twist(const LinVelocity & _linearVec3, const AngVelocity & _angularVec3);
         Twist(const SpatialMotionVector& other);
         Twist(const Twist& other);
 
         /** overloaded operators **/
-        Twist& operator=(const Twist & other);
         Twist operator+(const Twist &other) const;
         Twist operator-(const Twist &other) const;
         Twist operator-() const;
 
         /** overloaded cross products */
         SpatialAcc operator*(const Twist &other) const;
         Wrench operator*(const SpatialMomentum &other) const;
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Utils.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Utils.h`

 * *Files 14% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_UTILS_H
 #define IDYNTREE_UTILS_H
 
 #include <cstddef>
 
 /**
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/VectorDynSize.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/VectorDynSize.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_DYNAMIC_SIZE_VECTOR_H
 #define IDYNTREE_DYNAMIC_SIZE_VECTOR_H
 
 #if !defined(SWIG_VERSION) || SWIG_VERSION >= 0x030000
-#include <iDynTree/Span.h>
+#include <iDynTree/Core/Span.h>
 #endif
 
 #include <string>
 
 namespace iDynTree
 {
     /**
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/VectorFixSize.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/VectorFixSize.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_VECTOR_FIX_SIZE_H
 #define IDYNTREE_VECTOR_FIX_SIZE_H
 
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 #if !defined(SWIG_VERSION) || SWIG_VERSION >= 0x030000
-#include <iDynTree/Span.h>
+#include <iDynTree/Core/Span.h>
 #endif
 #include <string>
 #include <sstream>
 #include <cassert>
 #include <cstddef>
 #include <cstring>
```

### Comparing `idyntree-9.1.1.dev66/src/core/include/iDynTree/Wrench.h` & `idyntree-9.1.1.dev7/src/core/include/iDynTree/Core/Wrench.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_WRENCH_H
 #define IDYNTREE_WRENCH_H
 
-#include <iDynTree/SpatialForceVector.h>
+#include <iDynTree/Core/SpatialForceVector.h>
 
 namespace iDynTree
 {
     /**
      * Class representing a wrench, i.e. a 6D combination of linear force an angular torque.
      *
      * \ingroup iDynTreeCore
@@ -19,15 +26,14 @@
     public:
         inline Wrench() {}
         Wrench(const Force & _linearVec3, const Torque & _angularVec3);
         Wrench(const SpatialForceVector & other);
         Wrench(const Wrench & other);
 
         // overloaded operators
-        Wrench& operator=(const Wrench & other);
         Wrench operator+(const Wrench &other) const;
         Wrench operator-(const Wrench &other) const;
         Wrench operator-() const;
     };
 }
 
 #endif
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/ArticulatedBodyInertia.cpp` & `idyntree-9.1.1.dev7/src/core/src/ArticulatedBodyInertia.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+
+#include <iDynTree/Core/ArticulatedBodyInertia.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/Wrench.h>
 
-
-#include <iDynTree/ArticulatedBodyInertia.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/Wrench.h>
-
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <Eigen/Dense>
 
 #include <iostream>
 #include <sstream>
 
 #include <cassert>
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/Axis.cpp` & `idyntree-9.1.1.dev7/src/core/src/Axis.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/Axis.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/TransformDerivative.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/SpatialAcc.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/TransformDerivative.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/SpatialAcc.h>
 
 #include <Eigen/Dense>
 
 #include <cmath>
 #include <cstdio>
 #include <sstream>
 
@@ -23,20 +30,14 @@
 
     Axis::Axis(const Axis& other):
               direction(other.getDirection()), origin(other.getOrigin())
     {
 
     }
 
-    Axis& Axis::operator=(const Axis& other)
-    {
-        this->direction = other.getDirection();
-        this->origin = other.getOrigin();
-        return *this;
-    }
 
     const Direction& Axis::getDirection() const
     {
         return direction;
     }
 
     const Position& Axis::getOrigin() const
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/ClassicalAcc.cpp` & `idyntree-9.1.1.dev7/src/core/src/ClassicalAcc.cpp`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/ClassicalAcc.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/Rotation.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/ClassicalAcc.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/RotationRaw.h>
 
 #include <Eigen/Dense>
 
 namespace iDynTree
 {
 
 // \todo TODO avoid typedef duplication
@@ -25,15 +32,15 @@
 ClassicalAcc::ClassicalAcc(const ClassicalAcc& other):
               Vector6(other.data(),6)
 {
 
 }
 
 
-const ClassicalAcc& ClassicalAcc::changeCoordFrame(const Rotation& newCoordFrame)
+const ClassicalAcc& ClassicalAcc::changeCoordFrame(const RotationRaw& newCoordFrame)
 {
     Eigen::Map<Vector6d> thisData(this->data());
     Eigen::Map<const Matrix3dRowMajor> rotData(newCoordFrame.data());
 
     thisData.segment<3>(0) = rotData*thisData.segment<3>(0);
     thisData.segment<3>(3) = rotData*thisData.segment<3>(3);
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/CubicSpline.cpp` & `idyntree-9.1.1.dev7/src/core/src/CubicSpline.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/CubicSpline.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/CubicSpline.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <Eigen/Dense>
 #include <Eigen/Sparse>
 #include <Eigen/SparseLU>
 #include <iostream>
 #include <cmath>
 
 iDynTree::CubicSpline::CubicSpline()
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/Direction.cpp` & `idyntree-9.1.1.dev7/src/core/src/Direction.cpp`

 * *Files 19% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Direction.h>
+#include <iDynTree/Core/Direction.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <Eigen/Dense>
 
 #include <cstdio>
 #include <sstream>
 
 namespace iDynTree
@@ -30,21 +37,14 @@
     Direction::Direction(const Direction& other):VectorFixSize< int(3) >(other)
     {
         this->m_data[0] = other.m_data[0];
         this->m_data[1] = other.m_data[1];
         this->m_data[2] = other.m_data[2];
     }
 
-    Direction& Direction::operator=(const Direction& other)
-    {
-        this->m_data[0] = other.m_data[0];
-        this->m_data[1] = other.m_data[1];
-        this->m_data[2] = other.m_data[2];
-        return *this;
-    }
 
     void Direction::setToDefault()
     {
         this->m_data[0] = 1.0;
         this->m_data[1] = 0.0;
         this->m_data[2] = 0.0;
     }
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/GeomVector3.cpp` & `idyntree-9.1.1.dev7/src/core/src/GeomVector3.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/GeomVector3.h>
+#include <iDynTree/Core/GeomVector3.h>
 
-#include <iDynTree/Rotation.h>
+#include <iDynTree/Core/Rotation.h>
 
 #include <Eigen/Dense>
 
 namespace iDynTree
 {
     typedef Eigen::Matrix<double,3,1> Vector3d;
     typedef Eigen::Matrix<double,3,3,Eigen::RowMajor> Matrix3dRowMajor;
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/InertiaNonLinearParametrization.cpp` & `idyntree-9.1.1.dev7/src/core/src/InertiaNonLinearParametrization.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/InertiaNonLinearParametrization.h>
-#include <iDynTree/SpatialInertia.h>
+#include <iDynTree/Core/InertiaNonLinearParametrization.h>
+#include <iDynTree/Core/SpatialInertia.h>
 
 #include <Eigen/Dense>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree
 {
 
 /////////////////////////////////////////
 // EIGEN HELPERS
 //////////////////////////////////////////
@@ -122,15 +129,15 @@
 
     // We get the mass and the center of mass
     this->mass = inertia.getMass();
 
     this->com = inertia.getCenterOfMass();
 
     // We get the inertia at the COM
-    RotationalInertia inertiaAtCOM = inertia.getRotationalInertiaWrtCenterOfMass();
+    RotationalInertiaRaw inertiaAtCOM = inertia.getRotationalInertiaWrtCenterOfMass();
 
     // We get the inertia at the principal axis using eigen
     JacobiSVD<Matrix<double,3,3,RowMajor> > eigenValuesSolver;
 
     // We check both the positive definitiveness of the matrix and the triangle
     // inequality by directly checking the central second moment of mass of the rigid body
     // In a nutshell, we have that:
@@ -159,15 +166,15 @@
 
     toEigen(this->link_R_centroidal) = eigenValuesSolver.matrixU();
 }
 
 SpatialInertia RigidBodyInertiaNonLinearParametrization::toRigidBodyInertia() const
 {
     // Compute the inertia wrt to the center of mass
-    RotationalInertia rotInertia;
+    RotationalInertiaRaw rotInertia;
 
     Eigen::Vector3d principalMomentOfInertiaAtCOM;
 
     principalMomentOfInertiaAtCOM(0) = this->centralSecondMomentOfMass(1) + this->centralSecondMomentOfMass(2);
     principalMomentOfInertiaAtCOM(1) = this->centralSecondMomentOfMass(0) + this->centralSecondMomentOfMass(2);
     principalMomentOfInertiaAtCOM(2) = this->centralSecondMomentOfMass(0) + this->centralSecondMomentOfMass(1);
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/MatrixDynSize.cpp` & `idyntree-9.1.1.dev7/src/core/src/MatrixDynSize.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
 #include <algorithm>
 #include <cassert>
 #include <cstdio>
 #include <sstream>
 #include <cstring>
 
 namespace iDynTree
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/Rotation.cpp` & `idyntree-9.1.1.dev7/src/core/src/Rotation.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,35 +1,38 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/GeomVector3.h>
-#include <iDynTree/ClassicalAcc.h>
-#include <iDynTree/Rotation.h>
-#include <iDynTree/Axis.h>
-#include <iDynTree/Direction.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Wrench.h>
-#include <iDynTree/RotationalInertia.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/EigenHelpers.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/GeomVector3.h>
+#include <iDynTree/Core/ClassicalAcc.h>
+#include <iDynTree/Core/Rotation.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Wrench.h>
+#include <iDynTree/Core/RotationalInertiaRaw.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 
 #include <Eigen/Dense>
 
 #include <cassert>
 #include <iostream>
 #include <sstream>
 
-typedef Eigen::Matrix<double,3,3,Eigen::RowMajor> Matrix3dRowMajor;
-typedef Eigen::Matrix<double,6,1> Vector6d;
-
 namespace iDynTree
 {
     /**
      * Local static functions
      */
 
     template <class SpatialMotionForceVectorT>
@@ -44,205 +47,70 @@
      * class Method definitions
      */
 
 
     typedef Eigen::Matrix<double,3,3,Eigen::RowMajor> Matrix3dRowMajor;
 
 
-    Rotation::Rotation()
+    Rotation::Rotation(): RotationRaw()
     {
     }
 
     Rotation::Rotation(double xx, double xy, double xz,
                        double yx, double yy, double yz,
-                       double zx, double zy, double zz)
+                       double zx, double zy, double zz): RotationRaw(xx,xy,xz,
+                                                                     yx,yy,yz,
+                                                                     zx,zy,zz)
+    {
+    }
+
+    Rotation::Rotation(const Rotation & other): RotationRaw(other)
     {
-        this->m_data[0] = xx;
-        this->m_data[1] = xy;
-        this->m_data[2] = xz;
-        this->m_data[3] = yx;
-        this->m_data[4] = yy;
-        this->m_data[5] = yz;
-        this->m_data[6] = zx;
-        this->m_data[7] = zy;
-        this->m_data[8] = zz;
-    }
-
-    Rotation::Rotation(const Rotation& other):
-                             MatrixFixSize<3, 3>(other)
-    {}
-
-
-    Rotation::Rotation(MatrixView<const double> other):
-                             MatrixFixSize<3, 3>(other)
-    {}
+    }
 
-    Rotation::Rotation(const double* in_data, const unsigned int in_rows, const unsigned int in_cols):
-                             MatrixFixSize<3, 3>(in_data,in_rows,in_cols)
+    Rotation::Rotation(const RotationRaw& other): RotationRaw(other)
     {
 
     }
 
-    const Rotation& Rotation::changeOrientFrame(const Rotation& newOrientFrame)
+    Rotation::Rotation(MatrixView<const double> other): RotationRaw(other)
     {
-        Eigen::Map<Matrix3dRowMajor> thisData(this->m_data);
-        Eigen::Map<const Matrix3dRowMajor> newOrientFrameData(newOrientFrame.data());
 
-        thisData = thisData*newOrientFrameData;
+    }
 
+    const Rotation& Rotation::changeOrientFrame(const Rotation& newOrientFrame)
+    {
+        this->RotationRaw::changeOrientFrame(newOrientFrame);
         return *this;
     }
 
     const Rotation& Rotation::changeRefOrientFrame(const Rotation& newRefOrientFrame)
     {
-        Eigen::Map<Matrix3dRowMajor> thisData(this->m_data);
-        Eigen::Map<const Matrix3dRowMajor> newRefOrientFrameData(newRefOrientFrame.data());
-
-        thisData = newRefOrientFrameData*thisData;
-
+        this->RotationRaw::changeRefOrientFrame(newRefOrientFrame);
         return *this;
     }
 
     const Rotation& Rotation::changeCoordinateFrame(const Rotation& newCoordinateFrame)
     {
         return this->changeRefOrientFrame(newCoordinateFrame);
     }
 
     Rotation Rotation::compose(const Rotation& op1, const Rotation& op2)
     {
-        Rotation result;
-
-        Eigen::Map<const Matrix3dRowMajor> op1Data(op1.m_data);
-        Eigen::Map<const Matrix3dRowMajor> op2Data(op2.m_data);
-        Eigen::Map<Matrix3dRowMajor> resultData(result.m_data);
-
-        resultData = op1Data*op2Data;
-
-        return result;
+        return Rotation(RotationRaw::compose(op1,op2));
     }
 
     Rotation Rotation::inverse2(const Rotation& orient)
     {
-        Rotation result;
-
-        Eigen::Map<const Matrix3dRowMajor> orientData(orient.m_data);
-        Eigen::Map<Matrix3dRowMajor> resultData(result.m_data);
-
-        resultData = orientData.transpose();
-
-        return result;
+        return Rotation(RotationRaw::inverse2(orient));
     }
 
     Position Rotation::changeCoordFrameOf(const Position & other) const
     {
-        Position result;
-
-        Eigen::Map<const Matrix3dRowMajor> newCoordFrame(m_data);
-        Eigen::Map<const Eigen::Vector3d> positionCoord(other.data());
-        Eigen::Map<Eigen::Vector3d> resultData(result.data());
-
-        resultData = newCoordFrame*positionCoord;
-
-        return result;
-    }
-
-    ClassicalAcc Rotation::changeCoordFrameOf(const ClassicalAcc& other) const
-    {
-        ClassicalAcc result;
-
-        Eigen::Map<const Matrix3dRowMajor> op1Rot(this->data());
-        Eigen::Map<const Vector6d> op2Wrench(other.data());
-
-        Eigen::Map<Vector6d> res(result.data());
-
-        res.segment<3>(3) =  op1Rot*(op2Wrench.segment<3>(3));
-        res.segment<3>(0) =  op1Rot*(op2Wrench.segment<3>(0));
-
-        return result;
-    }
-
-    RotationalInertia Rotation::changeCoordFrameOf(const RotationalInertia& other) const
-    {
-        RotationalInertia result;
-
-        Eigen::Map<const Matrix3dRowMajor> op1Rot(this->data());
-        Eigen::Map<const Matrix3dRowMajor> op2Inertia3d(other.data());
-
-
-        Eigen::Map<Matrix3dRowMajor> resInertia3d(result.data());
-
-        resInertia3d = op1Rot*op2Inertia3d*op1Rot.transpose();
-
-        return result;
-    }
-
-
-    Rotation Rotation::RotX(const double angle)
-    {
-        Rotation result;
-        Eigen::Map<Matrix3dRowMajor> thisData(result.data());
-        thisData = Eigen::AngleAxisd(angle, Eigen::Vector3d::UnitX()).matrix();
-
-        return result;
-    }
-
-    Rotation Rotation::RotY(const double angle)
-    {
-        Rotation result;
-        Eigen::Map<Matrix3dRowMajor> thisData(result.data());
-        thisData = Eigen::AngleAxisd(angle, Eigen::Vector3d::UnitY()).matrix();
-
-        return result;
-    }
-
-    Rotation Rotation::RotZ(const double angle)
-    {
-        Rotation result;
-        Eigen::Map<Matrix3dRowMajor> thisData(result.data());
-        thisData = Eigen::AngleAxisd(angle, Eigen::Vector3d::UnitZ()).matrix();
-
-        return result;
-    }
-
-    Rotation Rotation::RPY(const double roll, const double pitch, const double yaw)
-    {
-        return compose(RotZ(yaw), compose(RotY(pitch), RotX(roll)));
-    }
-
-    Rotation Rotation::Identity()
-    {
-        Rotation result;
-        Eigen::Map<Matrix3dRowMajor> thisData(result.data());
-
-        thisData.setIdentity();
-
-        return result;
-    }
-
-
-    std::string Rotation::toString() const
-    {
-        std::stringstream ss;
-
-        ss << this->m_data[0]
-        << " " << this->m_data[1]
-        << " " << this->m_data[2] << std::endl;
-        ss << this->m_data[3]
-        << " " << this->m_data[4]
-        << " " << this->m_data[5] << std::endl;
-        ss << this->m_data[6]
-        << " " << this->m_data[7]
-        << " " << this->m_data[8] << std::endl;
-
-        return ss.str();
-    }
-
-    std::string Rotation::reservedToString() const
-    {
-        return this->toString();
+        return Position(this->RotationRaw::changeCoordFrameOf(other));
     }
 
     SpatialMotionVector Rotation::changeCoordFrameOf(const SpatialMotionVector& other) const
     {
         return changeCoordFrameOfT<SpatialMotionVector>(*this, other);
     }
 
@@ -280,32 +148,40 @@
         Eigen::Map<Eigen::Vector3d> resultData(result.data());
 
         resultData = newCoordFrame*directionCoord;
 
         return result;
     }
 
-    Axis Rotation::changeCoordFrameOf(const Axis& other) const
+    ClassicalAcc Rotation::changeCoordFrameOf(const ClassicalAcc &other) const
     {
-        return Axis(this->changeCoordFrameOf(other.getDirection()),this->changeCoordFrameOf(other.getOrigin()));
+        ClassicalAcc result;
+        result = RotationRaw::changeCoordFrameOf(other);
+
+        return result;
     }
 
-    Rotation Rotation::inverse() const
+    RotationalInertiaRaw Rotation::changeCoordFrameOf(const RotationalInertiaRaw &other) const
     {
-        return inverse2(*this);
+        RotationalInertiaRaw result;
+
+        result = RotationRaw::changeCoordFrameOf(other);
+
+        return result;
     }
 
-    Rotation& Rotation::operator=(const Rotation & other)
+    Axis Rotation::changeCoordFrameOf(const Axis& other) const
     {
-        Eigen::Map<Matrix3dRowMajor> thisData(m_data);
-        Eigen::Map<const Matrix3dRowMajor> otherData(other.data());
-        thisData = otherData;
-        return *this;
+        return Axis(this->changeCoordFrameOf(other.getDirection()),this->changeCoordFrameOf(other.getOrigin()));
     }
 
+    Rotation Rotation::inverse() const
+    {
+        return inverse2(*this);
+    }
 
     Rotation Rotation::operator*(const Rotation& other) const
     {
         return compose(*this,other);
     }
 
     Position Rotation::operator*(const Position& other) const
@@ -349,15 +225,15 @@
     }
 
     Axis Rotation::operator*(const Axis& other) const
     {
         return changeCoordFrameOf(other);
     }
 
-    RotationalInertia Rotation::operator*(const RotationalInertia& other) const
+    RotationalInertiaRaw Rotation::operator*(const RotationalInertiaRaw& other) const
     {
         return changeCoordFrameOf(other);
     }
 
     void Rotation::fromQuaternion(const iDynTree::Vector4& _quaternion)
     {
         Eigen::Map<const Eigen::Vector4d> quaternionIn(_quaternion.data());
@@ -545,14 +421,29 @@
         // https://github.com/dartsim/dart/pull/334
         // https://github.com/dartsim/dart/issues/88
         Eigen::Map<Eigen::Vector3d>(ret.data()) = aa.angle()*aa.axis();
 
         return ret;
     }
 
+    Rotation Rotation::RotX(const double angle)
+    {
+        return Rotation(RotationRaw::RotX(angle));
+    }
+
+    Rotation Rotation::RotY(const double angle)
+    {
+        return Rotation(RotationRaw::RotY(angle));
+    }
+
+    Rotation Rotation::RotZ(const double angle)
+    {
+        return Rotation(RotationRaw::RotZ(angle));
+    }
+
     Rotation Rotation::RotAxis(const Direction & direction, const double angle)
     {
         Rotation result;
         Eigen::Map<Matrix3dRowMajor> thisData(result.data());
         Eigen::Map<const Eigen::Vector3d>   directionData(direction.data());
         thisData = Eigen::AngleAxisd(angle, directionData).matrix();
 
@@ -568,14 +459,19 @@
         Matrix3dRowMajor skewd = skew(d);
 
         res = skewd*cos(angle)+skewd*skewd*sin(angle);
 
         return result;
     }
 
+    Rotation Rotation::RPY(const double roll, const double pitch, const double yaw)
+    {
+        return Rotation(RotationRaw::RPY(roll, pitch, yaw));
+    }
+
     Matrix3x3 Rotation::RPYRightTrivializedDerivative(const double /*roll*/, const double pitch, const double yaw)
     {
         // See doc/symbolic/RPYExpressionReference.py
 
         Matrix3x3 map;
 
         double sp = std::sin(pitch);
@@ -688,14 +584,19 @@
         map.rightCols<3>() *= iDynTree::toEigen(quaternion)(0);
         map.rightCols<3>() += iDynTree::skew(iDynTree::toEigen(quaternion).tail<3>());
 
         map *= 2;
         return outputMatrix;
     }
 
+    Rotation Rotation::Identity()
+    {
+        return RotationRaw::Identity();
+    }
+
     Rotation Rotation::RotationFromQuaternion(const iDynTree::Vector4& _quaternion)
     {
         //Taken from "Contributions au controle automatique de vehicules aeriens"
         //PhD thesis of "Minh Duc HUA"
         //INRIA Sophia Antipolis
         //Equation 3.8 (page 101)
 
@@ -765,8 +666,24 @@
 
         Matrix3x3 phi_cross;
         toEigen(phi_cross) = skew(toEigen(phi));
 
         toEigen(Jinv) = alpha1*I3  + alpha2*toEigen(phi_cross) + alpha3*toEigen(phi)*toEigen(phi).transpose();
         return Jinv;
     }
+
+    std::string Rotation::toString() const
+    {
+        std::stringstream ss;
+
+        ss << RotationRaw::toString();
+
+        return ss.str();
+    }
+
+    std::string Rotation::reservedToString() const
+    {
+        return this->toString();
+    }
+
+
 }
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/SO3Utils.cpp` & `idyntree-9.1.1.dev7/src/core/src/SO3Utils.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2020 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/SO3Utils.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/SO3Utils.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cmath>
 #include <chrono>
 #include <string>
 #include <numeric>
 
 bool iDynTree::isValidRotationMatrix(const iDynTree::Rotation &r)
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/SparseMatrix.cpp` & `idyntree-9.1.1.dev7/src/core/src/SparseMatrix.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "SparseMatrix.h"
 
 #include "Triplets.h"
 
 #include <cassert>
 #include <sstream>
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/SpatialInertia.cpp` & `idyntree-9.1.1.dev7/src/core/src/SpatialInertia.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,187 +1,58 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/Position.h>
-#include <iDynTree/PrivateUtils.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/Wrench.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/Wrench.h>
 
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cassert>
 #include <iostream>
 #include <sstream>
 
 namespace iDynTree
 {
 
 SpatialInertia::SpatialInertia(const double mass,
-                                     const Position& com,
-                                     const RotationalInertia& rotInertia): m_mass(mass),
-                                                                              m_rotInertia(rotInertia)
-{
-    for(int i = 0; i < 3; i++ )
-    {
-        this->m_mcom[i] = this->m_mass*com(i);
-    }
-}
-
-SpatialInertia::SpatialInertia(const SpatialInertia& other): m_mass(other.m_mass),
-                                                                      m_rotInertia(other.m_rotInertia)
-{
-    for(int i = 0; i < 3; i++ )
-    {
-        m_mcom[i] = other.m_mcom[i];
-    }
-}
-
-void SpatialInertia::fromRotationalInertiaWrtCenterOfMass(const double mass,
-                                                        const Position& com,
-                                                        const RotationalInertia& rotInertiaWrtCom)
-{
-    this->m_mass = mass;
-
-    for(int i = 0; i < 3; i++ )
-    {
-        this->m_mcom[i] = this->m_mass*com(i);
-    }
-
-    // Here we need to compute the rotational inertia at the com
-    // given the one expressed at the frame origin
-    // we apply formula 2.63 in Featherstone 2008
-    Eigen::Map<Eigen::Matrix3d> linkInertia(this->m_rotInertia.data());
-    Eigen::Map<const Eigen::Matrix3d> comInertia(rotInertiaWrtCom.data());
-    Eigen::Map<const Eigen::Vector3d> mcom(this->m_mcom);
-
-    if( fabs(this->m_mass) > 0)
-    {
-        linkInertia = comInertia - squareCrossProductMatrix(mcom)/this->m_mass;
-    }
-    else
-    {
-        linkInertia = comInertia;
-    }
-}
-
-
-double SpatialInertia::getMass() const
-{
-    return this->m_mass;
-}
-
-Position SpatialInertia::getCenterOfMass() const
-{
-    Position ret;
-
-    if( fabs(this->m_mass) > 0 )
-    {
-        ret(0) = this->m_mcom[0]/this->m_mass;
-        ret(1) = this->m_mcom[1]/this->m_mass;
-        ret(2) = this->m_mcom[2]/this->m_mass;
-    }
-    else
-    {
-        ret.zero();
-    }
-
-    return ret;
-}
-
-const RotationalInertia& SpatialInertia::getRotationalInertiaWrtFrameOrigin() const
+                               const PositionRaw& com,
+                               const RotationalInertiaRaw& rotInertia): SpatialInertiaRaw(mass, com, rotInertia)
 {
-    return this->m_rotInertia;
-}
-
-RotationalInertia SpatialInertia::getRotationalInertiaWrtCenterOfMass() const
-{
-    RotationalInertia retComInertia;
-    // Here we need to compute the rotational inertia at the com
-    // given the one expressed at the frame origin
-    // we apply formula 2.63 in Featherstone 2008
-    Eigen::Map<const Eigen::Matrix3d> linkInertia(this->m_rotInertia.data());
-    Eigen::Map<Eigen::Matrix3d> comInertia(retComInertia.data());
-    Eigen::Map<const Eigen::Vector3d> mcom(this->m_mcom);
-
-    if( fabs(this->m_mass) > 0 )
-    {
-        comInertia = linkInertia + squareCrossProductMatrix(mcom)/this->m_mass;
-    }
-    else
-    {
-        comInertia = linkInertia;
-    }
 
-    return retComInertia;
 }
 
-SpatialInertia SpatialInertia::combine(const SpatialInertia& op1,
-                                                                const SpatialInertia& op2)
+SpatialInertia::SpatialInertia(const SpatialInertiaRaw& other): SpatialInertiaRaw(other)
 {
-    SpatialInertia ret;
-    // If the two inertia are expressed with the same orientation
-    // and with respect to the same point (and this will be checked by
-    // the semantic check) we just need to sum
-    // the mass, the first moment of mass and the rotational inertia
-    ret.m_mass = op1.m_mass + op2.m_mass;
-
-    Eigen::Map<Eigen::Vector3d> retMcom(ret.m_mcom);
-    Eigen::Map<const Eigen::Vector3d> op1Mcom(op1.m_mcom);
-    Eigen::Map<const Eigen::Vector3d> op2Mcom(op2.m_mcom);
-
-    retMcom = op1Mcom + op2Mcom;
-
-    Eigen::Map<Eigen::Matrix3d> retRotInertia(ret.m_rotInertia.data());
-    Eigen::Map<const Eigen::Matrix3d> op1RotInertia(op1.m_rotInertia.data());
-    Eigen::Map<const Eigen::Matrix3d> op2RotInertia(op2.m_rotInertia.data());
-
-    retRotInertia = op1RotInertia + op2RotInertia;
 
-    return ret;
 }
 
 
-SpatialForceVector SpatialInertia::multiply(const SpatialMotionVector& op) const
+SpatialInertia::SpatialInertia(const SpatialInertia& other): SpatialInertiaRaw(other)
 {
-    SpatialForceVector ret;
-
-    // we call this linearForce and angularForce
-    // but please remember that they can also be
-    // linear and angular momentum
-    Eigen::Map<Eigen::Vector3d> linearForce(ret.getLinearVec3().data());
-    Eigen::Map<Eigen::Vector3d> angularForce(ret.getAngularVec3().data());
-    Eigen::Map<const Eigen::Vector3d> linearMotion(op.getLinearVec3().data());
-    Eigen::Map<const Eigen::Vector3d> angularMotion(op.getAngularVec3().data());
-
-    Eigen::Map<const Eigen::Vector3d> mcom(this->m_mcom);
-    Eigen::Map<const Eigen::Matrix3d> inertia3d(this->m_rotInertia.data());
 
-    // Implementing the 2.63 formula in Featherstone 2008
-    linearForce  = this->m_mass*linearMotion - mcom.cross(angularMotion);
-    angularForce = mcom.cross(linearMotion) + inertia3d*(angularMotion);
-
-    return ret;
 }
 
 
-void SpatialInertia::zero()
+SpatialInertia SpatialInertia::combine(const SpatialInertia& op1, const SpatialInertia& op2)
 {
-    m_mass = 0.0;
-    for(int i = 0; i < 3; i++ )
-    {
-        this->m_mcom[i] = 0.0;
-    }
-    this->m_rotInertia.zero();
+    return SpatialInertiaRaw::combine(op1,op2);
 }
 
-
 // \todo TODO have a unique mySkew
 template<class Derived>
 inline Eigen::Matrix<typename Derived::Scalar, 3, 3> mySkewIn(const Eigen::MatrixBase<Derived> & vec)
 {
     EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Derived, 3);
     return (Eigen::Matrix<typename Derived::Scalar, 3, 3>() << 0.0, -vec[2], vec[1], vec[2], 0.0, -vec[0], -vec[1], vec[0], 0.0).finished();
 }
@@ -235,25 +106,26 @@
 SpatialInertia SpatialInertia::operator+(const SpatialInertia& other) const
 {
     return SpatialInertia::combine(*this,other);
 }
 
 SpatialForceVector SpatialInertia::operator*(const SpatialMotionVector& other) const
 {
-    return SpatialInertia::multiply(other);
+    return SpatialInertiaRaw::multiply(other);
 }
 
+
 Wrench SpatialInertia::operator*(const SpatialAcc& other) const
 {
-    return SpatialInertia::multiply(other);
+    return SpatialInertiaRaw::multiply(other);
 }
 
 SpatialMomentum SpatialInertia::operator*(const Twist& other) const
 {
-    return SpatialInertia::multiply(other);
+    return SpatialInertiaRaw::multiply(other);
 }
 
 Wrench SpatialInertia::biasWrench(const Twist& V) const
 {
     Wrench ret;
 
     Eigen::Map<Eigen::Vector3d> linearBiasForce(ret.getLinearVec3().data());
@@ -354,15 +226,15 @@
     if( this->m_mass <= 0 )
     {
         isConsistent = false;
         return isConsistent;
     }
 
     // We get the inertia at the COM
-    RotationalInertia inertiaAtCOM = this->getRotationalInertiaWrtCenterOfMass();
+    RotationalInertiaRaw inertiaAtCOM = this->getRotationalInertiaWrtCenterOfMass();
 
     // We get the inertia at the principal axis using eigen
     SelfAdjointEigenSolver<Matrix<double,3,3,RowMajor> > eigenValuesSolver;
 
     // We check both the positive definitiveness of the matrix and the triangle
     // inequality by directly checking the central second moment of mass of the rigid body
     // In a nutshell, we have that:
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/SpatialMotionVector.cpp` & `idyntree-9.1.1.dev7/src/core/src/SpatialMotionVector.cpp`

 * *Files 23% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/SpatialMotionVector.h>
+#include <iDynTree/Core/SpatialForceVector.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/PrivateUtils.h>
 
-#include <iDynTree/SpatialMotionVector.h>
-#include <iDynTree/SpatialForceVector.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/PrivateUtils.h>
-
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/PrivateUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/PrivateUtils.h>
 
 #include <Eigen/Dense>
 
 #include <sstream>
 
 
 namespace iDynTree
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/TestUtils.cpp` & `idyntree-9.1.1.dev7/src/core/src/TestUtils.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/SpatialForceVector.h>
-#include <iDynTree/SpatialMotionVector.h>
-#include <iDynTree/Axis.h>
-#include <iDynTree/SpatialForceVector.h>
-#include <iDynTree/SpatialMotionVector.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Transform.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/SpatialForceVector.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/SpatialForceVector.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Transform.h>
 
 #include <iostream>
 
 #include <cstdlib>
 #include <cmath>
 
 namespace iDynTree
@@ -115,15 +122,15 @@
                                   0.0,cxx+czz,0.0,
                                   0.0,0.0,cxx+cyy};
 
     Rotation rot = Rotation::RPY(getRandomDouble(),getRandomDouble(-1,1),getRandomDouble());
 
     SpatialInertia inertiaLink(getRandomDouble(0,4),
                                Position(getRandomDouble(-2,2),getRandomDouble(-2,2),getRandomDouble(-2,2)),
-                               rot*RotationalInertia(rotInertiaData,3,3));
+                               rot*RotationalInertiaRaw(rotInertiaData,3,3));
 
     return inertiaLink;
 }
 
 SpatialMotionVector getRandomTwist()
 {
     SpatialMotionVector ret;
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/Transform.cpp` & `idyntree-9.1.1.dev7/src/core/src/Transform.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,25 +1,32 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Rotation.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/Wrench.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/Direction.h>
-#include <iDynTree/Axis.h>
-#include <iDynTree/ArticulatedBodyInertia.h>
-#include <iDynTree/MatrixFixSize.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Rotation.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/Wrench.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/ArticulatedBodyInertia.h>
+#include <iDynTree/Core/MatrixFixSize.h>
 
-#include <iDynTree/PrivateUtils.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/PrivateUtils.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <Eigen/Dense>
 
 #include <iostream>
 #include <sstream>
 
 #include <cassert>
@@ -325,17 +332,17 @@
         double newMass = op2.getMass();
 
         // the com is transformed as any position
         Position newCenterOfMass = transform<Position>(op1,Position(op2.getCenterOfMass()));
 
         // the rotational inertial is rotated and then
         // the parallel axis theorem applies
-        RotationalInertia newRotInertia;
+        RotationalInertiaRaw newRotInertia;
         Eigen::Map<Eigen::Matrix3d> newI(newRotInertia.data());
-        RotationalInertia oldRotInertiaWrtCom = op2.getRotationalInertiaWrtCenterOfMass();
+        RotationalInertiaRaw oldRotInertiaWrtCom = op2.getRotationalInertiaWrtCenterOfMass();
         Eigen::Map<const Eigen::Matrix3d> oldIWrtCom(oldRotInertiaWrtCom.data());
 
         Eigen::Map<const Matrix3dRowMajor> R(op1.getRotation().data());
         Eigen::Map<const Eigen::Vector3d> newCOM(newCenterOfMass.data());
 
         newI =  R*oldIWrtCom*R.transpose() - newMass*squareCrossProductMatrix(newCOM);
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/TransformDerivative.cpp` & `idyntree-9.1.1.dev7/src/core/src/TransformDerivative.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/ArticulatedBodyInertia.h>
-#include <iDynTree/TransformDerivative.h>
-#include <iDynTree/Transform.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/ArticulatedBodyInertia.h>
+#include <iDynTree/Core/TransformDerivative.h>
+#include <iDynTree/Core/Transform.h>
 
 #include <Eigen/Dense>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 typedef Eigen::Matrix<double,3,3,Eigen::RowMajor> Matrix3dRowMajor;
 
 namespace iDynTree
 {
 
 TransformDerivative::TransformDerivative(const Matrix3x3& _rotDeriv,
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/Triplets.cpp` & `idyntree-9.1.1.dev7/src/core/src/Triplets.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "Triplets.h"
 #include "MatrixDynSize.h"
 #include "MatrixFixSize.h"
 #include "SparseMatrix.h"
 
 #include <algorithm>
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/Utils.cpp` & `idyntree-9.1.1.dev7/src/core/src/Utils.cpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <iostream>
 
 #include <cassert>
 #include <cmath>
 
 namespace iDynTree
```

### Comparing `idyntree-9.1.1.dev66/src/core/src/VectorDynSize.cpp` & `idyntree-9.1.1.dev7/src/core/src/VectorDynSize.cpp`

 * *Files 7% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <sstream>
 
 #include <cassert>
 #include <cstring>
 
 namespace iDynTree
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/ArticulatedBodyInertiaUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/ArticulatedBodyInertiaUnitTest.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/ArticulatedBodyInertia.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/Wrench.h>
-#include <iDynTree/MatrixFixSize.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/ArticulatedBodyInertia.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/Wrench.h>
+#include <iDynTree/Core/MatrixFixSize.h>
 
 #include <Eigen/Dense>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
@@ -121,15 +128,15 @@
     SpatialMotionVector twist(LinVelocity(twistData,3),AngVelocity(twistData+3,3));
 
     ASSERT_EQUAL_DOUBLE(twist.asVector()(0),twistData[0]);
 
     double rotInertiaData[3*3] = {10.0,0.5,0.8,
                                   0.5,20.0,0.6,
                                   0.8,0.6,25.0};
-    SpatialInertia inertia(1.0,Position(0.3,0.6,0.2),RotationalInertia(rotInertiaData,3,3));
+    SpatialInertia inertia(1.0,Position(0.3,0.6,0.2),RotationalInertiaRaw(rotInertiaData,3,3));
     ArticulatedBodyInertia abi = ArticulatedBodyInertia(inertia);
 
     checkInertiaAccProduct(abi,twist);
     checkInertiaTransformation(trans,abi);
     checkInvariance(trans,abi,twist);
     checkInversion();
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/AxisUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/AxisUnitTest.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/TransformDerivative.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Twist.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/TransformDerivative.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Twist.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
 
 void validateRotationAroundArbitraryAxis(const Axis & ax, const double theta)
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/core/tests/CMakeLists.txt`

 * *Files 13% similar despite different names*

```diff
@@ -1,9 +1,8 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+
 
 macro(add_unit_test classname)
     set(testsrc ${classname}UnitTest.cpp)
     set(testbinary ${classname}UnitTest)
     set(testname   UnitTest${classname})
     add_executable(${testbinary} ${testsrc})
     target_link_libraries(${testbinary} PRIVATE idyntree-core Eigen3::Eigen)
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/CubicSplineUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/CubicSplineUnitTest.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,13 +1,17 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Stefano Dafarra
+ * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ *
+ */
 
-#include "iDynTree/CubicSpline.h"
-#include "iDynTree/TestUtils.h"
-#include "iDynTree/VectorFixSize.h"
+#include "iDynTree/Core/CubicSpline.h"
+#include "iDynTree/Core/TestUtils.h"
+#include "iDynTree/Core/VectorFixSize.h"
 #include <cmath>
 
 using namespace iDynTree;
 using namespace std;
 
 bool setNpoints(size_t n, double initialTime, double finalTime, const Vector4& parameters, CubicSpline& spline){
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/DirectionUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/DirectionUnitTest.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Direction.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <cstdlib>
 
 using namespace iDynTree;
 
 int main()
 {
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/EigenHelpersUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/EigenHelpersUnitTest.cpp`

 * *Files 27% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
 #include <cstdlib>
 
 using namespace iDynTree;
 
 void validateSkewUnskew(const Vector3 randVec)
 {
     Vector3 randVecCheck;
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/EigenSparseHelpersUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/EigenSparseHelpersUnitTest.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/EigenSparseHelpers.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/SparseMatrix.h>
+#include <iDynTree/Core/EigenSparseHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/SparseMatrix.h>
 #include <cstdlib>
 #include <iostream>
 
 
 using namespace iDynTree;
 
 // Coeffs is not available in Eigen3.3-beta2
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/ExpLogUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/ExpLogUnitTest.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/SpatialMotionVector.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
 
 #include <cstdio>
 #include <cstdlib>
 #include <cmath>
 
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/MatrixDynSizeUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/MatrixDynSizeUnitTest.cpp`

 * *Files 27% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/TestUtils.h>
 
 
 using namespace iDynTree;
 
 void checkCapacity()
 {
     MatrixDynSize mat;
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/MatrixViewUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/MatrixViewUnitTest.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/MatrixView.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixView.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 using namespace iDynTree;
 
 template <class T, class U>
 void areMatricesEqual(const T & mat1, const U & mat2)
 {
     ASSERT_EQUAL_DOUBLE(mat1.rows(), mat2.rows());
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/RotationUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/RotationUnitTest.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Rotation.h>
+#include <iDynTree/Core/Rotation.h>
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
 
 void validateRPYRightTrivializedDerivative(const Rotation & R)
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/SO3UtilsUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/SO3UtilsUnitTest.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Stefano Dafarra
+ * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ *
+ */
 
-
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/SO3Utils.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/SO3Utils.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <Eigen/Dense>
 
 #include <cmath>
 #include <numeric>
 
 void checkIsValidRotationMatrix()
 {
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/SpanUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/SpanUnitTest.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -12,19 +12,26 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 //
 ///////////////////////////////////////////////////////////////////////////////
 
 //Most of this file has been taken from https://github.com/Microsoft/GSL/blob/master/tests/span_tests.cpp
 
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Span.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Span.h>
 
 #include <Eigen/Dense>
 
 #include <array>       // for array
 #include <iostream>    // for ptrdiff_t
 #include <iterator>    // for reverse_iterator, operator-, operator==
 #include <memory>      // for unique_ptr, shared_ptr, make_unique, allo...
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/SparseMatrixUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/SparseMatrixUnitTest.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/SparseMatrix.h>
-#include <iDynTree/Triplets.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/SparseMatrix.h>
+#include <iDynTree/Core/Triplets.h>
+#include <iDynTree/Core/TestUtils.h>
 #include <iostream>
 
 
 using namespace iDynTree;
 using namespace std;
 
 template <iDynTree::MatrixStorageOrdering ordering>
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/SpatialAccUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/SpatialAccUnitTest.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/MatrixFixSize.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/MatrixFixSize.h>
 
 #include <Eigen/Dense>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/SpatialInertiaUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/SpatialInertiaUnitTest.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/Wrench.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/MatrixFixSize.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/InertiaNonLinearParametrization.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/Wrench.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/MatrixFixSize.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/InertiaNonLinearParametrization.h>
 
 #include <Eigen/Dense>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
@@ -440,15 +447,15 @@
     Twist twist(LinVelocity(twistData,3),AngVelocity(twistData+3,3));
 
     ASSERT_EQUAL_DOUBLE(twist.asVector()(0),twistData[0]);
 
     double rotInertiaData[3*3] = {10.0,0.04,0.04,
                                   0.04,20.0,0.04,
                                   0.04,0.04,24.0};
-    SpatialInertia inertia(1.0,Position(100,-5,10),RotationalInertia(rotInertiaData,3,3));
+    SpatialInertia inertia(1.0,Position(100,-5,10),RotationalInertiaRaw(rotInertiaData,3,3));
 
     checkInertiaTwistProduct(inertia,twist);
     checkInertiaTransformation(trans,inertia);
     checkInvariance(trans,inertia,twist);
     checkBiasWrench(inertia,twist);
 
     inertia = getNonPhysicalConsistentInertia();
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/TransformFromMatrix4x4UnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/TransformFromMatrix4x4UnitTest.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,40 +1,51 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Rotation.h>
-#include <iDynTree/SpatialMotionVector.h>
-#include <iDynTree/MatrixFixSize.h>
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Rotation.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
+#include <iDynTree/Core/MatrixFixSize.h>
 #include <iostream>
 #include <string>
 
 using namespace std;
 using namespace iDynTree;
 
 void checkFromMatrix4x4()
 {
-    Rotation rot(-2.449, -1.224, -2.041, 0.408, -0.707, -0.707,  0.816, 0.409, -1.154);
-    Position pos(1, 2, 3);
+    RotationRaw rot_raw(-2.449, -1.224, -2.041, 0.408, -0.707, -0.707,  0.816, 0.409, -1.154);
+    PositionRaw pos_raw(1, 2, 3);
     double transform[16] = {-2.449, -1.224, -2.041, 1, 0.408, -0.707, -0.707, 2, 0.816, 0.409, -1.154, 3, 0, 0, 0, 1};
 
+    Rotation rot = Rotation(rot_raw);
+    Position pos = Position(pos_raw);
+
     Matrix4x4 homogeneousMatrix(transform, 4, 4);
 
     Transform t_posrot(rot, pos);
     Transform t_buffer(homogeneousMatrix);
 
     ASSERT_EQUAL_TRANSFORM(t_posrot, t_buffer);
 }
 
 void checkLogExp()
 {
-    Position pos(0, 0, 0);
+    PositionRaw pos_raw(0, 0, 0);
     Rotation rot = Rotation::RPY(0.0, 1.57, 0.0);
+    Position pos = Position(pos_raw);
     Transform t_posrot(rot, pos);
 
     SpatialMotionVector v;
     v.zero();
     v.setAngularVec3(rot.log());
 
     Transform t_v = v.exp();
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/VectorDynSizeUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/VectorDynSizeUnitTest.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/TestUtils.h>
 
 
 using namespace iDynTree;
 
 int main()
 {
     VectorDynSize vec;
```

### Comparing `idyntree-9.1.1.dev66/src/core/tests/WrenchUnitTest.cpp` & `idyntree-9.1.1.dev7/src/core/tests/TwistUnitTest.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,56 +1,45 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/Wrench.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/TestUtils.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <Eigen/Dense>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
 
-void checkWrenchTransformation(const Transform & trans, const Wrench & w)
+void checkTwistTransformation(const Transform & trans, const Twist & twist)
 {
-    Wrench wTransformed = trans*w;
-    Matrix6x6 adjWrench = trans.asAdjointTransformWrench();
-    Vector6 wTranslatedCheck;
+    Twist twistTransformed = trans*twist;
+    Matrix6x6 adj = trans.asAdjointTransform();
+    Vector6 twistTranslatedCheck;
 
-    Vector6 wp = w.asVector();
-    toEigen(wTranslatedCheck) = toEigen(adjWrench)*toEigen(wp);
-
-    ASSERT_EQUAL_VECTOR(wTranslatedCheck,wTransformed.asVector());
-}
-
-void checkDotProductInvariance(const Transform & trans, const Wrench & w, const Twist & twist)
-{
-    double power = w.dot(twist);
-    double powerCheck = twist.dot(w);
-    double powerCheck2 = (trans*w).dot(trans*twist);
-    double powerCheck3 = (trans*twist).dot(trans*w);
-
-    ASSERT_EQUAL_DOUBLE(power,powerCheck);
-    ASSERT_EQUAL_DOUBLE(power,powerCheck2);
-    ASSERT_EQUAL_DOUBLE(power,powerCheck3);
+    Vector6 twistp = twist.asVector();
+    toEigen(twistTranslatedCheck) = toEigen(adj)*toEigen(twistp);
 
+    ASSERT_EQUAL_VECTOR(twistTranslatedCheck,twistTransformed.asVector());
 }
 
 int main()
 {
-    Transform trans(Rotation::RPY(0.0,0.0,0.0),Position(10,0,0));
-
-    double wData[6] = {1.0,4.0,-50.0,1.0,2.0,3.0};
-    Wrench wrench(LinearForceVector3(wData,3),AngularForceVector3(wData+3,3));
+    Transform trans(Rotation::RPY(5.0,7.0,8.0),Position(10,0,-40));
 
-    double twistData[6] = {14.0,-4.0,-5.0,6.0,7.0,1.0};
+    double twistData[6] = {1.0,4.0,-50.0,1.0,2.0,3.0};
     Twist twist(LinVelocity(twistData,3),AngVelocity(twistData+3,3));
 
-    checkWrenchTransformation(trans,wrench);
-    checkDotProductInvariance(trans,wrench,twist);
+    checkTwistTransformation(trans,twist);
 
     return EXIT_SUCCESS;
-}
+}
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/estimation/CMakeLists.txt`

 * *Files 20% similar despite different names*

```diff
@@ -1,27 +1,31 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
+
+set(IDYNTREE_ESTIMATION_HEADERS include/iDynTree/Estimation/BerdyHelper.h
+                                include/iDynTree/Estimation/ExternalWrenchesEstimation.h
+                                include/iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h
+                                include/iDynTree/Estimation/SimpleLeggedOdometry.h
+                                include/iDynTree/Estimation/BerdySparseMAPSolver.h
+                                include/iDynTree/Estimation/SchmittTrigger.h
+                                include/iDynTree/Estimation/ContactStateMachine.h
+                                include/iDynTree/Estimation/BipedFootContactClassifier.h
+                                include/iDynTree/Estimation/GravityCompensationHelpers.h
+                                include/iDynTree/Estimation/ExtendedKalmanFilter.h
+                                include/iDynTree/Estimation/AttitudeEstimator.h
+                                include/iDynTree/Estimation/AttitudeMahonyFilter.h
+                                include/iDynTree/Estimation/AttitudeQuaternionEKF.h
+                                include/iDynTree/Estimation/KalmanFilter.h                                )
 
-
-set(IDYNTREE_ESTIMATION_HEADERS include/iDynTree/BerdyHelper.h
-                                include/iDynTree/ExternalWrenchesEstimation.h
-                                include/iDynTree/ExtWrenchesAndJointTorquesEstimator.h
-                                include/iDynTree/SimpleLeggedOdometry.h
-                                include/iDynTree/BerdySparseMAPSolver.h
-                                include/iDynTree/SchmittTrigger.h
-                                include/iDynTree/ContactStateMachine.h
-                                include/iDynTree/BipedFootContactClassifier.h
-                                include/iDynTree/GravityCompensationHelpers.h
-                                include/iDynTree/ExtendedKalmanFilter.h
-                                include/iDynTree/AttitudeEstimator.h
-                                include/iDynTree/AttitudeMahonyFilter.h
-                                include/iDynTree/AttitudeQuaternionEKF.h
-                                include/iDynTree/KalmanFilter.h                                )
-
-set(IDYNTREE_ESTIMATION_PRIVATE_INCLUDES include/iDynTree/AttitudeEstimatorUtils.h)
+set(IDYNTREE_ESTIMATION_PRIVATE_INCLUDES include/iDynTree/Estimation/AttitudeEstimatorUtils.h)
 
 set(IDYNTREE_ESTIMATION_SOURCES src/BerdyHelper.cpp
                                 src/ExternalWrenchesEstimation.cpp
                                 src/ExtWrenchesAndJointTorquesEstimator.cpp
                                 src/SimpleLeggedOdometry.cpp
                                 src/BerdySparseMAPSolver.cpp
                                 src/SchmittTrigger.cpp
@@ -42,43 +46,39 @@
 
 add_library(${libraryname} ${IDYNTREE_ESTIMATION_SOURCES} ${IDYNTREE_ESTIMATION_HEADERS} ${IDYNTREE_ESTIMATION_PRIVATE_INCLUDES})
 add_library(iDynTree::${libraryname} ALIAS ${libraryname})
 
 target_include_directories(${libraryname} PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
                                                  "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>")
 
-target_link_libraries(${libraryname} PUBLIC idyntree-core idyntree-model idyntree-modelio
+target_link_libraries(${libraryname} PUBLIC idyntree-core idyntree-model idyntree-sensors idyntree-modelio
                                      PRIVATE Eigen3::Eigen)
 
 target_compile_options(${libraryname} PRIVATE ${IDYNTREE_WARNING_FLAGS})
 
 set_property(TARGET ${libraryname} PROPERTY PUBLIC_HEADER ${IDYNTREE_ESTIMATION_HEADERS})
 
 install(TARGETS ${libraryname}
         EXPORT iDynTree
         COMPONENT runtime
         RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}" COMPONENT bin
         LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}" COMPONENT shlib
         ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}" COMPONENT lib
-        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree
-        PRIVATE_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree/impl)
+        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree/Estimation
+        PRIVATE_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree/Estimation/impl)
 
 set_property(GLOBAL APPEND PROPERTY ${VARS_PREFIX}_TARGETS ${libraryname})
 
 # Create deprecated target idyntree-modelio-urdf 
 add_library(idyntree-modelio-urdf INTERFACE)
 add_library(iDynTree::idyntree-modelio-urdf ALIAS idyntree-modelio-urdf)
 target_link_libraries(idyntree-modelio-urdf INTERFACE idyntree-modelio)
 install(TARGETS idyntree-modelio-urdf
         EXPORT iDynTree)
 if(CMAKE_VERSION VERSION_GREATER 3.17)
   set_target_properties(idyntree-modelio-urdf
                         PROPERTIES DEPRECATION "Do not use deprecated target iDynTree::idyntree-modelio-urdf, use iDynTree::idyntree-modelio instead.")
 endif()
 
-# Install deprecated headers
-install(DIRECTORY include/iDynTree/Estimation
-        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree)
-
 if(IDYNTREE_COMPILE_TESTS)
     add_subdirectory(tests)
 endif(IDYNTREE_COMPILE_TESTS)
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/AttitudeEstimator.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/AttitudeEstimator.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_ATTITUDEESTIMATOR_H
 #define IDYNTREE_ATTITUDEESTIMATOR_H
 
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/Rotation.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/Rotation.h>
 
 #include <iostream>
 
 namespace iDynTree
 {
     typedef iDynTree::Vector3 LinearAccelerometerMeasurements;
     typedef iDynTree::Vector3 GyroscopeMeasurements;
@@ -123,15 +130,15 @@
 
         /**
          * @brief Get orientation of the body with respect to inertial frame, in Euler's RPY form
          *        If we denote \f$ A \f$ as inertial frame and \f$ B \f$ as the frame attached to the body,
          *        then this method gives us the RPY 3d vector of Euler Angles when composed together gives us \f$ {^A}R_B \f$ as the rotation matrix
          *        where \f$ {^A}R_B = Rot_z(yaw)Rot_y(pitch)Rot_x(roll)\f$.
          *        For more details about the range of the RPY Euler angles, please refer the documentation of
-         *   <a href="https://github.com/robotology/idyntree/blob/c8bf721b771fa4b1e7c3a940632e121060719a19/src/core/include/iDynTree/Rotation.h#L167">GetRPY()</a>
+         *   <a href="https://github.com/robotology/idyntree/blob/c8bf721b771fa4b1e7c3a940632e121060719a19/src/core/include/iDynTree/Core/Rotation.h#L167">GetRPY()</a>
          *
          * @param[out] rpy 3D vector containing roll pitch yaw angles
          * @return true/false if successful/not
          */
         virtual bool getOrientationEstimateAsRPY(iDynTree::RPY& rpy) = 0;
 
         /**
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/AttitudeEstimatorUtils.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/AttitudeEstimatorUtils.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2019 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_ATTITUDE_ESTIMATOR_UTILS_H
 #define IDYNTREE_ATTITUDE_ESTIMATOR_UTILS_H
 
-#include <iDynTree/AttitudeEstimator.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Estimation/AttitudeEstimator.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #define _USE_MATH_DEFINES
 #include <cmath>
 #include <vector>
 
 /**
  *
  * @brief check a valid measurement
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/AttitudeMahonyFilter.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/AttitudeMahonyFilter.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef ATTITUDE_MAHONY_FILTER_H
 #define ATTITUDE_MAHONY_FILTER_H
 
-#include <iDynTree/AttitudeEstimator.h>
-#include <iDynTree/Direction.h>
+#include <iDynTree/Estimation/AttitudeEstimator.h>
+#include <iDynTree/Core/Direction.h>
 
 namespace iDynTree
 {
 
 /**
 * @struct AttitudeMahonyFilterParameters Parameters to set up the quaternion EKF
 * @var AttitudeMahonyFilterParameters::time_step_in_seconds
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/AttitudeQuaternionEKF.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/AttitudeQuaternionEKF.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef ATTITUDE_QUATERNION_EKF_H
 #define ATTITUDE_QUATERNION_EKF_H
 
-#include <iDynTree/AttitudeEstimator.h>
-#include <iDynTree/ExtendedKalmanFilter.h>
-#include <iDynTree/Direction.h>
+#include <iDynTree/Estimation/AttitudeEstimator.h>
+#include <iDynTree/Estimation/ExtendedKalmanFilter.h>
+#include <iDynTree/Core/Direction.h>
 
 namespace iDynTree
 {
     const unsigned int output_dimensions_with_magnetometer = 4;        ///< dimension of \f$ \mathbb{R}^3 \times \mathbb{R} \f$ accelerometer measurements and magnetometer yaw measurement
     const unsigned int output_dimensions_without_magnetometer = 3;     ///< dimension of \f$ \mathbb{R}^3 \f$ accelerometer measurements
     const unsigned int input_dimensions = 3;                           ///< dimension of \f$ \mathbb{R}^3 \f$ gyroscope measurements
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/BerdyHelper.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/BerdyHelper.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,30 +1,36 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_BERDY_HELPER_H
 #define IDYNTREE_BERDY_HELPER_H
 
-#include <iDynTree/Direction.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/Triplets.h>
-
-#include <iDynTree/Indices.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/FreeFloatingState.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/Triplets.h>
+
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/FreeFloatingState.h>
 
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Sensors/Sensors.h>
 
-#include <iDynTree/LinkTraversalsCache.h>
+#include <iDynTree/Model/LinkTraversalsCache.h>
 
 #include <vector>
 
 namespace iDynTree
 {
 
 /**
@@ -339,14 +345,19 @@
 {
     /**
      * Model used in this class.
      */
     Model m_model;
 
     /**
+     * Sensors used in this class
+     */
+    SensorsList m_sensors;
+
+    /**
      * Traversal used for the dynamics computations
      */
     Traversal m_dynamicsTraversal;
 
     /**
      * Caches of traversals used for kinematic computations.
      */
@@ -511,15 +522,14 @@
      * Access the model.
      */
     Model& model();
 
     /**
      * Access the sensors.
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use BerdyHelper::model::sensors method.")
     SensorsList& sensors();
 
     /**
      * Acces the traveral used for the dynamics computations (const version)
      */
     const Traversal& dynamicTraversal() const;
 
@@ -527,43 +537,31 @@
      * Access the model (const version).
      */
     const Model& model() const;
 
     /**
      * Access the model (const version).
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use BerdyHelper::model::sensors method.")
     const SensorsList& sensors() const;
 
     /**
      * Returns if the helper is valid.
      * The helper is valid if the model and the sensors have been loaded
      * @return true if the helper is valid. False otherwise
      */
     bool isValid() const;
 
     /**
      * Init the class
      *
      * @param[in] model The used model.
-     * @param[in] options The used options, check BerdyOptions docs.
-     * @return true if all went well, false otherwise.
-     */
-    bool init(const Model& model,
-              const BerdyOptions options=BerdyOptions());
-
-    /**
-     * Init the class
-     *
-     * @param[in] model The used model.
      * @param[in] sensors The used sensors.
      * @param[in] options The used options, check BerdyOptions docs.
      * @return true if all went well, false otherwise.
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use the version in which sensors are passed via the iDynTree::Model")
     bool init(const Model& model,
               const SensorsList& sensors,
               const BerdyOptions options=BerdyOptions());
 
     /**
      * Get currently used options.
      */
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/BerdySparseMAPSolver.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/BerdySparseMAPSolver.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_BERDY_SPARSEMAPSOLVER_H
 #define IDYNTREE_BERDY_SPARSEMAPSOLVER_H
 
-#include <iDynTree/Utils.h>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/Indices.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Model/Indices.h>
 
 namespace iDynTree {
 
     class BerdyHelper;
     class VectorDynSize;
     class JointPosDoubleArray;
     class JointDOFsDoubleArray;
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/BipedFootContactClassifier.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/BipedFootContactClassifier.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,9 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Silvio Traversaro, Prashanth Ramadoss
+ * email: silvio.traversaro@iit.it, prashanth.ramadoss@iit.it
+ *
+ * Permission is granted to copy, distribute, and/or modify this program
+ * under the terms of the GNU General Public License, version 2 or any
+ * later version published by the Free Software Foundation.
+ *
+ * A copy of the license can be found at
+ * http://www.robotcub.org/icub/license/gpl.txt
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details
+ */
 #ifndef IDYNTREE_BIPED_FOOT_CONTACT_CLASSIFIER_H
 #define IDYNTREE_BIPED_FOOT_CONTACT_CLASSIFIER_H
 
 #include <memory>
 #include "ContactStateMachine.h"
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/ContactStateMachine.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/ContactStateMachine.h`

 * *Files 25% similar despite different names*

```diff
@@ -1,9 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Silvio Traversaro, Prashanth Ramadoss
+ * email: silvio.traversaro@iit.it, prashanth.ramadoss@iit.it
+ *
+ * Permission is granted to copy, distribute, and/or modify this program
+ * under the terms of the GNU General Public License, version 2 or any
+ * later version published by the Free Software Foundation.
+ *
+ * A copy of the license can be found at
+ * http://www.robotcub.org/icub/license/gpl.txt
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details
+ */
 
 #ifndef IDYNTREE_CONTACTSTATEMACHINE_H
 #define IDYNTREE_CONTACTSTATEMACHINE_H
 #include <iostream>
 #include <memory>
 #include "SchmittTrigger.h"
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/ExtWrenchesAndJointTorquesEstimator.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/ExternalWrenchesEstimation.h`

 * *Files 22% similar despite different names*

```diff
@@ -1,377 +1,424 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#ifndef IDYNTREE_ESTIMATION_EXTWRENCHESANDJOINTTORQUEESTIMATOR_H
-#define IDYNTREE_ESTIMATION_EXTWRENCHESANDJOINTTORQUEESTIMATOR_H
+#ifndef IDYNTREE_ESTIMATION_EXTERNALWRENCHESTIMATION_H
+#define IDYNTREE_ESTIMATION_EXTERNALWRENCHESTIMATION_H
 
-#include <iDynTree/ExternalWrenchesEstimation.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/SubModel.h>
-#include <iDynTree/ContactWrench.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/LinkTraversalsCache.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/LinkState.h>
 
-#include <iDynTree/Sensors.h>
+#include <vector>
 
 namespace iDynTree
 {
+class Model;
+class Traversal;
+class SubModelDecomposition;
+class LinkContactWrenches;
+class SensorsMeasurements;
+class SensorsList;
+class LinkVelArray;
+class LinkAccArray;
+class JointPosDoubleArray;
+class JointDOFsDoubleArray;
 
 /**
- * \brief Estimator for external wrenches and joint torques using internal F/T sensors.
- *
- * This is a class for estimating external wrenches and joint torques using as an input
- * the robot velocities and the accelerations and the measurement of internal six axis
- * F/T sensors.
- *
- * The kinematic information (position,velocity and acceleration) necessary for the
- * estimation can be provided in two ways:
- * * using the updateKinematicsFromFloatingBase
- * * using the updateKinematicsFromFixedBase
- *
- * Note that in both ways there is no need (for the estimation) to provide the
- * absolute position and linear velocity of the robot with respect to the inertial frame.
- * The effect of gravity is considered by directly using the proper acceleration in the case
- * of the floating frame (proper acceleration can be directly measured by an accelerometer)
- * or by directly providing the gravity vector in the fixed frame case.
- *
- * Beside its main goal of estimation of external wrenches and joint torques, the class
- * also provide methods that can be useful to calibrate the six-axis FT sensors of the robot.
- * These methods are:
- *   * ExtWrenchesAndJointTorquesEstimator::computeExpectedFTSensorsMeasurements
- *   * ExtWrenchesAndJointTorquesEstimator::computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics
- * Details of each method can be found in the method documentation
+ * Type of a UnknownWrenchContact.
  */
-class ExtWrenchesAndJointTorquesEstimator
+enum UnknownWrenchContactType
 {
     /**
-     * Structure variables.
+     * Contact for which the complete wrench is unknown.
      */
-    Model m_model;
-    SubModelDecomposition m_submodels;
-    bool m_isModelValid;
-    bool m_isKinematicsUpdated;
+    FULL_WRENCH,
 
-    /**< Traveral used for the dynamics computations */
-    Traversal m_dynamicTraversal;
+    /**
+     * Contact assumed to be a pure force excerted on the contact point.
+     */
+    PURE_FORCE,
 
     /**
-     * Vector of Traversal used for the kinematic computations.
-     * m_kinematicTraversals.getTraversalWithLinkAsBase(l) contains the traversal with base link l .
+     * Contact assumed to be a pure force with a known direction excerted on the contact point
      */
-    LinkTraversalsCache m_kinematicTraversals;
+    PURE_FORCE_WITH_KNOWN_DIRECTION,
 
-    JointPosDoubleArray m_jointPos;
-    JointDOFsDoubleArray m_jointVel;
-    JointDOFsDoubleArray m_jointAcc;
-    LinkVelArray m_linkVels;
-    LinkAccArray m_linkProperAccs;
-    LinkNetExternalWrenches m_linkNetExternalWrenches;
-    LinkInternalWrenches    m_linkIntWrenches;
-    FreeFloatingGeneralizedTorques m_generalizedTorques;
+    /**
+     * The contact forces is assumed to be known.
+     */
+    NO_UNKNOWNS
+};
 
-    estimateExternalWrenchesBuffers m_calibBufs;
-    estimateExternalWrenchesBuffers m_bufs;
 
+/**
+ * \brief A contact whose wrench is unknown.
+ *
+ * Class representing a contact for which
+ * the approximate center of the contact surface is known,
+ * but the wrench is unknown.
+ *
+ */
+struct UnknownWrenchContact
+{
     /**
-     * Disable copy constructor and copy operator
+     * Constructor
      */
-   ExtWrenchesAndJointTorquesEstimator(const ExtWrenchesAndJointTorquesEstimator & /*other*/) {};
+    UnknownWrenchContact()
+    {}
 
-   /**
-    * Copy operator is forbidden
-    */
-   ExtWrenchesAndJointTorquesEstimator& operator=(const ExtWrenchesAndJointTorquesEstimator &/*other*/) {return *this;};
+    UnknownWrenchContact(const UnknownWrenchContactType _unknownType,
+                         const Position  & _contactPoint,
+                         const Direction & _forceDirection = iDynTree::Direction::Default(),
+                         const Wrench    & _knownWrench = iDynTree::Wrench(),
+                         const unsigned long & _contactId = 0): unknownType(_unknownType),
+                                                                contactPoint(_contactPoint),
+                                                                forceDirection(_forceDirection),
+                                                                knownWrench(_knownWrench),
+                                                                contactId(_contactId)
+    {}
 
-public:
     /**
-     * \brief Constructor.
+     * Type of the unknown contact.
      */
-    ExtWrenchesAndJointTorquesEstimator();
+    UnknownWrenchContactType unknownType;
 
     /**
-     * \brief Destructor.
+     * Position of the center of the contact, in the link frame.
      */
-    ~ExtWrenchesAndJointTorquesEstimator();
+    Position contactPoint;
 
     /**
-     * \brief Set model and sensors used for the estimation.
-     *
-     * @param[in] _model the kinematic and dynamic model used for the estimation.
-     * @return true if all went well (model and sensors are well formed), false otherwise.
+     * If unknownType is PURE_FORCE_WITH_KNOWN_DIRECTION,
+     * contains the known direction (in link frame) of the force.
      */
-    bool setModel(const Model & _model);
+    Direction forceDirection;
 
     /**
-     * \brief Set model and sensors used for the estimation.
-     *
-     * @param[in] _model the kinematic and dynamic model used for the estimation.
-     * @param[in] _sensors the sensor model used for the estimation.
-     * @return true if all went well (model and sensors are well formed), false otherwise.
+     * If unknownType is NO_UNKNOWNS,
+     * contains the value of the contact force, with the orientation of the link frame,
+     * and w.r.t. to the origin of the link frame, i.e. it ignores the contactPoint attribute.
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use variant of this method (i.e. setModel) where SensorsList is passed via the iDynTree::Model.")
-    bool setModelAndSensors(const Model & _model, const SensorsList & _sensors);
+    Wrench knownWrench;
 
     /**
-     * Load model and sensors from file.
-     *
-     * @deprecated Use iDynTree::ModelLoader::loadModelFromFile and call setModelAndSensors
-     * on the parsed Model and SensorsList
-     *
-     * @param[in] filename path to the file to load.
-     * @param[in] filetype (optional) explicit definiton of the filetype to load.
-     *                     Only "urdf" is supported at the moment.
-     * @return true if all went well (files were correctly loaded and consistent), false otherwise.
+     * Unique id identifing the contact.
+     * This id is propagated to the contact wrench data structure.
+     * It is implemented mainly for compatibility with the skinDynLib library.
      */
-    bool loadModelAndSensorsFromFile(const std::string filename, const std::string filetype="");
+    unsigned long contactId;
+};
+
+/**
+ * A set of UnknownWrenchContact for each link, representing all the contacts
+ * between the model and the external environment whose wrench is unkwnon.
+ *
+ */
+class LinkUnknownWrenchContacts
+{
+private:
+    std::vector< std::vector<UnknownWrenchContact> > m_linkUnknownWrenchContacts;
 
+public:
     /**
-     * Load model and sensors from file, specifieng the dof considered for the estimation.
+     * Create a LinkWrenches vector, with the size given
+     * by nrOfLinks .
      *
-     * @note this will create e a reduced model only with the joint specified in consideredDOFs and  the
-     *       fixed joints in which FT sensor are mounted.
-     *
-     * @param[in] filename path to the file to load.
-     * @param[in] consideredDOFs list of dof to consider in the model.
-     * @param[in] filetype (optional) explicit definiton of the filetype to load.
-     *                     Only "urdf" is supported at the moment.
-     * @return true if all went well (files were correctly loaded and consistent), false otherwise.
+     * @param[in] nrOfLinks the size of the vector.
      */
-    bool loadModelAndSensorsFromFileWithSpecifiedDOFs(const std::string filename,
-                                                      const std::vector<std::string> & consideredDOFs,
-                                                      const std::string filetype="");
-
+    LinkUnknownWrenchContacts(unsigned int nrOfLinks = 0);
+    LinkUnknownWrenchContacts(const Model & model);
 
     /**
-     * Get used model.
+     * Preserving the number of links, remove all the previously added unknowns.
      *
-     * @return the kinematic and dynamic model used for estimation.
      */
-    const Model & model() const;
+    void clear();
 
     /**
-     * Get used sensors.
      *
-     * @return the sensor model used for estimation.
+     * @param[in] nrOfLinks the number of links used to resize
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use model::sensors.")
-    const SensorsList & sensors() const;
+    void resize(unsigned int nrOfLinks);
+    void resize(const Model & model);
 
     /**
-     * Get the used submodel decomposition.
-     *
-     * @return the used submodel decomposition.
+     * Get the number of external contacts for a given link.
      */
-    const SubModelDecomposition & submodels() const;
+    size_t getNrOfContactsForLink(const LinkIndex linkIndex) const;
 
     /**
-     * Set the kinematic information necessary for the force estimation using the
-     * acceleration and angular velocity information of a floating frame.
-     *
-     * \note Tipically the floating frame information comes from an sensor
-     *       containing a gyroscope (providing the angular velocity) and an
-     *       accelerometer (providing the classical proper acceleration). As
-     *       inertial sensors that return angular acceleration exist but are not common,
-     *       the angular acceleration is usually obtained by numerical derivation
-     *       on the angular velocity measure. In some cases it could make sense
-     *       to just neglet the contribution of the floating frame angular acceleration
-     *       (setting it to a zero vector), if its impact to the dynamics is marginal.
-     *
-     * @param[in] jointPos the position of the joints of the model.
-     * @param[in] jointVel the velocities of the joints of the model.
-     * @param[in] jointAcc the accelerations of the joints of the model.
-     * @param[in] floatingFrame the index of the frame for which kinematic information is provided.
-     * @param[in] properClassicalLinearAcceleration proper (actual acceleration-gravity) classical acceleration
-     *                                              of the origin of the specified frame,
-     *                                              expressed in the specified frame orientation.
-     * @param[in] angularVel angular velocity (wrt to an inertial frame) of the specified floating frame,
-     *                       expressed in the specified frame orientation.
-     * @param[in] angularAcc angular acceleration (wrt to an inertial frame) of the specified floating frame ,
-     *                       expressed in the specified frame orientation.
-     * @return true if all went ok, false otherwise.
-     */
-    bool updateKinematicsFromFloatingBase(const VectorDynSize  & jointPos,
-                                          const VectorDynSize & jointVel,
-                                          const VectorDynSize & jointAcc,
-                                          const FrameIndex & floatingFrame,
-                                          const Vector3 & properClassicalLinearAcceleration,
-                                          const Vector3 & angularVel,
-                                          const Vector3 & angularAcc);
+     * Set the number of external contacts for a given link.
+     */
+    void setNrOfContactsForLink(const LinkIndex linkIndex, const size_t nrOfContacts);
 
     /**
-     * Set the kinematic information necessary for the force estimation assuming that a
-     * given frame is not accelerating with respect to the inertial frame.
-     *
-     * @param[in] jointPos the position of the joints of the model.
-     * @param[in] jointVel the velocities of the joints of the model.
-     * @param[in] jointAcc the accelerations of the joints of the model.
-     * @param[in] fixedFrame the index of the frame that is not accelerating with respect to the inertial frame.
-     * @param[in] gravity the gravity acceleration vector, expressed in the specified fixed frame.
-     * @return true if all went ok, false otherwise.
-     */
-    bool updateKinematicsFromFixedBase(const VectorDynSize  & jointPos,
-                                       const VectorDynSize & jointVel,
-                                       const VectorDynSize & jointAcc,
-                                       const FrameIndex & fixedFrame,
-                                       const Vector3 & gravity);
+     * Add a new contact for a link.
+     */
+    void addNewContactForLink(const LinkIndex linkIndex, const UnknownWrenchContact& newContact);
 
     /**
-     * \brief Predict FT sensors using the knoledge of external wrenches location.
-     *
-     * This function is used to estimate the expected measurement of the FT sensors.
-     * The typical use of this function is to specify only one external unknown wrench
-     * in the unknowns parameter and then compute the expected measurements of the FT sensors
-     * using the kinematic information specified with an updateKinematics*** method.
-     * The location of the single external unknown wrench is the one of the only link
-     * that is supporting the weight of the robot.
-     *
-     * This function can also be used to estimate the FT sensor measurements in case
-     * two unknown external wrenches are applied on the robot, if some additional
-     * assumption about the simmetry of the robot configuration, the joint torques and
-     * the external wrenches can be done.
+     * Add a new contact for a frame.
+     * If the specified frame is not the a link frame, the method automatically convert the unknown
+     * wrench to the relative link frame.
      *
-     * \warning Before calling this method, either updateKinematicsFromFloatingBase or
-     *          updateKinematicsFromFixedBase must be called.
-     *
-     * @param[in] unknowns the unknown external wrenches.
-     * @param[out] predictedMeasures the estimate measures for the FT sensors.
-     * @param[out] estimatedContactWrenches the estimated contact wrenches.
-     * @param[out] estimatedJointTorques the estimated joint torques.
-     * @return true if all went well, false otherwise.
-     */
-    bool computeExpectedFTSensorsMeasurements(const LinkUnknownWrenchContacts & unknowns,
-                                                    SensorsMeasurements & predictedMeasures,
-                                                    LinkContactWrenches & estimatedContactWrenches,
-                                                    JointDOFsDoubleArray & estimatedJointTorques);
+     * @param[in] model the model class for getting frame information.
+     * @param[in] frameIndex the index of the frame in which you are expressing the new unknown wrench.
+     * @param[in] newContact the new unknown wrench to add.
+     * @return true if all went well, false otherwise
+     */
+    bool addNewContactInFrame(const Model & model,
+                              const FrameIndex frameIndex,
+                              const UnknownWrenchContact& newContact);
 
     /**
-     * \brief For each submodel without any external wrench, computes the equation that relates the FT sensor measures with the kinematics-related known terms.
-     *
-     * For each submodel in which there are no external forces, we can write the following equation:
-     *
-     * \f[
-     *  A w = b
-     * \f]
-     * Where:
-     *   * \f$w\f$ is the vector of dimension 6*nrOfFTSensors obtained by stacking the FT sensors measures:
-     *   * \f$A\f$ is a matrix of size 6 x 6*nrOfFTSensors that depends on position in space of the FT sensors
-     *   * \f$b\f$ is a vector of size 6 that depends on the position, velocity, acceleration and gravity of each link in the submodel
-     *
-     * This function provides an easy way to compute A and B . Typically, these quantities are not used online
-     * during the estimation of external wrenches or  internal torques, but rather as an helper method when calibrating FT sensors.
-     *
-     * In the rest of the documentation, we will refer to this quantities:
-     *   * nrOfSubModels (\f$n_{sm}\f$): the number of submodels in which the model is divided, as induced by the FT sensors present in the model.
-     *   * nrOfSubModelsWithoutExtWrenches: the number of submodels on which there is no external wrench
-     *   * nrOfFTSensors (\f$n_{ft}\f$): the number of FT sensors present in the model
-     * In particular, the value of A and b for a given submodel is the following. First of all, for any submodel $sm$ with no external force,
-     * we can write (from Equation 4.19 of https://traversaro.github.io/traversaro-phd-thesis/traversaro-phd-thesis.pdf, modified to account
-     * for all FT sensors in the submodel and to remove external wrenches):
-     *
-     * \f[
-     *   \sum_{s=1}^{n_ft}~\mu_{sm, ft}~\sigma_{sm, ft}~{}_{B_{sm}} X^{ft} \mathrm{f}^{meas}_{ft} = \sum_{L \in \mathbb{L}_{sm}} {}_{B_{sm}} X^{L} {}_L \phi_L
-     * \f]
+     * Add a full wrench unknown at the origin of the specified frame.
+     * Simplified version of a addNewContactInFrame, in which the contact
+     * point is the origin of the frame and the unknown type is FULL_WRENCH.
      *
-     * where:
-     *  * \f$ \mu_{sm, ft} \f$ is equal to \f$1\f$ if the sensor \f$ft\f$ is attached to the submodel \f$sm\f$, and \f$0\f$ otherwise
-     *  * \f$ \sigma_{sm, ft} \f$ is equal to \f$1\f$ if the sensor \f$ft\f$ is measuring the force applied on submodel \f$sm\f$ or \f$-1\f$ if it is measuring the force that the submodel excerts on its neighbor submodel
-     *  *\f$ {B_{sm}} \f$ is a frame in which this equation is expressed, that for this function it is the base link of the submodel.
+     * Equivalent to
+     *   addNewContactInFrame(model,frame,UnknownWrenchContact(FULL_WRENCH,Position::Zero()))
      *
-     *
-     * With this definitions, we can see that A_sm and b_sm for a given submodel \f$sm\f$ can be simply be defined as:
-     *
-     * \f$
-     * A_{sm} = \begin{bmatrix} \mu_{sm, ft0}~\sigma_{sm, ft(0)}~{}_C X^{ft(0)}  & \hdots & \mu_{sm, ft(n_ft-1)}~\sigma_{sm, ft(n_ft-1)}~X^{ft(n_ft-1)} \end{bmatrix}
-     * \f$
-     *
-     * \f$
-     * w_{sm} = \begin{bmatrix} \mathrm{f}^{meas}_{ft(0)}  \\ \vdots \\ \mathrm{f}^{meas}_{ft(n_ft-1)}  \end{bmatrix}
-     * \f$
-     *
-     * \f$
-     * b_{sm} = \sum_{L \in \mathbb{L}_{sm}} {}_C X^{L} {}^L \phi_L
-     * \f$
-     *
-     * \warning Before calling this method, either updateKinematicsFromFloatingBase or
-     *          updateKinematicsFromFixedBase must be called.
-     *
-     * @param[in] unknowns the unknown external wrenches, that is used to understand the submodels in which no external wrench is present
-     * @param[out] A vector of nrOfSubModelsWithoutExtWrenches matrices of size 6 x 6*nrOfFTSensors
-     * @param[out] b vector of nrOfSubModelsWithoutExtWrenches vectors of size 6
-     * @param[out] subModelIDs vector of size nrOfSubModelsWithoutExtWrenches of unsigned integers from 0 to nrOfSubModels-1, subModelIDs[i] specifies to which submodel the quantities A[i]
-     * @param[out] baseLinkIndeces vector of size nrOfSubModelsWithoutExtWrenches of iDynTree::LinkIndex from 0 to nrOfLinks-1, baseLinkIndeces[i] specifies the link in which the equation i is expressed
-     * @return true if all went well, false otherwise.
-     */
-    bool computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics(const LinkUnknownWrenchContacts & unknowns,
-                                                                     std::vector<iDynTree::MatrixDynSize>& A,
-                                                                     std::vector<iDynTree::VectorDynSize>& b,
-                                                                     std::vector<std::ptrdiff_t>& subModelID,
-                                                                     std::vector<iDynTree::LinkIndex>& baseLinkIndeces);
+     * @param[in] model the model class for getting frame information.
+     * @param[in] frameIndex the index of the frame in which you are expressing the new unknown wrench.
+     * @return true if all went well, false otherwise
+     */
+    bool addNewUnknownFullWrenchInFrameOrigin(const Model& model,
+                                              const FrameIndex frameIndex);
 
     /**
-     * \brief Estimate the external wrenches and the internal joint torques using the measurement of the internal F/T sensors.
+     * Get a specific ContactWrench
      *
-     * This is the main method of the class. The technique implemented
-     * in this method is the one described in the paper:
-     *
-     * "Contact force estimations using tactile sensors and force/torque sensors"
-     *
-     * Del Prete, A., Natale, L., Nori, F., & Metta, G. (2012).
-     * Contact force estimations using tactile sensors and force/torque sensors.
-     * URL : http://www.researchgate.net/profile/Andrea_Del_Prete/publication/236152161_Contact_Force_Estimations_Using_Tactile_Sensors_and_Force__Torque_Sensors/links/00b495166e74a5369d000000.pdf
-     *
-     * \note There should be at least 6 unknowns variables for each submodel for which the estimation of
-     *       external wrenches is performed (i.e. usually 1 unknown wrench for each submodel).
-     *       If is not the case, undefined results could occur in the estimation.
-     *
-     * @param[in] unknowns the unknown external wrenches
-     * @param[in] ftSensorsMeasures the measurements for the FT sensors.
-     * @param[out] estimatedContactWrenches the estimated contact wrenches.
-     * @param[out] estimatedJointTorques the estimated joint torques.
-     * @return true if all went ok, false otherwise.
-     */
-    bool estimateExtWrenchesAndJointTorques(const LinkUnknownWrenchContacts & unknowns,
-                                            const SensorsMeasurements & ftSensorsMeasures,
-                                                  LinkContactWrenches & estimatedContactWrenches,
-                                                  JointDOFsDoubleArray & estimatedJointTorques);
+     * @param[in] linkIndex the index of the link for which the contact is retrieved
+     * @param[in] contactIndex a index (between 0 and getNrOfContactsForLink(link)-1 ) identifing the specific contact.
+     */
+    UnknownWrenchContact& contactWrench(const LinkIndex linkIndex, const size_t contactIndex);
+
+    const UnknownWrenchContact& contactWrench(const LinkIndex linkIndex, const size_t contactIndex) const;
+
 
     /**
-     * Check if the kinematics set in the model are the one of a fixed model.
-     *
-     * While computing the expected F/T sensors measures, you tipically want the
-     * model to be still, to reduce the sources of noise .
-     *
-     * @param[in] gravityNorm the norm of the gravity (tipically 9.81) against with all the
-     *                        proper accelerations are check (for a still model, the proper
-     *                        acceleration norm should be close to the gravity norm.
-     * @param[in] properAccTol tolerance to use for the check on the proper acceleration norm.
-     * @param[in] verbose     true if you want to print debug information, false otherwise.
-     * @return true if the model is still, false if it is moving or if the kinematics was never setted.
-     *
-     * \note This method can be computationally expensive, so in most case it
-     *       may be a better idea to just do the check on the input variables (joint velocities, joint acceleration).
+     * Get a human readable description of the LinkUnknownWrenchContacts (for debug)
      */
-    bool checkThatTheModelIsStill(const double gravityNorm,
-                                  const double properAccTol,
-                                  const double verbose);
+    std::string toString(const Model & model) const;
+};
 
+struct estimateExternalWrenchesBuffers
+{
+    estimateExternalWrenchesBuffers();
+    estimateExternalWrenchesBuffers(const SubModelDecomposition& subModels);
+    estimateExternalWrenchesBuffers(const size_t nrOfSubModels, const size_t nrOfLinks);
 
     /**
-     * Compute the vector of the sum of all the wrenches (both internal and external, excluding gravity) acting on
-     * link i, expressed (both orientation and point) with respect to the reference frame of link i,
-     * using the articulated body model and the kinematics information provided by the updateKinematics* methods.
-     *
-     * This is tipically computed as I*a+v*(I*v) , where a is the proper acceleration.
-     *
-     * @param[out] netWrenches the vector of link net wrenches.
-     * @return true if all went ok, false otherwise.
+     * Resize the struct for the number of submodel
      */
-    bool estimateLinkNetWrenchesWithoutGravity(LinkNetTotalWrenchesWithoutGravity & netWrenches);
+    void resize(const SubModelDecomposition& subModels);
+    void resize(const size_t nrOfSubModels, const size_t nrOfLinks);
+
+    size_t getNrOfSubModels() const;
+    size_t getNrOfLinks() const;
 
+    /**
+     * Check if the buffer size are consistent with the submodel
+     * decomposition.
+     */
+    bool isConsistent(const SubModelDecomposition& subModels) const;
+
+    /**
+     * The problem of external wrenches estimation boils down to
+     * solve a LS problem in the form argmin_x (Ax-b)^2 .
+     */
+    std::vector<MatrixDynSize> A;
+    std::vector<VectorDynSize> x;
+    std::vector<Vector6> b;
+
+    /**
+     * We compute the b term for each subtree
+     * in a iterative way, so we need a buffer
+     * to store it for each link
+     */
+    LinkWrenches b_contacts_subtree;
+
+    /**
+     * We compute the transform between each link
+     * and the submodel base, for computing the
+     * A matrices
+     */
+    LinkPositions subModelBase_H_link;
 };
 
+/**
+ * \brief Estimate the external contact wrenches using the MultiBody Newton-Euler equations.
+ *
+ * This function is used to estimate the external contacts forces **without** using any measurement
+ * of the internal FT sensors. It is tipically used to get data for calibrating the offset of
+ * the internal FT sensors.
+ */
+bool estimateExternalWrenchesWithoutInternalFT(const Model& model,
+                                               const Traversal& traversal,
+                                               const LinkUnknownWrenchContacts & unknownWrenches,
+                                               const JointPosDoubleArray & jointPos,
+                                               const LinkVelArray & linkVel,
+                                               const LinkAccArray & linkProperAcc,
+                                                     estimateExternalWrenchesBuffers & bufs,
+                                                     LinkContactWrenches & outputContactWrenches);
+
+/**
+ * \brief Estimate the external wrenches trasmitted by the contacts between the model and the external environment.
+ *
+ * This function exploits the measurements of internal FT sensors (whose structure is contained
+ * in the sensors parameters and which measurements are contained in the ftSensorsMeasurements
+ * parameters) to compute an estimation of the values of the unknown wrenches specified in the
+ * unknownWrenches parameter.
+ *
+ * @param[in] model the considered model.
+ * @param[in] subModels a decomposition of the model along the joint of the six axis F/T sensors.
+ * @param[in] sensors a description of the sensors available in the model.
+ * @param[in] unknownWrenches a description of the contacts for which the contact wrench is unknown.
+ * @param[in] linkVel a vector of link twists, expressed w.r.t to the link orientation and the link origin
+ * @param[in] linkProperAcc a vector of link spatial (in the Featherstone sense) and proper accelerations, expressed w.r.t to the link orientation and the link origin
+ * @param[in] ftSensorsMeasurements the measurements of the internal six axis F/T sensors.
+ * @param[out] outputContactWrenches the estimated contact wrenches.
+ * @return true if all went well (the dimension of the inputs are consistent), false otherwise
+ *
+ */
+bool estimateExternalWrenches(const Model& model,
+                              const SubModelDecomposition& subModels,
+                              const SensorsList& sensors,
+                              const LinkUnknownWrenchContacts & unknownWrenches,
+                              const JointPosDoubleArray & jointPos,
+                              const LinkVelArray & linkVel,
+                              const LinkAccArray & linkProperAcc,
+                              const SensorsMeasurements & ftSensorsMeasurements,
+                                    estimateExternalWrenchesBuffers & bufs,
+                                    LinkContactWrenches & outputContactWrenches);
+
+/**
+ * \brief Modified forward kinematics for torque/force estimation.
+ *
+ * This is a version of forward kinematics modified to fit the needs
+ * of joint torques/external wrenches estimation.
+ *
+ * There are several difference with respect to the classical
+ * forward kinematics.
+ * The first one is that the only inputs necessary related to the base link are
+ * the base link classical proper acceleration, the base link angular velocity
+ * and the base link angular acceleration. This is because the dynamics
+ * of an articulated system does not depend on an offset in linear velocity, and hence
+ * the estimation of joint torques/external wrenches is not affected by the base link
+ * linear velocity. This will mean that the link velocitity computed by this
+ * algorithm are not the velocity of the links with respect to an inertial frame.
+ * Nevertherless they can still be used for estimation.
+ *
+ * There are two main ways in which the base information is computed: one is
+ * exploiting the knoledge that a link is not moving with respect to an inertial frame:
+ * in this case the classical proper acceleration boils down to the inverted gravitational
+ * acceleration, while the angular velocity and angular accelerations are equal to zero.
+ * The other way is to exploit the measure of an accelerometer and of a gyroscope
+ * mounted on the base link of the traversal: the accelerometer will then measure
+ * directly the classical proper acceleration, while the gyroscope will measure the angular velocity.
+ * The angular acceleration can be computed by numerical derivation, or simply neglected if its
+ * effect on the estimation is minimal.
+ *
+ *
+ * \param[in] model the input model
+ * \param[in] traversal the traversal used to propagate the velocity and the proper acceleration
+ * \param[in] base_classicalProperAcc classical proper acceleration of the base origin
+ * \param[in] base_angularVel angular velocity of the base link frame
+ * \param[in] base_angularAcc angular acceleration of the base link frame
+ * \param[in] jointPos joint positions
+ * \param[in] jointVel joint velocities
+ * \param[in] jointAcc joint accelerations
+ * \param[out] linkVel vector of link twists, expressed in the link frame for both orientation and origin
+ * \param[out] linkProperAcc vector of link proper spatial acceleration, expressed in the link frame for both orientation and origin
+ * @return true if all went well, false otherwise
+ *
+ */
+bool dynamicsEstimationForwardVelAccKinematics(const Model & model,
+                                               const Traversal & traversal,
+                                               const Vector3 & base_classicalProperAcc,
+                                               const Vector3 & base_angularVel,
+                                               const Vector3 & base_angularAcc,
+                                               const JointPosDoubleArray & jointPos,
+                                               const JointDOFsDoubleArray & jointVel,
+                                               const JointDOFsDoubleArray & jointAcc,
+                                                     LinkVelArray & linkVel,
+                                                     LinkAccArray  & linkProperAcc);
+
+/**
+ * \brief Modified forward kinematics for floating basedynamics estimation.
+ *
+ * This is a version of velocity forward kinematics modified to fit the needs
+ * of free floating dynamics estimation.
+ *
+ * There are several difference with respect to the classical
+ * forward kinematics.
+ * The first one is that the only inputs necessary related to the base link is
+ *   the base link angular velocity. This is because the dynamics
+ * of an articulated system does not depend on an offset in linear velocity.
+ * This will mean that the link velocities computed by this
+ * algorithm are not the velocity of the links with respect to an inertial frame.
+ * Nevertherless they can still be used for estimation.
+ *
+ * There are two main ways in which the base information is computed: one is
+ * exploiting the knoledge that a link is not moving with respect to an inertial frame:
+ * in this case the angular velocity is equal to zero.
+ * The other way is to exploit the measure of a gyroscope
+ * mounted on the base link of the traversal: the gyroscope will measure the link angular velocity.
+ *
+ *
+ * \param[in] model the input model
+ * \param[in] traversal the traversal used to propagate the velocity and the proper acceleration
+ * \param[in] base_angularVel angular velocity of the base link frame
+ * \param[in] jointPos joint positions
+ * \param[in] jointVel joint velocities
+ * \param[out] linkVel vector of link twists, expressed in the link frame for both orientation and origin
+ * @return true if all went well, false otherwise
+ */
+bool dynamicsEstimationForwardVelKinematics(const Model & model,
+                                            const Traversal & traversal,
+                                            const Vector3 & base_angularVel,
+                                            const JointPosDoubleArray & jointPos,
+                                            const JointDOFsDoubleArray & jointVel,
+                                                  LinkVelArray & linkVel);
+
+/**
+ * \brief Compute the net internal and external wrenches (excluding gravity forces) acting on the links.
+ * @param[in] model the input model
+ * @param[in] linkVel a vector of link twists, expressed w.r.t to the link orientation and the link origin
+ * @param[in] linkProperAcc a vector of link spatial (in the Featherstone sense) and proper accelerations, expressed w.r.t to the link orientation and the link origin
+ * @param[in] linkNetWrenchesWithoutGravity the vector of the sum of all the wrenches (both internal and external, excluding gravity) acting on link i, expressed (both orientation and point) with respect to the reference frame of link i
+ */
+bool computeLinkNetWrenchesWithoutGravity(const Model& model,
+                                          const LinkVelArray & linkVel,
+                                          const LinkAccArray & linkProperAcc,
+                                                LinkNetTotalWrenchesWithoutGravity& linkNetWrenchesWithoutGravity);
+
+/**
+ * Compute the link contact wrenches from the net external wrenches
+ *
+ * If there are more than 6 unknows for link, the problem becomes ill-defined
+ * and the function just assign all the external wrench to the first contact.
+ * \todo(traversaro): support arbitrary LinkUnknownWrenchContacts by performing
+ *                    a least square fitting, similar to what implemented in
+ *                    the estimateExternalWrenches .
+ */
+bool estimateLinkContactWrenchesFromLinkNetExternalWrenches(const Model& model,
+                                                            const LinkUnknownWrenchContacts& unknownWrenches,
+                                                            const LinkNetExternalWrenches& netExtWrenches,
+                                                                  LinkContactWrenches & outputContactWrenches);
+
 }
 
 #endif
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/ExtendedKalmanFilter.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/ExtendedKalmanFilter.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef EXTENDED_KALMAN_FILTER_H
 #define EXTENDED_KALMAN_FILTER_H
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
 #include <vector>
 
 namespace iDynTree
 {
 
     /**
      * @class DiscreteExtendedKalmanFilterHelper naive base class implementation of discrete EKF with additive Gaussian noise
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/GravityCompensationHelpers.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/GravityCompensationHelpers.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,23 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef GRAVITY_COMPENSATION_HELPERS_H
 #define GRAVITY_COMPENSATION_HELPERS_H
 
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/Dynamics.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/Dynamics.h>
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/ClassicalAcc.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/ClassicalAcc.h>
 
-#include <iDynTree/ExternalWrenchesEstimation.h>
+#include <iDynTree/Estimation/ExternalWrenchesEstimation.h>
 
 namespace iDynTree
 {
   /** 
    * @brief Class computing the gravity compensation torques 
    * using accelerometer measurements
    *
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/KalmanFilter.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/KalmanFilter.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2019 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef KALMAN_FILTER_H
 #define KALMAN_FILTER_H
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <vector>
 
 namespace iDynTree
 {
     /**
      * @class DiscreteKalmanFilterHelper Time Invariant Discrete Kalman Filter with additive Gaussian noise
      *
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/SchmittTrigger.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/SchmittTrigger.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,9 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Silvio Traversaro, Prashanth Ramadoss
+ * email: silvio.traversaro@iit.it, prashanth.ramadoss@iit.it
+ *
+ * Permission is granted to copy, distribute, and/or modify this program
+ * under the terms of the GNU General Public License, version 2 or any
+ * later version published by the Free Software Foundation.
+ *
+ * A copy of the license can be found at
+ * http://www.robotcub.org/icub/license/gpl.txt
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details
+ */
 
 #ifndef IDYNTREE_SCHMITT_TRIGGER_H
 #define IDYNTREE_SCHMITT_TRIGGER_H
 
 #include <iostream>
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/include/iDynTree/SimpleLeggedOdometry.h` & `idyntree-9.1.1.dev7/src/estimation/include/iDynTree/Estimation/SimpleLeggedOdometry.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SIMPLE_LEGGED_ODOMETRY2_
 #define IDYNTREE_SIMPLE_LEGGED_ODOMETRY2_
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/Indices.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/LinkState.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/LinkState.h>
 
 namespace iDynTree
 {
 
 /**
  * \ingroup iDynTreeEstimation
  *
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/AttitudeEstimatorUtils.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/AttitudeEstimatorUtils.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2019 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/AttitudeEstimatorUtils.h>
+#include <iDynTree/Estimation/AttitudeEstimatorUtils.h>
 #include <vector>
 #include <cmath>
 
 bool checkValidMeasurement(const iDynTree::Vector3& in, const std::string& measurement_type, bool check_also_zero_vector)
 {
     if (check_also_zero_vector)
     {
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/AttitudeMahonyFilter.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/AttitudeMahonyFilter.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/AttitudeMahonyFilter.h>
-#include <iDynTree/AttitudeEstimatorUtils.h>
+#include <iDynTree/Estimation/AttitudeMahonyFilter.h>
+#include <iDynTree/Estimation/AttitudeEstimatorUtils.h>
 #include <ctime>
 
 iDynTree::Matrix3x3 getMatrixFromVectorVectorMultiplication(iDynTree::Vector3 a, iDynTree::Vector3 b)
 {
     using iDynTree::toEigen;
     iDynTree::Matrix3x3 out;
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/AttitudeQuaternionEKF.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/AttitudeQuaternionEKF.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2019 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/AttitudeQuaternionEKF.h>
-#include <iDynTree/AttitudeEstimatorUtils.h>
+#include <iDynTree/Estimation/AttitudeQuaternionEKF.h>
+#include <iDynTree/Estimation/AttitudeEstimatorUtils.h>
 
 void iDynTree::AttitudeQuaternionEKF::serializeStateVector()
 {
     using iDynTree::toEigen;
     auto x(toEigen(m_x));
     auto q(toEigen(m_state_qekf.m_orientation));
     auto Omega(toEigen(m_state_qekf.m_angular_velocity));
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/BerdyHelper.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/BerdyHelper.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,31 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Estimation/BerdyHelper.h>
+
+#include <iDynTree/Core/ClassicalAcc.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/SparseMatrix.h>
+
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Dynamics.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/AllSensorsTypes.h>
 
-#include <iDynTree/BerdyHelper.h>
-
-#include <iDynTree/ClassicalAcc.h>
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/SparseMatrix.h>
-
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Dynamics.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/Sensors.h>
-#include <iDynTree/AllSensorsTypes.h>
-
-#include <iDynTree/ExternalWrenchesEstimation.h>
+#include <iDynTree/Estimation/ExternalWrenchesEstimation.h>
 
 #include <sstream>
 #include <algorithm>
 
 namespace iDynTree
 {
 
@@ -154,21 +161,23 @@
                               m_nrOfDynamicEquations(0),
                               m_nrOfSensorsMeasurements(0)
 {
 
 }
 
 bool BerdyHelper::init(const Model& model,
-                       const BerdyOptions options)
+                        const SensorsList& sensors,
+                        const BerdyOptions options)
 {
     // Reset the class
     m_kinematicsUpdated = false;
     m_areModelAndSensorsValid = false;
 
     m_model = model;
+    m_sensors = sensors;
     m_options = options;
 
     LinkIndex baseLinkIndex;
     if (!options.baseLink.empty())
     {
         //find the LinkIndex corresponding to the baseLink option
         baseLinkIndex =  m_model.getLinkIndex(options.baseLink);
@@ -228,23 +237,14 @@
     {
         reportError("BerdyHelpers","init","initialization failed");
     }
 
     return res;
 }
 
-bool BerdyHelper::init(const Model& model,
-                       const SensorsList& sensors,
-                       const BerdyOptions options)
-{
-    Model modelCopy = model;
-    modelCopy.sensors() = sensors;
-    return init(modelCopy, options);
-}
-
 BerdyOptions BerdyHelper::getOptions() const
 {
     return m_options;
 }
 
 
 bool BerdyHelper::initSensorsMeasurements()
@@ -253,15 +253,15 @@
     // in sensorsList (informally: the number of measurements of sensors
     // contained in the robot model) plus the additional/fictitious sensors
     // specified in the BerdyOptions
     // The sensors in the robot model are not used if 
     // Berdy variant is BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES
     if(m_options.berdyVariant != BERDY_FLOATING_BASE_NON_COLLOCATED_EXT_WRENCHES)
     {
-        m_nrOfSensorsMeasurements = m_model.sensors().getSizeOfAllSensorsMeasurements();
+        m_nrOfSensorsMeasurements = m_sensors.getSizeOfAllSensorsMeasurements();
     }
     else
     {
         m_nrOfSensorsMeasurements = 0;
     }
     
 
@@ -350,17 +350,17 @@
     // Check that no sensors are attached to the base (this is not supported by the original berdy)
     for(SensorType type=SIX_AXIS_FORCE_TORQUE; type < NR_OF_SENSOR_TYPES; type = (SensorType)(type+1))
     {
         // TODO : link sensor are extremly widespared and they have all approximatly the same API,
         //        so we need a better way to iterate over them
         if( isLinkSensor(type) )
         {
-            for(size_t sensIdx = 0; sensIdx < m_model.sensors().getNrOfSensors(type); sensIdx++)
+            for(size_t sensIdx = 0; sensIdx < m_sensors.getNrOfSensors(type); sensIdx++)
             {
-                LinkSensor * linkSensor = dynamic_cast<LinkSensor*>(m_model.sensors().getSensor(type,sensIdx));
+                LinkSensor * linkSensor = dynamic_cast<LinkSensor*>(m_sensors.getSensor(type,sensIdx));
 
                 LinkIndex   linkToWhichTheSensorIsAttached = linkSensor->getParentLinkIndex();
 
                 if( linkToWhichTheSensorIsAttached == m_dynamicsTraversal.getBaseLink()->getIndex() )
                 {
                     std::stringstream ss;
                     ss << "Sensor " << linkSensor->getName() << " is attached to link " << m_model.getLinkName(linkToWhichTheSensorIsAttached) << " but this link is the base link and base link sensors are not supported by the original berdy.";
@@ -578,35 +578,35 @@
 
 IndexRange BerdyHelper::getRangeSensorVariable(const SensorType type, const unsigned int sensorIdx) const
 {
     unsigned int sensorOffset = 0;
 
     if( type > SIX_AXIS_FORCE_TORQUE )
     {
-        sensorOffset += 6*m_model.sensors().getNrOfSensors(SIX_AXIS_FORCE_TORQUE);
+        sensorOffset += 6*m_sensors.getNrOfSensors(SIX_AXIS_FORCE_TORQUE);
     }
 
     if( type > ACCELEROMETER )
     {
-        sensorOffset += 3*m_model.sensors().getNrOfSensors(ACCELEROMETER);
+        sensorOffset += 3*m_sensors.getNrOfSensors(ACCELEROMETER);
     }
 
     if( type > GYROSCOPE )
     {
-        sensorOffset += 3*m_model.sensors().getNrOfSensors(GYROSCOPE);
+        sensorOffset += 3*m_sensors.getNrOfSensors(GYROSCOPE);
     }
 
     if( type > THREE_AXIS_ANGULAR_ACCELEROMETER )
     {
-        sensorOffset += 3*m_model.sensors().getNrOfSensors(THREE_AXIS_ANGULAR_ACCELEROMETER);
+        sensorOffset += 3*m_sensors.getNrOfSensors(THREE_AXIS_ANGULAR_ACCELEROMETER);
     }
 
     if( type > THREE_AXIS_FORCE_TORQUE_CONTACT )
     {
-        sensorOffset += 3*m_model.sensors().getNrOfSensors(THREE_AXIS_FORCE_TORQUE_CONTACT);
+        sensorOffset += 3*m_sensors.getNrOfSensors(THREE_AXIS_FORCE_TORQUE_CONTACT);
     }
 
     sensorOffset += sensorIdx*getSensorTypeSize(type);
 
     IndexRange ret;
     ret.offset = sensorOffset;
     ret.size = getSensorTypeSize(type);
@@ -1148,18 +1148,18 @@
 
 
 bool BerdyHelper::computeBerdySensorsMatricesFromModel(SparseMatrix<iDynTree::ColumnMajor>& Y, VectorDynSize& bY)
 {
     ////////////////////////////////////////////////////////////////////////
     ///// SIX AXIS F/T SENSORS
     ////////////////////////////////////////////////////////////////////////
-    size_t numOfFTs = m_model.sensors().getNrOfSensors(iDynTree::SIX_AXIS_FORCE_TORQUE);
+    size_t numOfFTs = m_sensors.getNrOfSensors(iDynTree::SIX_AXIS_FORCE_TORQUE);
     for(size_t idx = 0; idx<numOfFTs; idx++)
     {
-        SixAxisForceTorqueSensor * ftSens = (SixAxisForceTorqueSensor*)m_model.sensors().getSensor(iDynTree::SIX_AXIS_FORCE_TORQUE, idx);
+        SixAxisForceTorqueSensor * ftSens = (SixAxisForceTorqueSensor*)m_sensors.getSensor(iDynTree::SIX_AXIS_FORCE_TORQUE, idx);
         LinkIndex childLink;
         childLink = m_dynamicsTraversal.getChildLinkIndexFromJointIndex(m_model,ftSens->getParentJointIndex());
         Matrix6x6 sensor_M_link;
         ftSens->getWrenchAppliedOnLinkInverseMatrix(childLink,sensor_M_link);
         IndexRange sensorRange = this->getRangeSensorVariable(SIX_AXIS_FORCE_TORQUE,idx);
         IndexRange jointWrenchRange = this->getRangeJointVariable(JOINT_WRENCH,ftSens->getParentJointIndex());
 
@@ -1168,18 +1168,18 @@
                                      sensor_M_link);
         // bY for the F/T sensor is equal to zero
     }
 
     ////////////////////////////////////////////////////////////////////////
     ///// ACCELEROMETERS
     ////////////////////////////////////////////////////////////////////////
-    unsigned int numAccl = m_model.sensors().getNrOfSensors(iDynTree::ACCELEROMETER);
+    unsigned int numAccl = m_sensors.getNrOfSensors(iDynTree::ACCELEROMETER);
     for(size_t idx = 0; idx<numAccl; idx++)
     {
-        AccelerometerSensor * accelerometer = (AccelerometerSensor *)m_model.sensors().getSensor(iDynTree::ACCELEROMETER, idx);
+        AccelerometerSensor * accelerometer = (AccelerometerSensor *)m_sensors.getSensor(iDynTree::ACCELEROMETER, idx);
         LinkIndex parentLinkId = accelerometer->getParentLinkIndex();
         Transform sensor_X_link = accelerometer->getLinkSensorTransform().inverse();
         IndexRange sensorRange = this->getRangeSensorVariable(ACCELEROMETER,idx);
 
         // The sensor equation are different between ORIGINAL_BERDY_FIXED_BASE and BERDY_FLOATING_BASE, due to
         // the difference in the convention used for expressing the body acceleration
         if (m_options.berdyVariant == ORIGINAL_BERDY_FIXED_BASE)
@@ -1218,35 +1218,35 @@
             setSubVector(bY, sensorRange, toEigen(sensor_R_link)*(linkAngVel.cross(linkAngVel.cross(toEigen(link_o_sensor)))));
         }
     }
 
     ////////////////////////////////////////////////////////////////////////
     ///// GYROSCOPES
     ////////////////////////////////////////////////////////////////////////
-    unsigned int numGyro = m_model.sensors().getNrOfSensors(iDynTree::GYROSCOPE);
+    unsigned int numGyro = m_sensors.getNrOfSensors(iDynTree::GYROSCOPE);
     for(size_t idx = 0; idx<numGyro; idx++)
     {
-        GyroscopeSensor * gyroscope = (GyroscopeSensor*)m_model.sensors().getSensor(iDynTree::GYROSCOPE, idx);
+        GyroscopeSensor * gyroscope = (GyroscopeSensor*)m_sensors.getSensor(iDynTree::GYROSCOPE, idx);
         LinkIndex parentLinkId = gyroscope->getParentLinkIndex();
         Transform sensor_X_link = gyroscope->getLinkSensorTransform().inverse();
         IndexRange sensorRange = this->getRangeSensorVariable(GYROSCOPE,idx);
 
         // Y for the gyroscope is already zero
 
         // bY for the gyroscope is just the angular velocity of the link rotated in the sensor frame
         setSubVector(bY,sensorRange,toEigen((sensor_X_link*m_linkVels(parentLinkId)).getAngularVec3()));
     }
 
     ////////////////////////////////////////////////////////////////////////
     ///// THREE AXIS ANGULAR ACCELEROMETERS
     ////////////////////////////////////////////////////////////////////////
-    unsigned int numThreeAxisAngularAccelerometer = m_model.sensors().getNrOfSensors(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER);
+    unsigned int numThreeAxisAngularAccelerometer = m_sensors.getNrOfSensors(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER);
     for(size_t idx = 0; idx<numThreeAxisAngularAccelerometer; idx++)
     {
-        ThreeAxisAngularAccelerometerSensor * angAccelerometer = (ThreeAxisAngularAccelerometerSensor*)m_model.sensors().getSensor(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER, idx);
+        ThreeAxisAngularAccelerometerSensor * angAccelerometer = (ThreeAxisAngularAccelerometerSensor*)m_sensors.getSensor(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER, idx);
         LinkIndex parentLinkId = angAccelerometer->getParentLinkIndex();
         Transform sensor_X_link = angAccelerometer->getLinkSensorTransform().inverse();
         IndexRange sensorRange = this->getRangeSensorVariable(THREE_AXIS_ANGULAR_ACCELEROMETER, idx);
 
         // Y for the gyroscope is just a rotation between the link frame and the sensor frame
         // for all the rappresentations of acceleration
         if (m_options.berdyVariant == ORIGINAL_BERDY_FIXED_BASE)
@@ -1267,18 +1267,18 @@
 
         // bY for the angular accelerometer is zero
     }
 
     ////////////////////////////////////////////////////////////////////////
     ///// THREE AXIS FORCE TORQUE CONTACT
     ////////////////////////////////////////////////////////////////////////
-    unsigned int numThreeAxisForceTorqueContact = m_model.sensors().getNrOfSensors(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT);
+    unsigned int numThreeAxisForceTorqueContact = m_sensors.getNrOfSensors(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT);
     for(size_t idx = 0; idx<numThreeAxisForceTorqueContact; idx++)
     {
-        ThreeAxisForceTorqueContactSensor * threeAxisFTContactSensor = (ThreeAxisForceTorqueContactSensor*)m_model.sensors().getSensor(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT, idx);
+        ThreeAxisForceTorqueContactSensor * threeAxisFTContactSensor = (ThreeAxisForceTorqueContactSensor*)m_sensors.getSensor(iDynTree::THREE_AXIS_FORCE_TORQUE_CONTACT, idx);
         LinkIndex parentLinkId = threeAxisFTContactSensor->getParentLinkIndex();
         Transform sensor_X_link = threeAxisFTContactSensor->getLinkSensorTransform().inverse();
         IndexRange sensorRange = this->getRangeSensorVariable(THREE_AXIS_FORCE_TORQUE_CONTACT, idx);
         IndexRange linkNetExtForceTorque = this->getRangeLinkVariable(NET_EXT_WRENCH, parentLinkId);
 
         // Y is just the third (force on z) fourth and fifth (torque on x, y) component of the Transform
         MatrixFixSize<3, 6> threeAxisFTtransform;
@@ -1523,20 +1523,20 @@
 const Model& BerdyHelper::model() const
 {
     return this->m_model;
 }
 
 SensorsList& BerdyHelper::sensors()
 {
-    return this->m_model.sensors();
+    return this->m_sensors;
 }
 
 const SensorsList& BerdyHelper::sensors() const
 {
-    return this->m_model.sensors();
+    return this->m_sensors;
 }
 
 const Traversal& BerdyHelper::dynamicTraversal() const
 {
     return this->m_dynamicsTraversal;
 }
 
@@ -1731,18 +1731,18 @@
     unsigned size = 0;
     m_sensorsOrdering.clear();
     m_sensorsOrdering.reserve(size);
 
     //To be a bit more flexible, rely on getRangeSensorVariable to have the order of
     //the URDF sensors
     //???: Isn't this a loop in some way??
-    for (SensorsList::Iterator it = m_model.sensors().allSensorsIterator();
+    for (SensorsList::Iterator it = m_sensors.allSensorsIterator();
          it.isValid(); ++it)
     {
-        IndexRange sensorRange = this->getRangeSensorVariable((*it)->getSensorType(), m_model.sensors().getSensorIndex((*it)->getSensorType(), (*it)->getName()));
+        IndexRange sensorRange = this->getRangeSensorVariable((*it)->getSensorType(), m_sensors.getSensorIndex((*it)->getSensorType(), (*it)->getName()));
 
         BerdySensor sensor;
         sensor.type = static_cast<BerdySensorTypes>((*it)->getSensorType());
         sensor.id = (*it)->getName();
         sensor.range = sensorRange;
         m_sensorsOrdering.push_back(sensor);
     }
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/BerdySparseMAPSolver.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/BerdySparseMAPSolver.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-#include "iDynTree/BerdySparseMAPSolver.h"
-#include "iDynTree/BerdyHelper.h"
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+#include "iDynTree/Estimation/BerdySparseMAPSolver.h"
+#include "iDynTree/Estimation/BerdyHelper.h"
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/SparseMatrix.h>
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/EigenSparseHelpers.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/SparseMatrix.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/EigenSparseHelpers.h>
 
 #include <Eigen/SparseCore>
 #include <Eigen/SparseCholesky>
 
 #include <cassert>
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/BipedFootContactClassifier.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/BipedFootContactClassifier.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,11 +1,8 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include "iDynTree/BipedFootContactClassifier.h"
+#include "iDynTree/Estimation/BipedFootContactClassifier.h"
 
 namespace iDynTree 
 {
 
 BipedFootContactClassifier::BipedFootContactClassifier(const SchmittParams& leftFootSchmittParams, 
                                              const SchmittParams& rightFootSchmittParams) : m_primaryFoot(RIGHT_FOOT),                                                                                          
                                                                                             m_leftFootContactState(true),
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/ContactStateMachine.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/ContactStateMachine.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,8 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include "iDynTree/ContactStateMachine.h"
+#include "iDynTree/Estimation/ContactStateMachine.h"
 namespace iDynTree
 {
 
 ContactStateMachine::ContactStateMachine(const SchmittParams& s) : m_previousState(true), 
                                                                    m_currentState(true)                                                                   
 {
     m_contactSchmitt = std::unique_ptr<SchmittTrigger>(new SchmittTrigger(s.stableTimeContactBreak,
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/ExtWrenchesAndJointTorquesEstimator.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/ExtWrenchesAndJointTorquesEstimator.cpp`

 * *Files 26% similar despite different names*

```diff
@@ -1,51 +1,57 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h>
+#include <iDynTree/Estimation/ExternalWrenchesEstimation.h>
+
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/EigenMathHelpers.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/ClassicalAcc.h>
+
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/SubModel.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/ContactWrench.h>
+#include <iDynTree/Model/Dynamics.h>
+#include <iDynTree/Model/ModelTransformers.h>
+#include <iDynTree/Sensors/ModelSensorsTransformers.h>
+
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Sensors/PredictSensorsMeasurements.h>
 
-#include <iDynTree/ExtWrenchesAndJointTorquesEstimator.h>
-#include <iDynTree/ExternalWrenchesEstimation.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/EigenMathHelpers.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/ClassicalAcc.h>
-
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/SubModel.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/ContactWrench.h>
-#include <iDynTree/Dynamics.h>
-#include <iDynTree/ModelTransformers.h>
-#include <iDynTree/ModelSensorsTransformers.h>
-
-#include <iDynTree/Sensors.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
-#include <iDynTree/PredictSensorsMeasurements.h>
-
-#include <iDynTree/ModelLoader.h>
-
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <sstream>
 
 namespace iDynTree
 {
 
 ExtWrenchesAndJointTorquesEstimator::ExtWrenchesAndJointTorquesEstimator():
     m_model(),
     m_submodels(),
+    m_sensors(),
     m_isModelValid(false),
     m_isKinematicsUpdated(false),
     m_dynamicTraversal(),
     m_kinematicTraversals(),
     m_jointPos(),
-    m_jointVel(),
-    m_jointAcc(),
     m_linkVels(),
     m_linkProperAccs(),
     m_linkNetExternalWrenches(),
     m_linkIntWrenches(),
     m_generalizedTorques(),
     m_calibBufs(),
     m_bufs()
@@ -72,40 +78,32 @@
     return;
 }
 
 
 bool ExtWrenchesAndJointTorquesEstimator::setModelAndSensors(const Model& _model,
                                                              const SensorsList& _sensors)
 {
-    Model modelCopy = _model;
-    modelCopy.sensors() = _sensors;
-
-    return setModel(modelCopy);
-}
-
-bool ExtWrenchesAndJointTorquesEstimator::setModel(const Model& _model)
-{
+    // \todo TODO add isConsistent methods to Model and SensorList class
     m_model = _model;
+    m_sensors = _sensors;
 
     // resize the data structures
     m_model.computeFullTreeTraversal(m_dynamicTraversal);
     m_kinematicTraversals.resize(m_model);
 
-    m_jointPos.resize(m_model);
-    m_jointVel.resize(m_model);
-    m_jointAcc.resize(m_model);
+
     m_linkVels.resize(m_model);
     m_linkProperAccs.resize(m_model);
     m_linkIntWrenches.resize(m_model);
     m_linkNetExternalWrenches.resize(m_model);
     m_generalizedTorques.resize(m_model);
 
     // create submodel structure
     std::vector<std::string> ftJointNames;
-    getFTJointNames(m_model.sensors(),ftJointNames);
+    getFTJointNames(m_sensors,ftJointNames);
     bool ok = m_submodels.splitModelAlongJoints(m_model,m_dynamicTraversal,ftJointNames);
 
     if( !ok )
     {
         reportError("ExtWrenchesAndJointTorquesEstimator","setModelAndSensors","Error in creating submodel decomposition of the model.");
         return false;
     }
@@ -178,26 +176,26 @@
 const Model& ExtWrenchesAndJointTorquesEstimator::model() const
 {
     return m_model;
 }
 
 const SensorsList& ExtWrenchesAndJointTorquesEstimator::sensors() const
 {
-    return m_model.sensors();
+    return m_sensors;
 }
 
 const SubModelDecomposition& ExtWrenchesAndJointTorquesEstimator::submodels() const
 {
     return m_submodels;
 }
 
 
-bool ExtWrenchesAndJointTorquesEstimator::updateKinematicsFromFixedBase(const VectorDynSize& jointPos,
-                                                                        const VectorDynSize& jointVel,
-                                                                        const VectorDynSize& jointAcc,
+bool ExtWrenchesAndJointTorquesEstimator::updateKinematicsFromFixedBase(const JointPosDoubleArray& jointPos,
+                                                                        const JointDOFsDoubleArray& jointVel,
+                                                                        const JointDOFsDoubleArray& jointAcc,
                                                                         const FrameIndex& fixedFrame,
                                                                         const Vector3& gravity)
 {
     if( !m_isModelValid )
     {
         reportError("ExtWrenchesAndJointTorquesEstimator","updateKinematicsFromFixedBase","Model and sensors information not setted.");
         return false;
@@ -211,18 +209,17 @@
     properClassicalAcceleration(0) = -gravity(0);
     properClassicalAcceleration(1) = -gravity(1);
     properClassicalAcceleration(2) = -gravity(2);
 
     return updateKinematicsFromFloatingBase(jointPos,jointVel,jointAcc,fixedFrame,properClassicalAcceleration,zero,zero);
 }
 
-
-bool ExtWrenchesAndJointTorquesEstimator::updateKinematicsFromFloatingBase(const VectorDynSize& jointPos,
-                                                                           const VectorDynSize& jointVel,
-                                                                           const VectorDynSize& jointAcc,
+bool ExtWrenchesAndJointTorquesEstimator::updateKinematicsFromFloatingBase(const JointPosDoubleArray& jointPos,
+                                                                           const JointDOFsDoubleArray& jointVel,
+                                                                           const JointDOFsDoubleArray& jointAcc,
                                                                            const FrameIndex& floatingFrame,
                                                                            const Vector3& properClassicalLinearAcceleration,
                                                                            const Vector3& angularVel,
                                                                            const Vector3& angularAcc)
 {
     if( !m_isModelValid )
     {
@@ -233,34 +230,14 @@
     if( floatingFrame == FRAME_INVALID_INDEX ||
         floatingFrame < 0 || floatingFrame >= static_cast<FrameIndex>(m_model.getNrOfFrames()) )
     {
         reportError("ExtWrenchesAndJointTorquesEstimator","updateKinematicsFromFloatingBase","Unknown frame index specified.");
         return false;
     }
 
-    if (m_jointPos.size() != jointPos.size())
-    {
-        reportError("ExtWrenchesAndJointTorquesEstimator","updateKinematicsFromFloatingBase","Wrong size of input joint positions.");
-        return false;
-    }
-
-    if (m_jointVel.size() != jointVel.size())
-    {
-        reportError("ExtWrenchesAndJointTorquesEstimator","updateKinematicsFromFloatingBase","Wrong size of input joint velocities.");
-    }
-
-    if (m_jointAcc.size() != jointAcc.size())
-    {
-        reportError("ExtWrenchesAndJointTorquesEstimator","updateKinematicsFromFloatingBase","Wrong size of input joint accelerations.");
-    }
-
-    m_jointPos = jointPos;
-    m_jointVel = jointVel;
-    m_jointAcc = jointAcc;
-
     // Get link of the specified frame
     LinkIndex floatingLinkIndex = m_model.getFrameLink(floatingFrame);
 
     // To initialize the kinematic propagation, we should first convert the kinematics
     // information from the frame in which they are specified to the main frame of the link
     Transform link_H_frame = m_model.getFrameTransform(floatingFrame);
 
@@ -276,23 +253,24 @@
     SpatialAcc base_acc_frame, base_acc_link;
     ClassicalAcc  base_classical_acc_link;
     base_acc_frame.setLinearVec3(properClassicalLinearAcceleration);
     base_acc_frame.setAngularVec3(angularAcc);
     base_acc_link = link_H_frame*base_acc_frame;
     base_classical_acc_link.fromSpatial(base_acc_link,base_vel_link);
 
-
     // Propagate the kinematics information
     bool ok = dynamicsEstimationForwardVelAccKinematics(m_model,m_kinematicTraversals.getTraversalWithLinkAsBase(m_model,floatingLinkIndex),
                                                         base_classical_acc_link.getLinearVec3(),
                                                         base_vel_link.getAngularVec3(),
                                                         base_classical_acc_link.getAngularVec3(),
-                                                        m_jointPos,m_jointVel,m_jointAcc,
+                                                        jointPos,jointVel,jointAcc,
                                                         m_linkVels,m_linkProperAccs);
 
+    // Store joint positions
+    m_jointPos = jointPos;
 
     m_isKinematicsUpdated = ok;
     return ok;
 }
 
 bool ExtWrenchesAndJointTorquesEstimator::computeExpectedFTSensorsMeasurements(const LinkUnknownWrenchContacts& unknowns,
                                                                                      SensorsMeasurements& predictedMeasures,
@@ -351,218 +329,27 @@
                     "Error in computing the dynamic phase of the RNEA.");
         return false;
     }
 
     /**
      * Simulate FT sensor measurements
      */
-    predictSensorsMeasurementsFromRawBuffers(m_model,m_dynamicTraversal,
+    predictSensorsMeasurementsFromRawBuffers(m_model,m_sensors,m_dynamicTraversal,
                                              m_linkVels,m_linkProperAccs,m_linkIntWrenches,predictedMeasures);
 
 
     /**
      * Copy the joint torques computed by the RNEA to the output
      */
     estimatedJointTorques = m_generalizedTorques.jointTorques();
 
 
     return ok;
 }
 
-Wrench computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics_ComputebHelper(const Model& model,
-                                                              const Traversal& subModelTraversal,
-                                                              const JointPosDoubleArray & jointPos,
-                                                              const LinkVelArray& linkVel,
-                                                              const LinkAccArray& linkProperAcc,
-                                                                    estimateExternalWrenchesBuffers& bufs)
-{
-    // First compute the known term of the estimation for each link:
-    // this loop is similar to the dynamic phase of the RNEA
-    // \todo pimp up performance as done in RNEADynamicPhase
-     for(int traversalEl = subModelTraversal.getNrOfVisitedLinks()-1; traversalEl >= 0; traversalEl--)
-     {
-         LinkConstPtr visitedLink = subModelTraversal.getLink(traversalEl);
-         LinkIndex    visitedLinkIndex = visitedLink->getIndex();
-         LinkConstPtr parentLink  = subModelTraversal.getParentLink(traversalEl);
-
-         const iDynTree::SpatialInertia & I = visitedLink->getInertia();
-         const iDynTree::SpatialAcc     & properAcc = linkProperAcc(visitedLinkIndex);
-         const iDynTree::Twist          & v = linkVel(visitedLinkIndex);
-         bufs.b_contacts_subtree(visitedLinkIndex) = I*properAcc + v*(I*v);
-
-         // Iterate on childs of visitedLink
-         // We obtain all the children as all the neighbors of the link, except
-         // for its parent
-         // \todo TODO this point is definitly Tree-specific
-         // \todo TODO this "get child" for is duplicated in the code, we
-         //            should try to consolidate it
-         for(unsigned int neigh_i=0; neigh_i < model.getNrOfNeighbors(visitedLinkIndex); neigh_i++)
-         {
-             LinkIndex neighborIndex = model.getNeighbor(visitedLinkIndex,neigh_i).neighborLink;
-             // Check if this neighbor is a child of the link according to this traversal
-             if( subModelTraversal.isParentOf(visitedLinkIndex,neighborIndex) )
-             {
-                 LinkIndex childIndex = neighborIndex;
-                 IJointConstPtr neighborJoint = model.getJoint(model.getNeighbor(visitedLinkIndex,neigh_i).neighborJoint);
-                 Transform visitedLink_X_child = neighborJoint->getTransform(jointPos,visitedLinkIndex,childIndex);
-
-                 // One term of the sum in Equation 5.20 in Featherstone 2008
-                 bufs.b_contacts_subtree(visitedLinkIndex) = bufs.b_contacts_subtree(visitedLinkIndex)
-                                                            + visitedLink_X_child*bufs.b_contacts_subtree(childIndex);
-             }
-         }
-
-         if( parentLink == 0 )
-         {
-             // If the visited link is the base of the submodel, the
-             // computed known terms is the known term of the submodel itself
-             return bufs.b_contacts_subtree(visitedLinkIndex);
-         }
-     }
-
-     // If we reach this point of the code, something is really really wrong
-     assert(false);
-     return Wrench::Zero();
-}
-
-
-// If it exists, get the link of the traversal to which the FT sensor is connected. If this link does not exists,
-// return nullptr otherwise
-// Warning: this function assumes that only one link in the traversal is connected to the FT sensors, so it is
-// suitable to be used with submodels generated by some code similar to:
-// std::vector<std::string> ftJointNames;
-// getFTJointNames(m_model.sensors(),ftJointNames);
-// bool ok = m_submodels.splitModelAlongJoints(m_model,m_dynamicTraversal,ftJointNames);
-iDynTree::LinkConstPtr getLinkOfSubModelThatIsConnectedToFTSensors(const Traversal & subModelTraversal, iDynTree::SixAxisForceTorqueSensor * ftSens)
-{
-    for(size_t traversalEl = 0; traversalEl < subModelTraversal.getNrOfVisitedLinks(); traversalEl++)
-    {
-        iDynTree::LinkConstPtr visitedLink = subModelTraversal.getLink(traversalEl);
-
-        if (ftSens->isLinkAttachedToSensor(visitedLink->getIndex()))
-        {
-            return visitedLink;
-        }
-    }
-
-    return nullptr;
-}
-
-
-bool ExtWrenchesAndJointTorquesEstimator::computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics(const LinkUnknownWrenchContacts & unknownWrenches,
-                                                                                                      std::vector<iDynTree::MatrixDynSize>& A,
-                                                                                                      std::vector<iDynTree::VectorDynSize>& b,
-                                                                                                      std::vector<std::ptrdiff_t>& subModelIDs,
-                                                                                                      std::vector<iDynTree::LinkIndex>& baseLinkIndeces)
-{
-    if( !m_isModelValid )
-    {
-        reportError("ExtWrenchesAndJointTorquesEstimator","computeExpectedFTSensorsMeasurements",
-                    "Model and sensors information not set.");
-        return false;
-    }
-
-    if( !m_isKinematicsUpdated )
-    {
-        reportError("ExtWrenchesAndJointTorquesEstimator","computeExpectedFTSensorsMeasurements",
-                    "Kinematic information not set.");
-        return false;
-    }
-
-    // Compute nrOfSubmodels without external forces, and specifically which submodel
-    subModelIDs.resize(0);
-    size_t nrOfSubModels = m_submodels.getNrOfSubModels();
-    for(size_t sm=0; sm < nrOfSubModels; sm++)
-    {
-        bool subModelHasExternalWrenchOnIt = false;
-
-        // Iterate over all links of the submodel, and check if there is any external contact
-        const Traversal & subModelTraversal = m_submodels.getTraversal(sm);
-        for(size_t traversalEl = 0; traversalEl < subModelTraversal.getNrOfVisitedLinks(); traversalEl++)
-        {
-            LinkConstPtr visitedLink = subModelTraversal.getLink(traversalEl);
-            size_t nrOfContactForLink = unknownWrenches.getNrOfContactsForLink(visitedLink->getIndex());
-
-            if (nrOfContactForLink > 0)
-            {
-                subModelHasExternalWrenchOnIt = true;
-            }
-        }
-
-        if (!subModelHasExternalWrenchOnIt)
-        {
-            subModelIDs.push_back(sm);
-        }
-    }
-
-    size_t nrOfSubModelsWithoutExtWrenches = subModelIDs.size();
-    size_t nrOfFTSensors = m_model.sensors().getNrOfSensors(iDynTree::SIX_AXIS_FORCE_TORQUE);
-
-    // Resize quantities
-    baseLinkIndeces.resize(nrOfSubModelsWithoutExtWrenches);
-    A.resize(nrOfSubModelsWithoutExtWrenches);
-    b.resize(nrOfSubModelsWithoutExtWrenches);
-
-    for(size_t l=0; l < nrOfSubModelsWithoutExtWrenches; l++)
-    {
-        A[l].resize(6, 6*nrOfFTSensors);
-        b[l].resize(6);
-    }
-
-    // Populate quantities
-    for (size_t l = 0; l < subModelIDs.size(); l++)
-    {
-        size_t sm = subModelIDs[l];
-        const Traversal & subModelTraversal = m_submodels.getTraversal(sm);
-
-        // Assign baseLinkIndeces
-        baseLinkIndeces[l] = subModelTraversal.getBaseLink()->getIndex();
-
-        // Compute b vector
-
-        // First compute the known term of the estimation for each link:
-        // this loop is similar to the dynamic phase of the RNEA
-        toEigen(b[l]) = toEigen(computeSubModelMatrixRelatingFTSensorsMeasuresAndKinematics_ComputebHelper(m_model,subModelTraversal,m_jointPos,m_linkVels,m_linkProperAccs,m_bufs));
-
-        // Compute A matrix
-        Eigen::Map< Eigen::Matrix<double,Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> > Aeig = toEigen(A[l]);
-        Aeig.setZero();
-
-        // As a first step, we need to compute the transform between each link and the base
-        // of its submodel (we are computing the estimation equation in the submodel base frame
-        computeTransformToTraversalBase(m_model,subModelTraversal,m_jointPos,m_bufs.subModelBase_H_link);
-
-        // Iterate over all FTs of the full model, and check if they are connected to the submodel
-        // TODO: if this O(n^2) loop turns out to be expensive, we can speed it up by caching somewhere
-        // the set of FT sensors that belong to a submodel
-        for(size_t ft=0; ft < nrOfFTSensors; ft++ )
-        {
-            ::iDynTree::SixAxisForceTorqueSensor * ftSens
-                = (::iDynTree::SixAxisForceTorqueSensor *) m_model.sensors().getSensor(::iDynTree::SIX_AXIS_FORCE_TORQUE,ft);
-
-            assert(ftSens != 0);
-
-            iDynTree::LinkConstPtr linkConnectedToFt = getLinkOfSubModelThatIsConnectedToFTSensors(subModelTraversal, ftSens);
-
-            if (linkConnectedToFt)
-            {
-                iDynTree::Matrix6x6 link_T_sens;
-                bool ok = ftSens->getWrenchAppliedOnLinkMatrix(linkConnectedToFt->getIndex(), link_T_sens);
-                IDYNTREE_UNUSED(ok);
-                assert(ok);
-                iDynTree::Transform subModelBase_T_link = m_bufs.subModelBase_H_link(linkConnectedToFt->getIndex());
-                Aeig.block<6,6>(0, 6*ft) = iDynTree::toEigen(subModelBase_T_link.asAdjointTransformWrench())*iDynTree::toEigen(link_T_sens);
-            }
-        }
-
-    }
-
-    return true;
-}
-
 bool ExtWrenchesAndJointTorquesEstimator::estimateExtWrenchesAndJointTorques(const LinkUnknownWrenchContacts& unknowns,
                                                                              const SensorsMeasurements& ftSensorsMeasures,
                                                                                    LinkContactWrenches& estimateContactWrenches,
                                                                                    JointDOFsDoubleArray& jointTorques)
 {
     if( !m_isModelValid )
     {
@@ -577,15 +364,15 @@
                     "Kinematic information not set.");
         return false;
     }
 
     /**
      * Compute external forces
      */
-    bool ok = estimateExternalWrenches(m_model,m_submodels,m_model.sensors(),
+    bool ok = estimateExternalWrenches(m_model,m_submodels,m_sensors,
                                        unknowns,m_jointPos,m_linkVels,m_linkProperAccs,
                                        ftSensorsMeasures,m_bufs,estimateContactWrenches);
 
     if( !ok )
     {
         reportError("ExtWrenchesAndJointTorquesEstimator","estimateExtWrenchesAndJointTorques",
                     "Error in estimating the external contact wrenches");
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/ExtendedKalmanFilter.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/ExtendedKalmanFilter.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/ExtendedKalmanFilter.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Estimation/ExtendedKalmanFilter.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 iDynTree::DiscreteExtendedKalmanFilterHelper::DiscreteExtendedKalmanFilterHelper()
 {
 
 }
 
 void iDynTree::DiscreteExtendedKalmanFilterHelper::ekfReset()
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/ExternalWrenchesEstimation.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/ExternalWrenchesEstimation.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,25 +1,32 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-#include <iDynTree/ExternalWrenchesEstimation.h>
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+#include <iDynTree/Estimation/ExternalWrenchesEstimation.h>
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/EigenMathHelpers.h>
-#include <iDynTree/SpatialMomentum.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/EigenMathHelpers.h>
+#include <iDynTree/Core/SpatialMomentum.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/SubModel.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/ContactWrench.h>
-#include <iDynTree/LinkTraversalsCache.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/SubModel.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/ContactWrench.h>
+#include <iDynTree/Model/LinkTraversalsCache.h>
 
-#include <iDynTree/Sensors.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
 
 namespace iDynTree
 {
 
 LinkUnknownWrenchContacts::LinkUnknownWrenchContacts(unsigned int nrOfLinks)
 {
     this->resize(nrOfLinks);
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/GravityCompensationHelpers.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/GravityCompensationHelpers.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include "iDynTree/GravityCompensationHelpers.h"
+#include "iDynTree/Estimation/GravityCompensationHelpers.h"
 
 namespace iDynTree 
 {
 
   GravityCompensationHelper::GravityCompensationHelper() : m_isModelValid(false),
                                                            m_isKinematicsUpdated(false),
                                                            m_model(),
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/KalmanFilter.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/KalmanFilter.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2019 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/KalmanFilter.h>
+#include <iDynTree/Estimation/KalmanFilter.h>
 
 iDynTree::DiscreteKalmanFilterHelper::DiscreteKalmanFilterHelper()
 {
 
 }
 
 bool iDynTree::DiscreteKalmanFilterHelper::constructKalmanFilter(const iDynTree::MatrixDynSize& A,
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/SchmittTrigger.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/SchmittTrigger.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,11 +1,8 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include "iDynTree/SchmittTrigger.h"
+#include "iDynTree/Estimation/SchmittTrigger.h"
 
 namespace iDynTree 
 {
 
 SchmittTrigger::SchmittTrigger(double stableOFFTime, double stableONTime, double lowValueThreshold, double highValueThreshold)
 {
     configure(stableOFFTime, stableONTime, lowValueThreshold, highValueThreshold);
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/src/SimpleLeggedOdometry.cpp` & `idyntree-9.1.1.dev7/src/estimation/src/SimpleLeggedOdometry.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+
+#include <iDynTree/Core/EigenHelpers.h>
+
+#include <iDynTree/Estimation/SimpleLeggedOdometry.h>
+
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/ModelTransformers.h>
 
-
-#include <iDynTree/EigenHelpers.h>
-
-#include <iDynTree/SimpleLeggedOdometry.h>
-
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Indices.h>
-#include <iDynTree/ModelTransformers.h>
-
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 #include <sstream>
 
 namespace iDynTree
 {
 
 SimpleLeggedOdometry::SimpleLeggedOdometry(): m_model(),
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/tests/AttitudeEstimatorUnitTest.cpp` & `idyntree-9.1.1.dev7/src/estimation/tests/AttitudeEstimatorUnitTest.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/AttitudeQuaternionEKF.h>
-#include <iDynTree/AttitudeMahonyFilter.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/SpatialMotionVector.h>
-#include <iDynTree/SpatialForceVector.h>
+#include <iDynTree/Estimation/AttitudeQuaternionEKF.h>
+#include <iDynTree/Estimation/AttitudeMahonyFilter.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
+#include <iDynTree/Core/SpatialForceVector.h>
 #include <iostream>
 #include <memory>
 
 void run(iDynTree::IAttitudeEstimator* estimator,
          const iDynTree::LinAcceleration& acc,
          const iDynTree::GyroscopeMeasurements& gyro,
          const iDynTree::MagnetometerMeasurements& mag)
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/tests/BerdyHelperUnitTest.cpp` & `idyntree-9.1.1.dev7/src/estimation/tests/BerdyHelperUnitTest.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,31 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/BerdyHelper.h>
-#include <iDynTree/ExtWrenchesAndJointTorquesEstimator.h>
+#include <iDynTree/Estimation/BerdyHelper.h>
+#include <iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h>
 
-#include <iDynTree/PredictSensorsMeasurements.h>
+#include <iDynTree/Sensors/PredictSensorsMeasurements.h>
 
 #include "testModels.h"
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/EigenSparseHelpers.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/SparseMatrix.h>
-#include <iDynTree/ModelTestUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/EigenSparseHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/SparseMatrix.h>
+#include <iDynTree/Model/ModelTestUtils.h>
 
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Dynamics.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Dynamics.h>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/tests/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/estimation/tests/CMakeLists.txt`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 macro(add_estimation_test classname)
     set(testsrc ${classname}UnitTest.cpp)
     set(testbinary ${classname}UnitTest)
     set(testname   UnitTest${classname})
     add_executable(${testbinary} ${testsrc})
     target_link_libraries(${testbinary} PRIVATE idyntree-model idyntree-estimation idyntree-testmodels Eigen3::Eigen)
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/tests/ExternalWrenchesEstimationUnitTest.cpp` & `idyntree-9.1.1.dev7/src/estimation/tests/ExternalWrenchesEstimationUnitTest.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,34 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Estimation/ExternalWrenchesEstimation.h>
+
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Sensors/PredictSensorsMeasurements.h>
+
+#include <iDynTree/Model/ContactWrench.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/SubModel.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/ModelTestUtils.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Dynamics.h>
 
-#include <iDynTree/ExternalWrenchesEstimation.h>
-
-#include <iDynTree/Sensors.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
-#include <iDynTree/PredictSensorsMeasurements.h>
-
-#include <iDynTree/ContactWrench.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/SubModel.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/ModelTestUtils.h>
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Dynamics.h>
-
-#include <iDynTree/Position.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
 
 inline Link getSimplestLink()
@@ -33,15 +40,15 @@
                                   0.0,cxx+czz,0.0,
                                   0.0,0.0,cxx+cyy};
 
     Rotation rot = Rotation::RPY(2.0,5.0,5.0);
 
     SpatialInertia inertiaLink(7.0,
                                Position(5.0,0.0,0.0),
-                               rot*RotationalInertia(rotInertiaData,3,3));
+                               rot*RotationalInertiaRaw(rotInertiaData,3,3));
 
     Link link;
 
     link.setInertia(inertiaLink);
 
     return link;
 }
@@ -190,15 +197,15 @@
     std::cerr << "checkSimpleModelExternalWrenchEstimationWithFTSensors " << std::endl;
 
     // Create a simple three link model
     double rotInertiaData[3*3] = {1.0,0.0,0.0,
                                   0.0,1.0,0.0,
                                   0.0,0.0,1.0};
 
-    SpatialInertia inertia(1.0,iDynTree::Position::Zero(),RotationalInertia(rotInertiaData,3,3));
+    SpatialInertia inertia(1.0,iDynTree::Position::Zero(),RotationalInertiaRaw(rotInertiaData,3,3));
     Link link0, link1, link2, link3;
     link0.setInertia(inertia);
     link1.setInertia(inertia);
     link2.setInertia(inertia);
     link3.setInertia(inertia);
     Model model;
     model.addLink("link0",link0);
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/tests/KalmanFilterUnitTest.cpp` & `idyntree-9.1.1.dev7/src/estimation/tests/KalmanFilterUnitTest.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2019 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/KalmanFilter.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Estimation/KalmanFilter.h>
+#include <iDynTree/Core/TestUtils.h>
 #include <iostream>
 #include <memory>
 
 #include <random>
 
 int main()
 {
```

### Comparing `idyntree-9.1.1.dev66/src/estimation/tests/SimpleLeggedOdometryUnitTest.cpp` & `idyntree-9.1.1.dev7/src/estimation/tests/SimpleLeggedOdometryUnitTest.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/SimpleLeggedOdometry.h>
+#include <iDynTree/Estimation/SimpleLeggedOdometry.h>
 
 #include "testModels.h"
 
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 
 using namespace iDynTree;
 
 std::vector<std::string> getCanonical_iCubJoints()
 {
     std::vector<std::string> consideredJoints;
```

### Comparing `idyntree-9.1.1.dev66/src/high-level/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/high-level/CMakeLists.txt`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 set(IDYNTREE_HIGH_LEVEL_HEADERS include/iDynTree/KinDynComputations.h)
 
 set(IDYNTREE_HIGH_LEVEL_SOURCES src/KinDynComputations.cpp)
 
 SOURCE_GROUP("Source Files" FILES ${IDYNTREE_HIGH_LEVEL_SOURCES})
 SOURCE_GROUP("Header Files" FILES ${IDYNTREE_HIGH_LEVEL_HEADERS})
@@ -13,15 +17,15 @@
 
 add_library(${libraryname} ${IDYNTREE_HIGH_LEVEL_SOURCES} ${IDYNTREE_HIGH_LEVEL_HEADERS} ${IDYNTREE_HIGH_LEVEL_PRIVATE_INCLUDES})
 add_library(iDynTree::${libraryname} ALIAS ${libraryname})
 
 target_include_directories(${libraryname} PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
                                                  "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>")
 
-target_link_libraries(${libraryname} PUBLIC idyntree-core idyntree-model idyntree-modelio
+target_link_libraries(${libraryname} PUBLIC idyntree-core idyntree-model idyntree-sensors idyntree-modelio
                                      PRIVATE Eigen3::Eigen)
 
 set_property(TARGET ${libraryname} PROPERTY PUBLIC_HEADER ${IDYNTREE_HIGH_LEVEL_HEADERS})
 
 install(TARGETS ${libraryname}
         EXPORT iDynTree
         COMPONENT runtime
```

### Comparing `idyntree-9.1.1.dev66/src/high-level/include/iDynTree/KinDynComputations.h` & `idyntree-9.1.1.dev7/src/high-level/include/iDynTree/KinDynComputations.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,25 +1,32 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_KINDYNCOMPUTATIONS_H
 #define IDYNTREE_KINDYNCOMPUTATIONS_H
 
 #include <string>
 #include <vector>
 
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/MatrixView.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/Span.h>
-
-#include <iDynTree/Indices.h>
-#include <iDynTree/FreeFloatingMatrices.h>
-#include <iDynTree/LinkState.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixView.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/Span.h>
+
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/FreeFloatingMatrices.h>
+#include <iDynTree/Model/LinkState.h>
 
 namespace iDynTree
 {
 
 class VectorDynSize;
 class MatrixDynSize;
 class Transform;
```

### Comparing `idyntree-9.1.1.dev66/src/high-level/src/KinDynComputations.cpp` & `idyntree-9.1.1.dev7/src/high-level/src/KinDynComputations.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,35 +1,42 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iDynTree/KinDynComputations.h>
 
-#include <iDynTree/ClassicalAcc.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Rotation.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/Wrench.h>
-
-#include <iDynTree/EigenHelpers.h>
-
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/LinkTraversalsCache.h>
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Dynamics.h>
-#include <iDynTree/Jacobians.h>
+#include <iDynTree/Core/ClassicalAcc.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Rotation.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/Wrench.h>
+
+#include <iDynTree/Core/EigenHelpers.h>
+
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/LinkTraversalsCache.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Dynamics.h>
+#include <iDynTree/Model/Jacobians.h>
 
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 #include <cassert>
 #include <iostream>
 #include <fstream>
 
 namespace iDynTree
 {
@@ -2201,15 +2208,15 @@
 
 void KinDynComputations::KinDynComputationsPrivateAttributes::processOnLeftSideBodyFixedCentroidalAvgVelocityJacobian(
     MatrixView<double> jac, const FrameVelocityRepresentation & leftSideRepresentation)
 {
     assert(jac.cols() == m_robot_model.getNrOfDOFs()+6);
 
     // Get the center of mass in the base frame
-    Position vectorFromComToBaseWithRotationOfBase = Position::inverse(this->getRobotLockedInertia().getCenterOfMass());
+    Position vectorFromComToBaseWithRotationOfBase = PositionRaw::inverse(this->getRobotLockedInertia().getCenterOfMass());
 
     Transform newOutputFrame_X_oldOutputFrame;
     if (leftSideRepresentation == BODY_FIXED_REPRESENTATION)
     {
         // oldOutputFrame is B
         // newOutputFrame is G[B]
 
@@ -2235,15 +2242,15 @@
     this->computeRawMassMatrixAndTotalMomentum();
 
     const SpatialInertia & base_lockedInertia = pimpl->getRobotLockedInertia();
     SpatialMomentum base_momentum = pimpl->m_pos.worldBasePos().inverse()*pimpl->m_totalMomentum;
     Twist           base_averageVelocity = base_lockedInertia.applyInverse(base_momentum);
 
     // Get the center of mass in the base frame
-    Position vectorFromComToBaseWithRotationOfBase = Position::inverse(pimpl->getRobotLockedInertia().getCenterOfMass());
+    Position vectorFromComToBaseWithRotationOfBase = PositionRaw::inverse(pimpl->getRobotLockedInertia().getCenterOfMass());
 
     Transform newOutputFrame_X_oldOutputFrame;
     if (pimpl->m_frameVelRepr == BODY_FIXED_REPRESENTATION)
     {
         // oldOutputFrame is B
         // newOutputFrame is G[B]
 
@@ -2383,15 +2390,15 @@
 SpatialMomentum KinDynComputations::getCentroidalTotalMomentum()
 {
     this->computeRawMassMatrixAndTotalMomentum();
 
     SpatialMomentum base_momentum = pimpl->m_pos.worldBasePos().inverse()*pimpl->m_totalMomentum;
 
     // Get the center of mass in the base frame
-    Position vectorFromComToBaseWithRotationOfBase = Position::inverse(pimpl->getRobotLockedInertia().getCenterOfMass());
+    Position vectorFromComToBaseWithRotationOfBase = PositionRaw::inverse(pimpl->getRobotLockedInertia().getCenterOfMass());
 
     Transform newOutputFrame_X_oldOutputFrame;
     if (pimpl->m_frameVelRepr == BODY_FIXED_REPRESENTATION)
     {
         // oldOutputFrame is B
         // newOutputFrame is G[B]
         newOutputFrame_X_oldOutputFrame =  Transform(Rotation::Identity(),vectorFromComToBaseWithRotationOfBase);
```

### Comparing `idyntree-9.1.1.dev66/src/high-level/tests/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/high-level/tests/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/high-level/tests/KinDynComputationsMatrixViewAndSpanUnitTest.cpp` & `idyntree-9.1.1.dev7/src/high-level/tests/KinDynComputationsMatrixViewAndSpanUnitTest.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,28 +1,35 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2020 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "testModels.h"
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <iDynTree/KinDynComputations.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/FreeFloatingState.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
 
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 
 namespace Eigen
 {
     using Vector6d = Eigen::Matrix<double, 6, 1>;
 }
```

### Comparing `idyntree-9.1.1.dev66/src/high-level/tests/KinDynComputationsUnitTest.cpp` & `idyntree-9.1.1.dev7/src/high-level/tests/KinDynComputationsUnitTest.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,31 +1,38 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "testModels.h"
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <iDynTree/KinDynComputations.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/SubModel.h>
-#include <iDynTree/ModelTransformers.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/SubModel.h>
+#include <iDynTree/Model/ModelTransformers.h>
 
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 
 using namespace iDynTree;
 
 double random_double()
 {
     return 1.0*((double)rand()-RAND_MAX/2)/((double)RAND_MAX);
```

### Comparing `idyntree-9.1.1.dev66/src/icub/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/icub/CMakeLists.txt`

 * *Files 18% similar despite different names*

```diff
@@ -1,9 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
+# Copyright (C) Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 SET(iDynTree_ICUB_header include/iDynTree/iKinConversions.h
                          include/iDynTree/iKinConversionsImplementation.h
                          include/iDynTree/skinDynLibConversions.h
                          include/iDynTree/skinDynLibConversionsImplementation.h)
 
 SOURCE_GROUP("Header Files" FILES ${iDynTree_ICUB_header})
```

### Comparing `idyntree-9.1.1.dev66/src/icub/include/iDynTree/iKinConversions.h` & `idyntree-9.1.1.dev7/src/icub/include/iDynTree/iKinConversions.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_IKIN_CONVERSIONS_H
 #define IDYNTREE_IKIN_CONVERSIONS_H
 
 #include <string>
 
 #include <iCub/iKin/iKinFwd.h>
```

### Comparing `idyntree-9.1.1.dev66/src/icub/include/iDynTree/iKinConversionsImplementation.h` & `idyntree-9.1.1.dev7/src/icub/include/iDynTree/iKinConversionsImplementation.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_IKIN_CONVERSIONS_IMPLEMENTATION_H
 #define IDYNTREE_IKIN_CONVERSIONS_IMPLEMENTATION_H
 
 #include <iDynTree/iKinConversions.h>
-#include <iDynTree/DenavitHartenberg.h>
+#include <iDynTree/Model/DenavitHartenberg.h>
 
-#include <iDynTree/YARPConversions.h>
+#include <iDynTree/yarp/YARPConversions.h>
 
 #include <iCub/iKin/iKinFwd.h>
 
 #include <cassert>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/icub/include/iDynTree/skinDynLibConversions.h` & `idyntree-9.1.1.dev7/src/icub/include/iDynTree/skinDynLibConversions.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SKINDYNLIB_CONVERSIONS_H
 #define IDYNTREE_SKINDYNLIB_CONVERSIONS_H
 
 #include <map>
 #include <string>
 
-#include <iDynTree/Indices.h>
-#include <iDynTree/ExternalWrenchesEstimation.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Estimation/ExternalWrenchesEstimation.h>
 
 #include <iCub/skinDynLib/dynContactList.h>
 #include <iCub/skinDynLib/skinContactList.h>
 
 namespace iDynTree
 {
 class Model;
```

### Comparing `idyntree-9.1.1.dev66/src/icub/include/iDynTree/skinDynLibConversionsImplementation.h` & `idyntree-9.1.1.dev7/src/icub/include/iDynTree/skinDynLibConversionsImplementation.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SKINDYNLIB_CONVERSIONS_IMPLEMENTATION_H
 #define IDYNTREE_SKINDYNLIB_CONVERSIONS_IMPLEMENTATION_H
 
 #include <iDynTree/skinDynLibConversions.h>
 
-#include <iDynTree/Position.h>
-#include <iDynTree/Wrench.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Wrench.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/ContactWrench.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/ContactWrench.h>
 
-#include <iDynTree/YARPConversions.h>
+#include <iDynTree/yarp/YARPConversions.h>
 
 #include <cassert>
 
 namespace iDynTree
 {
 
 inline bool skinDynLibConversionsHelper::addSkinDynLibAlias(const Model& model, const std::string iDynTree_link_name, const std::string iDynTree_frame_name,
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/inverse-kinematics/CMakeLists.txt`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,7 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
 set(libraryname idyntree-inverse-kinematics)
 
 set(IDYN_TREE_IK_SOURCES src/ConvexHullHelpers.cpp
                          src/BoundingBoxHelpers.cpp
                          src/InverseKinematics.cpp)
 set(IDYN_TREE_IK_HEADERS include/iDynTree/ConvexHullHelpers.h
                          include/iDynTree/BoundingBoxHelpers.h
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/include/iDynTree/BoundingBoxHelpers.h` & `idyntree-9.1.1.dev7/src/inverse-kinematics/include/iDynTree/BoundingBoxHelpers.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*!
+ * @file  BoundingBoxHelpers.h
+ * @author Jorhabib Eljaik
+ * @copyright 2018 iCub Facility - Istituto Italiano di Tecnologia
+ *            Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ * @date 2018
+ *
+ */
+
 
 #ifndef IDYNTREE_BOUNDINGBOXHELPERS_H
 #define IDYNTREE_BOUNDINGBOXHELPERS_H
 
 #include <string>
 #include <vector>
 
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/VectorDynSize.h>
 #include <iDynTree/ConvexHullHelpers.h>
 
 namespace iDynTree
 {
     /**
      * BoundingBoxProjectionConstraint helper.
      *
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/include/iDynTree/ConvexHullHelpers.h` & `idyntree-9.1.1.dev7/src/inverse-kinematics/include/iDynTree/ConvexHullHelpers.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef IDYNTREE_CONVEXHULLHELPERS_H
 #define IDYNTREE_CONVEXHULLHELPERS_H
 
 #include <string>
 #include <vector>
 
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Position.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
 
 namespace iDynTree
 {
     /**
      * Class representing a 2D Polygon expressed in the 3D space.
      *
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/include/iDynTree/InverseKinematics.h` & `idyntree-9.1.1.dev7/src/inverse-kinematics/include/iDynTree/InverseKinematics.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef IDYNTREE_INVERSEKINEMATICS_H
 #define IDYNTREE_INVERSEKINEMATICS_H
 
 #include <string>
 #include <vector>
 
 #include <iDynTree/ConvexHullHelpers.h>
-#include <iDynTree/Direction.h>
+#include <iDynTree/Core/Direction.h>
 
 namespace iDynTree {
     class VectorDynSize;
     class Transform;
     class Position;
     class Rotation;
     class Model;
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/include/private/InverseKinematicsData.h` & `idyntree-9.1.1.dev7/src/inverse-kinematics/include/private/InverseKinematicsData.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_INTERNAL_INVERSEKINEMATICSDATA_H
 #define IDYNTREE_INTERNAL_INVERSEKINEMATICSDATA_H
 
 #include "InverseKinematicsNLP.h"
 #include <iDynTree/ConvexHullHelpers.h>
 #include <iDynTree/InverseKinematics.h>
 
 #include <iDynTree/KinDynComputations.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Twist.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Twist.h>
 
 #include <IpIpoptApplication.hpp>
 
 
 #include <vector>
 #include <map>
 #include <unordered_map>
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/include/private/InverseKinematicsNLP.h` & `idyntree-9.1.1.dev7/src/inverse-kinematics/include/private/InverseKinematicsNLP.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_INTERNAL_INVERSEKINEMATICSNLP_H
 #define IDYNTREE_INTERNAL_INVERSEKINEMATICSNLP_H
 
 #include <IpTNLP.hpp>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/Transform.h>
 
 #include <map>
 
 // use expression as sub-expression,
 // then make type of full expression int, discard result
 #define UNUSED_VARIABLE(x) (void)(sizeof((x), 0))
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/include/private/TransformConstraint.h` & `idyntree-9.1.1.dev7/src/inverse-kinematics/include/private/TransformConstraint.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_INTERNAL_TRANSFORM_CONSTRAINT_H
 #define IDYNTREE_INTERNAL_TRANSFORM_CONSTRAINT_H
 
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/Transform.h>
 #include <iDynTree/InverseKinematics.h>
 
 namespace internal {
     namespace kinematics {
         class TransformConstraint;
     }
 }
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/src/BoundingBoxHelpers.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/src/BoundingBoxHelpers.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*!
+ * @file  BoundingBoxHelpers.cpp
+ * @author Jorhabib Eljaik
+ * @copyright 2018 iCub Facility - Istituto Italiano di Tecnologia
+ *            Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ * @date 2017
+ */
 
 #include <iDynTree/BoundingBoxHelpers.h>
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <Eigen/Core>
 
 #include <algorithm>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/src/ConvexHullHelpers.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/src/ConvexHullHelpers.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iDynTree/ConvexHullHelpers.h>
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <Eigen/Core>
 
 #include <algorithm>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/src/InverseKinematics.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/src/InverseKinematics.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iDynTree/InverseKinematics.h>
 #ifdef IDYNTREE_USES_IPOPT
 #include "InverseKinematicsData.h"
 #include "TransformConstraint.h"
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/Direction.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cassert>
 #include <iostream>
 
 // TODO: directly access the raw data, thus removing the methods in IKData class
 #define IK_PIMPL(x) static_cast<internal::kinematics::InverseKinematicsData*>((x))
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/src/InverseKinematicsData.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/src/InverseKinematicsData.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "InverseKinematicsData.h"
 #include "InverseKinematicsNLP.h"
 #include "TransformConstraint.h"
-#include <iDynTree/Axis.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/ClassicalAcc.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/ClassicalAcc.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cassert>
 #include <private/InverseKinematicsData.h>
 
 namespace internal {
 namespace kinematics {
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/src/InverseKinematicsNLP.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/src/InverseKinematicsNLP.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,22 +1,29 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 //For using the M_PI macro in visual studio it
 //is necessary to define _USE_MATH_DEFINES
 #ifndef _USE_MATH_DEFINES
 #define _USE_MATH_DEFINES
 #endif
 
 #include "InverseKinematicsNLP.h"
 
 #include "InverseKinematicsData.h"
 #include "TransformConstraint.h"
 
 #include <Eigen/Core>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <cassert>
 #include <cmath>
 
 
 namespace internal {
 namespace kinematics {
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/src/TransformConstraint.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/src/TransformConstraint.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "TransformConstraint.h"
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/Transform.h>
 
 namespace internal {
 namespace kinematics {
 
     TransformConstraint::TransformConstraint(const std::string& constrainedFrameName,
                                              TransformConstraintType type)
     : m_type(type)
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/tests/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/inverse-kinematics/tests/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/tests/ConvexHullHelpersUnitTest.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/tests/ConvexHullHelpersUnitTest.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iDynTree/ConvexHullHelpers.h>
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/TestUtils.h>
 
 void testConvexHullProjectionConstraint()
 {
     // Check that given an "easy" problem the constraint works fine
     iDynTree::ConvexHullProjectionConstraint projectionConstraint;
 
     // Add a nice big square convex hull
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/tests/InverseKinematicsMatrixViewAndSpanUnitTest.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/tests/InverseKinematicsMatrixViewAndSpanUnitTest.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iDynTree/InverseKinematics.h>
 #include <iDynTree/KinDynComputations.h>
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/ModelTestUtils.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/ModelTestUtils.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 #include "testModels.h"
 
 #include <cmath>
 #include <cstdio>
 #include <cstdlib>
 #include <ctime>
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/tests/InverseKinematicsUnitTest.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/tests/InverseKinematicsUnitTest.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iDynTree/InverseKinematics.h>
 #include <iDynTree/KinDynComputations.h>
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/ModelTestUtils.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/ModelTestUtils.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 #include "testModels.h"
 
 #include <cmath>
 #include <cstdio>
 #include <cstdlib>
 #include <ctime>
```

### Comparing `idyntree-9.1.1.dev66/src/inverse-kinematics/tests/iKinVersusLegacyTest.cpp` & `idyntree-9.1.1.dev7/src/inverse-kinematics/tests/iKinVersusLegacyTest.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,27 +1,34 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iDynTree/InverseKinematics.h>
 #include <yarp/os/ResourceFinder.h>
 #include <yarp/os/Network.h>
 #include <yarp/os/LogStream.h>
 #include <string>
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/Transform.h>
 #include <iCub/iKin/iKinIpOpt.h>
 #include <iCub/iKin/iKinFwd.h>
 
 
 using namespace yarp::os;
 using namespace iCub::iKin;
 using namespace yarp::sig;
 using namespace yarp::math;
 
 #include <Eigen/Core>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 int main(int argc, char **argv) {
 
     ResourceFinder finder = ResourceFinder::getResourceFinderSingleton();
     finder.configure(argc, argv);
     finder.setVerbose(false);
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/AccelerometerSensor.h` & `idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/AccelerometerSensor.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,32 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef ACCELEROMETER_HPP
 #define ACCELEROMETER_HPP
 
-#include <iDynTree/GeomVector3.h>
+#include <iDynTree/Core/GeomVector3.h>
 
 namespace iDynTree
 {
     class Transform;
     typedef LinearMotionVector3 LinAcceleration;
     class SpatialAcc;
     class Twist;
 }
 
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 namespace iDynTree {
 
     /**
      * Interface to the Accelerometer class.
      *
      * An implementation of the Accelerometer Sensor
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/Centroidal.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Centroidal.h`

 * *Files 25% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_CENTROIDAL_H
 #define IDYNTREE_CENTROIDAL_H
 
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Indices.h>
 
 namespace iDynTree
 {
     class Model;
     class Traversal;
     class Transform;
     class FreeFloatingPos;
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/ContactWrench.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/ContactWrench.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_CONTACT_WRENCH_H
 #define IDYNTREE_CONTACT_WRENCH_H
 
-#include <iDynTree/Position.h>
-#include <iDynTree/Wrench.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/Wrench.h>
 
-#include <iDynTree/Indices.h>
-#include <iDynTree/LinkState.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/LinkState.h>
 
 
 #include <vector>
 
 namespace iDynTree
 {
     class Model;
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/DenavitHartenberg.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/DenavitHartenberg.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_DENAVIT_HARTENBERG_H
 #define IDYNTREE_DENAVIT_HARTENBERG_H
 
-#include <iDynTree/Indices.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/Model.h>
 
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/Transform.h>
 
 #include <vector>
 
 namespace iDynTree
 {
 
 /**
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/Dynamics.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Dynamics.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_INVERSE_DYNAMICS_H
 #define IDYNTREE_INVERSE_DYNAMICS_H
 
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 
-#include <iDynTree/Indices.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/JointState.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/JointState.h>
 
 namespace iDynTree
 {
     class Model;
     class Traversal;
     class FreeFloatingPos;
     class FreeFloatingVel;
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/DynamicsLinearization.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/DynamicsLinearization.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_DYNAMICS_LINEARIZATION_H
 #define IDYNTREE_DYNAMICS_LINEARIZATION_H
 
-#include <iDynTree/MatrixFixSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixFixSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 
-#include <iDynTree/Dynamics.h>
-#include <iDynTree/DynamicsLinearizationHelpers.h>
+#include <iDynTree/Model/Dynamics.h>
+#include <iDynTree/Model/DynamicsLinearizationHelpers.h>
 
 namespace iDynTree
 {
     /**
      * Structure containing the internal buffers used
      * by the ForwardDynamicsLinearization function.
      */
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/DynamicsLinearizationHelpers.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/DynamicsLinearizationHelpers.h`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_DYNAMICS_LINEARIZATION_HELPERS_H
 #define IDYNTREE_DYNAMICS_LINEARIZATION_HELPERS_H
 
-#include <iDynTree/MatrixFixSize.h>
+#include <iDynTree/Core/MatrixFixSize.h>
 
-#include <iDynTree/Dynamics.h>
+#include <iDynTree/Model/Dynamics.h>
 
 namespace iDynTree
 {
     /**
      * Class representing the derivative
      * of a spatial motion vector with respect to
      * another spatial motion vector.
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/FixedJoint.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/FixedJoint.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_FIXED_JOINT_H
 #define IDYNTREE_FIXED_JOINT_H
 
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/Transform.h>
 
-#include <iDynTree/Indices.h>
-#include <iDynTree/IJoint.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/IJoint.h>
 
 namespace iDynTree
 {
     /**
      * Class representing a fixed joint, i.e. a joint that rigidly attaches two links.
      *
      * \ingroup iDynTreeModel
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/ForwardKinematics.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/ForwardKinematics.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_FORWARD_KINEMATICS_H
 #define IDYNTREE_FORWARD_KINEMATICS_H
 
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Indices.h>
 
 namespace iDynTree
 {
     class Model;
     class Traversal;
     class Transform;
     class FreeFloatingPos;
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/FreeFloatingMatrices.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/FreeFloatingMatrices.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_FREE_FLOATING_MATRICES_H
 #define IDYNTREE_FREE_FLOATING_MATRICES_H
 
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 
 namespace iDynTree
 {
 
 class Model;
 
 /**
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/FreeFloatingState.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/FreeFloatingState.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_FREE_FLOATING_STATE_H
 #define IDYNTREE_FREE_FLOATING_STATE_H
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/VectorDynSize.h>
-
-#include <iDynTree/Indices.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/JointState.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/VectorDynSize.h>
+
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/JointState.h>
 
 #include <vector>
 
 namespace iDynTree
 {
     class Model;
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/GyroscopeSensor.h` & `idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/GyroscopeSensor.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,23 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef GYROSCOPE_HPP
 #define GYROSCOPE_HPP
 
-#include <iDynTree/GeomVector3.h>
+#include <iDynTree/Core/GeomVector3.h>
 
 namespace iDynTree
 {
     class Transform;
     typedef AngularMotionVector3 AngVelocity;
 }
 
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Sensors/Sensors.h>
 #include <vector>
 
 namespace iDynTree {
 
     /**
      * Interface to the Gyroscope class.
      *
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/IJoint.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/IJoint.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_I_JOINT_H
 #define IDYNTREE_I_JOINT_H
 
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Indices.h>
 
 namespace iDynTree
 {
     class LinkPositions;
     class LinkVelArray;
     class LinkAccArray;
     class Transform;
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/Indices.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Indices.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_INDICES_H
 #define IDYNTREE_INDICES_H
 
 #include <cstddef>
 #include <string>
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/JointState.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/JointState.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_JOINT_STATE_H
 #define IDYNTREE_JOINT_STATE_H
 
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/SpatialForceVector.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/SpatialForceVector.h>
 
 #include <vector>
 
 namespace iDynTree
 {
     class Model;
     class SpatialMotionVector;
@@ -25,15 +32,14 @@
         JointPosDoubleArray(std::size_t nrOfDOFs = 0);
         JointPosDoubleArray(const iDynTree::Model & model);
 
         void resize(std::size_t nrOfDOFs);
         void resize(const iDynTree::Model & model);
 
         bool isConsistent(const iDynTree::Model & model) const;
-        JointPosDoubleArray& operator=(const iDynTree::VectorDynSize& input);
 
         ~JointPosDoubleArray();
     };
 
     /**
      * Class for storing a vector of scalar values,
      *  one for each internal coordinate in a model.
@@ -44,15 +50,14 @@
         JointDOFsDoubleArray(std::size_t nrOfDOFs = 0);
         JointDOFsDoubleArray(const iDynTree::Model & model);
 
         void resize(std::size_t nrOfDOFs);
         void resize(const iDynTree::Model & model);
 
         bool isConsistent(const iDynTree::Model & model) const;
-        JointDOFsDoubleArray& operator=(const iDynTree::VectorDynSize& input);
 
         ~JointDOFsDoubleArray();
     };
 
     /**
      * Class for storing a vector of spatial force vectors,
      *  one for each dof in a model.
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/Link.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Link.h`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_LINK_H
 #define IDYNTREE_LINK_H
 
-#include <iDynTree/SpatialInertia.h>
+#include <iDynTree/Core/SpatialInertia.h>
 
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Indices.h>
 
 
 namespace iDynTree
 {
 
     /**
      * Class that represents a link.
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/LinkState.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/LinkState.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_LINK_STATE_H
 #define IDYNTREE_LINK_STATE_H
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/Twist.h>
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/Wrench.h>
-#include <iDynTree/ArticulatedBodyInertia.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/Twist.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/Wrench.h>
+#include <iDynTree/Core/ArticulatedBodyInertia.h>
 
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Indices.h>
 
 #include <vector>
 
 namespace iDynTree
 {
     class Model;
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/LinkTraversalsCache.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/LinkTraversalsCache.h`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODEL_LINKTRAVERSALSCACHE_H
 #define IDYNTREE_MODEL_LINKTRAVERSALSCACHE_H
 
 #include <vector>
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Indices.h>
 
 namespace iDynTree {
     class Traversal;
     class Model;
     
     class LinkTraversalsCache;
 }
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/Model.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Model.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODEL_H
 #define IDYNTREE_MODEL_H
 
-#include <iDynTree/IJoint.h>
-#include <iDynTree/Link.h>
-#include <iDynTree/Transform.h>
-
-#include <iDynTree/Indices.h>
-#include <iDynTree/Sensors.h>
-#include <iDynTree/SolidShapes.h>
+#include <iDynTree/Model/IJoint.h>
+#include <iDynTree/Model/Link.h>
+#include <iDynTree/Core/Transform.h>
+
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/SolidShapes.h>
 
 #include <cstdlib>
 #include <string>
 #include <vector>
 
 namespace iDynTree
 {
@@ -133,19 +139,14 @@
 
         /**
          * Solid shapes used for collision checking.
          */
         ModelSolidShapes m_collisionSolidShapes;
 
         /**
-         * Sensors associated to the model.
-         */
-        SensorsList m_sensors;
-
-        /**
          * Copy the structure of the model from another instance of a model.
          */
         void copy(const Model & model);
 
         /**
          * Destroy the object, properly deallocating memory.
          */
@@ -566,40 +567,19 @@
          * Get the ModelSolidShapes meant for collision checking (const version)
          *
          * @return a reference to ModelSolidShapes meant for visualization.
          */
         const ModelSolidShapes& collisionSolidShapes() const;
 
         /**
-         * Get the (mutable) sensors associated with the model.
-         *
-         * @return a (mutable) reference to SensorsList associated with the model.
-         */
-        SensorsList& sensors();
-
-        /**
-         * Get the (const) sensors associated with the model.
-         *
-         * @return a (const) reference to SensorsList associated with the model.
-         */
-        const SensorsList& sensors() const;
-
-        /**
          * \brief Get a printable representation of the Model.
          *
          * Useful for debugging.
          */
         std::string toString() const;
 
-        /**
-         * \brief Check if the model is valid.
-         *
-         * Useful for debugging.
-         */
-        bool isValid() const;
-
     };
 
 
 }
 
 #endif /* IDYNTREE_LINK_H */
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/ModelTestUtils.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/ModelTestUtils.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,29 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODEL_TEST_UTILS_H
 #define IDYNTREE_MODEL_TEST_UTILS_H
 
 
-#include <iDynTree/Model.h>
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/PrismaticJoint.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/LinkState.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/Model/PrismaticJoint.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/LinkState.h>
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <cassert>
 #include "IJoint.h"
 
 namespace iDynTree
 {
 
@@ -29,15 +36,15 @@
                                   0.0,cxx+czz,0.0,
                                   0.0,0.0,cxx+cyy};
 
     Rotation rot = Rotation::RPY(getRandomDouble(),getRandomDouble(-1,1),getRandomDouble());
 
     SpatialInertia inertiaLink(getRandomDouble(0,4),
                                Position(getRandomDouble(-2,2),getRandomDouble(-2,2),getRandomDouble(-2,2)),
-                               rot*RotationalInertia(rotInertiaData,3,3));
+                               rot*RotationalInertiaRaw(rotInertiaData,3,3));
 
     Link link;
 
     link.setInertia(inertiaLink);
 
     return link;
 }
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/ModelTransformers.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/ModelTransformers.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 /**
  * \file ModelTransformers.h
  *  \brief Collection of function to modify model in various ways
  *
  *
  *  In this file a series of functions for transforming Model
@@ -32,16 +39,14 @@
  *  * The link is connected to its only neighbor with a fixed joint.
  *
  * Once a "fake link" has been identified to respect this two conditions,
  * it and the joint that it connects it to its only neighbor is not copied
  * to the output model, but a frame with the same name of the "fake link"
  * and with the same transform is added to the model.
  *
- * @warning This function does not handle SensorsList contained inside the input model.
- * 
  * \note The definition of "fake link" used in this function excludes
  *       the case in which two fake links are attached to one another.
  *
  */
 bool removeFakeLinks(const Model& modelWithFakeLinks,
                      Model& modelWithoutFakeLinks);
 
@@ -71,16 +76,14 @@
  * the fixed joints are also added with the same criteria, but applied to fixed joints.
  *
  * @note This method make sure that the non-fixed joint in the model have a "regular numbering"
  *       as described in Featherstone "Rigid Body Dynamics Algorithm", section 4.1.2 . Note that
  *       this numbering is not required by any algorithm in iDynTree, but it may be useful for
  *       example to ensure that for a chain model the joint numbering is the one induced by the
  *       kinematic structure.
- * 
- * @warning This function does not handle SensorsList contained inside the input model.
  *
  * @return true if all went well, false if there was an error in conversion.
  */
 bool createModelWithNormalizedJointNumbering(const Model& model,
                                              const std::string& baseForNormalizedJointNumbering,
                                              Model& reducedModel);
 
@@ -89,17 +92,14 @@
  * Extract sub model from sub model traversal.
  *
  * This function creates a new iDynTree::Model containing links and joints composing the subModelTraversal.
  * The function takes in input a iDynTree::Model and a iDynTree::Traversal. The new model will contain joints
  * and links composing the subModelTraversal, with the same order.
  * The FT sensor frames are added as additional frames.
  *
- * @warning This function does not handle SensorsList contained inside the input model.
- *
- *
  * @return true if all went well, false if there was an error in creating the sub model.
  */
 bool extractSubModel(const iDynTree::Model& fullModel, const iDynTree::Traversal& subModelTraversal,
                      iDynTree::Model& outputSubModel);
 
 }
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/MovableJointImpl.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/MovableJointImpl.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MOVABLE_JOINT_IMPL_H
 #define IDYNTREE_MOVABLE_JOINT_IMPL_H
 
 
 
-#include <iDynTree/IJoint.h>
+#include <iDynTree/Model/IJoint.h>
 
 
 namespace iDynTree
 {
     /**
      * Base template for implementation of non-fixed joints.
      * A specific joint can be derived from an instantiation of this template.
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/PrismaticJoint.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/PrismaticJoint.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_PRISMATIC_JOINT_H
 #define IDYNTREE_PRISMATIC_JOINT_H
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/SpatialMotionVector.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/Indices.h>
-#include <iDynTree/MovableJointImpl.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/MovableJointImpl.h>
 
 namespace iDynTree
 {
     /**
      * Class representing a prismatic joint, i.e. a joint that
      * constraint two links to translate only along an axis.
      *
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/RevoluteJoint.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/RevoluteJoint.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_REVOLUTE_JOINT_H
 #define IDYNTREE_REVOLUTE_JOINT_H
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/SpatialMotionVector.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/Indices.h>
-#include <iDynTree/MovableJointImpl.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/MovableJointImpl.h>
 
 namespace iDynTree
 {
     /**
      * Class representing a revolute joint, i.e. a joint that
      * constraint two links to move only around a common axis.
      *
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/Sensors.h` & `idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/Sensors.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,31 +1,37 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_CORE_SENSORS_HPP
 #define IDYNTREE_CORE_SENSORS_HPP
 
-#include <iDynTree/GeomVector3.h>
+#include <iDynTree/Core/GeomVector3.h>
 
 
 namespace iDynTree {
-    class Model;
     class Wrench;
     typedef LinearMotionVector3 LinAcceleration;
     typedef AngularMotionVector3 AngVelocity;
 }
 
 #include <string>
 #include <vector>
 #include <iterator>
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Indices.h>
 
 namespace iDynTree {
 
     enum SensorType
     {
         SIX_AXIS_FORCE_TORQUE = 0,
         ACCELEROMETER = 1,
@@ -214,15 +220,15 @@
         /**
          * Return the transform that applied on a element
          * expressed in sensor frames it transform it
          * in one expressed in the link frame (\f[ {}^l H_s \f]).
          *
          * @return the link_H_sensor transform
          */
-        virtual iDynTree::Transform getLinkSensorTransform() const = 0;
+        virtual Transform getLinkSensorTransform() const = 0;
 
         /**
          * Set the name of the parent Link.
          */
         virtual bool setParentLink(const std::string & parentLinkName) = 0;
 
         /**
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/SixAxisForceTorqueSensor.h` & `idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/SixAxisForceTorqueSensor.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,33 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef IDYNTREE_SIX_AXIS_FORCE_TORQUE_H
 #define IDYNTREE_SIX_AXIS_FORCE_TORQUE_H
 
 namespace iDynTree
 {
     class Transform;
     class Wrench;
     class Traversal;
     class Model;
 }
 
 
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Sensors/Sensors.h>
 
-#include <iDynTree/LinkState.h>
+#include <iDynTree/Model/LinkState.h>
 
 #include <vector>
 
 namespace iDynTree {
 
 
     /**
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/SolidShapes.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/SolidShapes.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SOLID_SHAPES_H
 #define IDYNTREE_SOLID_SHAPES_H
 
 #include <cstdlib>
 #include <string>
 #include <vector>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Indices.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Model/Indices.h>
 
 namespace iDynTree
 {
     class Material {
     public:
         explicit Material();
         explicit Material(const std::string& name);
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/SubModel.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/SubModel.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,33 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_SUB_MODEL_H
 #define IDYNTREE_SUB_MODEL_H
 
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Indices.h>
 
 #include <vector>
 #include <string>
 #include <cstddef>
 
 namespace iDynTree
 {
     class Model;
     class Traversal;
     class JointPosDoubleArray;
     class LinkPositions;
+    class IRawVector;
 
     /**
      * Class representing the decomposition in one model in several submodels.
      *
      * This class is used in algorithms, such as estimation of external wrenches,
      * where a complete model is decomposed in several submodels.
      *
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/ThreeAxisAngularAccelerometerSensor.h` & `idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,32 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef THREE_AXIS_ANGULAR_ACCELEROMETER_H
 #define THREE_AXIS_ANGULAR_ACCELEROMETER_H
 
-#include <iDynTree/GeomVector3.h>
+#include <iDynTree/Core/GeomVector3.h>
 
 namespace iDynTree
 {
     class Transform;
     typedef LinearMotionVector3 LinAcceleration;
     class SpatialAcc;
     class Twist;
 }
 
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 namespace iDynTree {
 
     /**
      * Class representing a three axis angular accelerometer, i.e. a sensor that measures
      * the 3D angular acceleration of the sensor frame.
      *
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/ThreeAxisForceTorqueContactSensor.h` & `idyntree-9.1.1.dev7/src/sensors/include/iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,25 +1,32 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #ifndef THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR_H
 #define THREE_AXIS_FORCE_TORQUE_CONTACT_SENSOR_H
 
-#include <iDynTree/GeomVector3.h>
+#include <iDynTree/Core/GeomVector3.h>
 
 namespace iDynTree
 {
     class Transform;
     typedef LinearMotionVector3 LinAcceleration;
     class SpatialAcc;
     class Twist;
 }
 
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 namespace iDynTree {
 
     /**
      * Class representing a three axis force-torque contact sensor.
      *
      * It is meant to represent sole sensor composed of a array of uniaxial
```

### Comparing `idyntree-9.1.1.dev66/src/model/include/iDynTree/Traversal.h` & `idyntree-9.1.1.dev7/src/model/include/iDynTree/Model/Traversal.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_TRAVERSAL_H
 #define IDYNTREE_TRAVERSAL_H
 
-#include <iDynTree/Indices.h>
+#include <iDynTree/Model/Indices.h>
 
 #include <vector>
 
 namespace iDynTree
 {
     class IJoint;
     class Link;
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/AccelerometerSensor.cpp` & `idyntree-9.1.1.dev7/src/sensors/src/AccelerometerSensor.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,20 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include "iDynTree/AccelerometerSensor.h"
+#include "iDynTree/Sensors/AccelerometerSensor.h"
 
-#include "iDynTree/Transform.h"
-
-#include "iDynTree/SpatialAcc.h"
-#include "iDynTree/Twist.h"
-
-#include "iDynTree/Model.h"
+#include "iDynTree/Core/Transform.h"
 
+#include "iDynTree/Core/SpatialAcc.h"
+#include "iDynTree/Core/Twist.h"
 
 namespace iDynTree {
 
 struct AccelerometerSensor::AccelerometerPrivateAttributes
 {
     // Name/id of the sensor
     std::string name;
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/ContactWrench.cpp` & `idyntree-9.1.1.dev7/src/model/src/ContactWrench.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/Model.h>
-#include <iDynTree/ContactWrench.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/ContactWrench.h>
 
 namespace iDynTree
 {
 
 Position& ContactWrench::contactPoint()
 {
     return m_contactPoint;
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/DenavitHartenberg.cpp` & `idyntree-9.1.1.dev7/src/model/src/DenavitHartenberg.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/DenavitHartenberg.h>
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/FreeFloatingState.h>
+#include <iDynTree/Model/DenavitHartenberg.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 
 namespace iDynTree
 {
 
 void DHChain::setNrOfDOFs(size_t nDofs)
 {
@@ -734,15 +741,15 @@
 bool CreateModelFromDHChain(const DHChain& inputChain,
                                   Model& outputModel)
 {
     // First we clear the model
     outputModel = Model();
 
     // All the inertial will be of one kg in the origin
-    iDynTree::SpatialInertia inertiaDefault(1.0,Position::Zero(),RotationalInertia::Zero());
+    iDynTree::SpatialInertia inertiaDefault(1.0,Position::Zero(),RotationalInertiaRaw::Zero());
     iDynTree::Link linkDefault;
     linkDefault.setInertia(inertiaDefault);
 
     std::string baseLinkName  = "link0";
 
 
     // Then we create a base link
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/Dynamics.cpp` & `idyntree-9.1.1.dev7/src/model/src/Dynamics.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,26 +1,33 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/FreeFloatingMatrices.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/JointState.h>
+
+#include <iDynTree/Core/ArticulatedBodyInertia.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/SpatialMomentum.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/FreeFloatingMatrices.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/JointState.h>
-
-#include <iDynTree/ArticulatedBodyInertia.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/SpatialMomentum.h>
-#include <iDynTree/EigenHelpers.h>
-
-#include <iDynTree/Dynamics.h>
+#include <iDynTree/Model/Dynamics.h>
 
 #include <Eigen/Core>
 
 namespace iDynTree
 {
 
 bool ComputeLinearAndAngularMomentum(const Model& model,
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/DynamicsLinearization.cpp` & `idyntree-9.1.1.dev7/src/model/src/DynamicsLinearization.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 
-#include <iDynTree/DynamicsLinearization.h>
+#include <iDynTree/Model/DynamicsLinearization.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
 
-#include <iDynTree/FreeFloatingState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/TransformDerivative.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/TransformDerivative.h>
 
 #include <Eigen/Core>
 
 namespace iDynTree
 {
 
 ForwardDynamicsLinearizationInternalBuffers::ForwardDynamicsLinearizationInternalBuffers(const Model& model)
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/DynamicsLinearizationHelpers.cpp` & `idyntree-9.1.1.dev7/src/model/src/DynamicsLinearizationHelpers.cpp`

 * *Files 17% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/DynamicsLinearizationHelpers.h>
+#include <iDynTree/Model/DynamicsLinearizationHelpers.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree
 {
 
 SpatialForceWrtMotionDerivative SpatialForceWrtMotionDerivative::operator*(const Transform& a_X_b)
 {
     SpatialForceWrtMotionDerivative ret;
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/FixedJoint.cpp` & `idyntree-9.1.1.dev7/src/model/src/FixedJoint.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/SpatialMotionVector.h>
-#include <iDynTree/TransformDerivative.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
+#include <iDynTree/Core/TransformDerivative.h>
+#include <iDynTree/Core/Utils.h>
 
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/LinkState.h>
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/LinkState.h>
 
 #include <cassert>
 
 namespace iDynTree
 {
 
 FixedJoint::FixedJoint()
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/ForwardKinematics.cpp` & `idyntree-9.1.1.dev7/src/model/src/ForwardKinematics.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/ForwardKinematics.h>
+#include <iDynTree/Model/ForwardKinematics.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
 
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/LinkState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/LinkState.h>
 
 namespace iDynTree
 {
 
 bool ForwardPositionKinematics(const Model& model,
                                const Traversal& traversal,
                                const FreeFloatingPos& robotPosition,
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/FreeFloatingMatrices.cpp` & `idyntree-9.1.1.dev7/src/model/src/FreeFloatingMatrices.cpp`

 * *Files 11% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/FreeFloatingMatrices.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/FreeFloatingMatrices.h>
+#include <iDynTree/Model/Model.h>
 
 #include <cassert>
 
 namespace iDynTree
 {
 
 FrameFreeFloatingJacobian::FrameFreeFloatingJacobian(size_t nrOfDofs): MatrixDynSize(6,6+nrOfDofs)
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/FreeFloatingState.cpp` & `idyntree-9.1.1.dev7/src/model/src/FreeFloatingState.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/Model.h>
 
 #include <cassert>
 
 namespace iDynTree
 {
 FreeFloatingPos::FreeFloatingPos()
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/GyroscopeSensor.cpp` & `idyntree-9.1.1.dev7/src/sensors/src/GyroscopeSensor.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include "iDynTree/GyroscopeSensor.h"
-#include "iDynTree/Transform.h"
-#include "iDynTree/Wrench.h"
-#include "iDynTree/Twist.h"
-#include <iDynTree/Model.h>
+#include "iDynTree/Sensors/GyroscopeSensor.h"
+#include "iDynTree/Core/Transform.h"
+#include "iDynTree/Core/Wrench.h"
+#include "iDynTree/Core/Twist.h"
 
 
 namespace iDynTree {
 
 struct GyroscopeSensor::GyroscopePrivateAttributes
 {
     // Name/id of the sensor
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/Jacobians.cpp` & `idyntree-9.1.1.dev7/src/model/src/Jacobians.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-
-#include <iDynTree/Jacobians.h>
-
-#include <iDynTree/EigenHelpers.h>
-
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/LinkState.h>
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+
+#include <iDynTree/Model/Jacobians.h>
+
+#include <iDynTree/Core/EigenHelpers.h>
+
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/LinkState.h>
 
 namespace iDynTree
 {
 
 bool FreeFloatingJacobianUsingLinkPos(const Model& model,
                                       const Traversal& traversal,
                                       const JointPosDoubleArray& jointPositions,
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/JointState.cpp` & `idyntree-9.1.1.dev7/src/model/src/JointState.cpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/JointState.h>
+#include <iDynTree/Model/JointState.h>
 
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Model.h>
 
-#include <iDynTree/SpatialMotionVector.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
 
 namespace iDynTree
 {
 
 JointPosDoubleArray::JointPosDoubleArray(std::size_t nrOfPosCoords): VectorDynSize(nrOfPosCoords)
 {
 
@@ -32,21 +39,14 @@
 }
 
 bool JointPosDoubleArray::isConsistent(const Model& model) const
 {
     return (this->size() == model.getNrOfPosCoords());
 }
 
-JointPosDoubleArray& JointPosDoubleArray::operator=(const iDynTree::VectorDynSize& input)
-{
-    iDynTree::VectorDynSize* thisUpCast = static_cast<iDynTree::VectorDynSize*>(this);
-    *thisUpCast = input;
-    return *this;
-}
-
 JointPosDoubleArray::~JointPosDoubleArray()
 {
 
 }
 
 
 JointDOFsDoubleArray::JointDOFsDoubleArray(std::size_t nrOfDOFs): VectorDynSize(nrOfDOFs)
@@ -71,21 +71,14 @@
 }
 
 bool JointDOFsDoubleArray::isConsistent(const Model& model) const
 {
     return (this->size() == model.getNrOfDOFs());
 }
 
-JointDOFsDoubleArray& JointDOFsDoubleArray::operator=(const iDynTree::VectorDynSize& input)
-{
-    iDynTree::VectorDynSize* thisUpCast = static_cast<iDynTree::VectorDynSize*>(this);
-    *thisUpCast = input;
-    return *this;
-}
-
 JointDOFsDoubleArray::~JointDOFsDoubleArray()
 {
 
 }
 
 DOFSpatialForceArray::DOFSpatialForceArray(std::size_t nrOfDOFs)
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/LinkState.cpp` & `idyntree-9.1.1.dev7/src/model/src/LinkState.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/LinkState.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/Model.h>
 
-#include <iDynTree/ArticulatedBodyInertia.h>
+#include <iDynTree/Core/ArticulatedBodyInertia.h>
 
 namespace iDynTree
 {
 
 LinkPositions::LinkPositions(std::size_t nrOfLinks)
 {
     resize(nrOfLinks);
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/LinkTraversalsCache.cpp` & `idyntree-9.1.1.dev7/src/model/src/LinkTraversalsCache.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include "iDynTree/LinkTraversalsCache.h"
+#include "iDynTree/Model/LinkTraversalsCache.h"
 
-#include "iDynTree/Traversal.h"
-#include "iDynTree/Model.h"
+#include "iDynTree/Model/Traversal.h"
+#include "iDynTree/Model/Model.h"
 
 #include <cassert>
 
 namespace iDynTree {
 
 LinkTraversalsCache::LinkTraversalsCache()
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/Model.cpp` & `idyntree-9.1.1.dev7/src/model/src/Model.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/SolidShapes.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/SolidShapes.h>
-
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cassert>
 #include <deque>
 #include <sstream>
 #include <string>
 
 
@@ -59,17 +66,14 @@
 
     // Copy the default base link
     this->setDefaultBaseLink(other.getDefaultBaseLink());
 
     // Copy the solid shapes
     this->m_collisionSolidShapes = other.m_collisionSolidShapes;
     this->m_visualSolidShapes    = other.m_visualSolidShapes;
-
-    // Copy the sensors
-    this->m_sensors = other.m_sensors;
 }
 
 
 Model::Model(const Model& other)
 {
     copy(other);
 }
@@ -865,18 +869,17 @@
             {
                 addLinkToTraversal(*this,traversal,neighb.neighborLink,
                     neighb.neighborJoint,visitedLink->getIndex(),linkToVisit);
             }
         }
     }
 
-    // At this point the traversal should contain part of the links of the model
-    // (not all, as it is a subset if the links of the model are not all connected by joints )
-    // See https://github.com/robotology/idyntree/pull/914
-    assert(traversal.getNrOfVisitedLinks() <= this->getNrOfLinks());
+    // At this point the traversal should contain all the links
+    // of the model
+    assert(traversal.getNrOfVisitedLinks() == this->getNrOfLinks());
 
     return true;
 }
 
 bool Model::getInertialParameters(VectorDynSize& modelInertialParams) const
 {
     // Resize vector if necessary
@@ -931,24 +934,14 @@
 }
 
 const ModelSolidShapes& Model::collisionSolidShapes() const
 {
     return m_collisionSolidShapes;
 }
 
-SensorsList& Model::sensors()
-{
-    return m_sensors;
-}
-
-const SensorsList& Model::sensors() const
-{
-    return m_sensors;
-}
-
 std::string Model::toString() const
 {
     std::stringstream ss;
 
     ss << "Model: " << std::endl;
     ss << "  Links: " << std::endl;
     for(size_t i=0; i < this->getNrOfLinks(); i++ )
@@ -970,14 +963,8 @@
         ss << "    [" << i << "] "
            << this->getJointName(i) << " (dofs: " << this->getJoint(i)->getNrOfDOFs() << ") : "
            << this->getLinkName(this->getJoint(i)->getFirstAttachedLink()) << "<-->" << this->getLinkName(this->getJoint(i)->getSecondAttachedLink()) << std::endl;
     }
 
     return ss.str();
 }
-
-bool Model::isValid() const
-{
-    return m_sensors.isConsistent(*this);
-}
-
 }
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/ModelTransformers.cpp` & `idyntree-9.1.1.dev7/src/model/src/ModelTransformers.cpp`

 * *Files 23% similar despite different names*

```diff
@@ -1,21 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/Model.h>
-#include <iDynTree/SubModel.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/FreeFloatingState.h>
-
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/PrismaticJoint.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Sensors.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/SubModel.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/Model/PrismaticJoint.h>
 
 #include <cassert>
 #include <set>
 
 
 namespace iDynTree
 {
@@ -495,207 +499,14 @@
         reducedModel.addJoint(jointName,newJoint);
 
         // The pointer is cloned in the addJoint call,
         // we need to delete the one that we allocated ourself
         delete newJoint;
     }
 
-    // We then handle the sensors
-    // make sure that reducedModel.sensors() is empty
-    assert(reducedModel.sensors().getNrOfSensors(SIX_AXIS_FORCE_TORQUE) == 0);
-    assert(reducedModel.sensors().getNrOfSensors(ACCELEROMETER) == 0);
-    assert(reducedModel.sensors().getNrOfSensors(GYROSCOPE) == 0);
-
-    // Process first F/T sensors
-    for (auto it = fullModel.sensors().sensorsIteratorForType(SIX_AXIS_FORCE_TORQUE); it.isValid(); ++it) {
-        Sensor* s = *it;
-        JointSensor* jointSens = dynamic_cast<JointSensor*>(s);
-
-        // If the sensor is a joint sensor
-        if (jointSens) {
-            // The parent joint can be present in the reduced model, or it could have been assigned to
-            // a submodel after the reduction
-            std::string parentJointName = jointSens->getParentJoint();
-
-            // If the parent's joint is present in the model
-            if (reducedModel.isJointNameUsed(parentJointName)) {
-                // If we add the sensor to the new sensors list, we have to upgrade the indices
-                SixAxisForceTorqueSensor* sensorCopy;
-                sensorCopy = static_cast<SixAxisForceTorqueSensor*>(jointSens->clone());
-
-                std::string oldFirstLinkName = sensorCopy->getFirstLinkName();
-                std::string oldSecondLinkName = sensorCopy->getSecondLinkName();
-
-                iDynTree::LinkIndex firstLinkIndex = reducedModel.getLinkIndex(oldFirstLinkName);
-                iDynTree::LinkIndex secondLinkIndex = reducedModel.getLinkIndex(oldSecondLinkName);
-
-                // The reduced model contains both the links attached to the joint
-                // No particular operations are required in this case
-                if ((firstLinkIndex != iDynTree::LINK_INVALID_INDEX) &&
-                    (secondLinkIndex != iDynTree::LINK_INVALID_INDEX)) {
-                    // Update indices
-                    sensorCopy->updateIndices(reducedModel);
-                    // Add the sensor to the reduced model
-                    reducedModel.sensors().addSensor(*sensorCopy);
-                }
-                // If one of the links attached to the joint has been lumped in the reduced model,
-                // updating the transform is required
-                else if (firstLinkIndex != iDynTree::LINK_INVALID_INDEX) {
-                    // The secondLink has been lumped
-                    // Get the link to which it was merged
-                    FrameIndex frameIndexOfSecondLink = reducedModel.getFrameIndex(oldSecondLinkName);
-                    LinkIndex newSecondLinkIndex = reducedModel.getFrameLink(frameIndexOfSecondLink);
-
-                    // Update the transform. It requires two steps:
-                    // New second link (reducedModel) -> Old second link (fullModel) -> jointSens frame
-                    Transform oldSecondLinkInFullModel_H_sensorFrame;
-
-                    sensorCopy->getLinkSensorTransform(sensorCopy->getSecondLinkIndex(),
-                                                       oldSecondLinkInFullModel_H_sensorFrame);
-
-                    Transform newSecondLinkInReducedModel_H_oldSecondLinkInFullModel =
-                        reducedModel.getFrameTransform(frameIndexOfSecondLink);
-
-                    // Get the name of the new second link (to which the old one has been lumped)
-                    std::string newSecondLinkName = reducedModel.getLinkName(newSecondLinkIndex);
-
-                    // Set the name of the new secondLink and update its index
-                    sensorCopy->setSecondLinkName(newSecondLinkName);
-                    sensorCopy->updateIndices(reducedModel);
-
-                    // Update the transform
-                    sensorCopy->setSecondLinkSensorTransform(sensorCopy->getSecondLinkIndex(),
-                                                            newSecondLinkInReducedModel_H_oldSecondLinkInFullModel*oldSecondLinkInFullModel_H_sensorFrame);
-
-                    // Update the appliedWrenchLink
-                    if (fullModel.getLinkName(sensorCopy->getAppliedWrenchLink()) == oldSecondLinkName) {
-                        sensorCopy->setAppliedWrenchLink(reducedModel.getLinkIndex(newSecondLinkName));
-                    }
-
-                    // Add the sensor to the reduced model
-                    reducedModel.sensors().addSensor(*sensorCopy);
-                }
-                else if (secondLinkIndex != iDynTree::LINK_INVALID_INDEX) {
-                    // The firstLink has been lumped
-                    // Get the link to which it was merged
-                    FrameIndex frameIndexOfFirstLink = reducedModel.getFrameIndex(oldFirstLinkName);
-                    LinkIndex newFirstLinkIndex = reducedModel.getFrameLink(frameIndexOfFirstLink);
-
-                    // Update the transform. It requires two steps:
-                    // New first link (reducedModel) -> Old first link (fullModel) -> jointSens frame
-                    Transform oldFirstLinkInFullModel_H_sensorFrame;
-
-                    sensorCopy->getLinkSensorTransform(sensorCopy->getFirstLinkIndex(),
-                                                       oldFirstLinkInFullModel_H_sensorFrame);
-
-                    Transform newFirstLinkInReducedModel_H_oldFirstLinkInFullModel =
-                        reducedModel.getFrameTransform(frameIndexOfFirstLink);
-
-                    // Get the name of the new first link (to which the old one has been lumped)
-                    std::string newFirstLinkName = reducedModel.getLinkName(newFirstLinkIndex);
-
-                    // Set the name of the new firstLink and update its index
-                    sensorCopy->setFirstLinkName(newFirstLinkName);
-                    sensorCopy->updateIndices(reducedModel);
-
-                    // Update the transform
-                    sensorCopy->setFirstLinkSensorTransform(sensorCopy->getFirstLinkIndex(),
-                                                            newFirstLinkInReducedModel_H_oldFirstLinkInFullModel*oldFirstLinkInFullModel_H_sensorFrame);
-
-                    // Update the appliedWrenchLink
-                    if (fullModel.getLinkName(sensorCopy->getAppliedWrenchLink()) == oldFirstLinkName) {
-                        sensorCopy->setAppliedWrenchLink(reducedModel.getLinkIndex(newFirstLinkName));
-                    }
-
-                    // Add the sensor to the reduced model
-                    reducedModel.sensors().addSensor(*sensorCopy);
-                }
-                else {
-                    std::stringstream ss;
-                    ss << "The links related to the joint sensor attached on " << parentJointName << " have an invalid index" << std::endl;
-                    reportError("", "createReducedModelAndSensors", ss.str().c_str());
-                    delete sensorCopy;
-                    return false;
-                }
-
-                delete sensorCopy;
-            }
-        }
-        else {
-            std::stringstream ss;
-            ss << "The processed FT sensor couldn't be cast as a joint sensor" << std::endl;
-            reportWarning("", "createReducedModelAndSensors", ss.str().c_str());
-
-        }
-    }
-
-    // Then all link sensors
-    for (SensorsList::const_iterator it = fullModel.sensors().allSensorsIterator(); it.isValid(); ++it)
-    {
-        Sensor *s = *it;
-
-        // This should select only link sensors
-        LinkSensor *linkSens = dynamic_cast<LinkSensor*>(s);
-        if( linkSens )
-        {
-            std::string sensorLinkInFullModel = linkSens->getParentLink();
-
-            // If the link to wicht the sensors is attached (parentLink) is also in the reduced model, we can just copy the sensor to the reduced sensors models
-            if( reducedModel.isLinkNameUsed(sensorLinkInFullModel) )
-            {
-                // update the link index of the reduced model
-                LinkSensor *sensorInReducedModel = static_cast<LinkSensor*>(linkSens->clone());
-                if (!sensorInReducedModel || !sensorInReducedModel->updateIndices(reducedModel)) {
-                    reportError("","createReducedModelAndSensors", "Failed to duplicate LinkSensor and update indices");
-                    return false;
-                }
-                reducedModel.sensors().addSensor(*sensorInReducedModel);
-                delete sensorInReducedModel;
-            }
-            else
-            {
-                // Otherwise there should be a additional frame in the reduced model named like the sensor link in the full model
-                if( !reducedModel.isFrameNameUsed(sensorLinkInFullModel) )
-                {
-                    std::stringstream ss;
-                    ss << "additional frame " << sensorLinkInFullModel << " is not in the reduced model, reducing sensors failed" << std::endl;
-                    reportError("","createReducedModelAndSensors",ss.str().c_str());
-                    return false;
-                }
-
-
-                FrameIndex sensorLinkAdditionalFrameIndexInReducedModel = reducedModel.getFrameIndex(sensorLinkInFullModel);
-                LinkIndex sensorLinkInReducedModelIdx = reducedModel.getFrameLink(sensorLinkAdditionalFrameIndexInReducedModel);
-
-                std::string sensorLinkInReducedModel = reducedModel.getLinkName(sensorLinkInReducedModelIdx);
-
-                // If we found the original link sensor as an additonal frame, we can compute the pose of the sensor w.r.t. to the new link to which it is attached
-                Transform sensorLinkInReducedModel_H_sensorLinkInFullModel = reducedModel.getFrameTransform(sensorLinkAdditionalFrameIndexInReducedModel);
-                Transform sensorLinkInFullModel_H_sensorFrame              = linkSens->getLinkSensorTransform();
-
-                Transform sensorLinkInReducedModel_H_sensorFrame = sensorLinkInReducedModel_H_sensorLinkInFullModel*sensorLinkInFullModel_H_sensorFrame;
-
-                // Copy the sensor to modify it
-                LinkSensor* sensorCopy = (LinkSensor*)linkSens->clone();
-
-                // Update the pose
-                sensorCopy->setLinkSensorTransform(sensorLinkInReducedModel_H_sensorFrame);
-
-                // Update the link name and indices
-                sensorCopy->setParentLink(sensorLinkInReducedModel);
-                sensorCopy->setParentLinkIndex(reducedModel.getLinkIndex(sensorLinkInReducedModel));
-
-                reducedModel.sensors().addSensor(*sensorCopy);
-
-                delete sensorCopy;
-            }
-
-        }
-    }
-
     return ok;
 }
 
 bool createModelWithNormalizedJointNumbering(const Model& model,
                                              const std::string& baseForNormalizedJointNumbering,
                                              Model& normalizedModel)
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/PredictSensorsMeasurements.cpp` & `idyntree-9.1.1.dev7/src/sensors/src/PredictSensorsMeasurements.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,30 +1,39 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Sensors/PredictSensorsMeasurements.h>
+#include <iDynTree/Core/SpatialMotionVector.h>
+#include <iDynTree/Sensors/AccelerometerSensor.h>
+#include <iDynTree/Sensors/GyroscopeSensor.h>
+#include <iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Sensors/Sensors.h>
+
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/Dynamics.h>
 
-#include <iDynTree/PredictSensorsMeasurements.h>
-#include <iDynTree/SpatialMotionVector.h>
-#include <iDynTree/AccelerometerSensor.h>
-#include <iDynTree/GyroscopeSensor.h>
-#include <iDynTree/ThreeAxisAngularAccelerometerSensor.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
-#include <iDynTree/Sensors.h>
-
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/Dynamics.h>
-
-#include <iDynTree/SpatialAcc.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/SpatialAcc.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree {
 
+
 bool predictSensorsMeasurements(const Model & model,
+                                const SensorsList &sensorsList,
                                 const Traversal & traversal,
                                 const FreeFloatingPos& robotPos,
                                 const FreeFloatingVel& robotVel,
                                 const FreeFloatingAcc& robotAcc,
                                 const LinAcceleration & gravity,
                                 const LinkNetExternalWrenches & externalWrenches,
                                       FreeFloatingAcc& buf_properRobotAcc,
@@ -47,109 +56,71 @@
     ForwardPosVelAccKinematics(model,traversal,robotPos,robotVel,
                                buf_properRobotAcc,buf_linkPos,buf_linkVel,buf_linkProperAcc);
 
     // Calling the backward pass of RNEA to simulat FT sensors
     RNEADynamicPhase(model,traversal,robotPos.jointPos(),buf_linkVel,buf_linkProperAcc,
                      externalWrenches,buf_internalWrenches,buf_outputTorques);
 
-    return predictSensorsMeasurementsFromRawBuffers(model,traversal,
+    return predictSensorsMeasurementsFromRawBuffers(model,sensorsList,traversal,
                                                     buf_linkVel,buf_linkProperAcc,
                                                     buf_internalWrenches,predictedMeasurement);
 }
 
-bool predictSensorsMeasurementsFromRawBuffers(const Model& model,
+bool predictSensorsMeasurementsFromRawBuffers(const Model& /*model*/,
+                                              const SensorsList& sensorsList,
                                               const Traversal& traversal,
                                               const LinkVelArray& buf_linkVel,
                                               const LinkAccArray& buf_linkProperAcc,
                                               const LinkInternalWrenches& buf_internalWrenches,
                                               SensorsMeasurements& predictedMeasurement)
 {
     bool retVal = true;
 
-    size_t numOfFTs = model.sensors().getNrOfSensors(iDynTree::SIX_AXIS_FORCE_TORQUE);
+    size_t numOfFTs = sensorsList.getNrOfSensors(iDynTree::SIX_AXIS_FORCE_TORQUE);
     for(size_t idx = 0; idx<numOfFTs; idx++)
     {
-        SixAxisForceTorqueSensor * ftSens = (SixAxisForceTorqueSensor*)model.sensors().getSensor(iDynTree::SIX_AXIS_FORCE_TORQUE, idx);
+        SixAxisForceTorqueSensor * ftSens = (SixAxisForceTorqueSensor*)sensorsList.getSensor(iDynTree::SIX_AXIS_FORCE_TORQUE, idx);
 
         Wrench predictedWrench = ftSens->predictMeasurement(traversal,buf_internalWrenches);
         retVal = retVal && predictedMeasurement.setMeasurement(iDynTree::SIX_AXIS_FORCE_TORQUE,idx,predictedWrench);
     }
 
 
     //Iterate through each accelrometer and find its parent. Compute local (classical accelration)
     // It is automatically proper acceleration since gravity is incorporated into the base acceleration
-    unsigned int numAccl = model.sensors().getNrOfSensors(iDynTree::ACCELEROMETER);
+    unsigned int numAccl = sensorsList.getNrOfSensors(iDynTree::ACCELEROMETER);
     for(size_t idx = 0; idx<numAccl; idx++)
     {
-        AccelerometerSensor * accelerometer = (AccelerometerSensor *)model.sensors().getSensor(iDynTree::ACCELEROMETER, idx);
+        AccelerometerSensor * accelerometer = (AccelerometerSensor *)sensorsList.getSensor(iDynTree::ACCELEROMETER, idx);
         LinkIndex parentLinkId = accelerometer->getParentLinkIndex();
         LinAcceleration predictedAcc = accelerometer->predictMeasurement(buf_linkProperAcc(parentLinkId),
                                                                          buf_linkVel(parentLinkId));
         retVal = retVal && predictedMeasurement.setMeasurement(iDynTree::ACCELEROMETER,idx,predictedAcc);
     }
 
-    unsigned int numGyro = model.sensors().getNrOfSensors(iDynTree::GYROSCOPE);
+    unsigned int numGyro = sensorsList.getNrOfSensors(iDynTree::GYROSCOPE);
     for(size_t idx = 0; idx<numGyro; idx++)
     {
-        GyroscopeSensor * gyroscope = (GyroscopeSensor*)model.sensors().getSensor(iDynTree::GYROSCOPE, idx);
+        GyroscopeSensor * gyroscope = (GyroscopeSensor*)sensorsList.getSensor(iDynTree::GYROSCOPE, idx);
         LinkIndex parentLinkId = gyroscope->getParentLinkIndex();
         AngVelocity predictedAngVel = gyroscope->predictMeasurement(buf_linkVel(parentLinkId));
         retVal = retVal && predictedMeasurement.setMeasurement(iDynTree::GYROSCOPE,idx,predictedAngVel);
     }
 
-    unsigned int numAngAccl = model.sensors().getNrOfSensors(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER);
+    unsigned int numAngAccl = sensorsList.getNrOfSensors(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER);
     for(size_t idx = 0; idx<numAngAccl; idx++)
     {
         ThreeAxisAngularAccelerometerSensor * angAccelerometer =
-        (ThreeAxisAngularAccelerometerSensor*)model.sensors().getSensor(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER, idx);
+        (ThreeAxisAngularAccelerometerSensor*)sensorsList.getSensor(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER, idx);
         LinkIndex parentLinkId = angAccelerometer->getParentLinkIndex();
         Vector3 predictedAngAcc = angAccelerometer->predictMeasurement(buf_linkProperAcc(parentLinkId));
         retVal = retVal && predictedMeasurement.setMeasurement(iDynTree::THREE_AXIS_ANGULAR_ACCELEROMETER,idx,predictedAngAcc);
     }
 
     return retVal;
 }
 
-bool predictSensorsMeasurements(const Model & model,
-                                const SensorsList &sensorsList,
-                                const Traversal & traversal,
-                                const FreeFloatingPos& robotPos,
-                                const FreeFloatingVel& robotVel,
-                                const FreeFloatingAcc& robotAcc,
-                                const LinAcceleration & gravity,
-                                const LinkNetExternalWrenches & externalWrenches,
-                                      FreeFloatingAcc& buf_properRobotAcc,
-                                      LinkPositions& buf_linkPos,
-                                      LinkVelArray& buf_linkVel,
-                                      LinkAccArray& buf_linkProperAcc,
-                                      LinkInternalWrenches& buf_internalWrenches,
-                                      FreeFloatingGeneralizedTorques& buf_outputTorques,
-                                      SensorsMeasurements &predictedMeasurement)
-{
-    Model modelCopy = model;
-    modelCopy.sensors() = sensorsList;
-
-    return predictSensorsMeasurements(modelCopy, traversal, robotPos, robotVel, robotAcc, gravity, 
-                                      externalWrenches, buf_properRobotAcc, buf_linkPos, buf_linkVel, 
-                                      buf_linkProperAcc, buf_internalWrenches, buf_outputTorques, predictedMeasurement);
-}
-
-bool predictSensorsMeasurementsFromRawBuffers(const Model& model,
-                                              const SensorsList& sensorsList,
-                                              const Traversal& traversal,
-                                              const LinkVelArray& buf_linkVel,
-                                              const LinkAccArray& buf_linkProperAcc,
-                                              const LinkInternalWrenches& buf_internalWrenches,
-                                              SensorsMeasurements& predictedMeasurement)
-{
-    Model modelCopy = model;
-    modelCopy.sensors() = sensorsList;
-
-    return predictSensorsMeasurementsFromRawBuffers(modelCopy, traversal, buf_linkVel, 
-                                                    buf_linkProperAcc, buf_internalWrenches, predictedMeasurement);
-}
-
 
 
 
 
 }
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/PrismaticJoint.cpp` & `idyntree-9.1.1.dev7/src/model/src/PrismaticJoint.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/PrismaticJoint.h>
+#include <iDynTree/Model/PrismaticJoint.h>
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/TransformDerivative.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/Wrench.h>
-#include <iDynTree/Twist.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/TransformDerivative.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Core/Wrench.h>
+#include <iDynTree/Core/Twist.h>
 
 #include <cassert>
 
 #include <cfloat>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/RevoluteJoint.cpp` & `idyntree-9.1.1.dev7/src/model/src/RevoluteJoint.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/RevoluteJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/TransformDerivative.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/Wrench.h>
-#include <iDynTree/Twist.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/TransformDerivative.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Core/Wrench.h>
+#include <iDynTree/Core/Twist.h>
 
 #include <cassert>
 
 #include <cfloat>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/Sensors.cpp` & `idyntree-9.1.1.dev7/src/sensors/src/Sensors.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 
 #include <vector>
 #include <map>
 
-#include <iDynTree/Wrench.h>
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Core/Wrench.h>
+#include <iDynTree/Sensors/Sensors.h>
 
-#include <iDynTree/SixAxisForceTorqueSensor.h>
-#include <iDynTree/AccelerometerSensor.h>
-#include <iDynTree/GyroscopeSensor.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Sensors/AccelerometerSensor.h>
+#include <iDynTree/Sensors/GyroscopeSensor.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
 #include <cassert>
 #include <iostream>
 
 namespace iDynTree {
 
 Sensor::~Sensor()
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/SixAxisForceTorqueSensor.cpp` & `idyntree-9.1.1.dev7/src/sensors/src/SixAxisForceTorqueSensor.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-#include "iDynTree/Wrench.h"
-#include "iDynTree/SixAxisForceTorqueSensor.h"
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+#include "iDynTree/Core/Wrench.h"
+#include "iDynTree/Sensors/SixAxisForceTorqueSensor.h"
 
-#include "iDynTree/Transform.h"
+#include "iDynTree/Core/Transform.h"
 
-#include <iDynTree/Traversal.h>
-#include <iDynTree/Link.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/Link.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
-#include <iDynTree/Model.h>
 
 #include <cassert>
 
 
 namespace iDynTree {
 
 struct SixAxisForceTorqueSensor::SixAxisForceTorqueSensorPrivateAttributes
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/SolidShapes.cpp` & `idyntree-9.1.1.dev7/src/model/src/SolidShapes.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/SolidShapes.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/SolidShapes.h>
+#include <iDynTree/Model/Model.h>
 
 #include <string>
 #include <cstdlib>
 #include <fstream>
 #include <unordered_set>
 
 namespace iDynTree
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/SubModel.cpp` & `idyntree-9.1.1.dev7/src/model/src/SubModel.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/SubModel.h>
+#include <iDynTree/Model/SubModel.h>
 
-#include <iDynTree/IJoint.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/JointState.h>
+#include <iDynTree/Model/IJoint.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/JointState.h>
 
 #include <cassert>
 #include <algorithm>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/ThreeAxisAngularAccelerometerSensor.cpp` & `idyntree-9.1.1.dev7/src/sensors/src/ThreeAxisAngularAccelerometerSensor.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,22 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include "iDynTree/ThreeAxisAngularAccelerometerSensor.h"
+#include "iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h"
 
-#include "iDynTree/Transform.h"
+#include "iDynTree/Core/Transform.h"
 
-#include "iDynTree/SpatialAcc.h"
-#include "iDynTree/Twist.h"
-
-#include <iDynTree/EigenHelpers.h>
-
-#include <iDynTree/Model.h>
+#include "iDynTree/Core/SpatialAcc.h"
+#include "iDynTree/Core/Twist.h"
 
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree {
 
 struct ThreeAxisAngularAccelerometerSensor::ThreeAxisAngularAccelerometerPrivateAttributes
 {
     // Name/id of the sensor
     std::string name;
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/ThreeAxisForceTorqueContactSensor.cpp` & `idyntree-9.1.1.dev7/src/sensors/src/ThreeAxisForceTorqueContactSensor.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include "iDynTree/ThreeAxisForceTorqueContactSensor.h"
+#include "iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h"
 
-#include "iDynTree/Transform.h"
+#include "iDynTree/Core/Transform.h"
 
-#include "iDynTree/SpatialAcc.h"
-#include "iDynTree/Twist.h"
+#include "iDynTree/Core/SpatialAcc.h"
+#include "iDynTree/Core/Twist.h"
 
-#include <iDynTree/EigenHelpers.h>
-
-#include <iDynTree/Model.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree {
 
 struct ThreeAxisForceTorqueContactSensor::ThreeAxisForceTorqueContactSensorPrivateAttributes
 {
     std::string name;
     Transform link_H_sensor;
```

### Comparing `idyntree-9.1.1.dev66/src/model/src/Traversal.cpp` & `idyntree-9.1.1.dev7/src/model/src/Traversal.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/Traversal.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/Model.h>
 
 #include <cassert>
 #include <sstream>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model/tests/JointUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model/tests/JointUnitTest.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/Model/Link.h>
+
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/TransformDerivative.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
-#include <iDynTree/Link.h>
-
-#include <iDynTree/Position.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/TransformDerivative.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/EigenHelpers.h>
-
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/PrismaticJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/Model/PrismaticJoint.h>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
 
 template<typename OneDofJoint>
```

### Comparing `idyntree-9.1.1.dev66/src/model/tests/LinkUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model/tests/LinkUnitTest.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,26 +1,33 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Link.h>
+#include <iDynTree/Model/Link.h>
 
-#include <iDynTree/Position.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/Position.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
 
 int main()
 {
     double rotInertiaData[3*3] = {10.0,0.0,0.0,
                                   0.0,20.0,0.0,
                                   0.0,0.0,30.0};
-    SpatialInertia settedInertia(1.0,Position(100,0,0),RotationalInertia(rotInertiaData,3,3));
+    SpatialInertia settedInertia(1.0,Position(100,0,0),RotationalInertiaRaw(rotInertiaData,3,3));
 
     Link link;
 
     link.setInertia(settedInertia);
 
     SpatialInertia gettedInertia = link.getInertia();
```

### Comparing `idyntree-9.1.1.dev66/src/model/tests/ModelUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model/tests/ModelUnitTest.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,30 +1,37 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/PrismaticJoint.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelTestUtils.h>
-#include <iDynTree/Traversal.h>
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/Model/PrismaticJoint.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/ModelTestUtils.h>
+#include <iDynTree/Model/Traversal.h>
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <algorithm>
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 
 // For modelTransformsers testing
-#include <iDynTree/ModelTransformers.h>
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Dynamics.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/SubModel.h>
+#include <iDynTree/Model/ModelTransformers.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Dynamics.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/SubModel.h>
 
 using namespace iDynTree;
 
 
 void createCopyAndDestroy(const Model & model)
 {
     Model * p_model = new Model(model);
@@ -301,15 +308,15 @@
 {
     std::cout << "Checking simple model... " << std::endl;
 
     double rotInertiaData[3*3] = {14.0,0.0,0.0,
                                   0.0,12.0,0.0,
                                   0.0,0.0,10.0};
 
-    SpatialInertia inertiaLink0(1.0,Position(100,0,0),RotationalInertia(rotInertiaData,3,3));
+    SpatialInertia inertiaLink0(1.0,Position(100,0,0),RotationalInertiaRaw(rotInertiaData,3,3));
 
     Link link0;
     link0.setInertia(inertiaLink0);
 
     Link link1(link0);
 
     FixedJoint fixJoint(0,1,Transform(Rotation::Identity(),Position(1,3,4)));
@@ -350,15 +357,15 @@
 {
     std::cout << "Checking InsertJointAndLink... " << std::endl;
 
     double rotInertiaData[3*3] = {14.0,0.0,0.0,
                                   0.0,12.0,0.0,
                                   0.0,0.0,10.0};
 
-    SpatialInertia inertiaLink0(1.0,Position(100,0,0),RotationalInertia(rotInertiaData,3,3));
+    SpatialInertia inertiaLink0(1.0,Position(100,0,0),RotationalInertiaRaw(rotInertiaData,3,3));
 
     Link link0;
     link0.setInertia(inertiaLink0);
 
     Link link1(link0);
```

### Comparing `idyntree-9.1.1.dev66/src/model/tests/SensorsListUnitTest.cpp` & `idyntree-9.1.1.dev7/src/sensors/tests/SensorsListUnitTest.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Sensors.h>
-#include <iDynTree/AccelerometerSensor.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/AccelerometerSensor.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
 
 void checkList()
 {
 
     std::cout << "Checking SensorsList Addition/Removal... " << std::endl;
     using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/model/tests/ThreeAxisForceTorqueContactSensorUnitTest.cpp` & `idyntree-9.1.1.dev7/src/sensors/tests/ThreeAxisForceTorqueContactSensorUnitTest.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/ThreeAxisForceTorqueContactSensor.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Sensors/ThreeAxisForceTorqueContactSensor.h>
 
 using namespace iDynTree;
 
 void checkCOPcomputation(const ThreeAxisForceTorqueContactSensor& sensor)
 {
     std::vector<Position> loadCellLocations = sensor.getLoadCellLocations();
     VectorDynSize arbitraryLoadCellReadings(loadCellLocations.size());
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/model_io/codecs/CMakeLists.txt`

 * *Files 14% similar despite different names*

```diff
@@ -1,14 +1,19 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
-set(IDYNTREE_MODELIO_HEADERS include/iDynTree/URDFDofsImport.h
-                                  include/iDynTree/ModelLoader.h
-                                  include/iDynTree/ModelExporter.h
-                                  include/iDynTree/ModelCalibrationHelper.h)
+# Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
+
+set(IDYNTREE_MODELIO_HEADERS include/iDynTree/ModelIO/URDFDofsImport.h
+                                  include/iDynTree/ModelIO/ModelLoader.h
+                                  include/iDynTree/ModelIO/ModelExporter.h
+                                  include/iDynTree/ModelIO/ModelCalibrationHelper.h)
 
 set(IDYNTREE_MODELIO_PRIVATE_HEADERS include/private/URDFDocument.h
                                           include/private/InertialElement.h
                                           include/private/JointElement.h
                                           include/private/LinkElement.h
                                           include/private/RobotElement.h
                                           include/private/OriginElement.h
@@ -47,15 +52,15 @@
 
 target_compile_features(${libraryname} PRIVATE cxx_auto_type cxx_delegating_constructors cxx_final cxx_lambdas cxx_lambda_init_captures)
 
 target_include_directories(${libraryname} PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
                                                  "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/private>"
                                                  "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>")
 
-target_link_libraries(${libraryname} PUBLIC idyntree-core idyntree-model idyntree-modelio-xml
+target_link_libraries(${libraryname} PUBLIC idyntree-core idyntree-model idyntree-sensors idyntree-modelio-xml
                                      PRIVATE Eigen3::Eigen LibXml2::LibXml2)
 # See https://stackoverflow.com/questions/38832528/transitive-target-include-directories-on-object-libraries
 # Can be removed with CMake 3.12
 target_include_directories(${libraryname} PRIVATE $<TARGET_PROPERTY:idyntree-private-fpconv,INTERFACE_INCLUDE_DIRECTORIES>)
 
 target_compile_options(${libraryname} PRIVATE ${IDYNTREE_WARNING_FLAGS})
 
@@ -63,19 +68,14 @@
 
 install(TARGETS ${libraryname}
         EXPORT iDynTree
         COMPONENT runtime
         RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}" COMPONENT bin
         LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}" COMPONENT shlib
         ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}" COMPONENT lib
-        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree)
+        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree/ModelIO)
 
 set_property(GLOBAL APPEND PROPERTY ${VARS_PREFIX}_TARGETS ${libraryname})
 
 if(IDYNTREE_COMPILE_TESTS)
     add_subdirectory(tests)
 endif(IDYNTREE_COMPILE_TESTS)
-
-
-# Install deprecated headers
-install(DIRECTORY include/iDynTree/ModelIO
-        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/iDynTree)
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelCalibrationHelper.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/ModelCalibrationHelper.h`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODEL_CALIBRATION_HELPER_H
 #define IDYNTREE_MODEL_CALIBRATION_HELPER_H
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Sensors.h>
-#include <iDynTree/ModelExporter.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/ModelIO/ModelExporter.h>
 
 #include <memory>
 #include <string>
 #include <vector>
 
 namespace iDynTree
 {
@@ -92,15 +99,14 @@
     const Model & model();
 
     /**
      * Get the loaded sensors.
      * 
      * @note This always return the model loaded via loadModel method, and is not affected by the updateModel methods.
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use ModelCalibrationHelper::model::sensors method.")
     const SensorsList & sensors();
 
     /**
      * Return true if the model have been correctly true.
      *
      * @note This always return the validity of the model loaded via loadModel method, and is not affected by the updateModel methods.
      * @return True if the model was loaded correctly.
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelExporter.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/ModelExporter.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2019 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODEL_EXPORTER_H
 #define IDYNTREE_MODEL_EXPORTER_H
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 #include <memory>
 #include <string>
 #include <vector>
 
 namespace iDynTree
 {
@@ -141,43 +148,31 @@
 
     void setExportingOptions(const ModelExporterOptions& options);
 
     /**
      * Specifies the model of the robot to export.
      *
      * @param[in] model The used model.
-     * @param[in] options The used options.
-     * @return true if all went well, false otherwise.
-     */
-    bool init(const Model& model,
-              const ModelExporterOptions options=ModelExporterOptions());
-
-    /**
-     * Specifies the model of the robot to export.
-     *
-     * @param[in] model The used model.
      * @param[in] sensors The used sensors.
      * @param[in] options The used options.
      * @return true if all went well, false otherwise.
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use the variant in which the sensors are passed as part of the iDynTree::Model.")
     bool init(const Model& model,
-              const SensorsList& sensors,
+              const SensorsList& sensors=SensorsList(),
               const ModelExporterOptions options=ModelExporterOptions());
 
     /**
      * Get the loaded model that will be exported.
      *
      */
     const Model & model();
 
     /**
      * Get the loaded sensors that will be exported.
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use ModelExporter::model::sensors method.")
     const SensorsList & sensors();
 
     /**
      * Return true if the model have been correctly loaded, and can be exported.
      *
      * @return True if the model was loaded correctly.
      */
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/ModelLoader.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/ModelLoader.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODEL_LOADER_H
 #define IDYNTREE_MODEL_LOADER_H
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 #include <memory>
 #include <string>
 #include <vector>
 
 namespace iDynTree
 {
@@ -206,15 +213,14 @@
      *
      */
     const Model & model();
 
     /**
      * Get the loaded sensors.
      */
-    IDYNTREE_DEPRECATED_WITH_MSG("Deprecated, please use ModelLoader::model::sensors method.")
     const SensorsList & sensors();
 
     /**
      * Return true if the model have been correctly true.
      *
      * @return True if the model was loaded correctly.
      */
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/iDynTree/URDFDofsImport.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/iDynTree/ModelIO/URDFDofsImport.h`

 * *Files 23% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_URDF_DOFS_IMPORT_H
 #define IDYNTREE_URDF_DOFS_IMPORT_H
 
 #include <vector>
 #include <string>
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/ForceTorqueSensorElement.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/ForceTorqueSensorElement.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_URDF_FORCETORQUESENSORELEMENT_H
 #define IDYNTREE_MODELIO_URDF_FORCETORQUESENSORELEMENT_H
 
 #include <iDynTree/XMLElement.h>
 #include "SensorElement.h"
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/InertialElement.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/InertialElement.h`

 * *Files 15% similar despite different names*

```diff
@@ -1,27 +1,36 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_URDF_INERTIAELEMENT_H
 #define IDYNTREE_MODELIO_URDF_INERTIAELEMENT_H
 
 #include <iDynTree/XMLElement.h>
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Model/Model.h>
 
 namespace iDynTree {
     class InertialElement;
     class XMLParserState;
 }
 
 class iDynTree::InertialElement: public iDynTree::XMLElement {
     Transform m_centerOfMass;
     double m_mass;
-    RotationalInertia m_rotationalInertiaWRTCoM;
+    RotationalInertiaRaw m_rotationalInertiaWRTCoM;
     iDynTree::Link &m_link;
     
 public:
     explicit InertialElement(XMLParserState& parserState, iDynTree::Link &link);
     
     std::shared_ptr<iDynTree::XMLElement> childElementForName(const std::string& name) override;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/JointElement.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/JointElement.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,19 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_URDF_JOINTELEMENT_H
 #define IDYNTREE_MODELIO_URDF_JOINTELEMENT_H
 
 #include <iDynTree/XMLElement.h>
 
-#include <iDynTree/IJoint.h>
+#include <iDynTree/Model/IJoint.h>
 
-#include <iDynTree/Axis.h>
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/Axis.h>
+#include <iDynTree/Core/Transform.h>
 
 #include <memory>
 #include <string>
 #include <unordered_map>
 
 namespace iDynTree {
     class JointElement;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/LinkElement.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/VisualElement.h`

 * *Files 20% similar despite different names*

```diff
@@ -1,47 +1,65 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#ifndef IDYNTREE_MODELIO_URDF_LINKELEMENT_H
-#define IDYNTREE_MODELIO_URDF_LINKELEMENT_H
+#ifndef IDYNTREE_MODELIO_URDF_VISUALELEMENT_H
+#define IDYNTREE_MODELIO_URDF_VISUALELEMENT_H
 
 #include <iDynTree/XMLElement.h>
 
-#include "VisualElement.h"
+#include "MaterialElement.h"
 
-#include <iDynTree/Link.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Model/SolidShapes.h>
+
+#include <memory>
+#include <string>
+#include <unordered_map>
+#include <vector>
 
 namespace iDynTree {
-    class LinkElement;
+    class VisualElement;
+
     class XMLAttribute;
-    
-    class Model;
     class XMLParserState;
 }
 
-class iDynTree::LinkElement : public iDynTree::XMLElement {
-    iDynTree::Model& m_model;
+class iDynTree::VisualElement: public iDynTree::XMLElement
+{
+public:
+    struct VisualInfo {
+        std::string m_name;
+        bool m_nameAttributeFound;
+        iDynTree::Transform m_origin{iDynTree::Transform::Identity()};
+        std::shared_ptr<SolidShape> m_solidShape;
+        std::shared_ptr<MaterialElement::MaterialInfo> m_material;
+        const std::vector<std::string>& m_packageDirs;
+
+        VisualInfo(const std::vector<std::string>& packageDirs);
+    };
+
+private:
+    VisualInfo m_info;
 
-    iDynTree::Link m_link;
-    std::string m_linkName;
-    std::vector<VisualElement::VisualInfo> m_visuals;
-    std::vector<VisualElement::VisualInfo> m_collisions;
-    
 public:
-    explicit LinkElement(XMLParserState& parserState, iDynTree::Model &model);
+    explicit VisualElement(
+        XMLParserState& parserState,
+        const std::string& name,
+        const std::vector<std::string>& packageDirs);
 
-    // Exposing useful properties
-    const std::string& linkName() const;
-    const std::vector<VisualElement::VisualInfo>& visuals() const;
-    const std::vector<VisualElement::VisualInfo>& collisions() const;
-    
-    void exitElementScope() override;
-    
-    bool setAttributes(const std::unordered_map<std::string, std::shared_ptr<iDynTree::XMLAttribute>>& attributes) override;
+    const VisualInfo& visualInfo() const;
 
-    void childHasBeenParsed(std::shared_ptr<iDynTree::XMLElement> child) override;
-    
+    bool setAttributes(const std::unordered_map<std::string, std::shared_ptr<iDynTree::XMLAttribute>>& attributes) override;
     std::shared_ptr<iDynTree::XMLElement> childElementForName(const std::string& name) override;
-    
 };
 
-#endif /* end of include guard: IDYNTREE_MODELIO_URDF_LINKELEMENT_H */
+#endif /* end of include guard: IDYNTREE_MODELIO_URDF_VISUALELEMENT_H */
+
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/MaterialElement.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/MaterialElement.h`

 * *Files 21% similar despite different names*

```diff
@@ -1,16 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_URDF_MATERIALELEMENT_H
 #define IDYNTREE_MODELIO_URDF_MATERIALELEMENT_H
 
 #include <iDynTree/XMLElement.h>
 
-#include <iDynTree/VectorFixSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
 
 #include <memory>
 #include <string>
 
 
 namespace iDynTree {
     class MaterialElement;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/OriginElement.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/OriginElement.h`

 * *Files 18% similar despite different names*

```diff
@@ -1,9 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_URDF_ORIGINELEMENT_H
 #define IDYNTREE_MODELIO_URDF_ORIGINELEMENT_H
 
 #include <iDynTree/XMLElement.h>
 
 #include <unordered_map>
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/RobotElement.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/RobotElement.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,9 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_URDF_ROBOTELEMENT_H
 #define IDYNTREE_MODELIO_URDF_ROBOTELEMENT_H
 
 #include <iDynTree/XMLElement.h>
 
 #include "JointElement.h"
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/SensorElement.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/SensorElement.h`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_URDF_SENSORELEMENT_H
 #define IDYNTREE_MODELIO_URDF_SENSORELEMENT_H
 
 #include <iDynTree/XMLElement.h>
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 #include <memory>
 #include <string>
 #include <unordered_map>
 #include <vector>
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/URDFDocument.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/URDFDocument.h`

 * *Files 22% similar despite different names*

```diff
@@ -1,37 +1,47 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_URDF_URDFDOCUMENT_H
 #define IDYNTREE_MODELIO_URDF_URDFDOCUMENT_H
 
 #include <iDynTree/XMLDocument.h>
 
 #include "JointElement.h"
 #include "MaterialElement.h"
 #include "SensorElement.h"
 #include "VisualElement.h"
-#include "iDynTree/ModelLoader.h"
+#include "iDynTree/ModelIO/ModelLoader.h"
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 #include <string>
 #include <vector>
 #include <unordered_map>
 
 namespace iDynTree {
     class URDFDocument;
     class XMLParserState;
 }
 
 
 class iDynTree::URDFDocument: public iDynTree::XMLDocument {
     // This is the final output of the parsing + processing
     iDynTree::Model m_model;
+    iDynTree::SensorsList m_sensors;
 
     iDynTree::ModelParserOptions m_options;
 
     struct {
         // Intermediate variable needed for saving the parsing result before the processing
         std::vector<std::shared_ptr<SensorHelper>> sensorHelpers;
         std::unordered_map<std::string, JointElement::JointInfo> joints;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/URDFModelExport.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/URDFModelExport.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Silvio Traversaro
+ * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ */
 
 #ifndef IDYNTREE_URDF_MODEL_EXPORT_H
 #define IDYNTREE_URDF_MODEL_EXPORT_H
 
 #include <string>
 
-#include <iDynTree/ModelExporter.h>
+#include <iDynTree/ModelIO/ModelExporter.h>
 
 namespace iDynTree
 
 {
 
 class Model;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/include/private/URDFParsingUtils.h` & `idyntree-9.1.1.dev7/src/model_io/codecs/include/private/URDFParsingUtils.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_URDF_PARSING_UTILS_H
 #define IDYNTREE_URDF_PARSING_UTILS_H
 
 #include <cmath>
 #include <cstdlib>
 #include <sstream>
 #include <string>
 #include <vector>
 
-#include <iDynTree/Transform.h>
-#include <iDynTree/VectorFixSize.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/VectorFixSize.h>
 
 #include <fpconv.h>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/ForceTorqueSensorElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/ForceTorqueSensorElement.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "ForceTorqueSensorElement.h"
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
 
 namespace iDynTree {
 
     ForceTorqueSensorHelper::ForceTorqueSensorHelper(std::shared_ptr<const SensorElement::SensorInfo> sensorInfo)
     : SensorHelper(sensorInfo) {}
 
     Sensor* ForceTorqueSensorHelper::generateSensor(const Model& model) const
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/GeometryElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/GeometryElement.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "GeometryElement.h"
 
 #include "URDFParsingUtils.h"
 
 #include <iDynTree/XMLAttribute.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/SolidShapes.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Model/SolidShapes.h>
 
 namespace iDynTree{
 
     GeometryElement::GeometryElement(
         XMLParserState& parserState, 
         std::shared_ptr<SolidShape>& shape, const std::vector<std::string>& packageDirs)
     : iDynTree::XMLElement(parserState, "geometry")
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/InertialElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/InertialElement.cpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,9 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "InertialElement.h"
 
 #include "OriginElement.h"
 
 #include <iDynTree/XMLAttribute.h>
 
@@ -75,15 +84,15 @@
                     return false;
                 }
                 double buffer[3 * 3] = {
                     xx, xy, xz,
                     xy, yy, yz,
                     xz, yz, zz
                 };
-                m_rotationalInertiaWRTCoM = RotationalInertia(buffer, 3, 3);
+                m_rotationalInertiaWRTCoM = RotationalInertiaRaw(buffer, 3, 3);
                 
                 return true;
             });
             return element;
         }
         return std::make_shared<iDynTree::XMLElement>(getParserState(), name);
     }
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/JointElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/JointElement.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "JointElement.h"
 
 #include "OriginElement.h"
 #include "URDFParsingUtils.h"
 
 #include <iDynTree/XMLAttribute.h>
 #include <iDynTree/XMLParser.h>
 
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/PrismaticJoint.h>
-#include <iDynTree/RevoluteJoint.h>
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/PrismaticJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
 
 #include <array>
 
 namespace iDynTree {
     
     JointElement::JointElement(
         XMLParserState& parserState,
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/LinkElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/LinkElement.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "LinkElement.h"
 
 #include "InertialElement.h"
 #include "VisualElement.h"
 
 #include <iDynTree/XMLAttribute.h>
 
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Model.h>
 
 #include <string>
 #include <unordered_map>
 
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/MaterialElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/MaterialElement.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "MaterialElement.h"
 
 #include "URDFParsingUtils.h"
 
 #include <iDynTree/XMLAttribute.h>
 
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 namespace iDynTree {
 
     MaterialElement::MaterialElement(
         XMLParserState& parserState, 
         std::shared_ptr<MaterialInfo> materialInfo)
     : iDynTree::XMLElement(parserState, "material")
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/ModelCalibrationHelper.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/ModelCalibrationHelper.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,13 +1,20 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-#include <iDynTree/ModelCalibrationHelper.h>
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/ModelExporter.h>
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+#include <iDynTree/ModelIO/ModelCalibrationHelper.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelExporter.h>
 
 #include <string>
 #include <vector>
 
 namespace iDynTree
 {
     class ModelCalibrationHelper::ModelCalibrationHelperPimpl {
@@ -54,22 +61,23 @@
 
     bool ModelCalibrationHelper::updateModelInertialParametersToString(std::string & model_string, 
                                                                        const iDynTree::VectorDynSize& inertialParams,
                                                                        const std::string filetype,
                                                                        const ModelExporterOptions options)
     {
         Model exportedModel = this->model();
+        SensorsList exportedSensors = this->sensors();
         
         bool ok = exportedModel.updateInertialParameters(inertialParams);
         if (!ok) {
             reportError("ModelCalibrationHelper", "updateModelInertialParametersToString", "Error in iDynTree::Model::updateInertialParameters method.");
             return false;
         }
         
-        ok = m_pimpl->modelExporter.init(exportedModel, options);
+        ok = m_pimpl->modelExporter.init(exportedModel, exportedSensors, options);
         ok = ok && m_pimpl->modelExporter.exportModelToString(model_string, filetype);
         if (!ok) {
             reportError("ModelCalibrationHelper", "updateModelInertialParametersToString", "Error in ModelExporter::exportModelToString method.");
             return false;
         }
 
         return true;
@@ -78,22 +86,23 @@
 
     bool ModelCalibrationHelper::updateModelInertialParametersToFile(const std::string & filename, 
                                                                      const iDynTree::VectorDynSize& inertialParams,
                                                                      const std::string filetype,
                                                                      const ModelExporterOptions options)
     {
         Model exportedModel = this->model();
+        SensorsList exportedSensors = this->sensors();
 
         bool ok = exportedModel.updateInertialParameters(inertialParams);
         if (!ok) {
             reportError("ModelCalibrationHelper", "updateModelInertialParametersToFile", "Error in iDynTree::Model::updateInertialParameters method.");
             return false;
         }
 
-        ok = m_pimpl->modelExporter.init(exportedModel, options);
+        ok = m_pimpl->modelExporter.init(exportedModel, exportedSensors, options);
         ok = ok && m_pimpl->modelExporter.exportModelToFile(filename, filetype);
         if (!ok) {
             reportError("ModelCalibrationHelper", "updateModelInertialParametersToFile", "Error in ModelExporter::exportModelToFile method.");
             return false;
         }
         
         return true;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/ModelExporter.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/ModelExporter.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,11 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2019 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include "iDynTree/ModelExporter.h"
+#include "iDynTree/ModelIO/ModelExporter.h"
 
 #include "URDFModelExport.h"
 
 #include <string>
 #include <vector>
 
 namespace iDynTree
@@ -17,23 +24,27 @@
     robotExportedName("iDynTreeURDFModelExportModelName"),
     xmlBlobs{} {}
 
 
 class ModelExporter::Pimpl {
 public:
     Model m_model;
+    SensorsList m_sensors;
     bool m_isModelValid;
     ModelExporterOptions m_options;
 
-    bool setModel(const Model& _model);
+    bool setModelAndSensors(const Model& _model, const SensorsList& _sensors);
 };
 
-bool ModelExporter::Pimpl::setModel(const Model& _model)
+bool ModelExporter::Pimpl::setModelAndSensors(const Model& _model,
+                                                           const SensorsList& _sensors)
 {
+
     m_model = _model;
+    m_sensors = _sensors;
 
     m_isModelValid = true;
 
     return true;
 }
 
 ModelExporter::ModelExporter()
@@ -47,15 +58,15 @@
 const Model& ModelExporter::model()
 {
     return m_pimpl->m_model;
 }
 
 const SensorsList& ModelExporter::sensors()
 {
-    return m_pimpl->m_model.sensors();
+    return m_pimpl->m_sensors;
 }
 
 bool ModelExporter::isValid()
 {
     return m_pimpl->m_isModelValid;
 }
 
@@ -66,27 +77,19 @@
 
 void ModelExporter::setExportingOptions(const ModelExporterOptions& options)
 {
     m_pimpl->m_options = options;
 }
 
 bool ModelExporter::init(const Model& model,
-                         const ModelExporterOptions options)
-{
-    m_pimpl->m_options = options;
-    return m_pimpl->setModel(model);
-}
-
-bool ModelExporter::init(const Model& model,
                          const SensorsList& sensors,
                          const ModelExporterOptions options)
 {
-    Model modelCopy = model;
-    modelCopy.sensors() = sensors;
-    return init(modelCopy, options);
+    m_pimpl->m_options = options;
+    return m_pimpl->setModelAndSensors(model, sensors);
 }
 
 bool ModelExporter::exportModelToString(std::string & modelString, const std::string filetype)
 {
     if (filetype != "urdf") {
         std::stringstream error_msg;
         error_msg << "Filetype " << filetype << " not supported. Only urdf format is currently supported.";
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/ModelLoader.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/ModelLoader.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include "iDynTree/ModelLoader.h"
+#include "iDynTree/ModelIO/ModelLoader.h"
 
 #include "URDFDocument.h"
 
 #include <iDynTree/XMLParser.h>
-#include <iDynTree/ModelTransformers.h>
+#include <iDynTree/Sensors/ModelSensorsTransformers.h>
 
 
 #include <string>
 #include <vector>
 
 namespace iDynTree
 {
@@ -19,31 +26,36 @@
     : addSensorFramesAsAdditionalFrames(true)
     , originalFilename("") {}
 
 
     class ModelLoader::ModelLoaderPimpl {
     public:
         Model m_model;
+        SensorsList m_sensors;
         bool m_isModelValid;
         ModelParserOptions m_options;
 
-        bool setModel(const Model& _model);
+        bool setModelAndSensors(const Model& _model, const SensorsList& _sensors);
     };
 
-    bool ModelLoader::ModelLoaderPimpl::setModel(const Model& _model)
+    bool ModelLoader::ModelLoaderPimpl::setModelAndSensors(const Model& _model,
+                                                           const SensorsList& _sensors)
     {
+
         m_model = _model;
+        m_sensors = _sensors;
 
         // TODO \todo add a self consistency check of model/sensors
         m_isModelValid = true;
 
         if (!m_isModelValid)
         {
-            reportError("ModelLoader","setModel","Loading failed, resetting ModelLoader to be invalid");
+            reportError("ModelLoader","setModelAndSensors","Loading failed, resetting ModelLoader to be invalid");
             m_model = Model();
+            m_sensors = SensorsList();
         }
 
         return m_isModelValid;
     }
 
     ModelLoader::ModelLoader()
     : m_pimpl(new ModelLoaderPimpl())
@@ -56,15 +68,15 @@
     const Model& ModelLoader::model()
     {
         return m_pimpl->m_model;
     }
 
     const SensorsList& ModelLoader::sensors()
     {
-        return m_pimpl->m_model.sensors();
+        return m_pimpl->m_sensors;
     }
 
     bool ModelLoader::isValid()
     {
         return m_pimpl->m_isModelValid;
     }
 
@@ -94,15 +106,15 @@
         std::shared_ptr<const XMLDocument> document = parser->document();
         std::shared_ptr<const URDFDocument> urdfDocument = std::dynamic_pointer_cast<const URDFDocument>(document);
         if (!urdfDocument) {
             reportError("ModelLoader", "loadModelFromFile", "Fatal error in retrieving the parsed model.");
             return false;
         }
 
-        return m_pimpl->setModel(urdfDocument->model());
+        return m_pimpl->setModelAndSensors(urdfDocument->model(),urdfDocument->sensors());
     }
 
     bool ModelLoader::loadModelFromString(const std::string& modelString,
                                           const std::string& /*filetype*/,
                                           const std::vector<std::string>& packageDirs /* = {} */)
     {
         // Allocate parser
@@ -119,67 +131,71 @@
         std::shared_ptr<const XMLDocument> document = parser->document();
         std::shared_ptr<const URDFDocument> urdfDocument = std::dynamic_pointer_cast<const URDFDocument>(document);
         if (!urdfDocument) {
             reportError("ModelLoader", "loadModelFromString", "Fatal error in retrieving the parsed model.");
             return false;
         }
 
-        return m_pimpl->setModel(urdfDocument->model());
+        return m_pimpl->setModelAndSensors(urdfDocument->model(),urdfDocument->sensors());
     }
 
     bool ModelLoader::loadReducedModelFromFullModel(const Model& fullModel,
                                                     const std::vector< std::string >& consideredJoints,
                                                     const std::string /*filetype*/)
     {
+        SensorsList _sensorsFull, _sensorsReduced;
         Model _modelReduced;
         _modelReduced.setPackageDirs(fullModel.getPackageDirs());
-        bool ok = createReducedModel(fullModel,consideredJoints,_modelReduced);
+        bool ok = createReducedModelAndSensors(fullModel,_sensorsFull,consideredJoints,_modelReduced,_sensorsReduced);
 
         if( !ok )
         {
             return false;
         }
 
-        return m_pimpl->setModel(_modelReduced);
+        return m_pimpl->setModelAndSensors(_modelReduced,_sensorsReduced);
     }
 
     bool ModelLoader::loadReducedModelFromString(const std::string modelString,
                                                  const std::vector< std::string >& consideredJoints,
                                                  const std::string filetype,
                                                  const std::vector<std::string>& packageDirs /*= {}*/)
     {
         bool parsingCorrect = loadModelFromString(modelString, filetype, packageDirs);
         if (!parsingCorrect) return false;
+        SensorsList _sensorsFull = m_pimpl->m_sensors, _sensorsReduced;
         Model _modelFull = m_pimpl->m_model, _modelReduced;
         _modelReduced.setPackageDirs(packageDirs);
 
-        parsingCorrect = createReducedModel(_modelFull, consideredJoints,
-                                            _modelReduced);
+        parsingCorrect = createReducedModelAndSensors(_modelFull, _sensorsFull,
+                                                      consideredJoints,
+                                                      _modelReduced, _sensorsReduced);
 
         if (!parsingCorrect)
         {
             return false;
         }
 
-        return m_pimpl->setModel(_modelReduced);
+        return m_pimpl->setModelAndSensors(_modelReduced, _sensorsReduced);
     }
 
     bool ModelLoader::loadReducedModelFromFile(const std::string filename,
                                                const std::vector< std::string >& consideredJoints,
                                                const std::string filetype,
                                                const std::vector<std::string>& packageDirs /*= {}*/)
     {
         bool parsingCorrect = loadModelFromFile(filename, filetype, packageDirs);
         if (!parsingCorrect) return false;
+        SensorsList _sensorsFull = m_pimpl->m_sensors, _sensorsReduced;
         Model _modelFull = m_pimpl->m_model, _modelReduced;
         _modelReduced.setPackageDirs(packageDirs);
 
-        parsingCorrect = createReducedModel(_modelFull,consideredJoints,_modelReduced);
+        parsingCorrect = createReducedModelAndSensors(_modelFull,_sensorsFull,consideredJoints,_modelReduced,_sensorsReduced);
 
         if (!parsingCorrect)
         {
             return false;
         }
 
-        return m_pimpl->setModel(_modelReduced);
+        return m_pimpl->setModelAndSensors(_modelReduced,_sensorsReduced);
     }
 }
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/OriginElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/OriginElement.cpp`

 * *Files 24% similar despite different names*

```diff
@@ -1,17 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "OriginElement.h"
 
 #include "URDFParsingUtils.h"
 
 #include <iDynTree/XMLAttribute.h>
 
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/Transform.h>
 
 namespace iDynTree {
     OriginElement::OriginElement(
         XMLParserState& parserState,
         iDynTree::Transform& jointOrigin)
     : iDynTree::XMLElement(parserState, "origin")
     , m_jointOrigin(jointOrigin) {}
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/RobotElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/RobotElement.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "RobotElement.h"
 
 #include "LinkElement.h"
 #include "JointElement.h"
 #include "SensorElement.h"
 #include "MaterialElement.h"
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Sensors.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Sensors/Sensors.h>
 
 #include <unordered_set>
 
 namespace iDynTree {
 
     RobotElement::RobotElement(
         XMLParserState& parserState,
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/SensorElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/SensorElement.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,29 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "SensorElement.h"
 
 #include "OriginElement.h"
 #include "ForceTorqueSensorElement.h"
 
 #include <iDynTree/XMLAttribute.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/Sensors.h>
-#include <iDynTree/AccelerometerSensor.h>
-#include <iDynTree/GyroscopeSensor.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/AccelerometerSensor.h>
+#include <iDynTree/Sensors/GyroscopeSensor.h>
 
 
 namespace iDynTree {
 
     SensorHelper::SensorHelper(std::shared_ptr<const SensorElement::SensorInfo> sensorInfo)
     : m_sensorInfo(sensorInfo) {}
     SensorHelper::~SensorHelper() {}
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/URDFDocument.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/URDFDocument.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,31 +1,42 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "URDFDocument.h"
 #include "RobotElement.h"
 
-#include <iDynTree/PrismaticJoint.h>
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/ModelTransformers.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Model/PrismaticJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/Model/ModelTransformers.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
 
 #include <algorithm>
 #include <unordered_set>
 #include <vector>
 
 namespace iDynTree {
 
     // Functions local to the current compilation unit
     static std::unordered_set<std::string> processJoints(iDynTree::Model& model,
                                                          std::unordered_map<std::string, JointElement::JointInfo>& joints,
                                                          std::unordered_map<std::string, JointElement::JointInfo>& fixed_joints);
-    static bool processSensors(Model& model,
-                               const std::vector<std::shared_ptr<SensorHelper>>& helpers);
-    static bool addSensorFramesAsAdditionalFramesToModel(Model& model);
+    static bool processSensors(const Model& model,
+                               const std::vector<std::shared_ptr<SensorHelper>>& helpers,
+                               iDynTree::SensorsList& sensors);
+    static bool addSensorFramesAsAdditionalFramesToModel(Model& model,
+                                                         const SensorsList& sensors);
     static bool addVisualPropertiesToModel(const Model& model,
                                            const std::unordered_map<std::string, std::vector<VisualElement::VisualInfo>>& visuals,
                                            const std::unordered_map<std::string, MaterialElement::MaterialInfo>& materialDatabase,
                                            ModelSolidShapes &modelGeometries);
     
     URDFDocument::URDFDocument(XMLParserState& parserState)
     : XMLDocument(parserState) {}
@@ -35,15 +46,15 @@
     const iDynTree::Model& URDFDocument::model() const
     {
         return m_model;
     }
 
     const iDynTree::SensorsList& URDFDocument::sensors() const
     {
-        return m_model.sensors();
+        return m_sensors;
     }
     
     URDFDocument::~URDFDocument() {}
     std::shared_ptr<XMLElement> URDFDocument::rootElementForName(const std::string& name,
                                                                  const std::vector<std::string>& packageDirs)
     {
         // allowed tag is <robot>
@@ -123,23 +134,23 @@
         if (!createModelWithNormalizedJointNumbering(newModel, baseLinkName, normalizedModel)) {
             reportError("URDFDocument", "documentHasBeenParsed", "Failed to remove fake links from the model");
             return false;
         }
 
         m_model = normalizedModel;
 
-        if (!processSensors(m_model, m_buffers.sensorHelpers))
+        if (!processSensors(m_model, m_buffers.sensorHelpers, m_sensors))
         {
             //TODO: error
             return false;
         }
 
         if (m_options.addSensorFramesAsAdditionalFrames)
         {
-            if (!addSensorFramesAsAdditionalFramesToModel(m_model)) {
+            if (!addSensorFramesAsAdditionalFramesToModel(m_model, m_sensors)) {
                 //TODO: error
                 return false;
             }
         }
 
         // Assign visual properties to objects
         if (!addVisualPropertiesToModel(m_model,
@@ -206,47 +217,49 @@
             model.addJoint(jointName, joint.get());
             // save the child link name
             childLinks.insert(childLinkName);
         }
         return childLinks;
     }
 
-    bool processSensors(Model& model,
-                        const std::vector<std::shared_ptr<SensorHelper>>& helpers)
+    bool processSensors(const Model& model,
+                        const std::vector<std::shared_ptr<SensorHelper>>& helpers,
+                        iDynTree::SensorsList& sensors)
     {
-        model.sensors() = iDynTree::SensorsList();
+        sensors = iDynTree::SensorsList();
         for (auto& sensorHelper : helpers) {
             Sensor *sensor = sensorHelper->generateSensor(model);
             if (!sensor) {
                 // TODO: write error
                 // Clean sensor list
-                model.sensors() = iDynTree::SensorsList();
+                sensors = iDynTree::SensorsList();
                 return false;
             }
-            model.sensors().addSensor(*sensor);
+            sensors.addSensor(*sensor);
             delete sensor;
         }
         return true;
     }
 
-    bool addSensorFramesAsAdditionalFramesToModel(Model& model)
+    bool addSensorFramesAsAdditionalFramesToModel(Model& model,
+                                                  const SensorsList& sensors)
     {
         bool ret = true;
 
         // First, we cycle on all the sensor that are attached to a link, because their frame is easy to add
         // TODO : not super happy about this cycle, but is doing is work well
         for (SensorType type = SIX_AXIS_FORCE_TORQUE; type < NR_OF_SENSOR_TYPES; type = (SensorType)(type + 1))
         {
             // TODO : link sensor are extremly widespared and they have all approximatly the same API,
             //        so we need a better way to iterate over them
             if (isLinkSensor(type))
             {
-                for (size_t sensIdx = 0; sensIdx < model.sensors().getNrOfSensors(type); ++sensIdx)
+                for (size_t sensIdx = 0; sensIdx < sensors.getNrOfSensors(type); ++sensIdx)
                 {
-                    LinkSensor * linkSensor = dynamic_cast<LinkSensor*>(model.sensors().getSensor(type,sensIdx));
+                    LinkSensor * linkSensor = dynamic_cast<LinkSensor*>(sensors.getSensor(type,sensIdx));
                     if (!linkSensor) {
                         //TODO: error
                         return false;
                     }
 
                     LinkIndex linkToWhichTheSensorIsAttached = linkSensor->getParentLinkIndex();
                     std::string linkToWhichTheSensorIsAttachedName = model.getLinkName(linkToWhichTheSensorIsAttached);
@@ -267,17 +280,17 @@
             }
 
             // Explictly address the case of F/T sensors
             if (type == SIX_AXIS_FORCE_TORQUE)
             {
                 // We add the sensor frame as an additional frame of the **child** link
                 // (as tipically for URDF sensors the child link frame is coincident with the F/T sensor frame
-                for (size_t sensIdx = 0; sensIdx < model.sensors().getNrOfSensors(type); ++sensIdx)
+                for (size_t sensIdx = 0; sensIdx < sensors.getNrOfSensors(type); ++sensIdx)
                 {
-                    SixAxisForceTorqueSensor * ftSensor = dynamic_cast<SixAxisForceTorqueSensor*>(model.sensors().getSensor(type,sensIdx));
+                    SixAxisForceTorqueSensor * ftSensor = dynamic_cast<SixAxisForceTorqueSensor*>(sensors.getSensor(type,sensIdx));
 
                     std::string linkToWhichTheSensorIsAttachedName = ftSensor->getSecondLinkName();
 
                     if (!model.isFrameNameUsed(ftSensor->getName()))
                     {
                         Transform link_H_sensor;
                         bool ok = ftSensor->getLinkSensorTransform(ftSensor->getSecondLinkIndex(),link_H_sensor);
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/URDFModelExport.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/URDFModelExport.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,23 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Silvio Traversaro
+ * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ */
 
 #include "URDFModelExport.h"
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/VectorFixSize.h>
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/Indices.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/PrismaticJoint.h>
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/Traversal.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/VectorFixSize.h>
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/Indices.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/PrismaticJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/Model/Traversal.h>
 
 #include "URDFParsingUtils.h"
 
 
 #include <iomanip>
 #include <fstream>
 #include <string>
@@ -85,15 +87,15 @@
     xmlNodePtr mass_xml = xmlNewChild(inertial, NULL, BAD_CAST "mass", NULL);
     ok = ok && doubleToStringWithClassicLocale(inertia.getMass(), bufStr);
     xmlNewProp(mass_xml, BAD_CAST "value", BAD_CAST bufStr.c_str());
 
     ok = ok && exportTransform(Transform(Rotation::Identity(), inertia.getCenterOfMass()), inertial);
 
     xmlNodePtr inertia_xml = xmlNewChild(inertial, NULL, BAD_CAST "inertia", NULL);
-    RotationalInertia rotInertia = inertia.getRotationalInertiaWrtCenterOfMass();
+    RotationalInertiaRaw rotInertia = inertia.getRotationalInertiaWrtCenterOfMass();
     ok = ok && doubleToStringWithClassicLocale(rotInertia(0, 0), bufStr);
     xmlNewProp(inertia_xml, BAD_CAST "ixx", BAD_CAST bufStr.c_str());
     ok = ok && doubleToStringWithClassicLocale(rotInertia(0, 1), bufStr);
     xmlNewProp(inertia_xml, BAD_CAST "ixy", BAD_CAST bufStr.c_str());
     ok = ok && doubleToStringWithClassicLocale(rotInertia(0, 2), bufStr);
     xmlNewProp(inertia_xml, BAD_CAST "ixz", BAD_CAST bufStr.c_str());
     ok = ok && doubleToStringWithClassicLocale(rotInertia(1, 1), bufStr);
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/src/VisualElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/src/VisualElement.cpp`

 * *Files 19% similar despite different names*

```diff
@@ -1,18 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "VisualElement.h"
 
 #include "GeometryElement.h"
 #include "MaterialElement.h"
 #include "OriginElement.h"
 
 #include <iDynTree/XMLAttribute.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 namespace iDynTree {
 
     iDynTree::VisualElement::VisualInfo::VisualInfo(const std::vector<std::string>& packageDirs)
         : m_packageDirs(packageDirs)
     {
     }
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/tests/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/sensors/tests/CMakeLists.txt`

 * *Files 23% similar despite different names*

```diff
@@ -1,25 +1,18 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
-
-macro(add_modelio_urdf_unit_test classname)
+macro(add_unit_test classname)
     set(testsrc ${classname}UnitTest.cpp)
     set(testbinary ${classname}UnitTest)
     set(testname   UnitTest${classname})
     add_executable(${testbinary} ${testsrc})
-    target_link_libraries(${testbinary} PRIVATE idyntree-modelio idyntree-testmodels Eigen3::Eigen)
+    target_link_libraries(${testbinary} PRIVATE idyntree-sensors idyntree-testmodels Eigen3::Eigen)
     add_test(NAME ${testname} COMMAND ${testbinary})
 
     if(IDYNTREE_RUN_VALGRIND_TESTS)
         add_test(NAME memcheck_${testname} COMMAND ${MEMCHECK_COMMAND_COMPLETE} $<TARGET_FILE:${testbinary}>)
 
     endif()
-
 endmacro()
 
-add_modelio_urdf_unit_test(URDFModelImport)
-add_modelio_urdf_unit_test(ModelCalibrationHelper)
-add_modelio_urdf_unit_test(ModelExporter)
-add_modelio_urdf_unit_test(URDFGenericSensorImport)
-add_modelio_urdf_unit_test(PredictSensorsMeasurement)
-add_modelio_urdf_unit_test(icubSensorURDF)
+add_unit_test(SensorsList)
+add_unit_test(ThreeAxisForceTorqueContactSensor)
+add_unit_test(ReducedModelWithFT)
+target_link_libraries(ReducedModelWithFTUnitTest PRIVATE idyntree-high-level)
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/tests/ModelCalibrationHelperUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/tests/ModelCalibrationHelperUnitTest.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "testModels.h"
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/ModelCalibrationHelper.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelCalibrationHelper.h>
 
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 #include <algorithm>
 
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/tests/ModelExporterUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/tests/ModelExporterUnitTest.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Silvio Traversaro
+ * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ *
+ */
 
 #include "testModels.h"
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 
-#include <iDynTree/Model.h>
-#include <iDynTree/RevoluteJoint.h>
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/ModelExporter.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/RevoluteJoint.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelExporter.h>
 
 
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 #include <algorithm>
 #include <memory>
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/tests/PredictSensorsMeasurementUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/tests/PredictSensorsMeasurementUnitTest.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,32 +1,39 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iostream>
 
-# include <iDynTree/Sensors.h>
+# include <iDynTree/Sensors/Sensors.h>
 #include "testModels.h"
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/URDFDofsImport.h>
-#include <iDynTree/PredictSensorsMeasurements.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/FreeFloatingState.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/ModelIO/URDFDofsImport.h>
+#include <iDynTree/Sensors/PredictSensorsMeasurements.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 const double acclTestVal = 1.5;
 const double gyroTestVal = 1.5;
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 using namespace iDynTree;
 
 void init(std::string fileName, Model &model, Traversal &traversal,
-         SensorsMeasurements &predictedMeasurement)
+          SensorsList &sensorsList, SensorsMeasurements &predictedMeasurement)
 {
     // load URDF model
     ModelLoader loader;
     bool ok = loader.loadModelFromFile(fileName);
     model = loader.model();
     ASSERT_IS_TRUE(ok);
     std::cout<<"Model "<<fileName.c_str()<<" created with :"<<model.getNrOfDOFs()<<" DoFs"<<std::endl;
@@ -38,23 +45,24 @@
     ASSERT_EQUAL_STRING(model.getLinkName(model.getDefaultBaseLink()),"link1");
 
     ok = model.computeFullTreeTraversal(traversal);
 
     ASSERT_EQUAL_DOUBLE(ok,true);
 
     // Load sensorList
+    sensorsList = loader.sensors();
 
-    ASSERT_EQUAL_DOUBLE(loader.sensors().getNrOfSensors(ACCELEROMETER),2);
-    ASSERT_EQUAL_DOUBLE(loader.sensors().getNrOfSensors(GYROSCOPE),1);
+    ASSERT_EQUAL_DOUBLE(sensorsList.getNrOfSensors(ACCELEROMETER),2);
+    ASSERT_EQUAL_DOUBLE(sensorsList.getNrOfSensors(GYROSCOPE),1);
 
-    predictedMeasurement.resize(loader.sensors());
+    predictedMeasurement.resize(sensorsList);
 }
 
 void runTest(const int& expID,const Model& model,const Traversal& traversal,
-             SensorsMeasurements& predictedMeasurement)
+             const SensorsList& sensorsList, SensorsMeasurements& predictedMeasurement)
 {
     // quantities to be set according to experiment
     FreeFloatingPos robotPos(model);
     FreeFloatingVel robotVel(model);
     FreeFloatingAcc robotAcc(model);
     LinAcceleration gravity(0,0,0);
     LinkNetExternalWrenches externalWrenches(model);
@@ -88,15 +96,15 @@
         case 3 :gravity= LinearMotionVector3(0,0,0);
                 robotAcc.baseAcc() = SpatialAcc::Zero();
                 robotVel.jointVel()(0) = 0;
                 robotAcc.jointAcc()(0) = acclTestVal;
                 break;
     }
 
-    predictSensorsMeasurements(model,
+    predictSensorsMeasurements(model,sensorsList,
                                traversal,robotPos,robotVel,robotAcc,gravity,externalWrenches,
                                buf_properRobotAcc,buf_linkPos,buf_linkVel,buf_linkAcc,buf_internalWrenches,
                                buf_generalizedTorques,predictedMeasurement);
 
     predictedMeasurement.getMeasurement(ACCELEROMETER,0,accl1);
     predictedMeasurement.getMeasurement(ACCELEROMETER,1,accl2);
     predictedMeasurement.getMeasurement(GYROSCOPE,0,gyro1);
@@ -135,22 +143,23 @@
 }
 int main()
 {
     std::string fileName = getAbsModelPath("twoLinks.urdf");
     Model model;
     Traversal traversal;
 
+    SensorsList sensorsList;
     SensorsMeasurements predictedMeasurement;
-    init(fileName, model,traversal,predictedMeasurement);
+    init(fileName, model,traversal,sensorsList,predictedMeasurement);
 
     //experiments 1-accelerometer gravity test, 2-angularVelocity test, 3-angularAccelerationTest
 
     for(int expID=1;expID<4;expID++)
     {
-        runTest(expID,model,traversal,predictedMeasurement);
+        runTest(expID,model,traversal,sensorsList,predictedMeasurement);
     }
 
 
     std::cout<<"Finished all three experiments\n";
 
     return 0;
 }
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/tests/URDFGenericSensorImportUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/tests/URDFGenericSensorImportUnitTest.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/Sensors.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/Sensors/Sensors.h>
 #include "testModels.h"
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 #include <iostream>
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/tests/URDFModelImportUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/tests/URDFModelImportUnitTest.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "testModels.h"
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/URDFDofsImport.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/URDFDofsImport.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 #include <algorithm>
 
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/codecs/tests/icubSensorURDFUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model_io/codecs/tests/icubSensorURDFUnitTest.cpp`

 * *Files 11% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-# include <iDynTree/Sensors.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+# include <iDynTree/Sensors/Sensors.h>
 #include "testModels.h"
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/URDFDofsImport.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/ModelIO/URDFDofsImport.h>
 
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/AccelerometerSensor.h>
-#include <iDynTree/GyroscopeSensor.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Sensors/AccelerometerSensor.h>
+#include <iDynTree/Sensors/GyroscopeSensor.h>
 
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 #include <iostream>
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/double_root.xml` & `idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/double_root.xml`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/invalid_schema.xml` & `idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/invalid_schema.xml`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/invalid_xml.xml` & `idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/invalid_xml.xml`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/schema.xsd` & `idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/schema.xsd`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/model_io/tests/format_examples/xml/valid.xml` & `idyntree-9.1.1.dev7/src/model_io/tests/format_examples/xml/valid.xml`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/model_io/xml/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/model_io/xml/CMakeLists.txt`

 * *Files 17% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 set(IDYNTREE_MODELIO_XML_HEADERS include/iDynTree/XMLParser.h
                                  include/iDynTree/XMLElement.h
                                  include/iDynTree/XMLAttribute.h
                                  include/iDynTree/XMLDocument.h)
 
 set(IDYNTREE_MODELIO_XML_PRIVATE_HEADERS )
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/xml/include/iDynTree/XMLDocument.h` & `idyntree-9.1.1.dev7/src/model_io/xml/src/XMLDocument.cpp`

 * *Files 25% similar despite different names*

```diff
@@ -1,49 +1,64 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#ifndef IDYNTREE_MODELIO_XML_XMLDOCUMENT_H
-#define IDYNTREE_MODELIO_XML_XMLDOCUMENT_H
+#include "XMLDocument.h"
 
-#include <memory>
-#include <vector>
-#include <string>
+#include "XMLElement.h"
+
+#include <sstream>
 
 namespace iDynTree {
-    class XMLDocument;
-    class XMLElement;
-    class XMLParser;
-    class XMLParserState;
-}
+    
+    class XMLDocument::XMLDocumentPimpl
+    {
+    public:
+        std::shared_ptr<XMLElement> m_root;
+        XMLParserState& m_parserState;
+
+        explicit XMLDocumentPimpl(XMLParserState& parserState)
+        : m_parserState(parserState) {}
+    };
+    
+    XMLDocument::XMLDocument(XMLParserState& parserState)
+    : m_pimpl(new XMLDocumentPimpl(parserState)) {}
+    
+    XMLDocument::~XMLDocument() {}
+    
+    void XMLDocument::setRootElement(std::shared_ptr<XMLElement> root)
+    {
+        m_pimpl->m_root = root;
+    }
+    
+    const std::shared_ptr<XMLElement> XMLDocument::root() const
+    {
+        return m_pimpl->m_root;
+    }
+    
+    std::shared_ptr<XMLElement> XMLDocument::rootElementForName(const std::string& name,
+                                                                const std::vector<std::string>& packageDirs)
+    {
+        return std::make_shared<XMLElement>(m_pimpl->m_parserState, name);
+    }
 
-class iDynTree::XMLDocument {
-    class XMLDocumentPimpl;
-    std::unique_ptr<XMLDocumentPimpl> m_pimpl;
-    
-    friend class XMLParser;
-    void setRootElement(std::shared_ptr<XMLElement> root);
-    
-public:
-    
-    explicit XMLDocument(XMLParserState& parserState);
-    virtual ~XMLDocument();
-
-    /**
-     * Factory method to create the XML root element given for the specified name.
-     *
-     * @param name name of the element to create
-     * @return a new parser element for the corresponding tag
-     */
-    virtual std::shared_ptr<XMLElement> rootElementForName(const std::string& name,
-                                                           const std::vector<std::string>& packageDirs);
-
-    // TODO: find a better name
-    virtual bool documentHasBeenParsed();
-    
-    const std::shared_ptr<XMLElement> root() const;
-    std::string description() const;
-
-protected:
-    XMLParserState& getParserState();
-};
+    bool XMLDocument::documentHasBeenParsed() { return true; }
+    
+    std::string XMLDocument::description() const
+    {
+        std::ostringstream str;
+        if (m_pimpl->m_root) {
+            str << m_pimpl->m_root->description();
+        }
+        return str.str();
+    }
 
-#endif /* end of include guard: IDYNTREE_MODELIO_XML_XMLDOCUMENT_H */
+    XMLParserState& XMLDocument::getParserState() { return m_pimpl->m_parserState; }
+}
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/xml/include/iDynTree/XMLElement.h` & `idyntree-9.1.1.dev7/src/model_io/xml/include/iDynTree/XMLElement.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,9 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_XML_XMLELEMENT_H
 #define IDYNTREE_MODELIO_XML_XMLELEMENT_H
 
 #include <functional>
 #include <memory>
 #include <string>
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/xml/include/iDynTree/XMLParser.h` & `idyntree-9.1.1.dev7/src/model_io/xml/include/iDynTree/XMLParser.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODELIO_XML_XMLPARSER_H
 #define IDYNTREE_MODELIO_XML_XMLPARSER_H
 
 #include <functional>
 #include <memory>
 #include <mutex>
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/xml/src/XMLElement.cpp` & `idyntree-9.1.1.dev7/src/model_io/xml/src/XMLElement.cpp`

 * *Files 21% similar despite different names*

```diff
@@ -1,9 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "XMLElement.h"
 
 #include "XMLAttribute.h"
 
 #include <sstream>
 #include <unordered_map>
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/xml/src/XMLParser.cpp` & `idyntree-9.1.1.dev7/src/model_io/xml/src/XMLParser.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Author: Francesco Romano - Google LLC
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "XMLParser.h"
 
 #include "XMLElement.h"
 #include "XMLAttribute.h"
 #include "XMLDocument.h"
 
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <libxml/SAX2.h>
 #include <libxml/xmlschemas.h>
 
 #include <cassert>
 #include <iostream>
 #include <mutex>
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/xml/tests/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/model_io/xml/tests/CMakeLists.txt`

 * *Files 24% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 set(IDYNTREE_MODELIO_XML_DATAFILES ${IDYNTREE_MODELIO_TESTFILES_DIR}/xml)
 
 add_executable(XMLParserUnitTest XMLParserUnitTest.cpp)
 target_compile_definitions(XMLParserUnitTest PUBLIC -DIDYNTREE_TEST_FILES_DIR="${IDYNTREE_MODELIO_XML_DATAFILES}")
 
 target_link_libraries(XMLParserUnitTest PRIVATE idyntree-core idyntree-modelio-xml Eigen3::Eigen)
```

### Comparing `idyntree-9.1.1.dev66/src/model_io/xml/tests/XMLParserUnitTest.cpp` & `idyntree-9.1.1.dev7/src/model_io/xml/tests/XMLParserUnitTest.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <iDynTree/XMLParser.h>
 #include <iDynTree/XMLElement.h>
 #include <iDynTree/XMLAttribute.h>
 #include <iDynTree/XMLDocument.h>
 
 #include <iostream>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/optimalcontrol/CMakeLists.txt`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 set(libraryname idyntree-optimalcontrol)
 
 
 set(PUBLIC_HEADERS include/iDynTree/OptimalControl.h
                    include/iDynTree/DynamicalSystem.h
                    include/iDynTree/ControlledDynamicalSystem.h
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Constraint.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Constraint.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,29 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_CONSTRAINT_H
 #define IDYNTREE_OPTIMALCONTROL_CONSTRAINT_H
 
 #include <cstddef>
 #include <string>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 #include <iDynTree/SparsityStructure.h>
 
 namespace iDynTree {
 
     class MatrixDynSize;
 
     namespace optimalcontrol {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/ConstraintsGroup.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/ConstraintsGroup.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/ControlledDynamicalSystem.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/ControlledDynamicalSystem.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Controller.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Controller.h`

 * *Files 22% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Cost.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Cost.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/DynamicalSystem.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/DynamicalSystem.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,21 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_DYNAMICALSYSTEM_H
 #define IDYNTREE_OPTIMALCONTROL_DYNAMICALSYSTEM_H
 
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 #include <iDynTree/SparsityStructure.h>
 
 namespace iDynTree {
 
     class MatrixDynSize;
 
 namespace optimalcontrol {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrator.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrator.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_INTEGRATOR_H
 #define IDYNTREE_OPTIMALCONTROL_INTEGRATOR_H
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <iDynTree/SparsityStructure.h>
 #include <vector>
 #include <string>
 #include <memory>
 #include <map>
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/FixedStepIntegrator.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/FixedStepIntegrator.h`

 * *Files 11% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_FIXEDSTEPINTEGRATOR_H
 #define IDYNTREE_OPTIMALCONTROL_FIXEDSTEPINTEGRATOR_H
 
 #include <iDynTree/Integrator.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         class DynamicalSystem;
 
         namespace integrators {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/ForwardEuler.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/ForwardEuler.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,17 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
- * Originally developed for Prioritized Optimal Control (2014)
- * Refactored in 2018.
- * Design inspired by
- * - ACADO toolbox (http://acado.github.io)
- * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
- */
-
+* Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+*
+* Licensed under either the GNU Lesser General Public License v3.0 :
+* https://www.gnu.org/licenses/lgpl-3.0.html
+* or the GNU Lesser General Public License v2.1 :
+* https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+* at your option.
+*
+* Originally developed for Prioritized Optimal Control (2014)
+* Refactored in 2018.
+* Design inspired by
+* - ACADO toolbox (http://acado.github.io)
+* - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
+*/
 
 #ifndef IDYNTREE_OPTIMALCONTROL_FORWARDEULER_H
 #define IDYNTREE_OPTIMALCONTROL_FORWARDEULER_H
 
 #include <iDynTree/Integrators/FixedStepIntegrator.h>
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/ImplicitTrapezoidal.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/ImplicitTrapezoidal.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,17 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
- * Originally developed for Prioritized Optimal Control (2014)
- * Refactored in 2018.
- * Design inspired by
- * - ACADO toolbox (http://acado.github.io)
- * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
- */
-
+* Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+*
+* Licensed under either the GNU Lesser General Public License v3.0 :
+* https://www.gnu.org/licenses/lgpl-3.0.html
+* or the GNU Lesser General Public License v2.1 :
+* https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+* at your option.
+*
+* Originally developed for Prioritized Optimal Control (2014)
+* Refactored in 2018.
+* Design inspired by
+* - ACADO toolbox (http://acado.github.io)
+* - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
+*/
 
 #ifndef IDYNTREE_OPTIMALCONTROL_IMPLICITTRAPEZOIDAL_H
 #define IDYNTREE_OPTIMALCONTROL_IMPLICITTRAPEZOIDAL_H
 
 #include <iDynTree/Integrators/FixedStepIntegrator.h>
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Integrators/RK4.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Integrators/RK4.h`

 * *Files 24% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_RK4_H
 #define IDYNTREE_OPTIMALCONTROL_RK4_H
 
 #include <iDynTree/Integrators/FixedStepIntegrator.h>
 #include <Eigen/Sparse>
 #include <Eigen/Dense>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         class DynamicalSystem;
 
         namespace integrators {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/L2NormCost.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/L2NormCost.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 
 #ifndef IDYNTREE_OPTIMALCONTROL_L2NORMCOST_H
 #define IDYNTREE_OPTIMALCONTROL_L2NORMCOST_H
 
 #include <iDynTree/Cost.h>
 #include <iDynTree/TimeVaryingObject.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 #include <memory>
 #include <string>
 
 namespace iDynTree {
 
     class MatrixDynSize;
     class VectorDynSize;
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/LinearConstraint.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/LinearConstraint.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_LINEARCONSTRAINT_H
 #define IDYNTREE_OPTIMALCONTROL_LINEARCONSTRAINT_H
 
 #include <iDynTree/Constraint.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <iDynTree/TimeVaryingObject.h>
 #include <iDynTree/SparsityStructure.h>
 #include <string>
 #include <memory>
 
 namespace iDynTree {
     namespace optimalcontrol {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/LinearCost.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/LinearCost.h`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/LinearMPC.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/SystemLineariser.h`

 * *Files 23% similar despite different names*

```diff
@@ -1,30 +1,36 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
-#ifndef IDYNTREE_OPTIMALCONTROL_LINEAR_MPC_H
-#define IDYNTREE_OPTIMALCONTROL_LINEAR_MPC_H
+#ifndef IDYNTREE_OPTIMALCONTROL_SYSTEMLINEARISER_H
+#define IDYNTREE_OPTIMALCONTROL_SYSTEMLINEARISER_H
 
 namespace iDynTree {
     namespace optimalcontrol {
 
+
         /**
          * @warning This class is still in active development, and so API interface can change between iDynTree versions.
          * \ingroup iDynTreeExperimental
          */
 
-        class LinearMPC {
-
+        class SystemLineariser {
 
         };
 
     }
 }
 
-#endif /* end of include guard: IDYNTREE_OPTIMALCONTROL_LINEAR_MPC_H */
+#endif /* end of include guard: IDYNTREE_OPTIMALCONTROL_SYSTEMLINEARISER_H */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/LinearSystem.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/LinearSystem.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/MPC.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/MPC.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OCSolvers/MultipleShootingSolver.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OCSolvers/MultipleShootingSolver.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OptimalControl.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OptimalControl.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OptimalControlProblem.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OptimalControlProblem.h`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,31 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_OPTIMALCONTROLPROBLEM_H
 #define IDYNTREE_OPTIMALCONTROL_OPTIMALCONTROLPROBLEM_H
 
 #include <memory>
 #include <vector>
 #include <string>
 
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 #include <iDynTree/SparsityStructure.h>
 #include <iDynTree/TimeVaryingObject.h>
 
 
 namespace iDynTree {
 
     class VectorDynSize;
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OptimalControlSolver.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OptimalControlSolver.h`

 * *Files 13% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/OptimizationProblem.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/OptimizationProblem.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizer.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizer.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/AlglibInterface.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/AlglibInterface.h`

 * *Files 13% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/IpoptInterface.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/IpoptInterface.h`

 * *Files 19% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/OsqpInterface.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/OsqpInterface.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/Optimizers/WorhpInterface.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/Optimizers/WorhpInterface.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/QuadraticCost.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/QuadraticCost.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_QUADRATICCOST_H
 #define IDYNTREE_OPTIMALCONTROL_QUADRATICCOST_H
 
 #include <iDynTree/QuadraticLikeCost.h>
 #include <iDynTree/TimeVaryingObject.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <memory>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
        /**
         * @warning This class is still in active development, and so API interface can change between iDynTree versions.
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/QuadraticLikeCost.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/QuadraticLikeCost.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/SparsityStructure.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/SparsityStructure.h`

 * *Files 20% similar despite different names*

```diff
@@ -1,21 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #ifndef IDYNTREE_OPTIMALCONTROL_SPARSITYSTRUCTURE_H
 #define IDYNTREE_OPTIMALCONTROL_SPARSITYSTRUCTURE_H
 
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 #include <vector>
 #include <cstddef>
 #include <unordered_set>
 #include <string>
 
 namespace iDynTree {
     namespace optimalcontrol {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/TimeRange.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/TimeRange.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/include/iDynTree/TimeVaryingObject.h` & `idyntree-9.1.1.dev7/src/optimalcontrol/include/iDynTree/TimeVaryingObject.h`

 * *Files 14% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 
 #ifndef IDYNTREE_OPTIMALCONTROL_TIMEVARYINGOBJECT_H
 #define IDYNTREE_OPTIMALCONTROL_TIMEVARYINGOBJECT_H
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Transform.h>
 
 namespace iDynTree {
 
     namespace optimalcontrol {
 
         /**
          * @warning This class is still in active development, and so API interface can change between iDynTree versions.
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/AlglibInterface.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/AlglibInterface.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,31 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Optimizers/AlglibInterface.h>
 
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <optimization.h>
 #include <stdafx.h>
 
 #include <cassert>
 #include <map>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/AlglibInterfaceNotImplemented.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/AlglibInterfaceNotImplemented.cpp`

 * *Files 24% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Optimizers/AlglibInterface.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 using namespace iDynTree::optimization;
 using namespace iDynTree;
 
 AlglibInterface::AlglibInterface()
 {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/Constraint.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/Constraint.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Constraint.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 
 #include <cassert>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         Constraint::Constraint(size_t size, const std::string name)
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/ConstraintsGroup.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/ConstraintsGroup.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,31 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
 #include <iDynTree/ConstraintsGroup.h>
 #include <iDynTree/Constraint.h>
 #include <iDynTree/LinearConstraint.h>
 #include <iDynTree/TimeRange.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <Eigen/Dense>
 #include <vector>
 #include <unordered_map>
 #include <algorithm>
 #include <cassert>
 #include <sstream>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/ControlledDynamicalSystem.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/ControlledDynamicalSystem.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/ControlledDynamicalSystem.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 #include <cassert>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         class DerivedDynamicalSystem : public DynamicalSystem {
             std::shared_ptr<DynamicalSystem> m_autonomousSystem;
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/Controller.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/Controller.cpp`

 * *Files 27% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/Cost.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/Cost.cpp`

 * *Files 21% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Cost.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 #include <sstream>
 
 namespace iDynTree {
     namespace optimalcontrol{
         Cost::Cost(const std::string &costName)
             :m_costName(costName)
         { }
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/DynamicalSystem.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/DynamicalSystem.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/DynamicalSystem.h>
 #include <iDynTree/Controller.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <cstddef>
 
 
 namespace iDynTree {
     namespace optimalcontrol {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/FixedStepIntegrator.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/FixedStepIntegrator.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,21 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Integrators/FixedStepIntegrator.h>
 #include <iDynTree/DynamicalSystem.h>
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/Utils.h>
 #include <stdio.h>
 #include <math.h>
 #include <sstream>
 #include <string>
 
 
 namespace iDynTree {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/ForwardEuler.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/ForwardEuler.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,24 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Integrators/ForwardEuler.h>
 #include <iDynTree/DynamicalSystem.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree {
     namespace optimalcontrol {
         namespace integrators {
 
             bool ForwardEuler::allocateBuffers()
             {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/ImplicitTrapezoidal.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/ImplicitTrapezoidal.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Integrators/ImplicitTrapezoidal.h>
 #include <iDynTree/DynamicalSystem.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <cstddef>
 #include <sstream>
 #include <string>
 
 namespace iDynTree {
     namespace optimalcontrol {
         namespace integrators {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/Integrator.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/Integrator.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Integrator.h>
 #include <iDynTree/DynamicalSystem.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cassert>
 #include <cstddef>
 #include <sstream>
 
 namespace iDynTree {
     namespace optimalcontrol {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/IpoptInterface.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/IpoptInterface.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 #ifndef HAVE_STDDEF_H
@@ -24,20 +30,20 @@
     #else
         #include <IpTNLP.hpp>
     #endif
 #endif
 #include <IpIpoptApplication.hpp>
 
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <iDynTree/Optimizers/IpoptInterface.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <cassert>
 #include <ostream>
 
 namespace iDynTree {
     namespace optimization {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/IpoptInterfaceNotImplemented.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/IpoptInterfaceNotImplemented.cpp`

 * *Files 13% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Optimizers/IpoptInterface.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 using namespace iDynTree::optimization;
 using namespace iDynTree;
 
 IpoptInterface::IpoptInterface()
 {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/L2NormCost.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/L2NormCost.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,31 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/L2NormCost.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/Span.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/Span.h>
 #include <cassert>
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
     //
     // Implementation of selector matrix
     //
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/LinearConstraint.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/LinearConstraint.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/LinearConstraint.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cassert>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         class LinearConstraint::LinearConstraintImplementation {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/LinearCost.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/LinearCost.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/LinearCost.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         LinearCost::LinearCost(const std::string &costName)
             : QuadraticLikeCost(costName)
         {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/LinearSystem.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/LinearSystem.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,29 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/LinearSystem.h>
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <cassert>
 #include <cstddef>
 
 namespace iDynTree {
     namespace optimalcontrol {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/MultipleShootingSolver.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/MultipleShootingSolver.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
@@ -13,19 +19,19 @@
 #include <iDynTree/SparsityStructure.h>
 #include <iDynTree/OptimalControlProblem.h>
 #include <iDynTree/DynamicalSystem.h>
 #include <iDynTree/Integrator.h>
 #include <iDynTree/TimeRange.h>
 #include <iDynTree/OptimizationProblem.h>
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include <cassert>
 #include <algorithm>
 #include <cmath>
 #include <string>
 #include <sstream>
 #include <map>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/OptimalControlProblem.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/OptimalControlProblem.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
@@ -16,19 +22,19 @@
 #include <iDynTree/LinearConstraint.h>
 #include <iDynTree/Cost.h>
 #include <iDynTree/QuadraticLikeCost.h>
 #include <iDynTree/QuadraticCost.h>
 #include <iDynTree/L2NormCost.h>
 #include <iDynTree/LinearCost.h>
 #include <iDynTree/TimeRange.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <Eigen/Dense>
 
 #include <map>
 #include <cassert>
 #include <sstream>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/OptimalControlSolver.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/OptimalControlSolver.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/OptimalControlSolver.h>
 
 #include <iDynTree/OptimalControlProblem.h>
 
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
 #include <cassert>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         OptimalControlSolver::OptimalControlSolver(const std::shared_ptr<OptimalControlProblem> ocProblem) {}
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/OptimizationProblem.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/OptimizationProblem.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/OptimizationProblem.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 namespace iDynTree {
 
     namespace optimization {
 
         OptimizationProblem::OptimizationProblem()
         :m_infoData(new OptimizationProblemInfoData)
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/OsqpInterface.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/OsqpInterface.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,32 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Optimizers/OsqpInterface.h>
 
 #include <Eigen/Dense>
 #include <Eigen/Sparse>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <cassert>
 #include <ostream>
 
 #include <OsqpEigen/OsqpEigen.h>
 
 #include <vector>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/OsqpInterfaceNotImplemented.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/OsqpInterfaceNotImplemented.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Optimizers/OsqpInterface.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 
 using namespace iDynTree::optimization;
 using namespace iDynTree;
 
 OsqpInterface::OsqpInterface()
 { }
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/QuadraticCost.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/QuadraticCost.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,21 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/QuadraticCost.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <cmath>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         QuadraticCost::QuadraticCost(const std::string &costName)
             : QuadraticLikeCost(costName)
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/QuadraticLikeCost.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/QuadraticLikeCost.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/QuadraticLikeCost.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <cmath>
 
 namespace iDynTree {
     namespace optimalcontrol {
 
         QuadraticLikeCost::QuadraticLikeCost(const std::string &costName)
             : Cost(costName)
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/RK4.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/RK4.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Integrators/RK4.h>
 #include <iDynTree/DynamicalSystem.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 namespace iDynTree {
     namespace optimalcontrol {
         namespace integrators {
             RK4::RK4(const std::shared_ptr<iDynTree::optimalcontrol::DynamicalSystem> dynamicalSystem) : FixedStepIntegrator(dynamicalSystem){
                 m_infoData->isExplicit = true;
                 m_infoData->numberOfStages = 4;
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/SparsityStructure.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/SparsityStructure.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/SparsityStructure.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 #include <cassert>
 
 void iDynTree::optimalcontrol::SparsityStructure::addNonZero(size_t row, size_t col)
 {
     m_nonZeroElementRows.push_back(row);
     m_nonZeroElementColumns.push_back(col);
     m_register.insert(std::to_string(row) + "_" + std::to_string(col));
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/TimeRange.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/TimeRange.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/TimeRange.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 namespace iDynTree {
     namespace optimalcontrol {
         TimeRange::TimeRange()
         :m_initTime(0.0)
         ,m_endTime(0.0)
         ,m_anyTime(false)
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/TimeVaryingObject.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/TimeVaryingObject.cpp`

 * *Files 27% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/WorhpInterface.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/WorhpInterface.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Optimizers/WorhpInterface.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/Triplets.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/Triplets.h>
 #include <worhp/worhp.h>
 #include <algorithm>
 #include <unordered_map>
 
 using namespace iDynTree::optimization;
 
 typedef struct {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/src/WorhpInterfaceNotImplemented.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/src/WorhpInterfaceNotImplemented.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,19 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/Optimizers/WorhpInterface.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/Utils.h>
 
 using namespace iDynTree::optimization;
 using namespace iDynTree;
 
 
 WorhpInterface::WorhpInterface()
 {
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/AlglibInterfaceTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/AlglibInterfaceTest.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 #include <iDynTree/OptimizationProblem.h>
 #include <iDynTree/Optimizers/AlglibInterface.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <vector>
 #include <memory>
 
 class TestProblem : public iDynTree::optimization::OptimizationProblem {
     double m_a1, m_b1, m_c1;
     double m_a2, m_b2, m_c2;
     double m_plusInfinity, m_minusInfinity;
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/ConstraintsGroupTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/ConstraintsGroupTest.cpp`

 * *Files 25% similar despite different names*

```diff
@@ -1,22 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 #include <iDynTree/Constraint.h>
 #include <iDynTree/LinearConstraint.h>
 #include <iDynTree/ConstraintsGroup.h>
 #include <iDynTree/TimeRange.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/TestUtils.h>
 #include <memory>
 
 using namespace iDynTree;
 using namespace iDynTree::optimalcontrol;
 
 class DummyConstraint1 : public Constraint{
 public:
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/IntegratorsTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/IntegratorsTest.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,20 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/DynamicalSystem.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/VectorDynSize.h>
 #include <iDynTree/Integrator.h>
 #include <iDynTree/Integrators/RK4.h>
 #include <iDynTree/Integrators/ForwardEuler.h>
 #include <iDynTree/Controller.h>
 #include <memory>
 #include <cmath>
 #include <iostream>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/IpoptInterfaceTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/WorhpInterfaceTest.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,23 +1,29 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/OptimizationProblem.h>
-#include <iDynTree/Optimizers/IpoptInterface.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Optimizers/WorhpInterface.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <vector>
 #include <memory>
 
 class TestProblem : public iDynTree::optimization::OptimizationProblem {
     double m_a1, m_b1, m_c1;
     double m_a2, m_b2, m_c2;
     double m_plusInfinity, m_minusInfinity;
@@ -189,31 +195,33 @@
             m_expectedVariables(1) = m_c2;
 
         return m_expectedVariables;
     }
 };
 
 int main(){
-    iDynTree::optimization::IpoptInterface ipoptSolver;
+    iDynTree::optimization::WorhpInterface worhpSolver;
     std::shared_ptr<TestProblem> problem(new TestProblem);
     iDynTree::VectorDynSize guess(2), dummy1, dummy2, dummy3;
     guess.zero();
 
-    ASSERT_IS_TRUE(ipoptSolver.setIpoptOption("nlp_lower_bound_inf", -1.0e20));
-    ASSERT_IS_TRUE(ipoptSolver.setIpoptOption("print_level", 0));
+    ASSERT_IS_TRUE(worhpSolver.setWorhpParam("AcceptTolOpti", 1e-6));
+    ASSERT_IS_TRUE(worhpSolver.setWorhpParam("AcceptTolFeas", 1e-6));
+    ASSERT_IS_TRUE(worhpSolver.setWorhpParam("Algorithm", 2));
+    ASSERT_IS_TRUE(worhpSolver.setWorhpParam("NLPprint", -1));
 
-    ASSERT_IS_TRUE(problem->setMinusInfinity(ipoptSolver.minusInfinity()));
-    ASSERT_IS_TRUE(problem->setPlusInfinity(ipoptSolver.plusInfinity()));
-    ASSERT_IS_TRUE(ipoptSolver.setProblem(problem));
-    double testTolerance = 5e-5;
+
+    ASSERT_IS_TRUE(problem->setMinusInfinity(worhpSolver.minusInfinity()));
+    ASSERT_IS_TRUE(problem->setPlusInfinity(worhpSolver.plusInfinity()));
+    ASSERT_IS_TRUE(worhpSolver.setProblem(problem));
     for (int i = 0; i < 5; ++i){
-        ASSERT_IS_TRUE(ipoptSolver.solve());
+        ASSERT_IS_TRUE(worhpSolver.solve());
         double optimalCost;
-        ASSERT_IS_TRUE(ipoptSolver.getOptimalCost(optimalCost));
-        ASSERT_EQUAL_DOUBLE_TOL(optimalCost, problem->expectedMinimum(), testTolerance);
+        ASSERT_IS_TRUE(worhpSolver.getOptimalCost(optimalCost));
+        ASSERT_EQUAL_DOUBLE_TOL(optimalCost, problem->expectedMinimum(), 1e-5);
         iDynTree::VectorDynSize solution;
-        ASSERT_IS_TRUE(ipoptSolver.getPrimalVariables(solution));
-        ASSERT_EQUAL_VECTOR_TOL(solution, problem->expectedVariables(), testTolerance);
-        ASSERT_IS_TRUE(ipoptSolver.getDualVariables(dummy1, dummy2, dummy3));
+        ASSERT_IS_TRUE(worhpSolver.getPrimalVariables(solution));
+        ASSERT_EQUAL_VECTOR_TOL(solution, problem->expectedVariables(), 1e-5);
+        ASSERT_IS_TRUE(worhpSolver.getDualVariables(dummy1, dummy2, dummy3));
     }
     return EXIT_SUCCESS;
 }
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/L2NormTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/L2NormTest.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,18 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ * Authors: Stefano Dafarra
+ * CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
+ *
+ */
 
 #include <iDynTree/L2NormCost.h>
 #include <iDynTree/TimeVaryingObject.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <memory>
 
 int main() {
 
     iDynTree::VectorDynSize state(5), desiredStateValue(2), control(10);
     iDynTree::IndexRange stateRange, controlRange;
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/LinearOCOsqpTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/LinearOCOsqpTest.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <iDynTree/LinearSystem.h>
 #include <iDynTree/L2NormCost.h>
 #include <iDynTree/LinearConstraint.h>
 #include <iDynTree/ConstraintsGroup.h>
 #include <iDynTree/TimeRange.h>
 #include <iDynTree/Integrators/ForwardEuler.h>
 #include <iDynTree/OCSolvers/MultipleShootingSolver.h>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/MultipleShootingTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/MultipleShootingTest.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
@@ -12,22 +18,22 @@
 #include <iDynTree/ConstraintsGroup.h>
 #include <iDynTree/DynamicalSystem.h>
 #include <iDynTree/Constraint.h>
 #include <iDynTree/Cost.h>
 #include <iDynTree/Optimizer.h>
 #include <iDynTree/OCSolvers/MultipleShootingSolver.h>
 #include <iDynTree/DynamicalSystem.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Utils.h>
 #include <iDynTree/Integrators/ForwardEuler.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <iDynTree/TimeRange.h>
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <string>
 
 class TestSystem : public iDynTree::optimalcontrol::DynamicalSystem {
 public:
     TestSystem() : iDynTree::optimalcontrol::DynamicalSystem(2,3) {}
     ~TestSystem() override;
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/OCProblemTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/OCProblemTest.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,29 +1,35 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/OptimalControlProblem.h>
 #include <iDynTree/DynamicalSystem.h>
 #include <iDynTree/Constraint.h>
 #include <iDynTree/Cost.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <iDynTree/ConstraintsGroup.h>
 #include <iDynTree/TimeRange.h>
 #include <Eigen/Dense>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 #include <string>
 
 class TestSystem : public iDynTree::optimalcontrol::DynamicalSystem {
 public:
     TestSystem() : iDynTree::optimalcontrol::DynamicalSystem(2,3) {}
     ~TestSystem() override;
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/OptimalControlIpoptTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/OptimalControlIpoptTest.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,27 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
-#include <iDynTree/Utils.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <iDynTree/DynamicalSystem.h>
 #include <iDynTree/Cost.h>
 #include <iDynTree/Constraint.h>
 #include <iDynTree/ConstraintsGroup.h>
 #include <iDynTree/TimeRange.h>
 #include <iDynTree/Integrators/ForwardEuler.h>
 #include <iDynTree/OCSolvers/MultipleShootingSolver.h>
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/OptimalControlTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/OptimalControlTest.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,14 +1,12 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 
 // TODO: change this to correct include
 #include <iDynTree/OptimalControl.h>
 
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 
 int main()
 {
     using namespace iDynTree;
     using namespace iDynTree::optimalcontrol;
 
     // Linear OC problemm with constraints
```

### Comparing `idyntree-9.1.1.dev66/src/optimalcontrol/tests/WorhpInterfaceTest.cpp` & `idyntree-9.1.1.dev7/src/optimalcontrol/tests/IpoptInterfaceTest.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,23 +1,29 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
 /*
+ * Copyright (C) 2014,2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ *
  * Originally developed for Prioritized Optimal Control (2014)
  * Refactored in 2018.
  * Design inspired by
  * - ACADO toolbox (http://acado.github.io)
  * - ADRL Control Toolbox (https://adrlab.bitbucket.io/ct/ct_doc/doc/html/index.html)
  */
 
 #include <iDynTree/OptimizationProblem.h>
-#include <iDynTree/Optimizers/WorhpInterface.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
+#include <iDynTree/Optimizers/IpoptInterface.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
 #include <vector>
 #include <memory>
 
 class TestProblem : public iDynTree::optimization::OptimizationProblem {
     double m_a1, m_b1, m_c1;
     double m_a2, m_b2, m_c2;
     double m_plusInfinity, m_minusInfinity;
@@ -189,33 +195,31 @@
             m_expectedVariables(1) = m_c2;
 
         return m_expectedVariables;
     }
 };
 
 int main(){
-    iDynTree::optimization::WorhpInterface worhpSolver;
+    iDynTree::optimization::IpoptInterface ipoptSolver;
     std::shared_ptr<TestProblem> problem(new TestProblem);
     iDynTree::VectorDynSize guess(2), dummy1, dummy2, dummy3;
     guess.zero();
 
-    ASSERT_IS_TRUE(worhpSolver.setWorhpParam("AcceptTolOpti", 1e-6));
-    ASSERT_IS_TRUE(worhpSolver.setWorhpParam("AcceptTolFeas", 1e-6));
-    ASSERT_IS_TRUE(worhpSolver.setWorhpParam("Algorithm", 2));
-    ASSERT_IS_TRUE(worhpSolver.setWorhpParam("NLPprint", -1));
+    ASSERT_IS_TRUE(ipoptSolver.setIpoptOption("nlp_lower_bound_inf", -1.0e20));
+    ASSERT_IS_TRUE(ipoptSolver.setIpoptOption("print_level", 0));
 
-
-    ASSERT_IS_TRUE(problem->setMinusInfinity(worhpSolver.minusInfinity()));
-    ASSERT_IS_TRUE(problem->setPlusInfinity(worhpSolver.plusInfinity()));
-    ASSERT_IS_TRUE(worhpSolver.setProblem(problem));
+    ASSERT_IS_TRUE(problem->setMinusInfinity(ipoptSolver.minusInfinity()));
+    ASSERT_IS_TRUE(problem->setPlusInfinity(ipoptSolver.plusInfinity()));
+    ASSERT_IS_TRUE(ipoptSolver.setProblem(problem));
+    double testTolerance = 5e-5;
     for (int i = 0; i < 5; ++i){
-        ASSERT_IS_TRUE(worhpSolver.solve());
+        ASSERT_IS_TRUE(ipoptSolver.solve());
         double optimalCost;
-        ASSERT_IS_TRUE(worhpSolver.getOptimalCost(optimalCost));
-        ASSERT_EQUAL_DOUBLE_TOL(optimalCost, problem->expectedMinimum(), 1e-5);
+        ASSERT_IS_TRUE(ipoptSolver.getOptimalCost(optimalCost));
+        ASSERT_EQUAL_DOUBLE_TOL(optimalCost, problem->expectedMinimum(), testTolerance);
         iDynTree::VectorDynSize solution;
-        ASSERT_IS_TRUE(worhpSolver.getPrimalVariables(solution));
-        ASSERT_EQUAL_VECTOR_TOL(solution, problem->expectedVariables(), 1e-5);
-        ASSERT_IS_TRUE(worhpSolver.getDualVariables(dummy1, dummy2, dummy3));
+        ASSERT_IS_TRUE(ipoptSolver.getPrimalVariables(solution));
+        ASSERT_EQUAL_VECTOR_TOL(solution, problem->expectedVariables(), testTolerance);
+        ASSERT_IS_TRUE(ipoptSolver.getDualVariables(dummy1, dummy2, dummy3));
     }
     return EXIT_SUCCESS;
 }
```

### Comparing `idyntree-9.1.1.dev66/src/solid-shapes/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/solid-shapes/CMakeLists.txt`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,7 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
 set(libraryname idyntree-solid-shapes)
 
 set(IDYNTREE_SOLID_SHAPES_SOURCES src/InertialParametersSolidShapesHelpers.cpp
                                   src/ModelTransformersSolidShapes.cpp)
 set(IDYNTREE_SOLID_SHAPES_HEADERS include/iDynTree/InertialParametersSolidShapesHelpers.h
                                   include/iDynTree/ModelTransformersSolidShapes.h)
```

### Comparing `idyntree-9.1.1.dev66/src/solid-shapes/include/iDynTree/InertialParametersSolidShapesHelpers.h` & `idyntree-9.1.1.dev7/src/solid-shapes/include/iDynTree/InertialParametersSolidShapesHelpers.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_INERTIAL_PARAMETERS_HELPERS_H
 #define IDYNTREE_INERTIAL_PARAMETERS_HELPERS_H
 
-#include <iDynTree/Model.h>
-#include <iDynTree/SolidShapes.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/SolidShapes.h>
 
 namespace iDynTree
 {
 
 /**
  * @brief Estimate the inertial parameters of a model using link bounding boxes and the total mass.
  *
```

### Comparing `idyntree-9.1.1.dev66/src/solid-shapes/include/iDynTree/ModelTransformersSolidShapes.h` & `idyntree-9.1.1.dev7/src/solid-shapes/include/iDynTree/ModelTransformersSolidShapes.h`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,11 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
+/*
+ * SPDX-FileCopyrightText: 2021 Istituto Italiano di Tecnologia (IIT)
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
 
 
 /**
  * \file ModelTransformersSolidShapes.h
  *  \brief Collection of function to modify model, related to solid shapes.
  *
 */
```

### Comparing `idyntree-9.1.1.dev66/src/solid-shapes/src/InertialParametersSolidShapesHelpers.cpp` & `idyntree-9.1.1.dev7/src/solid-shapes/src/InertialParametersSolidShapesHelpers.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,19 +1,26 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <iDynTree/InertialParametersSolidShapesHelpers.h>
 
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/SpatialInertia.h>
-#include <iDynTree/Utils.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/VectorFixSize.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/SpatialInertia.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/VectorFixSize.h>
 
-#include <iDynTree/SolidShapes.h>
+#include <iDynTree/Model/SolidShapes.h>
 
 #ifdef IDYNTREE_USES_ASSIMP
 #include <assimp/Importer.hpp>
 #include <assimp/scene.h>
 #endif
 
 namespace iDynTree
@@ -23,18 +30,18 @@
 // This should be eventually be moved to be methods of the Box class
 SpatialInertia boxGet6DInertiaInLinkFrameFromDensity(const Box& box,
                                                      double density)
 {
     double boxVolume = box.getX() * box.getY() * box.getZ();
     double boxMass   = density*boxVolume;
     // Assuming uniform density, the center of mass is coincident with the box center
-    Position comInGeomFrame;
+    PositionRaw comInGeomFrame;
     comInGeomFrame.zero();
     // From http://scienceworld.wolfram.com/physics/MomentofInertiaRectangularParallelepiped.html
-    RotationalInertia rotInertiaInGeomFrame;
+    RotationalInertiaRaw rotInertiaInGeomFrame;
     rotInertiaInGeomFrame.zero();
     double x2 = box.getX() * box.getX();
     double y2 = box.getY() * box.getY();
     double z2 = box.getZ() * box.getZ();
     rotInertiaInGeomFrame(0, 0) = (boxMass/12.0)*(y2+z2);
     rotInertiaInGeomFrame(1, 1) = (boxMass/12.0)*(x2+z2);
     rotInertiaInGeomFrame(2, 2) = (boxMass/12.0)*(x2+y2);
```

### Comparing `idyntree-9.1.1.dev66/src/solid-shapes/src/ModelTransformersSolidShapes.cpp` & `idyntree-9.1.1.dev7/src/solid-shapes/src/ModelTransformersSolidShapes.cpp`

 * *Files 11% similar despite different names*

```diff
@@ -1,14 +1,15 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
+/*
+ * SPDX-FileCopyrightText: 2021 Istituto Italiano di Tecnologia (IIT)
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
 
 #include <iDynTree/ModelTransformersSolidShapes.h>
 
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Model.h>
 #include <iDynTree/InertialParametersSolidShapesHelpers.h>
 
 #include <cassert>
 #include <set>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/solid-shapes/tests/InertialParametersSolidShapesHelpersIntegrationTest.cpp` & `idyntree-9.1.1.dev7/src/solid-shapes/tests/InertialParametersSolidShapesHelpersIntegrationTest.cpp`

 * *Files 7% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 
 #include <iDynTree/InertialParametersSolidShapesHelpers.h>
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Model/Model.h>
 
 
 using namespace iDynTree;
 
 void checkOneCubeVsEightSmallCubes()
 {
     // Create a model with one shape with one cube of 1 meter of side,
```

### Comparing `idyntree-9.1.1.dev66/src/solid-shapes/tests/ModelTransformersSolidShapesIntegrationTest.cpp` & `idyntree-9.1.1.dev7/src/solid-shapes/tests/ModelTransformersSolidShapesIntegrationTest.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,18 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * SPDX-FileCopyrightText: 2021 Istituto Italiano di Tecnologia (IIT)
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
 
-
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 
 #include <iDynTree/ModelTransformersSolidShapes.h>
 
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Model/Model.h>
 
 
 using namespace iDynTree;
 
 void checkThatOneSphereIsApproximatedToABox()
 {
     // Create a model with one shape with one sphere, and
```

### Comparing `idyntree-9.1.1.dev66/src/tests/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/tests/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/benchmark/DynamicsBenchmark.cpp` & `idyntree-9.1.1.dev7/src/tests/benchmark/DynamicsBenchmark.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,39 +1,46 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "testModels.h"
 
 // KDL related includes
 #include <kdl_codyco/position_loops.hpp>
 #include <kdl_codyco/rnea_loops.hpp>
 #include <kdl_codyco/crba_loops.hpp>
 #include <kdl_codyco/undirectedtree.hpp>
 #include <kdl_codyco/KDLConversions.h>
 
-#include <iDynTree/impl/urdf_import.hpp>
+#include <iDynTree/ModelIO/impl/urdf_import.hpp>
 
 // iDynTree includes
-#include <iDynTree/Model.h>
-#include <iDynTree/FixedJoint.h>
-#include <iDynTree/RevoluteJoint.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/FixedJoint.h>
+#include <iDynTree/Model/RevoluteJoint.h>
 
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Dynamics.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Dynamics.h>
 
-#include <iDynTree/LinkState.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/FreeFloatingMatrices.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/FreeFloatingMatrices.h>
 
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 using namespace iDynTree;
 
 #include <ctime>
 
 /**
  * Return the current time in seconds, with respect
```

### Comparing `idyntree-9.1.1.dev66/src/tests/data/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/tests/data/CMakeLists.txt`

 * *Files 16% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 
 # This folder contains resources useful for testing (such as URDF files)
 # that are copied in all the test directories
 
 # if you add a file to this list, please
 # remember to add it also in the
```

### Comparing `idyntree-9.1.1.dev66/src/tests/data/bigman.urdf` & `idyntree-9.1.1.dev7/src/tests/data/bigman.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/cube.stl` & `idyntree-9.1.1.dev7/src/tests/data/cube.stl`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/frame.urdf` & `idyntree-9.1.1.dev7/src/tests/data/frame.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/iCubDarmstadt01.urdf` & `idyntree-9.1.1.dev7/src/tests/data/iCubDarmstadt01.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/iCubGenova02.urdf` & `idyntree-9.1.1.dev7/src/tests/data/iCubGenova02.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/icalibrate.urdf` & `idyntree-9.1.1.dev7/src/tests/data/icalibrate.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/icub.urdf` & `idyntree-9.1.1.dev7/src/tests/data/icub.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/icub2BB5Sea.urdf` & `idyntree-9.1.1.dev7/src/tests/data/icub2BB5Sea.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/icubTwoLinks.urdf` & `idyntree-9.1.1.dev7/src/tests/data/icubTwoLinks.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/icub_model.urdf` & `idyntree-9.1.1.dev7/src/tests/data/icub_model.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/icub_sensorised.urdf` & `idyntree-9.1.1.dev7/src/tests/data/icub_sensorised.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/icub_skin_frames.urdf` & `idyntree-9.1.1.dev7/src/tests/data/icub_skin_frames.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/oneLink.urdf` & `idyntree-9.1.1.dev7/src/tests/data/oneLink.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/robotModelTestTwoLinks.urdf` & `idyntree-9.1.1.dev7/src/tests/data/robotModelTestTwoLinks.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/testModels.h.in` & `idyntree-9.1.1.dev7/src/tests/data/testModels.h.in`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/threeLinks.urdf` & `idyntree-9.1.1.dev7/src/tests/data/threeLinks.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/twoLinks.urdf` & `idyntree-9.1.1.dev7/src/tests/data/twoLinks.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/twoLinksFixed.urdf` & `idyntree-9.1.1.dev7/src/tests/data/twoLinksFixed.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/twoLinksRotationOnZAxis.urdf` & `idyntree-9.1.1.dev7/src/tests/data/twoLinksRotationOnZAxis.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/data/twoLinksWithoutBaseSensors.urdf` & `idyntree-9.1.1.dev7/src/tests/data/twoLinksWithoutBaseSensors.urdf`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tests/icub_consistency/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/tests/icub_consistency/CMakeLists.txt`

 * *Files 20% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 
 
 macro(add_icub_consistency_test testName)
     set(testsrc ${testName}ConsistencyTest.cpp)
     set(testbinary ${testName}ConsistencyTest)
     set(testname   ConsistencyTest${testName})
```

### Comparing `idyntree-9.1.1.dev66/src/tests/icub_consistency/iCubExternalWrenchesEstimationConsistencyTest.cpp` & `idyntree-9.1.1.dev7/src/tests/icub_consistency/iCubExternalWrenchesEstimationConsistencyTest.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #define _USE_MATH_DEFINES
 
 #include "testModels.h"
 
 #include <cmath>
 #include <iCub/iDynTree/TorqueEstimationTree.h>
@@ -19,35 +26,35 @@
 #include <yarp/math/api.h>
 #include <yarp/os/Log.h>
 
 #include <iCub/ctrl/math.h>
 #include <iCub/skinDynLib/dynContactList.h>
 #include <kdl_codyco/regressors/dirl_utils.hpp>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/SubModel.h>
-#include <iDynTree/ModelTransformers.h>
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/ContactWrench.h>
-#include <iDynTree/Dynamics.h>
-#include <iDynTree/Traversal.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/JointState.h>
-#include <iDynTree/FreeFloatingState.h>
-
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/ClassicalAcc.h>
-
-#include <iDynTree/Sensors.h>
-#include <iDynTree/PredictSensorsMeasurements.h>
-
-#include <iDynTree/ModelLoader.h>
-#include <iDynTree/ExternalWrenchesEstimation.h>
-#include <iDynTree/YARPConversions.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/SubModel.h>
+#include <iDynTree/Model/ModelTransformers.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/ContactWrench.h>
+#include <iDynTree/Model/Dynamics.h>
+#include <iDynTree/Model/Traversal.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/ClassicalAcc.h>
+
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/PredictSensorsMeasurements.h>
+
+#include <iDynTree/ModelIO/ModelLoader.h>
+#include <iDynTree/Estimation/ExternalWrenchesEstimation.h>
+#include <iDynTree/yarp/YARPConversions.h>
 #include <iDynTree/skinDynLibConversions.h>
 
 using namespace iCub::iDyn;
 using namespace iCub::ctrl;
 using namespace iCub::iDynTree;
 using namespace yarp::sig;
 using namespace yarp::math;
```

### Comparing `idyntree-9.1.1.dev66/src/tests/icub_consistency/iKinConsistencyTest.cpp` & `idyntree-9.1.1.dev7/src/tests/icub_consistency/iKinConsistencyTest.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,24 +1,31 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include <iDynTree/iKinConversions.h>
 
 #include <iDynTree/KinDynComputations.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/JointState.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/JointState.h>
 
-#include <iDynTree/YARPConversions.h>
+#include <iDynTree/yarp/YARPConversions.h>
 
 #include <iCub/iKin/iKinFwd.h>
 
-#include <iDynTree/DenavitHartenberg.h>
+#include <iDynTree/Model/DenavitHartenberg.h>
 
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/tests/integration/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/tests/integration/CMakeLists.txt`

 * *Files 22% similar despite different names*

```diff
@@ -1,18 +1,22 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 macro(add_integration_test testname)
     set(testsrc ${testname}IntegrationTest.cpp)
     set(testbinary ${testname}IntegrationTest)
     set(testtarget   IntegrationTest${testname})
     add_executable(${testbinary} ${testsrc})
     target_link_libraries(${testbinary} PRIVATE idyntree-core idyntree-model idyntree-modelio
-                                                idyntree-high-level idyntree-estimation
+                                                idyntree-high-level idyntree-sensors idyntree-estimation
                                                 idyntree-solid-shapes idyntree-testmodels Eigen3::Eigen)
     # Setting explicitly the WORKING_DIRECTORY is necessary to make sure that meshes are correctly loaded,
     # as a workaround for https://github.com/robotology/idyntree/issues/291
     add_test(NAME ${testtarget} COMMAND ${testbinary} WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/src/tests/data)
 
     if(IDYNTREE_RUN_VALGRIND_TESTS)
         add_test(NAME memcheck_${testtarget} COMMAND ${MEMCHECK_COMMAND_COMPLETE} $<TARGET_FILE:${testbinary}> WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/src/tests/data)
@@ -21,15 +25,15 @@
 
 macro(add_integration_test_no_valgrind testname)
     set(testsrc ${testname}IntegrationTest.cpp)
     set(testbinary ${testname}IntegrationTest)
     set(testtarget   IntegrationTest${testname})
     add_executable(${testbinary} ${testsrc})
     target_link_libraries(${testbinary} PRIVATE idyntree-core idyntree-model idyntree-modelio
-                                                idyntree-high-level idyntree-estimation
+                                                idyntree-high-level idyntree-sensors idyntree-estimation
                                                 idyntree-solid-shapes idyntree-testmodels Eigen3::Eigen)
     add_test(NAME ${testtarget} COMMAND ${testbinary})
 endmacro()
 
 macro(add_integration_exe testname)
     set(testsrc ${testname}IntegrationTest.cpp)
     set(testbinary ${testname}IntegrationTest)
@@ -37,16 +41,14 @@
     add_executable(${testbinary} ${testsrc})
     target_link_libraries(${testbinary} PRIVATE idyntree-core idyntree-model idyntree-modelio
                                                 idyntree-high-level idyntree-testmodels Eigen3::Eigen)
 endmacro()
 
 add_integration_test(Dynamics)
 add_integration_test(DenavitHartenberg)
-add_integration_test(ReducedModelWithFT)
-
 
 # See issue https://github.com/robotology/idyntree/issues/367
 add_integration_test_no_valgrind(iCubTorqueEstimation)
 
 # Until we fix it, add DynamicsLinearization test but don't execute it
 add_integration_exe(DynamicsLinearization)
```

### Comparing `idyntree-9.1.1.dev66/src/tests/integration/DenavitHartenbergIntegrationTest.cpp` & `idyntree-9.1.1.dev7/src/tests/integration/DenavitHartenbergIntegrationTest.cpp`

 * *Files 7% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/ModelTestUtils.h>
-
-#include <iDynTree/Model.h>
-#include <iDynTree/DenavitHartenberg.h>
-#include <iDynTree/ModelLoader.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Model/ModelTestUtils.h>
+
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/DenavitHartenberg.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 #include <iDynTree/KinDynComputations.h>
 
 #include "testModels.h"
 
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/tests/integration/DynamicsIntegrationTest.cpp` & `idyntree-9.1.1.dev7/src/tests/integration/DynamicsIntegrationTest.cpp`

 * *Files 7% similar despite different names*

```diff
@@ -1,26 +1,33 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
-
-
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/TestUtils.h>
-
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
-
-#include <iDynTree/ModelLoader.h>
-
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Dynamics.h>
-
-#include <iDynTree/JointState.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/FreeFloatingMatrices.h>
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
+
+
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
+
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
+
+#include <iDynTree/ModelIO/ModelLoader.h>
+
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Dynamics.h>
+
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/FreeFloatingMatrices.h>
 
 #include "testModels.h"
 
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
```

### Comparing `idyntree-9.1.1.dev66/src/tests/integration/DynamicsLinearizationIntegrationTest.cpp` & `idyntree-9.1.1.dev7/src/tests/integration/DynamicsLinearizationIntegrationTest.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,29 +1,36 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
 
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Dynamics.h>
-#include <iDynTree/DynamicsLinearization.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Dynamics.h>
+#include <iDynTree/Model/DynamicsLinearization.h>
 
-#include <iDynTree/JointState.h>
-#include <iDynTree/LinkState.h>
-#include <iDynTree/FreeFloatingState.h>
-#include <iDynTree/FreeFloatingMatrices.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/LinkState.h>
+#include <iDynTree/Model/FreeFloatingState.h>
+#include <iDynTree/Model/FreeFloatingMatrices.h>
 
-#include <iDynTree/ModelTestUtils.h>
+#include <iDynTree/Model/ModelTestUtils.h>
 
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 #include "testModels.h"
 
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 
@@ -468,15 +475,15 @@
 
 
 int main()
 {
     // First test some models used for debug
     Model doubleBodyModel;
 
-    RotationalInertia rotInertia = RotationalInertia::Zero();
+    RotationalInertiaRaw rotInertia = RotationalInertiaRaw::Zero();
     rotInertia(0,0) = rotInertia(1,1) = rotInertia(2,2) = 1.0;
 
     Position com = Position::Zero();
     com(0) = 0.0;
     com(1) = 0.0;
     com(2) = 0.0;
```

### Comparing `idyntree-9.1.1.dev66/src/tests/integration/InertialParametersSolidShapesHelpersIntegrationTest.cpp` & `idyntree-9.1.1.dev7/src/tests/integration/InertialParametersSolidShapesHelpersIntegrationTest.cpp`

 * *Files 23% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include "testModels.h"
 
 #include <iDynTree/InertialParametersSolidShapesHelpers.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 
 using namespace iDynTree;
 
 int main()
 {
     // Open file with a external mesh (cube centered in 0 and with vertices in (1,0,0), (0,0,1), etc etc
@@ -29,15 +36,15 @@
 
     // Extract the inertial parameters assuming a total mass of 24 Kg
     // The principal moment of inertia for a cube of 2 meters side will
     // be (density is 24/8 = 3 Kg/m^3) of 2*24/3 = 16 .
     // http://scienceworld.wolfram.com/physics/MomentofInertiaRectangularParallelepiped.html
     double totalMass = 24;
     double expectedInertia = 16;
-    RotationalInertia rotInertia;
+    RotationalInertiaRaw rotInertia;
     rotInertia.zero();
     rotInertia(0, 0) = rotInertia(1, 1) = rotInertia(2, 2) = expectedInertia;
 
 
     VectorDynSize inertialParams;
     inertialParams.resize(10);
     inertialParams(2) = 3.0;
```

### Comparing `idyntree-9.1.1.dev66/src/tests/integration/ReducedModelWithFTIntegrationTest.cpp` & `idyntree-9.1.1.dev7/src/sensors/tests/ReducedModelWithFTUnitTest.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/Sensors.h>
-#include <iDynTree/SixAxisForceTorqueSensor.h>
-#include <iDynTree/ModelSensorsTransformers.h>
-#include <iDynTree/ModelTransformers.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Sensors/Sensors.h>
+#include <iDynTree/Sensors/SixAxisForceTorqueSensor.h>
+#include <iDynTree/Sensors/ModelSensorsTransformers.h>
+#include <iDynTree/Model/ModelTransformers.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 #include "testModels.h"
 #include <iostream>
 #include <memory>
 
 using namespace std;
 using namespace iDynTree;
```

### Comparing `idyntree-9.1.1.dev66/src/tests/integration/iCubTorqueEstimationIntegrationTest.cpp` & `idyntree-9.1.1.dev7/src/tests/integration/iCubTorqueEstimationIntegrationTest.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,29 +1,36 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "testModels.h"
 
 #include <cmath>
 #include <ctime>
 
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/EigenSparseHelpers.h>
-#include <iDynTree/ModelTestUtils.h>
-
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelLoader.h>
-
-#include <iDynTree/AccelerometerSensor.h>
-#include <iDynTree/ThreeAxisAngularAccelerometerSensor.h>
-
-#include <iDynTree/BerdyHelper.h>
-#include <iDynTree/BerdySparseMAPSolver.h>
-#include <iDynTree/ExtWrenchesAndJointTorquesEstimator.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/EigenSparseHelpers.h>
+#include <iDynTree/Model/ModelTestUtils.h>
+
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
+
+#include <iDynTree/Sensors/AccelerometerSensor.h>
+#include <iDynTree/Sensors/ThreeAxisAngularAccelerometerSensor.h>
+
+#include <iDynTree/Estimation/BerdyHelper.h>
+#include <iDynTree/Estimation/BerdySparseMAPSolver.h>
+#include <iDynTree/Estimation/ExtWrenchesAndJointTorquesEstimator.h>
 
 using namespace iDynTree;
 
 void extractJointTorquesAndContactForces(const iDynTree::BerdyHelper& berdyHelper,
                                          const iDynTree::VectorDynSize& jointPos,
                                          const iDynTree::VectorDynSize& estimatedDynamicVariables,
                                          const iDynTree::LinkUnknownWrenchContacts& unknownWrenches,
```

### Comparing `idyntree-9.1.1.dev66/src/tests/yarp_benchmark/PseudoInverseBenchmark.cpp` & `idyntree-9.1.1.dev7/src/tests/yarp_benchmark/PseudoInverseBenchmark.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "testModels.h"
 
-#include <iDynTree/TestUtils.h>
-#include <iDynTree/EigenHelpers.h>
-#include <iDynTree/EigenMathHelpers.h>
-#include <iDynTree/VectorDynSize.h>
-#include <iDynTree/MatrixDynSize.h>
-#include <iDynTree/Transform.h>
+#include <iDynTree/Core/TestUtils.h>
+#include <iDynTree/Core/EigenHelpers.h>
+#include <iDynTree/Core/EigenMathHelpers.h>
+#include <iDynTree/Core/VectorDynSize.h>
+#include <iDynTree/Core/MatrixDynSize.h>
+#include <iDynTree/Core/Transform.h>
 
 #include <yarp/sig/Matrix.h>
 #include <yarp/math/SVD.h>
 
 using namespace iDynTree;
 
 #include <ctime>
```

### Comparing `idyntree-9.1.1.dev66/src/tools/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/tools/CMakeLists.txt`

 * *Files 13% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 macro(IDYNTREE_ADD_TOOL tool_name tool_code)
     add_executable(${tool_name} ${tool_code})
     target_link_libraries(${tool_name} PRIVATE idyntree-core
                                                idyntree-model
                                                idyntree-high-level
                                                idyntree-modelio
```

### Comparing `idyntree-9.1.1.dev66/src/tools/cmdline.h` & `idyntree-9.1.1.dev7/src/tools/cmdline.h`

 * *Files identical despite different names*

### Comparing `idyntree-9.1.1.dev66/src/tools/idyntree-model-info.cpp` & `idyntree-9.1.1.dev7/src/tools/idyntree-model-info.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 #include <iDynTree/KinDynComputations.h>
 
 #include "cmdline.h"
 
 #include <iostream>
 #include <cstdlib>
```

### Comparing `idyntree-9.1.1.dev66/src/tools/idyntree-model-simplify-shapes.cpp` & `idyntree-9.1.1.dev7/src/tools/idyntree-model-simplify-shapes.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * SPDX-FileCopyrightText: 2006-2021 Istituto Italiano di Tecnologia (IIT)
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
 
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Model.h>
 
 // To load models from file
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 // To approximate shapes of a model
 #include <iDynTree/ModelTransformersSolidShapes.h>
 
 // To write model to file
-#include <iDynTree/ModelExporter.h>
+#include <iDynTree/ModelIO/ModelExporter.h>
 
 #include "cmdline.h"
 
 #include <iostream>
 #include <cstdlib>
 
 /**
```

### Comparing `idyntree-9.1.1.dev66/src/tools/idyntree-model-view.cpp` & `idyntree-9.1.1.dev7/src/tools/idyntree-model-view.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Model.h>
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 
 #include <iDynTree/Visualizer.h>
 
 #include "cmdline.h"
 
 #include <iostream>
 #include <cstdlib>
```

### Comparing `idyntree-9.1.1.dev66/src/tools/idyntree-normalize-collada-meshes.py` & `idyntree-9.1.1.dev7/src/tools/idyntree-normalize-collada-meshes.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,14 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright (C) 2015 Fondazione Istituto Italiano di Tecnologia
+#
+# Licensed under either the GNU Lesser General Public License v3.0 :
+# https://www.gnu.org/licenses/lgpl-3.0.html
+# or the GNU Lesser General Public License v2.1 :
+# https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+# at your option.
 
 #!/usr/bin/env python
 
 # -*- coding: utf-8 -*-
 """
 Simple script to remove any transformation from the 
 scene of the dae file and directly modify the points
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/CMakeLists.txt` & `idyntree-9.1.1.dev7/src/visualization/CMakeLists.txt`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-# SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-# SPDX-License-Identifier: BSD-3-Clause
-
+# Copyright: (C) 2016 Fondazione Istituto Italiano di Tecnologia
+# Authors: Silvio Traversaro
+# CopyPolicy: Released under the terms of the LGPLv2.1 or later, see LGPL.TXT
 
 set(iDynTree_visualization_source src/Visualizer.cpp)
 set(iDynTree_visualization_header include/iDynTree/Visualizer.h)
 set(iDynTree_visualization_private_headers)
 set(iDynTree_visualization_private_source)
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/include/iDynTree/Visualizer.h` & `idyntree-9.1.1.dev7/src/visualization/include/iDynTree/Visualizer.h`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,28 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_VISUALIZER_H
 #define IDYNTREE_VISUALIZER_H
 
 #include <string>
 #include <vector>
 
-#include <iDynTree/Direction.h>
-#include <iDynTree/Position.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Position.h>
 
-#include <iDynTree/JointState.h>
-#include <iDynTree/LinkState.h>
+#include <iDynTree/Model/JointState.h>
+#include <iDynTree/Model/LinkState.h>
 
 namespace iDynTree
 {
 class Model;
 class Transform;
 class Visualizer;
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Camera.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/Camera.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "Camera.h"
 #include "IrrlichtUtils.h"
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Camera.h` & `idyntree-9.1.1.dev7/src/visualization/src/Camera.h`

 * *Files 9% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_CAMERA_H
 #define IDYNTREE_CAMERA_H
 
 #include <iDynTree/Visualizer.h>
 #include "CameraAnimator.h"
 #include <irrlicht.h>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/CameraAnimator.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/CameraAnimator.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include <irrlicht.h>
 #include "CameraAnimator.h"
 #include "IrrlichtUtils.h"
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/CameraAnimator.h` & `idyntree-9.1.1.dev7/src/visualization/src/CameraAnimator.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_CAMERAANIMATOR_H
 #define IDYNTREE_CAMERAANIMATOR_H
 
 #include <irrlicht.h>
 #include <iDynTree/Visualizer.h>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/DummyImplementations.h` & `idyntree-9.1.1.dev7/src/visualization/src/DummyImplementations.h`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_DUMMYIMPLEMENTATIONS_H
 #define IDYNTREE_DUMMYIMPLEMENTATIONS_H
 
 #include <iDynTree/Visualizer.h>
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Model.h>
 
 namespace iDynTree
 {
 
 /**
  * Dummy camera.
  */
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Environment.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/Environment.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "Environment.h"
 #include "IrrlichtUtils.h"
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Environment.h` & `idyntree-9.1.1.dev7/src/visualization/src/Environment.h`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_ENVIRONMENT_H
 #define IDYNTREE_ENVIRONMENT_H
 
 #include <iDynTree/Visualizer.h>
 #include "Light.h"
 #include "DummyImplementations.h"
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/FloorGridSceneNode.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/FloorGridSceneNode.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "FloorGridSceneNode.h"
 #include "IrrlichtUtils.h"
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/FloorGridSceneNode.h` & `idyntree-9.1.1.dev7/src/visualization/src/FloorGridSceneNode.h`

 * *Files 23% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_FLOORGRID_SCENENODE_H
 #define IDYNTREE_FLOORGRID_SCENENODE_H
 
 #include <iDynTree/Visualizer.h>
 
 #include <irrlicht.h>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/FrameVisualization.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/FrameVisualization.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "FrameVisualization.h"
 #include "IrrlichtUtils.h"
 
 
 void iDynTree::FrameVisualization::setFrameTransform(size_t index, const iDynTree::Transform &transformation)
 {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/FrameVisualization.h` & `idyntree-9.1.1.dev7/src/visualization/src/FrameVisualization.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 #ifndef IDYNTREE_FRAMEVISUALIZATION_H
 #define IDYNTREE_FRAMEVISUALIZATION_H
 
 #include <iDynTree/Visualizer.h>
 #include "Label.h"
 
 #include <vector>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/IrrlichtUtils.h` & `idyntree-9.1.1.dev7/src/visualization/src/IrrlichtUtils.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,23 +1,30 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_IRRLICHT_UTILS_H
 #define IDYNTREE_IRRLICHT_UTILS_H
 
 #include <EMaterialTypes.h>
-#include <iDynTree/SolidShapes.h>
+#include <iDynTree/Model/SolidShapes.h>
 #include <iDynTree/Visualizer.h>
 
 #include <irrlicht.h>
 
 #include <Eigen/Core>
 #include <Eigen/LU>
 
-#include <iDynTree/EigenHelpers.h>
+#include <iDynTree/Core/EigenHelpers.h>
 
 #include "FloorGridSceneNode.h"
 
 #include <cmath>
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/JetsVisualization.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/JetsVisualization.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 
 #include "JetsVisualization.h"
 #include "ModelVisualization.h"
 
 #include "IrrlichtUtils.h"
 
-#include <iDynTree/Model.h>
+#include <iDynTree/Model/Model.h>
 
 #include <cassert>
 
 namespace iDynTree
 {
 
 JetsVisualization::JetsVisualization(): m_smgr(0),
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/JetsVisualization.h` & `idyntree-9.1.1.dev7/src/visualization/src/JetsVisualization.h`

 * *Files 18% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_JETS_VISUALIZATION_H
 #define IDYNTREE_JETS_VISUALIZATION_H
 
 #include <iDynTree/Visualizer.h>
 
 #include <irrlicht.h>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Label.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/Label.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "Label.h"
 #include <cassert>
 #include <string>
 #include <codecvt>
 #include <locale>
 #include "IrrlichtUtils.h"
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Light.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/Light.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "Light.h"
 #include "IrrlichtUtils.h"
 
 namespace iDynTree
 {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Light.h` & `idyntree-9.1.1.dev7/src/visualization/src/Light.h`

 * *Files 17% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_LIGHT_H
 #define IDYNTREE_LIGHT_H
 
 #include <iDynTree/Visualizer.h>
 
 #include <irrlicht.h>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/ModelVisualization.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/ModelVisualization.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,25 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "ModelVisualization.h"
 #include "JetsVisualization.h"
 #include "IrrlichtUtils.h"
 #include "Label.h"
 
-#include <iDynTree/ForwardKinematics.h>
-#include <iDynTree/Model.h>
-#include <iDynTree/Traversal.h>
+#include <iDynTree/Model/ForwardKinematics.h>
+#include <iDynTree/Model/Model.h>
+#include <iDynTree/Model/Traversal.h>
 
 namespace iDynTree
 {
 
 struct ModelVisualization::ModelVisualizationPimpl
 {
     std::string m_instanceName;
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/ModelVisualization.h` & `idyntree-9.1.1.dev7/src/visualization/src/ModelVisualization.h`

 * *Files 18% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_MODEL_VISUALIZATION_H
 #define IDYNTREE_MODEL_VISUALIZATION_H
 
 #include <iDynTree/Visualizer.h>
 
 #include <irrlicht.h>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Texture.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/Texture.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "Texture.h"
 #include "DummyImplementations.h"
 
 void iDynTree::Texture::init(irr::video::IVideoDriver *irrDriverInput,
                              irr::scene::ISceneManager* sceneManager,
                              const std::string &name,
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Texture.h` & `idyntree-9.1.1.dev7/src/visualization/src/Texture.h`

 * *Files 21% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 #ifndef IDYNTREE_TEXTURE_H
 #define IDYNTREE_TEXTURE_H
 #include <iDynTree/Visualizer.h>
 
 #include "Environment.h"
 
 #include <irrlicht.h>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/TexturesHandler.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/TexturesHandler.cpp`

 * *Files 13% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "TexturesHandler.h"
 
 iDynTree::TexturesHandler::~TexturesHandler()
 {
     if (m_irrDriver)
     {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/TexturesHandler.h` & `idyntree-9.1.1.dev7/src/visualization/src/TexturesHandler.h`

 * *Files 21% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2021 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 #ifndef IDYNTREE_TEXTUREHANDLER_H
 #define IDYNTREE_TEXTUREHANDLER_H
 
 #include <iDynTree/Visualizer.h>
 #include <irrlicht.h>
 #include "Texture.h"
 #include "Camera.h"
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/VectorsVisualization.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/VectorsVisualization.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #include "VectorsVisualization.h"
 
 #include "IrrlichtUtils.h"
 
 #include <cassert>
 #include <string>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/VectorsVisualization.h` & `idyntree-9.1.1.dev7/src/visualization/src/VectorsVisualization.h`

 * *Files 22% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2018 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 #ifndef IDYNTREE_VECTORS_VISUALIZATION_H
 #define IDYNTREE_VECTORS_VISUALIZATION_H
 
 #include <iDynTree/Visualizer.h>
 #include "Label.h"
 
 #include <vector>
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/src/Visualizer.cpp` & `idyntree-9.1.1.dev7/src/visualization/src/Visualizer.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,12 +1,19 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/Utils.h>
-#include <iDynTree/JointState.h>
+#include <iDynTree/Core/Utils.h>
+#include <iDynTree/Model/JointState.h>
 #include <iDynTree/Visualizer.h>
 
 #ifdef IDYNTREE_USES_IRRLICHT
 #include <irrlicht.h>
 #include "IrrlichtUtils.h"
 #include "Camera.h"
 #include "Environment.h"
@@ -35,21 +42,14 @@
 // Required by SetEnvironmentVariableA, _putenv is not unsetting
 // correctly the variables
 #define NOMINMAX
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #endif
 
-#if defined(_IRR_COMPILE_WITH_SDL_DEVICE_) || defined(_WIN32) ||  defined(__APPLE__)
-#if (defined(_WIN32) ||  defined(__APPLE__)) && !defined(_IRR_COMPILE_WITH_SDL_DEVICE_)
-#error "On Windows and MacOS it is necessary to use Irrlicht with SDL"
-#endif
-#define IDYNTREE_USE_GLFW_WINDOW
-#endif
-
 #endif
 
 #include "DummyImplementations.h"
 
 #include <unordered_map>
 #include <cassert>
 
@@ -129,30 +129,28 @@
     /**
      * Last FPS measured.
      */
     int lastFPS;
 
 #ifdef IDYNTREE_USES_IRRLICHT
 
-#ifdef IDYNTREE_USE_GLFW_WINDOW
     /**
      * Custom window object
      */
     GLFWwindow* m_window{nullptr};
 
     static unsigned int m_glfwInstances;
 
 #if defined(_WIN32)
     HWND m_windowId;
 #elif defined(__APPLE__)
     id m_windowId;
 #elif defined(__linux__)
     Window m_windowId;
 #endif
-#endif
 
     /**
      * Collection of model visualization.
      */
     std::vector<ModelVisualization*> m_modelViz;
 
     /**
@@ -243,15 +241,14 @@
         m_palette["meshcat"].gridColor =  irr::video::SColor(128,128,128,100);
         m_palette["meshcat"].xAxis = irr::video::SColor(alphaLev,234, 67, 53);
         m_palette["meshcat"].yAxis = irr::video::SColor(alphaLev,52, 168, 83);
         m_palette["meshcat"].zAxis = irr::video::SColor(alphaLev,66,133,244);
         m_palette["meshcat"].vector = irr::video::SColor(255,253,98,2);
     }
 
-#ifdef IDYNTREE_USE_GLFW_WINDOW
     void cursorPositionCallback(GLFWwindow* window, double xpos, double ypos)
     {
         if (window != m_window)
         {
             return;
         }
 
@@ -381,15 +378,14 @@
         static_cast<Visualizer::VisualizerPimpl*>(glfwGetWindowUserPointer(window))->mouseButtonCallback(window, button, action, mods);
     }
 
     static void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
     {
         static_cast<Visualizer::VisualizerPimpl*>(glfwGetWindowUserPointer(window))->scrollCallback(window, xoffset, yoffset);
     }
-#endif
 
 #else
     DummyCamera m_camera;
     DummyEnvironment m_environment;
     DummyVectorsVisualization m_invalidVectors;
     DummyFrameVisualization m_invalidFrames;
     DummyTexturesHandler m_invalidTextures;
@@ -406,15 +402,15 @@
         m_irrDevice  = 0;
         m_irrSmgr    = 0;
         m_irrDriver  = 0;
 #endif
     }
 };
 
-#ifdef IDYNTREE_USE_GLFW_WINDOW
+#ifdef IDYNTREE_USES_IRRLICHT
 
 unsigned int Visualizer::VisualizerPimpl::m_glfwInstances = 0;
 
 #endif
 
 Visualizer::Visualizer(const Visualizer& /*other*/)
 {
@@ -448,17 +444,14 @@
         reportWarning("Visualizer","init","Visualier already initialized, call close() to close it to open it again.");
         return false;
     }
 
     // initialize the color palette
     pimpl->initializePalette();
 
-    irr::SIrrlichtCreationParameters irrDevParams;
-
-#ifdef IDYNTREE_USE_GLFW_WINDOW
     if (pimpl->m_glfwInstances == 0)
     {
         if (!glfwInit()) {
             reportError("Visualizer", "init", "Unable to initialize GLFW");
             return false;
         }
 
@@ -471,32 +464,40 @@
         reportError("Visualizer","init","Could not create window");
         return false;
     }
 
     glfwMakeContextCurrent(pimpl->m_window);
     glfwSwapInterval(1);
 
+    irr::SIrrlichtCreationParameters irrDevParams;
+
+// If we are on Windows, only SDL works with the external window
+#if defined(_WIN32) ||  defined(__APPLE__)
+#ifndef _IRR_COMPILE_WITH_SDL_DEVICE_
+#error "On Windows and MacOS it is necessary to use Irrlicht with SDL"
+#endif
+    irrDevParams.DeviceType = irr::EIDT_SDL;
+#endif
+
+    irrDevParams.DriverType = irr::video::EDT_OPENGL;
+    irrDevParams.WindowSize = irr::core::dimension2d<irr::u32>(visualizerOptions.winWidth, visualizerOptions.winHeight);
+    irrDevParams.WithAlphaChannel = true;
+    irrDevParams.AntiAlias = 4;
+
 #if defined(_WIN32)
     pimpl->m_windowId = glfwGetWin32Window(pimpl->m_window);
     irrDevParams.WindowId = (void*)(pimpl->m_windowId);
 #elif defined(__APPLE__)
     pimpl->m_windowId = glfwGetCocoaWindow(pimpl->m_window);
     irrDevParams.WindowId = (void*)(pimpl->m_windowId);
 #elif defined(__linux__)
     pimpl->m_windowId = glfwGetX11Window(pimpl->m_window);
     irrDevParams.WindowId = (void*)(pimpl->m_windowId);
 #endif
 
-    irrDevParams.DeviceType = irr::EIDT_SDL;
-#endif
-
-    irrDevParams.DriverType = irr::video::EDT_OPENGL;
-    irrDevParams.WindowSize = irr::core::dimension2d<irr::u32>(visualizerOptions.winWidth, visualizerOptions.winHeight);
-    irrDevParams.WithAlphaChannel = true;
-    irrDevParams.AntiAlias = 4;
 
     if( visualizerOptions.verbose )
     {
         reportWarning("Visualizer","init","verbose flag found, enabling verbose output in Visualizer");
         irrDevParams.LoggingLevel = irr::ELL_DEBUG;
     }
 
@@ -557,20 +558,18 @@
 
     pimpl->m_vectors.init(pimpl->m_irrSmgr);
 
     pimpl->m_frames.init(pimpl->m_irrSmgr);
 
     pimpl->m_textures.init(pimpl->m_irrDriver, pimpl->m_irrSmgr);
 
-#ifdef IDYNTREE_USE_GLFW_WINDOW
     glfwSetWindowUserPointer(pimpl->m_window, pimpl);
     glfwSetCursorPosCallback(pimpl->m_window, VisualizerPimpl::cursor_position_callback);
     glfwSetMouseButtonCallback(pimpl->m_window, VisualizerPimpl::mouse_button_callback);
     glfwSetScrollCallback(pimpl->m_window, VisualizerPimpl::scroll_callback);
-#endif
 
     pimpl->m_isInitialized = true;
     pimpl->lastFPS         = -1;
 
     return true;
 #else
     IDYNTREE_UNUSED(visualizerOptions);
@@ -671,17 +670,15 @@
         int winHeight = height();
 
         if (winHeight <= 0)
         {
             return;
         }
 
-#ifdef IDYNTREE_USE_GLFW_WINDOW
         glfwMakeContextCurrent(pimpl->m_window);
-#endif
 
         pimpl->m_irrDriver->beginScene(true,true, pimpl->m_environment.m_backgroundColor.toSColor(), pimpl->m_irrVideoData);
 
         pimpl->m_irrDriver->setViewPort(irr::core::rect<irr::s32>(0, 0, winWidth, winHeight));
 
         pimpl->m_irrDriver->OnResize(irr::core::dimension2d<irr::u32>(winWidth, winHeight));
 
@@ -691,35 +688,31 @@
 
         pimpl->m_irrSmgr->drawAll();
     }
 
     pimpl->m_irrDriver->endScene();
     pimpl->m_subDrawStarted = false;
 
-#ifdef IDYNTREE_USE_GLFW_WINDOW
     glfwSwapBuffers(pimpl->m_window);
 
     glfwPollEvents();
-#endif
 
     int fps = pimpl->m_irrDriver->getFPS();
 
     if (pimpl->lastFPS != fps)
     {
         irr::core::stringw str = L"iDynTree Visualizer [";
         str += pimpl->m_irrDriver->getName();
         str += "] FPS:";
         str += fps;
         str += " ";
         irr::core::stringc strc(str);
 
         pimpl->m_irrDevice->setWindowCaption(str.c_str());
-#ifdef IDYNTREE_USE_GLFW_WINDOW
         glfwSetWindowTitle(pimpl->m_window, strc.c_str());
-#endif
         pimpl->lastFPS = fps;
     }
 
 #else
     reportError("Visualizer","draw","Impossible to use iDynTree::Visualizer, as iDynTree has been compiled without Irrlicht.");
 #endif
 }
@@ -749,17 +742,15 @@
     {
         return;
     }
 
     bool clearTextureBuffers = false;
     if (!pimpl->m_subDrawStarted)
     {
-#ifdef IDYNTREE_USE_GLFW_WINDOW
         glfwMakeContextCurrent(pimpl->m_window);
-#endif
         pimpl->m_irrDriver->beginScene(true,true, pimpl->m_environment.m_backgroundColor.toSColor(), pimpl->m_irrVideoData);
         pimpl->m_subDrawStarted = true;
         clearTextureBuffers = true;
     }
 
     pimpl->m_textures.draw(pimpl->m_environment, pimpl->m_camera, clearTextureBuffers);
 
@@ -919,82 +910,65 @@
 {
 #ifdef IDYNTREE_USES_IRRLICHT
     if( !pimpl->m_isInitialized )
     {
         reportError("Visualizer","width","Visualizer not initialized.");
         return 0;
     }
-#ifdef IDYNTREE_USE_GLFW_WINDOW
+
     GLint ww, wh;
     glfwGetWindowSize(pimpl->m_window, &ww, &wh);
 
     return ww;
 #else
-    auto winDimensions = pimpl->m_irrDriver->getScreenSize();
-    return winDimensions.Width;
-#endif
-#else
     return 0;
 #endif
 }
 
 int Visualizer::height() const
 {
 #ifdef IDYNTREE_USES_IRRLICHT
     if( !pimpl->m_isInitialized )
     {
         reportError("Visualizer","height","Visualizer not initialized.");
         return 0;
     }
 
-#ifdef IDYNTREE_USE_GLFW_WINDOW
     GLint ww, wh;
     glfwGetWindowSize(pimpl->m_window, &ww, &wh);
-
     return wh;
 #else
-    auto winDimensions = pimpl->m_irrDriver->getScreenSize();
-    return winDimensions.Height;
-#endif
-#else
     return 0;
 #endif
 }
 
 bool Visualizer::run()
 {
 #ifdef IDYNTREE_USES_IRRLICHT
     if( !pimpl->m_isInitialized )
     {
         reportError("Visualizer","run","Impossible to run not initialized visualizer");
         return false;
     }
-    bool shouldClose = false;
-
-#ifdef IDYNTREE_USE_GLFW_WINDOW
-    shouldClose = glfwWindowShouldClose(pimpl->m_window);
-#endif
 
-    return pimpl->m_irrDevice->run() && !shouldClose;
+    return pimpl->m_irrDevice->run() && !glfwWindowShouldClose(pimpl->m_window);
 #else
     reportError("Visualizer","run","Impossible to use iDynTree::Visualizer, as iDynTree has been compiled without Irrlicht.");
     return false;
 #endif
 }
 
 void Visualizer::close()
 {
 #ifdef IDYNTREE_USES_IRRLICHT
     if( !pimpl->m_isInitialized )
     {
         return;
     }
-#ifdef IDYNTREE_USE_GLFW_WINDOW
     glfwMakeContextCurrent(pimpl->m_window);
-#endif
 
     pimpl->m_vectors.close();
     pimpl->m_frames.close();
     pimpl->m_environment.close();
 
     pimpl->m_irrDevice->closeDevice();
     pimpl->m_irrDevice->drop();
@@ -1008,29 +982,27 @@
             delete pimpl->m_modelViz[mdl];
             pimpl->m_modelViz[mdl] = nullptr;
         }
     }
 
     pimpl->m_modelViz.resize(0);
 
-#ifdef IDYNTREE_USE_GLFW_WINDOW
     if (pimpl->m_window)
     {
         glfwMakeContextCurrent(pimpl->m_window);
         glfwDestroyWindow(pimpl->m_window);
 
         pimpl->m_glfwInstances--;
         if (pimpl->m_glfwInstances == 0)
         {
             glfwTerminate();
         }
 
         pimpl->m_window = nullptr;
     }
-#endif
 
     return;
 #endif
 }
 
 bool Visualizer::isWindowActive() const
 {
```

### Comparing `idyntree-9.1.1.dev66/src/visualization/tests/VisualizerUnitTest.cpp` & `idyntree-9.1.1.dev7/src/visualization/tests/VisualizerUnitTest.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,21 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2016 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
-#include <iDynTree/ModelLoader.h>
+#include <iDynTree/ModelIO/ModelLoader.h>
 #include <iDynTree/Visualizer.h>
 
-#include <iDynTree/TestUtils.h>
+#include <iDynTree/Core/TestUtils.h>
 
 #include "testModels.h"
 
 void checkVizLoading(const iDynTree::Model & model)
 {
     // Open visualizer
     iDynTree::Visualizer viz;
```

### Comparing `idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPConfigurationsLoader.h` & `idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPConfigurationsLoader.h`

 * *Files 21% similar despite different names*

```diff
@@ -1,15 +1,22 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2017 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_YARP_CONFIGURATIONS_LOADER_H
 #define IDYNTREE_YARP_CONFIGURATIONS_LOADER_H
 
 #include <yarp/os/Searchable.h>
-#include <iDynTree/Rotation.h>
+#include <iDynTree/Core/Rotation.h>
 #include <string>
 
 namespace iDynTree
 {
     /**
     * Takes a rotation matrix from configuration file.
     * Notice, the matrix is parsed row-wise.
```

### Comparing `idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPConfigurationsLoaderImplementation.h` & `idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPConfigurationsLoaderImplementation.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2013 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_YARP_CONFIGURATIONS_LOADER_IMPLEMENTATION_H
 #define IDYNTREE_YARP_CONFIGURATIONS_LOADER_IMPLEMENTATION_H
 
 #include <yarp/os/Value.h>
 
 inline bool iDynTree::parseRotationMatrix(const yarp::os::Searchable& rf, const std::string& key, iDynTree::Rotation& rotation)
```

### Comparing `idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPConversions.h` & `idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPConversions.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,24 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2013 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_YARP_CONVERSIONS_H
 #define IDYNTREE_YARP_CONVERSIONS_H
 
 #include <yarp/sig/Matrix.h>
 #include <yarp/sig/Vector.h>
 
-#include <iDynTree/Wrench.h>
+#include <iDynTree/Core/Wrench.h>
 
 namespace iDynTree
 {
 
 class Direction;
 class VectorDynSize;
 class Transform;
```

### Comparing `idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPConversionsImplementation.h` & `idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPConversionsImplementation.h`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,23 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2013 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_YARP_CONVERSIONS_IMPLEMENTATION_H
 #define IDYNTREE_YARP_CONVERSIONS_IMPLEMENTATION_H
 
-#include <iDynTree/Direction.h>
-#include <iDynTree/Transform.h>
-#include <iDynTree/VectorDynSize.h>
+#include <iDynTree/Core/Direction.h>
+#include <iDynTree/Core/Transform.h>
+#include <iDynTree/Core/VectorDynSize.h>
 
 #include <yarp/math/Math.h>
 #include <cstring>
 
 using namespace yarp::math;
 
 namespace iDynTree
```

### Comparing `idyntree-9.1.1.dev66/src/yarp/include/iDynTree/YARPEigenConversions.h` & `idyntree-9.1.1.dev7/src/yarp/include/iDynTree/yarp/YARPEigenConversions.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,9 +1,16 @@
-// SPDX-FileCopyrightText: Fondazione Istituto Italiano di Tecnologia (IIT)
-// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (C) 2013 Fondazione Istituto Italiano di Tecnologia
+ *
+ * Licensed under either the GNU Lesser General Public License v3.0 :
+ * https://www.gnu.org/licenses/lgpl-3.0.html
+ * or the GNU Lesser General Public License v2.1 :
+ * https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+ * at your option.
+ */
 
 #ifndef IDYNTREE_YARP_EIGEN_CONVERSIONS_H
 #define IDYNTREE_YARP_EIGEN_CONVERSIONS_H
 
 #include <yarp/sig/Matrix.h>
 #include <yarp/sig/Vector.h>
```

