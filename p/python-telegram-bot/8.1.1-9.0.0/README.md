# Comparing `tmp/python-telegram-bot-8.1.1.tar.gz` & `tmp/python-telegram-bot-9.0.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/python-telegram-bot-8.1.1.tar", last modified: Sun Oct 15 15:01:51 2017, max compression
+gzip compressed data, was "dist/python-telegram-bot-9.0.0.tar", last modified: Fri Dec  8 22:09:14 2017, max compression
```

## Comparing `python-telegram-bot-8.1.1.tar` & `python-telegram-bot-9.0.0.tar`

### file list

```diff
@@ -1,172 +1,175 @@
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/
--rwxrwxrwx   0 root         (0) root         (0)    33041 2017-06-10 14:02:14.000000 python-telegram-bot-8.1.1/LICENSE
--rwxrwxrwx   0 root         (0) root         (0)     7816 2017-06-10 14:02:14.000000 python-telegram-bot-8.1.1/LICENSE.lesser
--rwxrwxrwx   0 root         (0) root         (0)     1356 2017-09-01 15:09:56.000000 python-telegram-bot-8.1.1/Makefile
--rwxrwxrwx   0 root         (0) root         (0)       58 2017-06-10 14:02:14.000000 python-telegram-bot-8.1.1/MANIFEST.in
--rwxrwxrwx   0 root         (0) root         (0)    10469 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/PKG-INFO
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/python_telegram_bot.egg-info/
--rwxrwxrwx   0 root         (0) root         (0)        1 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/python_telegram_bot.egg-info/dependency_links.txt
--rwxrwxrwx   0 root         (0) root         (0)    10469 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/python_telegram_bot.egg-info/PKG-INFO
--rwxrwxrwx   0 root         (0) root         (0)       53 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/python_telegram_bot.egg-info/requires.txt
--rwxrwxrwx   0 root         (0) root         (0)     5540 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/python_telegram_bot.egg-info/SOURCES.txt
--rwxrwxrwx   0 root         (0) root         (0)        9 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/python_telegram_bot.egg-info/top_level.txt
--rwxrwxrwx   0 root         (0) root         (0)     7705 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/README.rst
--rwxrwxrwx   0 root         (0) root         (0)       25 2017-06-24 11:14:48.000000 python-telegram-bot-8.1.1/requirements.txt
--rwxrwxrwx   0 root         (0) root         (0)      625 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/setup.cfg
--rwxrwxrwx   0 root         (0) root         (0)     2228 2017-06-10 14:02:14.000000 python-telegram-bot-8.1.1/setup.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/
--rwxrwxrwx   0 root         (0) root         (0)     2369 2017-09-16 14:58:41.000000 python-telegram-bot-8.1.1/telegram/base.py
--rwxrwxrwx   0 root         (0) root         (0)   132160 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/telegram/bot.py
--rwxrwxrwx   0 root         (0) root         (0)     8290 2017-09-16 14:58:41.000000 python-telegram-bot-8.1.1/telegram/callbackquery.py
--rwxrwxrwx   0 root         (0) root         (0)     8590 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/telegram/chat.py
--rwxrwxrwx   0 root         (0) root         (0)     1788 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/chataction.py
--rwxrwxrwx   0 root         (0) root         (0)     8025 2017-09-10 16:13:23.000000 python-telegram-bot-8.1.1/telegram/chatmember.py
--rwxrwxrwx   0 root         (0) root         (0)     3441 2017-09-16 14:58:41.000000 python-telegram-bot-8.1.1/telegram/choseninlineresult.py
--rwxrwxrwx   0 root         (0) root         (0)     2178 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/constants.py
--rwxrwxrwx   0 root         (0) root         (0)     2685 2017-07-23 21:07:40.000000 python-telegram-bot-8.1.1/telegram/error.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/ext/
--rwxrwxrwx   0 root         (0) root         (0)     6807 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/callbackqueryhandler.py
--rwxrwxrwx   0 root         (0) root         (0)     5066 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/choseninlineresulthandler.py
--rwxrwxrwx   0 root         (0) root         (0)     8246 2017-10-15 14:59:54.000000 python-telegram-bot-8.1.1/telegram/ext/commandhandler.py
--rwxrwxrwx   0 root         (0) root         (0)    14252 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/conversationhandler.py
--rwxrwxrwx   0 root         (0) root         (0)    14313 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/dispatcher.py
--rwxrwxrwx   0 root         (0) root         (0)    19595 2017-09-25 18:12:48.000000 python-telegram-bot-8.1.1/telegram/ext/filters.py
--rwxrwxrwx   0 root         (0) root         (0)     5898 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/handler.py
--rwxrwxrwx   0 root         (0) root         (0)     7117 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/inlinequeryhandler.py
--rwxrwxrwx   0 root         (0) root         (0)    20685 2017-09-25 18:58:53.000000 python-telegram-bot-8.1.1/telegram/ext/jobqueue.py
--rwxrwxrwx   0 root         (0) root         (0)     8274 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/telegram/ext/messagehandler.py
--rwxrwxrwx   0 root         (0) root         (0)    14066 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/messagequeue.py
--rwxrwxrwx   0 root         (0) root         (0)     4740 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/precheckoutqueryhandler.py
--rwxrwxrwx   0 root         (0) root         (0)     8236 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/telegram/ext/regexhandler.py
--rwxrwxrwx   0 root         (0) root         (0)     4724 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/shippingqueryhandler.py
--rwxrwxrwx   0 root         (0) root         (0)     4650 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/stringcommandhandler.py
--rwxrwxrwx   0 root         (0) root         (0)     5324 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/stringregexhandler.py
--rwxrwxrwx   0 root         (0) root         (0)     4005 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/typehandler.py
--rwxrwxrwx   0 root         (0) root         (0)    20034 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/telegram/ext/updater.py
--rwxrwxrwx   0 root         (0) root         (0)     2289 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/ext/__init__.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/files/
--rwxrwxrwx   0 root         (0) root         (0)     2833 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/audio.py
--rwxrwxrwx   0 root         (0) root         (0)     2037 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/chatphoto.py
--rwxrwxrwx   0 root         (0) root         (0)     2116 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/contact.py
--rwxrwxrwx   0 root         (0) root         (0)     2633 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/document.py
--rwxrwxrwx   0 root         (0) root         (0)     4270 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/file.py
--rwxrwxrwx   0 root         (0) root         (0)     5678 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/inputfile.py
--rwxrwxrwx   0 root         (0) root         (0)     1751 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/location.py
--rwxrwxrwx   0 root         (0) root         (0)     2238 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/photosize.py
--rwxrwxrwx   0 root         (0) root         (0)     6912 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/sticker.py
--rwxrwxrwx   0 root         (0) root         (0)     2201 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/venue.py
--rwxrwxrwx   0 root         (0) root         (0)     2958 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/video.py
--rwxrwxrwx   0 root         (0) root         (0)     2502 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/videonote.py
--rwxrwxrwx   0 root         (0) root         (0)     2223 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/files/voice.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-06-24 11:14:47.000000 python-telegram-bot-8.1.1/telegram/files/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)     2111 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/forcereply.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/games/
--rwxrwxrwx   0 root         (0) root         (0)     2624 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/games/animation.py
--rwxrwxrwx   0 root         (0) root         (0)     1079 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/games/callbackgame.py
--rwxrwxrwx   0 root         (0) root         (0)     6532 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/games/game.py
--rwxrwxrwx   0 root         (0) root         (0)     1821 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/games/gamehighscore.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-07-23 14:41:03.000000 python-telegram-bot-8.1.1/telegram/games/__init__.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/inline/
--rwxrwxrwx   0 root         (0) root         (0)     4763 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinekeyboardbutton.py
--rwxrwxrwx   0 root         (0) root         (0)     1972 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinekeyboardmarkup.py
--rwxrwxrwx   0 root         (0) root         (0)     4820 2017-09-16 14:58:41.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequery.py
--rwxrwxrwx   0 root         (0) root         (0)     1560 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresult.py
--rwxrwxrwx   0 root         (0) root         (0)     3909 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultarticle.py
--rwxrwxrwx   0 root         (0) root         (0)     3559 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultaudio.py
--rwxrwxrwx   0 root         (0) root         (0)     3050 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedaudio.py
--rwxrwxrwx   0 root         (0) root         (0)     3490 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcacheddocument.py
--rwxrwxrwx   0 root         (0) root         (0)     3297 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedgif.py
--rwxrwxrwx   0 root         (0) root         (0)     3356 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedmpeg4gif.py
--rwxrwxrwx   0 root         (0) root         (0)     3511 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedphoto.py
--rwxrwxrwx   0 root         (0) root         (0)     2748 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedsticker.py
--rwxrwxrwx   0 root         (0) root         (0)     3494 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedvideo.py
--rwxrwxrwx   0 root         (0) root         (0)     3221 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedvoice.py
--rwxrwxrwx   0 root         (0) root         (0)     3877 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcontact.py
--rwxrwxrwx   0 root         (0) root         (0)     4538 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultdocument.py
--rwxrwxrwx   0 root         (0) root         (0)     2011 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultgame.py
--rwxrwxrwx   0 root         (0) root         (0)     4199 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultgif.py
--rwxrwxrwx   0 root         (0) root         (0)     4205 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultlocation.py
--rwxrwxrwx   0 root         (0) root         (0)     4271 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultmpeg4gif.py
--rwxrwxrwx   0 root         (0) root         (0)     4258 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultphoto.py
--rwxrwxrwx   0 root         (0) root         (0)     4293 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultvenue.py
--rwxrwxrwx   0 root         (0) root         (0)     4706 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultvideo.py
--rwxrwxrwx   0 root         (0) root         (0)     3460 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultvoice.py
--rwxrwxrwx   0 root         (0) root         (0)     1821 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inputcontactmessagecontent.py
--rwxrwxrwx   0 root         (0) root         (0)     1875 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/telegram/inline/inputlocationmessagecontent.py
--rwxrwxrwx   0 root         (0) root         (0)     1303 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inputmessagecontent.py
--rwxrwxrwx   0 root         (0) root         (0)     2375 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inputtextmessagecontent.py
--rwxrwxrwx   0 root         (0) root         (0)     2204 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/inline/inputvenuemessagecontent.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-07-23 14:41:03.000000 python-telegram-bot-8.1.1/telegram/inline/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)     2474 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/keyboardbutton.py
--rwxrwxrwx   0 root         (0) root         (0)    43636 2017-10-15 13:28:55.000000 python-telegram-bot-8.1.1/telegram/message.py
--rwxrwxrwx   0 root         (0) root         (0)     3782 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/messageentity.py
--rwxrwxrwx   0 root         (0) root         (0)     1146 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/parsemode.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/payment/
--rwxrwxrwx   0 root         (0) root         (0)     2377 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/payment/invoice.py
--rwxrwxrwx   0 root         (0) root         (0)     1817 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/payment/labeledprice.py
--rwxrwxrwx   0 root         (0) root         (0)     2223 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/payment/orderinfo.py
--rwxrwxrwx   0 root         (0) root         (0)     4993 2017-09-16 14:58:41.000000 python-telegram-bot-8.1.1/telegram/payment/precheckoutquery.py
--rwxrwxrwx   0 root         (0) root         (0)     2428 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/payment/shippingaddress.py
--rwxrwxrwx   0 root         (0) root         (0)     1842 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/payment/shippingoption.py
--rwxrwxrwx   0 root         (0) root         (0)     3853 2017-09-16 14:58:41.000000 python-telegram-bot-8.1.1/telegram/payment/shippingquery.py
--rwxrwxrwx   0 root         (0) root         (0)     3698 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/payment/successfulpayment.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-07-23 14:41:03.000000 python-telegram-bot-8.1.1/telegram/payment/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)     3989 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/replykeyboardmarkup.py
--rwxrwxrwx   0 root         (0) root         (0)     2488 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/replykeyboardremove.py
--rwxrwxrwx   0 root         (0) root         (0)     1147 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/replymarkup.py
--rwxrwxrwx   0 root         (0) root         (0)     9013 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/update.py
--rwxrwxrwx   0 root         (0) root         (0)     4752 2017-09-25 18:12:48.000000 python-telegram-bot-8.1.1/telegram/user.py
--rwxrwxrwx   0 root         (0) root         (0)     2152 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/userprofilephotos.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/utils/
--rwxrwxrwx   0 root         (0) root         (0)     1662 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/utils/deprecate.py
--rwxrwxrwx   0 root         (0) root         (0)     2921 2017-09-14 16:16:57.000000 python-telegram-bot-8.1.1/telegram/utils/helpers.py
--rwxrwxrwx   0 root         (0) root         (0)     2020 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/utils/promise.py
--rwxrwxrwx   0 root         (0) root         (0)    11820 2017-09-25 18:58:53.000000 python-telegram-bot-8.1.1/telegram/utils/request.py
--rwxrwxrwx   0 root         (0) root         (0)     4229 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/utils/webhookhandler.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-06-10 14:02:14.000000 python-telegram-bot-8.1.1/telegram/utils/__init__.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/vendor/
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/
--rwxrwxrwx   0 root         (0) root         (0)    13078 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/connection.py
--rwxrwxrwx   0 root         (0) root         (0)    36387 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/connectionpool.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/contrib/
--rwxrwxrwx   0 root         (0) root         (0)    11161 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/contrib/appengine.py
--rwxrwxrwx   0 root         (0) root         (0)     4590 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/contrib/ntlmpool.py
--rwxrwxrwx   0 root         (0) root         (0)    15589 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/contrib/pyopenssl.py
--rwxrwxrwx   0 root         (0) root         (0)     6008 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/contrib/socks.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/contrib/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)     6849 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/exceptions.py
--rwxrwxrwx   0 root         (0) root         (0)     6121 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/fields.py
--rwxrwxrwx   0 root         (0) root         (0)     2415 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/filepost.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/backports/
--rwxrwxrwx   0 root         (0) root         (0)     1514 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/backports/makefile.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/backports/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)     9194 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/ordered_dict.py
--rwxrwxrwx   0 root         (0) root         (0)    30966 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/six.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/ssl_match_hostname/
--rwxrwxrwx   0 root         (0) root         (0)     5859 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/ssl_match_hostname/_implementation.py
--rwxrwxrwx   0 root         (0) root         (0)      707 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/ssl_match_hostname/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)      114 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)    13416 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/poolmanager.py
--rwxrwxrwx   0 root         (0) root         (0)     6094 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/request.py
--rwxrwxrwx   0 root         (0) root         (0)    23280 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/response.py
-drwxrwxrwx   0 root         (0) root         (0)        0 2017-10-15 15:01:51.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/
--rwxrwxrwx   0 root         (0) root         (0)     4367 2017-07-26 13:01:32.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/connection.py
--rwxrwxrwx   0 root         (0) root         (0)     3822 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/request.py
--rwxrwxrwx   0 root         (0) root         (0)     2424 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/response.py
--rwxrwxrwx   0 root         (0) root         (0)    14512 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/retry.py
--rwxrwxrwx   0 root         (0) root         (0)    19360 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/selectors.py
--rwxrwxrwx   0 root         (0) root         (0)    12382 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/ssl_.py
--rwxrwxrwx   0 root         (0) root         (0)     9999 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/timeout.py
--rwxrwxrwx   0 root         (0) root         (0)     6515 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/url.py
--rwxrwxrwx   0 root         (0) root         (0)     1491 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/wait.py
--rwxrwxrwx   0 root         (0) root         (0)     1046 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)    10877 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/_collections.py
--rwxrwxrwx   0 root         (0) root         (0)     2947 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-06-10 14:02:19.000000 python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)        0 2017-06-10 14:02:14.000000 python-telegram-bot-8.1.1/telegram/vendor/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)      852 2017-10-15 14:59:54.000000 python-telegram-bot-8.1.1/telegram/version.py
--rwxrwxrwx   0 root         (0) root         (0)     3556 2017-09-01 15:09:57.000000 python-telegram-bot-8.1.1/telegram/webhookinfo.py
--rwxrwxrwx   0 root         (0) root         (0)     6993 2017-07-23 21:07:40.000000 python-telegram-bot-8.1.1/telegram/__init__.py
--rwxrwxrwx   0 root         (0) root         (0)      429 2017-07-24 22:43:29.000000 python-telegram-bot-8.1.1/telegram/__main__.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    32422 2017-12-08 21:44:25.000000 python-telegram-bot-9.0.0/LICENSE
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     7651 2017-12-08 21:44:25.000000 python-telegram-bot-9.0.0/LICENSE.lesser
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)       57 2017-12-08 21:44:25.000000 python-telegram-bot-9.0.0/MANIFEST.in
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1304 2017-12-08 21:44:25.000000 python-telegram-bot-9.0.0/Makefile
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    10209 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/PKG-INFO
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     7495 2017-12-08 21:44:25.000000 python-telegram-bot-9.0.0/README.rst
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/python_telegram_bot.egg-info/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    10209 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/python_telegram_bot.egg-info/PKG-INFO
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     5637 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/python_telegram_bot.egg-info/SOURCES.txt
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        1 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/python_telegram_bot.egg-info/dependency_links.txt
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)       53 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/python_telegram_bot.egg-info/requires.txt
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        9 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/python_telegram_bot.egg-info/top_level.txt
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)       23 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/requirements.txt
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)      625 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/setup.cfg
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2113 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/setup.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/telegram/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     7067 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)      408 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/__main__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2286 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/base.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)   131718 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/bot.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     8094 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/callbackquery.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     8376 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/chat.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1743 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/chataction.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     7873 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/chatmember.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3352 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/choseninlineresult.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2124 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/constants.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2583 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/error.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/telegram/ext/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2243 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     6664 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/callbackqueryhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4961 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/choseninlineresulthandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     8075 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/commandhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    13942 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/conversationhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    14399 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/dispatcher.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    19035 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/filters.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     5773 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/handler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     6968 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/inlinequeryhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    20172 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/jobqueue.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     8105 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/messagehandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    13754 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/messagequeue.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4642 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/precheckoutqueryhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     8063 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/regexhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4626 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/shippingqueryhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4547 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/stringcommandhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     5207 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/stringregexhandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3916 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/typehandler.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    19670 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/ext/updater.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/telegram/files/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2761 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/audio.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1985 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/chatphoto.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2059 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/contact.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2562 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/document.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4161 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/file.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     5499 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/inputfile.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1104 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/inputmedia.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2412 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/inputmediaphoto.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3225 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/inputmediavideo.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1701 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/location.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2170 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/photosize.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     6724 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/sticker.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2140 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/venue.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2880 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/video.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2438 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/videonote.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2164 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/files/voice.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2060 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/forcereply.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:13.000000 python-telegram-bot-9.0.0/telegram/games/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/games/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2556 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/games/animation.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1054 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/games/callbackgame.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     6383 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/games/game.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1768 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/games/gamehighscore.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/inline/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4674 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinekeyboardbutton.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1922 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinekeyboardmarkup.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4709 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequery.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1517 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresult.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3816 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultarticle.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3475 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultaudio.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2981 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedaudio.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3412 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcacheddocument.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3222 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedgif.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3281 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedmpeg4gif.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3431 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedphoto.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2684 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedsticker.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3415 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedvideo.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3148 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedvoice.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3789 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcontact.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4438 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultdocument.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1961 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultgame.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4105 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultgif.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4111 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultlocation.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4176 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultmpeg4gif.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4163 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultphoto.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4196 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultvenue.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4603 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultvideo.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3380 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultvoice.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1776 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inputcontactmessagecontent.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1830 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inputlocationmessagecontent.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1271 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inputmessagecontent.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2324 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inputtextmessagecontent.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2153 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/inline/inputvenuemessagecontent.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2418 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/keyboardbutton.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    43047 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/message.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3677 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/messageentity.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1117 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/parsemode.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/payment/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2319 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/invoice.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1774 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/labeledprice.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2166 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/orderinfo.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4878 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/precheckoutquery.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2366 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/shippingaddress.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1790 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/shippingoption.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3760 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/shippingquery.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3618 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/payment/successfulpayment.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3902 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/replykeyboardmarkup.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2432 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/replykeyboardremove.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1116 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/replymarkup.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     8794 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/update.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4612 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/user.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2091 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/userprofilephotos.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/utils/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/utils/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1617 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/utils/deprecate.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2819 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/utils/helpers.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1958 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/utils/promise.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    11514 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/utils/request.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4104 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/utils/webhookhandler.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/vendor/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/vendor/__init__.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/__init__.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2851 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    10553 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/_collections.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    12709 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/connection.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    35475 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/connectionpool.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/contrib/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/contrib/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    10865 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/contrib/appengine.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4478 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/contrib/ntlmpool.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    15139 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/contrib/pyopenssl.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     5830 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/contrib/socks.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     6603 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/exceptions.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     5943 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/fields.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2321 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/filepost.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)      109 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/__init__.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/backports/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/backports/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1461 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/backports/makefile.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     8935 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/ordered_dict.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    30098 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/six.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/ssl_match_hostname/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)      688 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/ssl_match_hostname/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     5702 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/ssl_match_hostname/_implementation.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    13053 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/poolmanager.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     5946 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/request.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    22662 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/response.py
+drwxr-xr-x   0 Pieter    (1000) Pieter    (1000)        0 2017-12-08 22:09:14.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)      994 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/__init__.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     4237 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/connection.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3704 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/request.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     2343 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/response.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    14123 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/retry.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    18836 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/selectors.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)    12046 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/ssl_.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     9757 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/timeout.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     6289 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/url.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     1451 2017-12-08 21:44:48.000000 python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/wait.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)      832 2017-12-08 22:08:55.000000 python-telegram-bot-9.0.0/telegram/version.py
+-rw-r--r--   0 Pieter    (1000) Pieter    (1000)     3477 2017-12-08 21:44:26.000000 python-telegram-bot-9.0.0/telegram/webhookinfo.py
```

### Comparing `python-telegram-bot-8.1.1/LICENSE` & `python-telegram-bot-9.0.0/LICENSE`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,619 +1,619 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. [http://fsf.org/]
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. [http://fsf.org/]
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
```

### Comparing `python-telegram-bot-8.1.1/LICENSE.lesser` & `python-telegram-bot-9.0.0/LICENSE.lesser`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,165 +1,165 @@
-                   GNU LESSER GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. [http://fsf.org/]
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-
-  This version of the GNU Lesser General Public License incorporates
-the terms and conditions of version 3 of the GNU General Public
-License, supplemented by the additional permissions listed below.
-
-  0. Additional Definitions.
-
-  As used herein, "this License" refers to version 3 of the GNU Lesser
-General Public License, and the "GNU GPL" refers to version 3 of the GNU
-General Public License.
-
-  "The Library" refers to a covered work governed by this License,
-other than an Application or a Combined Work as defined below.
-
-  An "Application" is any work that makes use of an interface provided
-by the Library, but which is not otherwise based on the Library.
-Defining a subclass of a class defined by the Library is deemed a mode
-of using an interface provided by the Library.
-
-  A "Combined Work" is a work produced by combining or linking an
-Application with the Library.  The particular version of the Library
-with which the Combined Work was made is also called the "Linked
-Version".
-
-  The "Minimal Corresponding Source" for a Combined Work means the
-Corresponding Source for the Combined Work, excluding any source code
-for portions of the Combined Work that, considered in isolation, are
-based on the Application, and not on the Linked Version.
-
-  The "Corresponding Application Code" for a Combined Work means the
-object code and/or source code for the Application, including any data
-and utility programs needed for reproducing the Combined Work from the
-Application, but excluding the System Libraries of the Combined Work.
-
-  1. Exception to Section 3 of the GNU GPL.
-
-  You may convey a covered work under sections 3 and 4 of this License
-without being bound by section 3 of the GNU GPL.
-
-  2. Conveying Modified Versions.
-
-  If you modify a copy of the Library, and, in your modifications, a
-facility refers to a function or data to be supplied by an Application
-that uses the facility (other than as an argument passed when the
-facility is invoked), then you may convey a copy of the modified
-version:
-
-   a) under this License, provided that you make a good faith effort to
-   ensure that, in the event an Application does not supply the
-   function or data, the facility still operates, and performs
-   whatever part of its purpose remains meaningful, or
-
-   b) under the GNU GPL, with none of the additional permissions of
-   this License applicable to that copy.
-
-  3. Object Code Incorporating Material from Library Header Files.
-
-  The object code form of an Application may incorporate material from
-a header file that is part of the Library.  You may convey such object
-code under terms of your choice, provided that, if the incorporated
-material is not limited to numerical parameters, data structure
-layouts and accessors, or small macros, inline functions and templates
-(ten or fewer lines in length), you do both of the following:
-
-   a) Give prominent notice with each copy of the object code that the
-   Library is used in it and that the Library and its use are
-   covered by this License.
-
-   b) Accompany the object code with a copy of the GNU GPL and this license
-   document.
-
-  4. Combined Works.
-
-  You may convey a Combined Work under terms of your choice that,
-taken together, effectively do not restrict modification of the
-portions of the Library contained in the Combined Work and reverse
-engineering for debugging such modifications, if you also do each of
-the following:
-
-   a) Give prominent notice with each copy of the Combined Work that
-   the Library is used in it and that the Library and its use are
-   covered by this License.
-
-   b) Accompany the Combined Work with a copy of the GNU GPL and this license
-   document.
-
-   c) For a Combined Work that displays copyright notices during
-   execution, include the copyright notice for the Library among
-   these notices, as well as a reference directing the user to the
-   copies of the GNU GPL and this license document.
-
-   d) Do one of the following:
-
-       0) Convey the Minimal Corresponding Source under the terms of this
-       License, and the Corresponding Application Code in a form
-       suitable for, and under terms that permit, the user to
-       recombine or relink the Application with a modified version of
-       the Linked Version to produce a modified Combined Work, in the
-       manner specified by section 6 of the GNU GPL for conveying
-       Corresponding Source.
-
-       1) Use a suitable shared library mechanism for linking with the
-       Library.  A suitable mechanism is one that (a) uses at run time
-       a copy of the Library already present on the user's computer
-       system, and (b) will operate properly with a modified version
-       of the Library that is interface-compatible with the Linked
-       Version.
-
-   e) Provide Installation Information, but only if you would otherwise
-   be required to provide such information under section 6 of the
-   GNU GPL, and only to the extent that such information is
-   necessary to install and execute a modified version of the
-   Combined Work produced by recombining or relinking the
-   Application with a modified version of the Linked Version. (If
-   you use option 4d0, the Installation Information must accompany
-   the Minimal Corresponding Source and Corresponding Application
-   Code. If you use option 4d1, you must provide the Installation
-   Information in the manner specified by section 6 of the GNU GPL
-   for conveying Corresponding Source.)
-
-  5. Combined Libraries.
-
-  You may place library facilities that are a work based on the
-Library side by side in a single library together with other library
-facilities that are not Applications and are not covered by this
-License, and convey such a combined library under terms of your
-choice, if you do both of the following:
-
-   a) Accompany the combined library with a copy of the same work based
-   on the Library, uncombined with any other library facilities,
-   conveyed under the terms of this License.
-
-   b) Give prominent notice with the combined library that part of it
-   is a work based on the Library, and explaining where to find the
-   accompanying uncombined form of the same work.
-
-  6. Revised Versions of the GNU Lesser General Public License.
-
-  The Free Software Foundation may publish revised and/or new versions
-of the GNU Lesser General Public License from time to time. Such new
-versions will be similar in spirit to the present version, but may
-differ in detail to address new problems or concerns.
-
-  Each version is given a distinguishing version number. If the
-Library as you received it specifies that a certain numbered version
-of the GNU Lesser General Public License "or any later version"
-applies to it, you have the option of following the terms and
-conditions either of that published version or of any later version
-published by the Free Software Foundation. If the Library as you
-received it does not specify a version number of the GNU Lesser
-General Public License, you may choose any version of the GNU Lesser
-General Public License ever published by the Free Software Foundation.
-
-  If the Library as you received it specifies that a proxy can decide
-whether future versions of the GNU Lesser General Public License shall
-apply, that proxy's public statement of acceptance of any version is
-permanent authorization for you to choose that version for the
-Library.
+                   GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. [http://fsf.org/]
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+
+  This version of the GNU Lesser General Public License incorporates
+the terms and conditions of version 3 of the GNU General Public
+License, supplemented by the additional permissions listed below.
+
+  0. Additional Definitions.
+
+  As used herein, "this License" refers to version 3 of the GNU Lesser
+General Public License, and the "GNU GPL" refers to version 3 of the GNU
+General Public License.
+
+  "The Library" refers to a covered work governed by this License,
+other than an Application or a Combined Work as defined below.
+
+  An "Application" is any work that makes use of an interface provided
+by the Library, but which is not otherwise based on the Library.
+Defining a subclass of a class defined by the Library is deemed a mode
+of using an interface provided by the Library.
+
+  A "Combined Work" is a work produced by combining or linking an
+Application with the Library.  The particular version of the Library
+with which the Combined Work was made is also called the "Linked
+Version".
+
+  The "Minimal Corresponding Source" for a Combined Work means the
+Corresponding Source for the Combined Work, excluding any source code
+for portions of the Combined Work that, considered in isolation, are
+based on the Application, and not on the Linked Version.
+
+  The "Corresponding Application Code" for a Combined Work means the
+object code and/or source code for the Application, including any data
+and utility programs needed for reproducing the Combined Work from the
+Application, but excluding the System Libraries of the Combined Work.
+
+  1. Exception to Section 3 of the GNU GPL.
+
+  You may convey a covered work under sections 3 and 4 of this License
+without being bound by section 3 of the GNU GPL.
+
+  2. Conveying Modified Versions.
+
+  If you modify a copy of the Library, and, in your modifications, a
+facility refers to a function or data to be supplied by an Application
+that uses the facility (other than as an argument passed when the
+facility is invoked), then you may convey a copy of the modified
+version:
+
+   a) under this License, provided that you make a good faith effort to
+   ensure that, in the event an Application does not supply the
+   function or data, the facility still operates, and performs
+   whatever part of its purpose remains meaningful, or
+
+   b) under the GNU GPL, with none of the additional permissions of
+   this License applicable to that copy.
+
+  3. Object Code Incorporating Material from Library Header Files.
+
+  The object code form of an Application may incorporate material from
+a header file that is part of the Library.  You may convey such object
+code under terms of your choice, provided that, if the incorporated
+material is not limited to numerical parameters, data structure
+layouts and accessors, or small macros, inline functions and templates
+(ten or fewer lines in length), you do both of the following:
+
+   a) Give prominent notice with each copy of the object code that the
+   Library is used in it and that the Library and its use are
+   covered by this License.
+
+   b) Accompany the object code with a copy of the GNU GPL and this license
+   document.
+
+  4. Combined Works.
+
+  You may convey a Combined Work under terms of your choice that,
+taken together, effectively do not restrict modification of the
+portions of the Library contained in the Combined Work and reverse
+engineering for debugging such modifications, if you also do each of
+the following:
+
+   a) Give prominent notice with each copy of the Combined Work that
+   the Library is used in it and that the Library and its use are
+   covered by this License.
+
+   b) Accompany the Combined Work with a copy of the GNU GPL and this license
+   document.
+
+   c) For a Combined Work that displays copyright notices during
+   execution, include the copyright notice for the Library among
+   these notices, as well as a reference directing the user to the
+   copies of the GNU GPL and this license document.
+
+   d) Do one of the following:
+
+       0) Convey the Minimal Corresponding Source under the terms of this
+       License, and the Corresponding Application Code in a form
+       suitable for, and under terms that permit, the user to
+       recombine or relink the Application with a modified version of
+       the Linked Version to produce a modified Combined Work, in the
+       manner specified by section 6 of the GNU GPL for conveying
+       Corresponding Source.
+
+       1) Use a suitable shared library mechanism for linking with the
+       Library.  A suitable mechanism is one that (a) uses at run time
+       a copy of the Library already present on the user's computer
+       system, and (b) will operate properly with a modified version
+       of the Library that is interface-compatible with the Linked
+       Version.
+
+   e) Provide Installation Information, but only if you would otherwise
+   be required to provide such information under section 6 of the
+   GNU GPL, and only to the extent that such information is
+   necessary to install and execute a modified version of the
+   Combined Work produced by recombining or relinking the
+   Application with a modified version of the Linked Version. (If
+   you use option 4d0, the Installation Information must accompany
+   the Minimal Corresponding Source and Corresponding Application
+   Code. If you use option 4d1, you must provide the Installation
+   Information in the manner specified by section 6 of the GNU GPL
+   for conveying Corresponding Source.)
+
+  5. Combined Libraries.
+
+  You may place library facilities that are a work based on the
+Library side by side in a single library together with other library
+facilities that are not Applications and are not covered by this
+License, and convey such a combined library under terms of your
+choice, if you do both of the following:
+
+   a) Accompany the combined library with a copy of the same work based
+   on the Library, uncombined with any other library facilities,
+   conveyed under the terms of this License.
+
+   b) Give prominent notice with the combined library that part of it
+   is a work based on the Library, and explaining where to find the
+   accompanying uncombined form of the same work.
+
+  6. Revised Versions of the GNU Lesser General Public License.
+
+  The Free Software Foundation may publish revised and/or new versions
+of the GNU Lesser General Public License from time to time. Such new
+versions will be similar in spirit to the present version, but may
+differ in detail to address new problems or concerns.
+
+  Each version is given a distinguishing version number. If the
+Library as you received it specifies that a certain numbered version
+of the GNU Lesser General Public License "or any later version"
+applies to it, you have the option of following the terms and
+conditions either of that published version or of any later version
+published by the Free Software Foundation. If the Library as you
+received it does not specify a version number of the GNU Lesser
+General Public License, you may choose any version of the GNU Lesser
+General Public License ever published by the Free Software Foundation.
+
+  If the Library as you received it specifies that a proxy can decide
+whether future versions of the GNU Lesser General Public License shall
+apply, that proxy's public statement of acceptance of any version is
+permanent authorization for you to choose that version for the
+Library.
```

### Comparing `python-telegram-bot-8.1.1/python_telegram_bot.egg-info/SOURCES.txt` & `python-telegram-bot-9.0.0/python_telegram_bot.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -57,14 +57,17 @@
 telegram/files/__init__.py
 telegram/files/audio.py
 telegram/files/chatphoto.py
 telegram/files/contact.py
 telegram/files/document.py
 telegram/files/file.py
 telegram/files/inputfile.py
+telegram/files/inputmedia.py
+telegram/files/inputmediaphoto.py
+telegram/files/inputmediavideo.py
 telegram/files/location.py
 telegram/files/photosize.py
 telegram/files/sticker.py
 telegram/files/venue.py
 telegram/files/video.py
 telegram/files/videonote.py
 telegram/files/voice.py
```

### Comparing `python-telegram-bot-8.1.1/README.rst` & `python-telegram-bot-9.0.0/README.rst`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,210 +1,210 @@
-.. image:: https://github.com/python-telegram-bot/logos/blob/master/logo-text/png/ptb-logo-text_768.png?raw=true
-   :align: center
-   :target: https://python-telegram-bot.org
-   :alt: python-telegram-bot Logo
-
-We have made you a wrapper you can't refuse
-
-*Stay tuned for library updates and new releases on our* `Telegram Channel <https://telegram.me/pythontelegrambotchannel>`_.
-
-.. image:: https://img.shields.io/pypi/v/python-telegram-bot.svg
-   :target: https://pypi.python.org/pypi/python-telegram-bot
-   :alt: PyPi Package Version
-
-.. image:: https://img.shields.io/pypi/pyversions/python-telegram-bot.svg
-   :target: https://pypi.python.org/pypi/python-telegram-bot
-   :alt: Supported python versions
-
-.. image:: https://www.cpu.re/static/python-telegram-bot/downloads.svg
-   :target: https://www.cpu.re/static/python-telegram-bot/downloads-by-python-version.txt
-   :alt: PyPi Package Monthly Download
-
-.. image:: https://img.shields.io/badge/docs-latest-af1a97.svg
-   :target: https://python-telegram-bot.readthedocs.io/
-   :alt: Documentation Status
-
-.. image:: https://img.shields.io/pypi/l/python-telegram-bot.svg
-   :target: https://www.gnu.org/licenses/lgpl-3.0.html
-   :alt: LGPLv3 License
-
-.. image:: https://travis-ci.org/python-telegram-bot/python-telegram-bot.svg?branch=master
-   :target: https://travis-ci.org/python-telegram-bot/python-telegram-bot
-   :alt: Travis CI Status
-
-.. image:: https://img.shields.io/appveyor/ci/Eldinnie/python-telegram-bot/master.svg?logo=appveyor
-   :target: https://ci.appveyor.com/project/Eldinnie/python-telegram-bot
-   :alt: AppVeyor CI Status
-
-.. image:: https://codeclimate.com/github/python-telegram-bot/python-telegram-bot/badges/gpa.svg
-   :target: https://codeclimate.com/github/python-telegram-bot/python-telegram-bot
-   :alt: Code Climate
-
-.. image:: https://codecov.io/gh/python-telegram-bot/python-telegram-bot/branch/master/graph/badge.svg
-   :target: https://codecov.io/gh/python-telegram-bot/python-telegram-bot
-   :alt: Code coverage
-   
-.. image:: http://isitmaintained.com/badge/resolution/python-telegram-bot/python-telegram-bot.svg
-   :target: http://isitmaintained.com/project/python-telegram-bot/python-telegram-bot
-   :alt: Median time to resolve an issue
-
-.. image:: https://img.shields.io/badge/Telegram-Group-blue.svg
-   :target: https://telegram.me/pythontelegrambotgroup
-   :alt: Telegram Group
-
-.. image:: https://img.shields.io/badge/IRC-Channel-blue.svg
-   :target: https://webchat.freenode.net/?channels=##python-telegram-bot
-   :alt: IRC Bridge
-
-=================
-Table of contents
-=================
-
-- `Introduction`_
-
-- `Telegram API support`_
-
-- `Installing`_
-
-- `Getting started`_
-
-  #. `Learning by example`_
-
-  #. `Logging`_
-
-  #. `Documentation`_
-
-- `Getting help`_
-
-- `Contributing`_
-
-- `License`_
-
-============
-Introduction
-============
-
-This library provides a pure Python interface for the
-`Telegram Bot API <https://core.telegram.org/bots/api>`_.
-It's compatible with Python versions 2.7, 3.3+ and `PyPy <http://pypy.org/>`_.
-It also works with `Google App Engine <https://cloud.google.com/appengine>`_.
-
-In addition to the pure API implementation, this library features a number of high-level classes to
-make the development of bots easy and straightforward. These classes are contained in the
-``telegram.ext`` submodule.
-
-====================
-Telegram API support
-====================
-
-All types and methods of the Telegram Bot API 3.4 are supported.
-
-==========
-Installing
-==========
-
-You can install or upgrade python-telegram-bot with:
-
-.. code:: shell
-
-    $ pip install python-telegram-bot --upgrade
-
-Or you can install from source with:
-
-.. code:: shell
-
-    $ git clone https://github.com/python-telegram-bot/python-telegram-bot --recursive
-    $ cd python-telegram-bot
-    $ python setup.py install
-    
-In case you have a previously cloned local repository already, you should initialize the added urllib3 submodule before installing with:
-
-.. code:: shell
-
-    $ git submodule update --init --recursive
-
-===============
-Getting started
-===============
-
-Our Wiki contains a lot of resources to get you started with ``python-telegram-bot``:
-
-- `Introduction to the API <https://github.com/python-telegram-bot/python-telegram-bot/wiki/Introduction-to-the-API>`_
-- Tutorial: `Your first Bot <https://github.com/python-telegram-bot/python-telegram-bot/wiki/Extensions-%E2%80%93-Your-first-Bot>`_
-
-Other references:
-
-- `Telegram API documentation <https://core.telegram.org/bots/api>`_
-- `python-telegram-bot documentation <https://python-telegram-bot.readthedocs.io/>`_
-
--------------------
-Learning by example
--------------------
-
-We believe that the best way to learn and understand this simple package is by example. So here
-are some examples for you to review. Even if it's not your approach for learning, please take a
-look at ``echobot2``, it is de facto the base for most of the bots out there. Best of all,
-the code for these examples are released to the public domain, so you can start by grabbing the
-code and building on top of it.
-
-Visit `this page <https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/README.md>`_ to discover the official examples or look at the examples on the `wiki <https://github.com/python-telegram-bot/python-telegram-bot/wiki/Examples>`_ to see other bots the community has built.
-
--------
-Logging
--------
-
-This library uses the ``logging`` module. To set up logging to standard output, put:
-
-.. code:: python
-
-    import logging
-    logging.basicConfig(level=logging.DEBUG,
-                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
-
-at the beginning of your script.
-
-You can also use logs in your application by calling ``logging.getLogger()`` and setting the log level you want:
-
-.. code:: python
-
-    logger = logging.getLogger()
-    logger.setLevel(logging.INFO)
-
-If you want DEBUG logs instead:
-
-.. code:: python
-
-    logger.setLevel(logging.DEBUG)
-
-
-=============
-Documentation
-=============
-
-``python-telegram-bot``'s documentation lives at `readthedocs.io <https://python-telegram-bot.readthedocs.io/>`_.
-
-============
-Getting help
-============
-
-You can get help in several ways:
-
-1. We have a vibrant community of developers helping each other in our `Telegram group <https://telegram.me/pythontelegrambotgroup>`_. Join us!
-
-2. Our `Wiki pages <https://github.com/python-telegram-bot/python-telegram-bot/wiki/>`_ offer a growing amount of resources.
-
-3. You can ask for help on Stack Overflow using the `python-telegram-bot tag <https://stackoverflow.com/questions/tagged/python-telegram-bot>`_.
-
-4. As last resort, the developers are ready to help you with `serious issues <https://github.com/python-telegram-bot/python-telegram-bot/issues/new>`_.
-
-
-============
-Contributing
-============
-
-Contributions of all sizes are welcome. Please review our `contribution guidelines <https://github.com/python-telegram-bot/python-telegram-bot/blob/master/.github/CONTRIBUTING.rst>`_ to get started. You can also help by `reporting bugs <https://github.com/python-telegram-bot/python-telegram-bot/issues/new>`_.
-
-=======
-License
-=======
-
-You may copy, distribute and modify the software provided that modifications are described and licensed for free under `LGPL-3 <https://www.gnu.org/licenses/lgpl-3.0.html>`_. Derivatives works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don't have to be.
+.. image:: https://github.com/python-telegram-bot/logos/blob/master/logo-text/png/ptb-logo-text_768.png?raw=true
+   :align: center
+   :target: https://python-telegram-bot.org
+   :alt: python-telegram-bot Logo
+
+We have made you a wrapper you can't refuse
+
+*Stay tuned for library updates and new releases on our* `Telegram Channel <https://telegram.me/pythontelegrambotchannel>`_.
+
+.. image:: https://img.shields.io/pypi/v/python-telegram-bot.svg
+   :target: https://pypi.python.org/pypi/python-telegram-bot
+   :alt: PyPi Package Version
+
+.. image:: https://img.shields.io/pypi/pyversions/python-telegram-bot.svg
+   :target: https://pypi.python.org/pypi/python-telegram-bot
+   :alt: Supported python versions
+
+.. image:: https://www.cpu.re/static/python-telegram-bot/downloads.svg
+   :target: https://www.cpu.re/static/python-telegram-bot/downloads-by-python-version.txt
+   :alt: PyPi Package Monthly Download
+
+.. image:: https://img.shields.io/badge/docs-latest-af1a97.svg
+   :target: https://python-telegram-bot.readthedocs.io/
+   :alt: Documentation Status
+
+.. image:: https://img.shields.io/pypi/l/python-telegram-bot.svg
+   :target: https://www.gnu.org/licenses/lgpl-3.0.html
+   :alt: LGPLv3 License
+
+.. image:: https://travis-ci.org/python-telegram-bot/python-telegram-bot.svg?branch=master
+   :target: https://travis-ci.org/python-telegram-bot/python-telegram-bot
+   :alt: Travis CI Status
+
+.. image:: https://img.shields.io/appveyor/ci/Eldinnie/python-telegram-bot/master.svg?logo=appveyor
+   :target: https://ci.appveyor.com/project/Eldinnie/python-telegram-bot
+   :alt: AppVeyor CI Status
+
+.. image:: https://codeclimate.com/github/python-telegram-bot/python-telegram-bot/badges/gpa.svg
+   :target: https://codeclimate.com/github/python-telegram-bot/python-telegram-bot
+   :alt: Code Climate
+
+.. image:: https://codecov.io/gh/python-telegram-bot/python-telegram-bot/branch/master/graph/badge.svg
+   :target: https://codecov.io/gh/python-telegram-bot/python-telegram-bot
+   :alt: Code coverage
+   
+.. image:: http://isitmaintained.com/badge/resolution/python-telegram-bot/python-telegram-bot.svg
+   :target: http://isitmaintained.com/project/python-telegram-bot/python-telegram-bot
+   :alt: Median time to resolve an issue
+
+.. image:: https://img.shields.io/badge/Telegram-Group-blue.svg
+   :target: https://telegram.me/pythontelegrambotgroup
+   :alt: Telegram Group
+
+.. image:: https://img.shields.io/badge/IRC-Channel-blue.svg
+   :target: https://webchat.freenode.net/?channels=##python-telegram-bot
+   :alt: IRC Bridge
+
+=================
+Table of contents
+=================
+
+- `Introduction`_
+
+- `Telegram API support`_
+
+- `Installing`_
+
+- `Getting started`_
+
+  #. `Learning by example`_
+
+  #. `Logging`_
+
+  #. `Documentation`_
+
+- `Getting help`_
+
+- `Contributing`_
+
+- `License`_
+
+============
+Introduction
+============
+
+This library provides a pure Python interface for the
+`Telegram Bot API <https://core.telegram.org/bots/api>`_.
+It's compatible with Python versions 2.7, 3.3+ and `PyPy <http://pypy.org/>`_.
+It also works with `Google App Engine <https://cloud.google.com/appengine>`_.
+
+In addition to the pure API implementation, this library features a number of high-level classes to
+make the development of bots easy and straightforward. These classes are contained in the
+``telegram.ext`` submodule.
+
+====================
+Telegram API support
+====================
+
+All types and methods of the Telegram Bot API 3.4 are supported.
+
+==========
+Installing
+==========
+
+You can install or upgrade python-telegram-bot with:
+
+.. code:: shell
+
+    $ pip install python-telegram-bot --upgrade
+
+Or you can install from source with:
+
+.. code:: shell
+
+    $ git clone https://github.com/python-telegram-bot/python-telegram-bot --recursive
+    $ cd python-telegram-bot
+    $ python setup.py install
+    
+In case you have a previously cloned local repository already, you should initialize the added urllib3 submodule before installing with:
+
+.. code:: shell
+
+    $ git submodule update --init --recursive
+
+===============
+Getting started
+===============
+
+Our Wiki contains a lot of resources to get you started with ``python-telegram-bot``:
+
+- `Introduction to the API <https://github.com/python-telegram-bot/python-telegram-bot/wiki/Introduction-to-the-API>`_
+- Tutorial: `Your first Bot <https://github.com/python-telegram-bot/python-telegram-bot/wiki/Extensions-%E2%80%93-Your-first-Bot>`_
+
+Other references:
+
+- `Telegram API documentation <https://core.telegram.org/bots/api>`_
+- `python-telegram-bot documentation <https://python-telegram-bot.readthedocs.io/>`_
+
+-------------------
+Learning by example
+-------------------
+
+We believe that the best way to learn and understand this simple package is by example. So here
+are some examples for you to review. Even if it's not your approach for learning, please take a
+look at ``echobot2``, it is de facto the base for most of the bots out there. Best of all,
+the code for these examples are released to the public domain, so you can start by grabbing the
+code and building on top of it.
+
+Visit `this page <https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/README.md>`_ to discover the official examples or look at the examples on the `wiki <https://github.com/python-telegram-bot/python-telegram-bot/wiki/Examples>`_ to see other bots the community has built.
+
+-------
+Logging
+-------
+
+This library uses the ``logging`` module. To set up logging to standard output, put:
+
+.. code:: python
+
+    import logging
+    logging.basicConfig(level=logging.DEBUG,
+                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+
+at the beginning of your script.
+
+You can also use logs in your application by calling ``logging.getLogger()`` and setting the log level you want:
+
+.. code:: python
+
+    logger = logging.getLogger()
+    logger.setLevel(logging.INFO)
+
+If you want DEBUG logs instead:
+
+.. code:: python
+
+    logger.setLevel(logging.DEBUG)
+
+
+=============
+Documentation
+=============
+
+``python-telegram-bot``'s documentation lives at `readthedocs.io <https://python-telegram-bot.readthedocs.io/>`_.
+
+============
+Getting help
+============
+
+You can get help in several ways:
+
+1. We have a vibrant community of developers helping each other in our `Telegram group <https://telegram.me/pythontelegrambotgroup>`_. Join us!
+
+2. Our `Wiki pages <https://github.com/python-telegram-bot/python-telegram-bot/wiki/>`_ offer a growing amount of resources.
+
+3. You can ask for help on Stack Overflow using the `python-telegram-bot tag <https://stackoverflow.com/questions/tagged/python-telegram-bot>`_.
+
+4. As last resort, the developers are ready to help you with `serious issues <https://github.com/python-telegram-bot/python-telegram-bot/issues/new>`_.
+
+
+============
+Contributing
+============
+
+Contributions of all sizes are welcome. Please review our `contribution guidelines <https://github.com/python-telegram-bot/python-telegram-bot/blob/master/.github/CONTRIBUTING.rst>`_ to get started. You can also help by `reporting bugs <https://github.com/python-telegram-bot/python-telegram-bot/issues/new>`_.
+
+=======
+License
+=======
+
+You may copy, distribute and modify the software provided that modifications are described and licensed for free under `LGPL-3 <https://www.gnu.org/licenses/lgpl-3.0.html>`_. Derivatives works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don't have to be.
```

### Comparing `python-telegram-bot-8.1.1/setup.cfg` & `python-telegram-bot-9.0.0/setup.cfg`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -32,11 +32,11 @@
 concurrency = thread, multiprocessing
 omit = 
 	tests/
 	telegram/__main__.py
 	telegram/vendor/*
 
 [egg_info]
+tag_svn_revision = 0
 tag_build = 
 tag_date = 0
-tag_svn_revision = 0
```

### Comparing `python-telegram-bot-8.1.1/telegram/base.py` & `python-telegram-bot-9.0.0/telegram/base.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""Base class for Telegram Objects."""
-
-try:
-    import ujson as json
-except ImportError:
-    import json
-
-from abc import ABCMeta
-
-
-class TelegramObject(object):
-    """Base class for most telegram objects."""
-
-    __metaclass__ = ABCMeta
-    _id_attrs = ()
-
-    def __str__(self):
-        return str(self.to_dict())
-
-    def __getitem__(self, item):
-        return self.__dict__[item]
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = data.copy()
-
-        return data
-
-    def to_json(self):
-        """
-        Returns:
-            :obj:`str`
-
-        """
-
-        return json.dumps(self.to_dict())
-
-    def to_dict(self):
-        data = dict()
-
-        for key in iter(self.__dict__):
-            if key in ('bot', '_id_attrs'):
-                continue
-
-            value = self.__dict__[key]
-            if value is not None:
-                if hasattr(value, 'to_dict'):
-                    data[key] = value.to_dict()
-                else:
-                    data[key] = value
-
-        return data
-
-    def __eq__(self, other):
-        if isinstance(other, self.__class__):
-            return self._id_attrs == other._id_attrs
-        return super(TelegramObject, self).__eq__(other)  # pylint: disable=no-member
-
-    def __hash__(self):
-        if self._id_attrs:
-            return hash((self.__class__, self._id_attrs))  # pylint: disable=no-member
-        return super(TelegramObject, self).__hash__()
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""Base class for Telegram Objects."""
+
+try:
+    import ujson as json
+except ImportError:
+    import json
+
+from abc import ABCMeta
+
+
+class TelegramObject(object):
+    """Base class for most telegram objects."""
+
+    __metaclass__ = ABCMeta
+    _id_attrs = ()
+
+    def __str__(self):
+        return str(self.to_dict())
+
+    def __getitem__(self, item):
+        return self.__dict__[item]
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = data.copy()
+
+        return data
+
+    def to_json(self):
+        """
+        Returns:
+            :obj:`str`
+
+        """
+
+        return json.dumps(self.to_dict())
+
+    def to_dict(self):
+        data = dict()
+
+        for key in iter(self.__dict__):
+            if key in ('bot', '_id_attrs'):
+                continue
+
+            value = self.__dict__[key]
+            if value is not None:
+                if hasattr(value, 'to_dict'):
+                    data[key] = value.to_dict()
+                else:
+                    data[key] = value
+
+        return data
+
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            return self._id_attrs == other._id_attrs
+        return super(TelegramObject, self).__eq__(other)  # pylint: disable=no-member
+
+    def __hash__(self):
+        if self._id_attrs:
+            return hash((self.__class__, self._id_attrs))  # pylint: disable=no-member
+        return super(TelegramObject, self).__hash__()
```

### Comparing `python-telegram-bot-8.1.1/telegram/bot.py` & `python-telegram-bot-9.0.0/telegram/bot.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,3014 +1,3072 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-# pylint: disable=E0611,E0213,E1102,C0103,E1101,W0613,R0913,R0904
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Bot."""
-
-import functools
-import logging
-import warnings
-from datetime import datetime
-
-from telegram import (User, Message, Update, Chat, ChatMember, UserProfilePhotos, File,
-                      ReplyMarkup, TelegramObject, WebhookInfo, GameHighScore, StickerSet,
-                      PhotoSize, Audio, Document, Sticker, Video, Voice, VideoNote, Location,
-                      Venue, Contact)
-from telegram.error import InvalidToken, TelegramError
-from telegram.utils.helpers import to_timestamp
-from telegram.utils.request import Request
-
-logging.getLogger(__name__).addHandler(logging.NullHandler())
-
-
-def info(func):
-    @functools.wraps(func)
-    def decorator(self, *args, **kwargs):
-        if not self.bot:
-            self.get_me()
-
-        result = func(self, *args, **kwargs)
-        return result
-
-    return decorator
-
-
-def log(func):
-    logger = logging.getLogger(func.__module__)
-
-    @functools.wraps(func)
-    def decorator(self, *args, **kwargs):
-        logger.debug('Entering: %s', func.__name__)
-        result = func(self, *args, **kwargs)
-        logger.debug(result)
-        logger.debug('Exiting: %s', func.__name__)
-        return result
-
-    return decorator
-
-
-def message(func):
-    @functools.wraps(func)
-    def decorator(self, *args, **kwargs):
-        url, data = func(self, *args, **kwargs)
-        if kwargs.get('reply_to_message_id'):
-            data['reply_to_message_id'] = kwargs.get('reply_to_message_id')
-
-        if kwargs.get('disable_notification'):
-            data['disable_notification'] = kwargs.get('disable_notification')
-
-        if kwargs.get('reply_markup'):
-            reply_markup = kwargs.get('reply_markup')
-            if isinstance(reply_markup, ReplyMarkup):
-                data['reply_markup'] = reply_markup.to_json()
-            else:
-                data['reply_markup'] = reply_markup
-
-        result = self._request.post(url, data, timeout=kwargs.get('timeout'))
-
-        if result is True:
-            return result
-
-        return Message.de_json(result, self)
-
-    return decorator
-
-
-class Bot(TelegramObject):
-    """This object represents a Telegram Bot.
-
-    Args:
-        token (:obj:`str`): Bot's unique authentication.
-        base_url (:obj:`str`, optional): Telegram Bot API service URL.
-        base_file_url (:obj:`str`, optional): Telegram Bot API file URL.
-        request (:obj:`telegram.utils.request.Request`, optional): Pre initialized
-            :obj:`telegram.utils.request.Request`.
-
-    """
-
-    def __init__(self, token, base_url=None, base_file_url=None, request=None):
-        self.token = self._validate_token(token)
-
-        if base_url is None:
-            base_url = 'https://api.telegram.org/bot'
-
-        if base_file_url is None:
-            base_file_url = 'https://api.telegram.org/file/bot'
-
-        self.base_url = str(base_url) + str(self.token)
-        self.base_file_url = str(base_file_url) + str(self.token)
-        self.bot = None
-        self._request = request or Request()
-        self.logger = logging.getLogger(__name__)
-
-    @property
-    def request(self):
-        return self._request
-
-    @staticmethod
-    def _validate_token(token):
-        """A very basic validation on token."""
-        if any(x.isspace() for x in token):
-            raise InvalidToken()
-
-        left, sep, _right = token.partition(':')
-        if (not sep) or (not left.isdigit()) or (len(left) < 3):
-            raise InvalidToken()
-
-        return token
-
-    @property
-    @info
-    def id(self):
-        """:obj:`int`: Unique identifier for this bot."""
-
-        return self.bot.id
-
-    @property
-    @info
-    def first_name(self):
-        """:obj:`str`: Bot's first name."""
-
-        return self.bot.first_name
-
-    @property
-    @info
-    def last_name(self):
-        """:obj:`str`: Optional. Bot's last name."""
-
-        return self.bot.last_name
-
-    @property
-    @info
-    def username(self):
-        """:obj:`str`: Bot's username."""
-
-        return self.bot.username
-
-    @property
-    def name(self):
-        """:obj:`str`: Bot's @username."""
-
-        return '@{0}'.format(self.username)
-
-    @log
-    def get_me(self, timeout=None, **kwargs):
-        """A simple method for testing your bot's auth token. Requires no parameters.
-
-        Args:
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-
-        Returns:
-            :class:`telegram.User`: A :class:`telegram.User` instance representing that bot if the
-            credentials are valid, :obj:`None` otherwise.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getMe'.format(self.base_url)
-
-        result = self._request.get(url, timeout=timeout)
-
-        self.bot = User.de_json(result, self)
-
-        return self.bot
-
-    @log
-    @message
-    def send_message(self,
-                     chat_id,
-                     text,
-                     parse_mode=None,
-                     disable_web_page_preview=None,
-                     disable_notification=False,
-                     reply_to_message_id=None,
-                     reply_markup=None,
-                     timeout=None,
-                     **kwargs):
-        """Use this method to send text messages.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            text (:obj:`str`): Text of the message to be sent. Max 4096 characters. Also found as
-                :attr:`telegram.constants.MAX_MESSAGE_LENGTH`.
-            parse_mode (:obj:`str`): Send Markdown or HTML, if you want Telegram apps to show bold,
-                italic, fixed-width text or inline URLs in your bot's message. See the constants in
-                :class:`telegram.ParseMode` for the available modes.
-            disable_web_page_preview (:obj:`bool`, optional): Disables link previews for links in
-                this message.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options.
-                A JSON-serialized object for an inline keyboard, custom reply keyboard,
-                instructions to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendMessage'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'text': text}
-
-        if parse_mode:
-            data['parse_mode'] = parse_mode
-        if disable_web_page_preview:
-            data['disable_web_page_preview'] = disable_web_page_preview
-
-        return url, data
-
-    @log
-    def delete_message(self, chat_id, message_id, timeout=None, **kwargs):
-        """
-        Use this method to delete a message. A message can only be deleted if it was sent less
-        than 48 hours ago. Any such recently sent outgoing message may be deleted. Additionally,
-        if the bot is an administrator in a group chat, it can delete any message. If the bot is
-        an administrator in a supergroup, it can delete messages from any other user and service
-        messages about people joining or leaving the group (other types of service messages may
-        only be removed by the group creator). In channels, bots can only remove their own
-        messages.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            message_id (:obj:`int`): Identifier of the message to delete.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-            the read timeout
-                from the server (instead of the one specified during creation of the connection
-                pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool`: On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/deleteMessage'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'message_id': message_id}
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    @message
-    def forward_message(self,
-                        chat_id,
-                        from_chat_id,
-                        message_id,
-                        disable_notification=False,
-                        timeout=None,
-                        **kwargs):
-        """Use this method to forward messages of any kind.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            from_chat_id (:obj:`int` | :obj:`str`): Unique identifier for the chat where the
-                original message was sent (or channel username in the format @channelusername).
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            message_id (:obj:`int`): Message identifier in the chat specified in from_chat_id.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-            the read timeout
-                from the server (instead of the one specified during creation of the connection
-                pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/forwardMessage'.format(self.base_url)
-
-        data = {}
-
-        if chat_id:
-            data['chat_id'] = chat_id
-        if from_chat_id:
-            data['from_chat_id'] = from_chat_id
-        if message_id:
-            data['message_id'] = message_id
-
-        return url, data
-
-    @log
-    @message
-    def send_photo(self,
-                   chat_id,
-                   photo,
-                   caption=None,
-                   disable_notification=False,
-                   reply_to_message_id=None,
-                   reply_markup=None,
-                   timeout=20.,
-                   **kwargs):
-        """Use this method to send photos.
-
-        Note:
-            The video argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            photo (:obj:`str` | `filelike object` | :class:`telegram.PhotoSize`): Photo to send.
-                Pass a file_id as String to send a photo that exists on the Telegram servers
-                (recommended), pass an HTTP URL as a String for Telegram to get a photo from the
-                Internet, or upload a new photo using multipart/form-data. Lastly you can pass
-                an existing :class:`telegram.PhotoSize` object to send.
-            caption (:obj:`str`, optional): Photo caption (may also be used when resending photos
-                by file_id), 0-200 characters.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendPhoto'.format(self.base_url)
-
-        if isinstance(photo, PhotoSize):
-            photo = photo.file_id
-
-        data = {'chat_id': chat_id, 'photo': photo}
-
-        if caption:
-            data['caption'] = caption
-
-        return url, data
-
-    @log
-    @message
-    def send_audio(self,
-                   chat_id,
-                   audio,
-                   duration=None,
-                   performer=None,
-                   title=None,
-                   caption=None,
-                   disable_notification=False,
-                   reply_to_message_id=None,
-                   reply_markup=None,
-                   timeout=20.,
-                   **kwargs):
-        """
-        Use this method to send audio files, if you want Telegram clients to display them in the
-        music player. Your audio must be in the .mp3 format. On success, the sent Message is
-        returned. Bots can currently send audio files of up to 50 MB in size, this limit may be
-        changed in the future.
-
-        For sending voice messages, use the sendVoice method instead.
-
-        Note:
-            The audio argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            audio (:obj:`str` | `filelike object` | :class:`telegram.Audio`): Audio file to send.
-                Pass a file_id as String to send an audio file that exists on the Telegram servers
-                (recommended), pass an HTTP URL as a String for Telegram to get an audio file from
-                the Internet, or upload a new one using multipart/form-data. Lastly you can pass
-                an existing :class:`telegram.Audio` object to send.
-            caption (:obj:`str`, optional): Audio caption, 0-200 characters.
-            duration (:obj:`int`, optional): Duration of sent audio in seconds.
-            performer (:obj:`str`, optional): Performer.
-            title (:obj:`str`, optional): Track name.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendAudio'.format(self.base_url)
-
-        if isinstance(audio, Audio):
-            audio = audio.file_id
-
-        data = {'chat_id': chat_id, 'audio': audio}
-
-        if duration:
-            data['duration'] = duration
-        if performer:
-            data['performer'] = performer
-        if title:
-            data['title'] = title
-        if caption:
-            data['caption'] = caption
-
-        return url, data
-
-    @log
-    @message
-    def send_document(self,
-                      chat_id,
-                      document,
-                      filename=None,
-                      caption=None,
-                      disable_notification=False,
-                      reply_to_message_id=None,
-                      reply_markup=None,
-                      timeout=20.,
-                      **kwargs):
-        """Use this method to send general files.
-
-        Note:
-            The document argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            document (:obj:`str` | `filelike object` | :class:`telegram.Document`): File to send.
-                Pass a file_id as String to send a file that exists on the Telegram servers
-                (recommended), pass an HTTP URL as a String for Telegram to get a file from the
-                Internet, or upload a new one using multipart/form-data. Lastly you can pass
-                an existing :class:`telegram.Document` object to send.
-            filename (:obj:`str`, optional): File name that shows in telegram message (it is useful
-                when you send file generated by temp module, for example). Undocumented.
-            caption (:obj:`str`, optional): Document caption (may also be used when resending
-                documents by file_id), 0-200 characters.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendDocument'.format(self.base_url)
-
-        if isinstance(document, Document):
-            document = document.file_id
-
-        data = {'chat_id': chat_id, 'document': document}
-
-        if filename:
-            data['filename'] = filename
-        if caption:
-            data['caption'] = caption
-
-        return url, data
-
-    @log
-    @message
-    def send_sticker(self,
-                     chat_id,
-                     sticker,
-                     disable_notification=False,
-                     reply_to_message_id=None,
-                     reply_markup=None,
-                     timeout=None,
-                     **kwargs):
-        """Use this method to send .webp stickers.
-
-        Note:
-            The sticker argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            sticker (:obj:`str` | `filelike object` :class:`telegram.Sticker`): Sticker to send.
-                Pass a file_id as String to send a file that exists on the Telegram servers
-                (recommended), pass an HTTP URL as a String for Telegram to get a .webp file from
-                the Internet, or upload a new one using multipart/form-data. Lastly you can pass
-                an existing :class:`telegram.Sticker` object to send.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendSticker'.format(self.base_url)
-
-        if isinstance(sticker, Sticker):
-            sticker = sticker.file_id
-
-        data = {'chat_id': chat_id, 'sticker': sticker}
-
-        return url, data
-
-    @log
-    @message
-    def send_video(self,
-                   chat_id,
-                   video,
-                   duration=None,
-                   caption=None,
-                   disable_notification=False,
-                   reply_to_message_id=None,
-                   reply_markup=None,
-                   timeout=20.,
-                   width=None,
-                   height=None,
-                   **kwargs):
-        """
-        Use this method to send video files, Telegram clients support mp4 videos
-        (other formats may be sent as Document).
-
-        Note:
-            The video argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            video (:obj:`str` | `filelike object` | :class:`telegram.Video`): Video file to send.
-                Pass a file_id as String to send an video file that exists on the Telegram servers
-                (recommended), pass an HTTP URL as a String for Telegram to get an video file from
-                the Internet, or upload a new one using multipart/form-data. Lastly you can pass
-                an existing :class:`telegram.Video` object to send.
-            duration (:obj:`int`, optional): Duration of sent video in seconds.
-            width (:obj:`int`, optional): Video width.
-            height (:obj:`int`, optional): Video height.
-            caption (:obj:`str`, optional): Video caption (may also be used when resending videos
-                by file_id), 0-200 characters.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendVideo'.format(self.base_url)
-
-        if isinstance(video, Video):
-            video = video.file_id
-
-        data = {'chat_id': chat_id, 'video': video}
-
-        if duration:
-            data['duration'] = duration
-        if caption:
-            data['caption'] = caption
-        if width:
-            data['width'] = width
-        if height:
-            data['height'] = height
-
-        return url, data
-
-    @log
-    @message
-    def send_voice(self,
-                   chat_id,
-                   voice,
-                   duration=None,
-                   caption=None,
-                   disable_notification=False,
-                   reply_to_message_id=None,
-                   reply_markup=None,
-                   timeout=20.,
-                   **kwargs):
-        """
-        Use this method to send audio files, if you want Telegram clients to display the file
-        as a playable voice message. For this to work, your audio must be in an .ogg file
-        encoded with OPUS (other formats may be sent as Audio or Document).
-
-        Note:
-            The voice argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            voice (:obj:`str` | `filelike object` | :class:`telegram.Voice`): Voice file to send.
-                Pass a file_id as String to send an voice file that exists on the Telegram servers
-                (recommended), pass an HTTP URL as a String for Telegram to get an voice file from
-                the Internet, or upload a new one using multipart/form-data. Lastly you can pass
-                an existing :class:`telegram.Voice` object to send.
-            caption (:obj:`str`, optional): Voice message caption, 0-200 characters.
-            duration (:obj:`int`, optional): Duration of the voice message in seconds.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard,
-                instructions to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendVoice'.format(self.base_url)
-
-        if isinstance(voice, Voice):
-            voice = voice.file_id
-
-        data = {'chat_id': chat_id, 'voice': voice}
-
-        if duration:
-            data['duration'] = duration
-        if caption:
-            data['caption'] = caption
-
-        return url, data
-
-    @log
-    @message
-    def send_video_note(self,
-                        chat_id,
-                        video_note,
-                        duration=None,
-                        length=None,
-                        disable_notification=False,
-                        reply_to_message_id=None,
-                        reply_markup=None,
-                        timeout=20.,
-                        **kwargs):
-        """Use this method to send video messages.
-
-        Note:
-            The video_note argument can be either a file_id or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            video_note (:obj:`str` | `filelike object` | :class:`telegram.VideoNote`): Video note
-                to send. Pass a file_id as String to send a video note that exists on the Telegram
-                servers (recommended) or upload a new video using multipart/form-data. Or you can
-                pass an existing :class:`telegram.VideoNote` object to send. Sending video notes by
-                a URL is currently unsupported.
-            duration (:obj:`int`, optional): Duration of sent video in seconds.
-            length (:obj:`int`, optional): Video width and height
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard,
-                instructions to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendVideoNote'.format(self.base_url)
-
-        if isinstance(video_note, VideoNote):
-            video_note = video_note.file_id
-
-        data = {'chat_id': chat_id, 'video_note': video_note}
-
-        if duration is not None:
-            data['duration'] = duration
-        if length is not None:
-            data['length'] = length
-
-        return url, data
-
-    @log
-    @message
-    def send_location(self,
-                      chat_id,
-                      latitude=None,
-                      longitude=None,
-                      disable_notification=False,
-                      reply_to_message_id=None,
-                      reply_markup=None,
-                      timeout=None,
-                      location=None,
-                      live_period=None,
-                      **kwargs):
-        """Use this method to send point on the map.
-
-        Note:
-            You can either supply a :obj:`latitude` and :obj:`longitude` or a :obj:`location`.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            latitude (:obj:`float`, optional): Latitude of location.
-            longitude (:obj:`float`, optional): Longitude of location.
-            location (:class:`telegram.Location`, optional): The location to send.
-            live_period (:obj:`int`, optional): Period in seconds for which the location will be
-                updated, should be between 60 and 86400.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                    original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard,
-                instructions to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendLocation'.format(self.base_url)
-
-        if not (all([latitude, longitude]) or location):
-            raise ValueError("Either location or latitude and longitude must be passed as"
-                             "argument.")
-
-        if not ((latitude is not None or longitude is not None) ^ bool(location)):
-            raise ValueError("Either location or latitude and longitude must be passed as"
-                             "argument. Not both.")
-
-        if isinstance(location, Location):
-            latitude = location.latitude
-            longitude = location.longitude
-
-        data = {'chat_id': chat_id, 'latitude': latitude, 'longitude': longitude}
-
-        if live_period:
-            data['live_period'] = live_period
-
-        return url, data
-
-    @log
-    @message
-    def edit_message_live_location(self,
-                                   chat_id=None,
-                                   message_id=None,
-                                   inline_message_id=None,
-                                   latitude=None,
-                                   longitude=None,
-                                   location=None,
-                                   reply_markup=None,
-                                   **kwargs):
-        """Use this method to edit live location messages sent by the bot or via the bot
-        (for inline bots). A location can be edited until its :attr:`live_period` expires or
-        editing is explicitly disabled by a call to :attr:`stop_message_live_location`.
-
-        Note:
-            You can either supply a :obj:`latitude` and :obj:`longitude` or a :obj:`location`.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
-                Identifier of the sent message.
-            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
-                specified. Identifier of the inline message.
-            latitude (:obj:`float`, optional): Latitude of location.
-            longitude (:obj:`float`, optional): Longitude of location.
-            location (:class:`telegram.Location`, optional): The location to send.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-
-        Returns:
-             :class:`telegram.Message`: On success the edited message.
-        """
-
-        url = '{0}/editMessageLiveLocation'.format(self.base_url)
-
-        if not (all([latitude, longitude]) or location):
-            raise ValueError("Either location or latitude and longitude must be passed as"
-                             "argument.")
-        if not ((latitude is not None or longitude is not None) ^ bool(location)):
-            raise ValueError("Either location or latitude and longitude must be passed as"
-                             "argument. Not both.")
-
-        if isinstance(location, Location):
-            latitude = location.latitude
-            longitude = location.longitude
-
-        data = {'latitude': latitude, 'longitude': longitude}
-
-        if chat_id:
-            data['chat_id'] = chat_id
-        if message_id:
-            data['message_id'] = message_id
-        if inline_message_id:
-            data['inline_message_id'] = inline_message_id
-
-        return url, data
-
-    @log
-    @message
-    def stop_message_live_location(self,
-                                   chat_id=None,
-                                   message_id=None,
-                                   inline_message_id=None,
-                                   reply_markup=None,
-                                   **kwargs):
-        """Use this method to stop updating a live location message sent by the bot or via the bot
-        (for inline bots) before live_period expires.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
-                Identifier of the sent message.
-            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
-                specified. Identifier of the inline message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-
-        Returns:
-            :class:`telegram.Message`: On success the edited message.
-        """
-
-        url = '{0}/stopMessageLiveLocation'.format(self.base_url)
-
-        data = {}
-
-        if chat_id:
-            data['chat_id'] = chat_id
-        if message_id:
-            data['message_id'] = message_id
-        if inline_message_id:
-            data['inline_message_id'] = inline_message_id
-
-        return url, data
-
-    @log
-    @message
-    def send_venue(self,
-                   chat_id,
-                   latitude=None,
-                   longitude=None,
-                   title=None,
-                   address=None,
-                   foursquare_id=None,
-                   disable_notification=False,
-                   reply_to_message_id=None,
-                   reply_markup=None,
-                   timeout=None,
-                   venue=None,
-                   **kwargs):
-        """Use this method to send information about a venue.
-
-        Note:
-            you can either supply :obj:`venue`, or :obj:`latitude`, :obj:`longitude`,
-            :obj:`title` and :obj:`address` and optionally :obj:`foursquare_id`.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            latitude (:obj:`float`, optional): Latitude of venue.
-            longitude (:obj:`float`, optional): Longitude of venue.
-            title (:obj:`str`, optional): Name of the venue.
-            address (:obj:`str`, optional): Address of the venue.
-            foursquare_id (:obj:`str`, optional): Foursquare identifier of the venue.
-            venue (:class:`telegram.Venue`, optional): The venue to send.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendVenue'.format(self.base_url)
-
-        if not (venue or all([latitude, longitude, address, title])):
-            raise ValueError("Either venue or latitude, longitude, address and title must be"
-                             "passed as arguments.")
-
-        if isinstance(venue, Venue):
-            latitude = venue.location.latitude
-            longitude = venue.location.longitude
-            address = venue.address
-            title = venue.title
-            foursquare_id = venue.foursquare_id
-
-        data = {
-            'chat_id': chat_id,
-            'latitude': latitude,
-            'longitude': longitude,
-            'address': address,
-            'title': title
-        }
-
-        if foursquare_id:
-            data['foursquare_id'] = foursquare_id
-
-        return url, data
-
-    @log
-    @message
-    def send_contact(self,
-                     chat_id,
-                     phone_number=None,
-                     first_name=None,
-                     last_name=None,
-                     disable_notification=False,
-                     reply_to_message_id=None,
-                     reply_markup=None,
-                     timeout=None,
-                     contact=None,
-                     **kwargs):
-        """Use this method to send phone contacts.
-
-        Note:
-            You can either supply :obj:`contact` or :obj:`phone_number` and :obj:`first_name`
-            with optionally :obj:`last_name`.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            phone_number (:obj:`str`, optional): Contact's phone number.
-            first_name (:obj:`str`, optional): Contact's first name.
-            last_name (:obj:`str`, optional): Contact's last name.
-            contact (:class:`telegram.Contact`, optional): The contact to send.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendContact'.format(self.base_url)
-
-        if (not contact) and (not all([phone_number, first_name])):
-            raise ValueError("Either contact or phone_number and first_name must be passed as"
-                             "arguments.")
-
-        if isinstance(contact, Contact):
-            phone_number = contact.phone_number
-            first_name = contact.first_name
-            last_name = contact.last_name
-
-        data = {'chat_id': chat_id, 'phone_number': phone_number, 'first_name': first_name}
-
-        if last_name:
-            data['last_name'] = last_name
-
-        return url, data
-
-    @log
-    @message
-    def send_game(self,
-                  chat_id,
-                  game_short_name,
-                  disable_notification=False,
-                  reply_to_message_id=None,
-                  reply_markup=None,
-                  timeout=None,
-                  **kwargs):
-        """Use this method to send a game.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            game_short_name (:obj:`str`): Short name of the game, serves as the unique identifier
-                for the game. Set up your games via Botfather.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendGame'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'game_short_name': game_short_name}
-
-        return url, data
-
-    @log
-    def send_chat_action(self, chat_id, action, timeout=None, **kwargs):
-        """
-        Use this method when you need to tell the user that something is happening on the bot's
-        side. The status is set for 5 seconds or less (when a message arrives from your bot,
-        Telegram clients clear its typing status).
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            action(:class:`telegram.ChatAction` | :obj:`str`): Type of action to broadcast. Choose
-                one, depending on what the user is about to receive. For convenience look at the
-                constants in :class:`telegram.ChatAction`
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool`: ``True`` on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendChatAction'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'action': action}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def answer_inline_query(self,
-                            inline_query_id,
-                            results,
-                            cache_time=300,
-                            is_personal=None,
-                            next_offset=None,
-                            switch_pm_text=None,
-                            switch_pm_parameter=None,
-                            timeout=None,
-                            **kwargs):
-        """
-        Use this method to send answers to an inline query. No more than 50 results per query are
-        allowed.
-
-        Args:
-            inline_query_id (:obj:`str`): Unique identifier for the answered query.
-            results (List[:class:`telegram.InlineQueryResult`)]: A list of results for the inline
-                query.
-            cache_time (:obj:`int`, optional): The maximum amount of time in seconds that the
-                result of the inline query may be cached on the server. Defaults to 300.
-            is_personal (:obj:`bool`, optional): Pass True, if results may be cached on the server
-                side only for the user that sent the query. By default, results may be returned to
-                any user who sends the same query.
-            next_offset (:obj:`str`, optional): Pass the offset that a client should send in the
-                next query with the same text to receive more results. Pass an empty string if
-                there are no more results or if you don't support pagination. Offset length can't
-                exceed 64 bytes.
-            switch_pm_text (:obj:`str`, optional): If passed, clients will display a button with
-                specified text that switches the user to a private chat with the bot and sends the
-                bot a start message with the parameter switch_pm_parameter.
-            switch_pm_parameter (:obj:`str`, optional): Deep-linking parameter for the /start
-                message sent to the bot when user presses the switch button. 1-64 characters,
-                only A-Z, a-z, 0-9, _ and - are allowed.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                he read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Example:
-            An inline bot that sends YouTube videos can ask the user to connect the bot to their
-            YouTube account to adapt search results accordingly. To do this, it displays a
-            'Connect your YouTube account' button above the results, or even before showing any.
-            The user presses the button, switches to a private chat with the bot and, in doing so,
-            passes a start parameter that instructs the bot to return an oauth link. Once done, the
-            bot can offer a switch_inline button so that the user can easily return to the chat
-            where they wanted to use the bot's inline capabilities.
-
-        Returns:
-            :obj:`bool` On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/answerInlineQuery'.format(self.base_url)
-
-        results = [res.to_dict() for res in results]
-
-        data = {'inline_query_id': inline_query_id, 'results': results}
-
-        if cache_time or cache_time == 0:
-            data['cache_time'] = cache_time
-        if is_personal:
-            data['is_personal'] = is_personal
-        if next_offset is not None:
-            data['next_offset'] = next_offset
-        if switch_pm_text:
-            data['switch_pm_text'] = switch_pm_text
-        if switch_pm_parameter:
-            data['switch_pm_parameter'] = switch_pm_parameter
-
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def get_user_profile_photos(self, user_id, offset=None, limit=100, timeout=None, **kwargs):
-        """Use this method to get a list of profile pictures for a user.
-
-        Args:
-            user_id (:obj:`int`): Unique identifier of the target user.
-            offset (:obj:`int`, optional): Sequential number of the first photo to be returned.
-                By default, all photos are returned.
-            limit (:obj:`int`, optional): Limits the number of photos to be retrieved. Values
-                between 1-100 are accepted. Defaults to 100.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.UserProfilePhotos`
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getUserProfilePhotos'.format(self.base_url)
-
-        data = {'user_id': user_id}
-
-        if offset is not None:
-            data['offset'] = offset
-        if limit:
-            data['limit'] = limit
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return UserProfilePhotos.de_json(result, self)
-
-    @log
-    def get_file(self, file_id, timeout=None, **kwargs):
-        """
-        Use this method to get basic info about a file and prepare it for downloading. For the
-        moment, bots can download files of up to 20MB in size. The file can then be downloaded
-        with :attr:`telegram.File.download`. It is guaranteed that the link will be
-        valid for at least 1 hour. When the link expires, a new one can be requested by
-        calling getFile again.
-
-        Args:
-            file_id (:obj:`str`): File identifier to get info about.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.File`
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getFile'.format(self.base_url)
-
-        data = {'file_id': file_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        if result.get('file_path'):
-            result['file_path'] = '%s/%s' % (self.base_file_url, result['file_path'])
-
-        return File.de_json(result, self)
-
-    @log
-    def kick_chat_member(self, chat_id, user_id, timeout=None, until_date=None, **kwargs):
-        """
-        Use this method to kick a user from a group or a supergroup. In the case of supergroups,
-        the user will not be able to return to the group on their own using invite links, etc.,
-        unless unbanned first. The bot must be an administrator in the group for this to work.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or  username
-                of the target channel (in the format @channelusername).
-            user_id (:obj:`int`): Unique identifier of the target user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            until_date (:obj:`int` | :obj:`datetime.datetime`, optional): Date when the user will
-                be unbanned, unix time. If user is banned for more than 366 days or less than 30
-                seconds from the current time they are considered to be banned forever.
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Note:
-            In regular groups (non-supergroups), this method will only work if the
-            'All Members Are Admins' setting is off in the target group. Otherwise
-            members may only be removed by the group's creator or by the member that added them.
-
-        Returns:
-            :obj:`bool` On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/kickChatMember'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'user_id': user_id}
-        data.update(kwargs)
-
-        if until_date is not None:
-            if isinstance(until_date, datetime):
-                until_date = to_timestamp(until_date)
-            data['until_date'] = until_date
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def unban_chat_member(self, chat_id, user_id, timeout=None, **kwargs):
-        """Use this method to unban a previously kicked user in a supergroup.
-
-        The user will not return to the group automatically, but will be able to join via link,
-        etc. The bot must be an administrator in the group for this to work.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            user_id (:obj:`int`): Unique identifier of the target user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool` On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/unbanChatMember'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'user_id': user_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def answer_callback_query(self,
-                              callback_query_id,
-                              text=None,
-                              show_alert=False,
-                              url=None,
-                              cache_time=None,
-                              timeout=None,
-                              **kwargs):
-        """
-        Use this method to send answers to callback queries sent from inline keyboards. The answer
-        will be displayed to the user as a notification at the top of the chat screen or as an
-        alert.
-        Alternatively, the user can be redirected to the specified Game URL. For this option to
-        work, you must first create a game for your bot via BotFather and accept the terms.
-        Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with
-        a parameter.
-
-        Args:
-            callback_query_id (:obj:`str`): Unique identifier for the query to be answered.
-            text (:obj:`str`, optional): Text of the notification. If not specified, nothing will
-                be shown to the user, 0-200 characters.
-            show_alert (:obj:`bool`, optional): If true, an alert will be shown by the client
-                instead of a notification at the top of the chat screen. Defaults to false.
-            url (:obj:`str`, optional): URL that will be opened by the user's client. If you have
-                created a Game and accepted the conditions via @Botfather, specify the URL that
-                opens your game - note that this will only work if the query comes from a callback
-                game button. Otherwise, you may use links like t.me/your_bot?start=XXXX that open
-                your bot with a parameter.
-            cache_time (:obj:`int`, optional): The maximum amount of time in seconds that the
-                result of the callback query may be cached client-side. Defaults to 0.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool` On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url_ = '{0}/answerCallbackQuery'.format(self.base_url)
-
-        data = {'callback_query_id': callback_query_id}
-
-        if text:
-            data['text'] = text
-        if show_alert:
-            data['show_alert'] = show_alert
-        if url:
-            data['url'] = url
-        if cache_time is not None:
-            data['cache_time'] = cache_time
-        data.update(kwargs)
-
-        result = self._request.post(url_, data, timeout=timeout)
-
-        return result
-
-    @log
-    @message
-    def edit_message_text(self,
-                          text,
-                          chat_id=None,
-                          message_id=None,
-                          inline_message_id=None,
-                          parse_mode=None,
-                          disable_web_page_preview=None,
-                          reply_markup=None,
-                          timeout=None,
-                          **kwargs):
-        """
-        Use this method to edit text and game messages sent by the bot or via the bot (for inline
-        bots).
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target channel (in the format @channelusername).
-            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
-                Identifier of the sent message.
-            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
-                specified. Identifier of the inline message.
-            text (:obj:`str`): New text of the message.
-            parse_mode (:obj:`str`): Send Markdown or HTML, if you want Telegram apps to show bold,
-                italic, fixed-width text or inline URLs in your bot's message. See the constants in
-                :class:`telegram.ParseMode` for the available modes.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
-            edited Message is returned, otherwise ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/editMessageText'.format(self.base_url)
-
-        data = {'text': text}
-
-        if chat_id:
-            data['chat_id'] = chat_id
-        if message_id:
-            data['message_id'] = message_id
-        if inline_message_id:
-            data['inline_message_id'] = inline_message_id
-        if parse_mode:
-            data['parse_mode'] = parse_mode
-        if disable_web_page_preview:
-            data['disable_web_page_preview'] = disable_web_page_preview
-
-        return url, data
-
-    @log
-    @message
-    def edit_message_caption(self,
-                             chat_id=None,
-                             message_id=None,
-                             inline_message_id=None,
-                             caption=None,
-                             reply_markup=None,
-                             timeout=None,
-                             **kwargs):
-        """
-        Use this method to edit captions of messages sent by the bot or via the bot
-        (for inline bots).
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
-                Identifier of the sent message.
-            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
-                specified. Identifier of the inline message.
-            caption (:obj:`str`, optional): New caption of the message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
-            edited Message is returned, otherwise ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        if inline_message_id is None and (chat_id is None or message_id is None):
-            raise ValueError(
-                'edit_message_caption: Both chat_id and message_id are required when '
-                'inline_message_id is not specified')
-
-        url = '{0}/editMessageCaption'.format(self.base_url)
-
-        data = {}
-
-        if caption:
-            data['caption'] = caption
-        if chat_id:
-            data['chat_id'] = chat_id
-        if message_id:
-            data['message_id'] = message_id
-        if inline_message_id:
-            data['inline_message_id'] = inline_message_id
-
-        return url, data
-
-    @log
-    @message
-    def edit_message_reply_markup(self,
-                                  chat_id=None,
-                                  message_id=None,
-                                  inline_message_id=None,
-                                  reply_markup=None,
-                                  timeout=None,
-                                  **kwargs):
-        """
-        Use this method to edit only the reply markup of messages sent by the bot or via the bot
-        (for inline bots).
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
-                Identifier of the sent message.
-            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
-                specified. Identifier of the inline message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
-                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
-                to remove reply keyboard or to force a reply from the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
-            editedMessage is returned, otherwise ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        if inline_message_id is None and (chat_id is None or message_id is None):
-            raise ValueError(
-                'edit_message_reply_markup: Both chat_id and message_id are required when '
-                'inline_message_id is not specified')
-
-        url = '{0}/editMessageReplyMarkup'.format(self.base_url)
-
-        data = {}
-
-        if chat_id:
-            data['chat_id'] = chat_id
-        if message_id:
-            data['message_id'] = message_id
-        if inline_message_id:
-            data['inline_message_id'] = inline_message_id
-
-        return url, data
-
-    @log
-    def get_updates(self,
-                    offset=None,
-                    limit=100,
-                    timeout=0,
-                    network_delay=None,
-                    read_latency=2.,
-                    allowed_updates=None,
-                    **kwargs):
-        """Use this method to receive incoming updates using long polling.
-
-        Args:
-            offset (:obj:`int`, optional): Identifier of the first update to be returned. Must be
-                greater by one than the highest among the identifiers of previously received
-                updates. By default, updates starting with the earliest unconfirmed update are
-                returned. An update is considered confirmed as soon as getUpdates is called with an
-                offset higher than its update_id. The negative offset can be specified to retrieve
-                updates starting from -offset update from the end of the updates queue. All
-                previous updates will forgotten.
-            limit (:obj:`int`, optional): Limits the number of updates to be retrieved. Values
-                between 1-100 are accepted. Defaults to 100.
-            timeout (:obj:`int`, optional): Timeout in seconds for long polling. Defaults to 0,
-                i.e. usual short polling. Should be positive, short polling should be used for
-                testing purposes only.
-            allowed_updates (List[:obj:`str`]), optional): List the types of updates you want your
-                bot to receive. For example, specify ["message", "edited_channel_post",
-                "callback_query"] to only receive updates of these types. See
-                :class:`telegram.Update` for a complete list of available update types.
-                Specify an empty list to receive all updates regardless of type (default). If not
-                specified, the previous setting will be used. Please note that this parameter
-                doesn't affect updates created before the call to the get_updates, so unwanted
-                updates may be received for a short period of time.
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Notes:
-            1. This method will not work if an outgoing webhook is set up.
-            2. In order to avoid getting duplicate updates, recalculate offset after each
-               server response.
-            3. To take full advantage of this library take a look at :class:`telegram.ext.Updater`
-
-        Returns:
-            List[:class:`telegram.Update`]
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getUpdates'.format(self.base_url)
-
-        if network_delay is not None:
-            warnings.warn('network_delay is deprecated, use read_latency instead')
-            read_latency = network_delay
-
-        data = {'timeout': timeout}
-
-        if offset:
-            data['offset'] = offset
-        if limit:
-            data['limit'] = limit
-        if allowed_updates is not None:
-            data['allowed_updates'] = allowed_updates
-        data.update(kwargs)
-
-        # Ideally we'd use an aggressive read timeout for the polling. However,
-        # * Short polling should return within 2 seconds.
-        # * Long polling poses a different problem: the connection might have been dropped while
-        #   waiting for the server to return and there's no way of knowing the connection had been
-        #   dropped in real time.
-        result = self._request.post(url, data, timeout=float(read_latency) + float(timeout))
-
-        if result:
-            self.logger.debug('Getting updates: %s', [u['update_id'] for u in result])
-        else:
-            self.logger.debug('No new updates found.')
-
-        return [Update.de_json(u, self) for u in result]
-
-    @log
-    def set_webhook(self,
-                    url=None,
-                    certificate=None,
-                    timeout=None,
-                    max_connections=40,
-                    allowed_updates=None,
-                    **kwargs):
-        """
-        Use this method to specify a url and receive incoming updates via an outgoing webhook.
-        Whenever there is an update for the bot, we will send an HTTPS POST request to the
-        specified url, containing a JSON-serialized Update. In case of an unsuccessful request,
-        we will give up after a reasonable amount of attempts.
-
-        If you'd like to make sure that the Webhook request comes from Telegram, we recommend
-        using a secret path in the URL, e.g. https://www.example.com/<token>. Since nobody else
-        knows your bot's token, you can be pretty sure it's us.
-
-        Note:
-            The certificate argument should be a file from disk ``open(filename, 'rb')``.
-
-        Args:
-            url (:obj:`str`): HTTPS url to send updates to. Use an empty string to remove webhook
-                integration.
-            certificate (:obj:`filelike`): Upload your public key certificate so that the root
-                certificate in use can be checked. See our self-signed guide for details.
-                (https://goo.gl/rw7w6Y)
-            max_connections (:obj:`int`, optional): Maximum allowed number of simultaneous HTTPS
-                connections to the webhook for update delivery, 1-100. Defaults to 40. Use lower
-                values to limit the load on your bot's server, and higher values to increase your
-                bot's throughput.
-            allowed_updates (List[:obj:`str`], optional): List the types of updates you want your
-                bot to receive. For example, specify ["message", "edited_channel_post",
-                "callback_query"] to only receive updates of these types. See
-                :class:`telegram.Update` for a complete list of available update types. Specify an
-                empty list to receive all updates regardless of type (default). If not specified,
-                the previous setting will be used. Please note that this parameter doesn't affect
-                updates created before the call to the set_webhook, so unwanted updates may be
-                received for a short period of time.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Note:
-            1. You will not be able to receive updates using get_updates for as long as an outgoing
-               webhook is set up.
-            2. To use a self-signed certificate, you need to upload your public key certificate
-               using certificate parameter. Please upload as InputFile, sending a String will not
-               work.
-            3. Ports currently supported for Webhooks: 443, 80, 88, 8443.
-
-        Returns:
-            :obj:`bool` On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url_ = '{0}/setWebhook'.format(self.base_url)
-
-        # Backwards-compatibility: 'url' used to be named 'webhook_url'
-        if 'webhook_url' in kwargs:  # pragma: no cover
-            warnings.warn("The 'webhook_url' parameter has been renamed to 'url' in accordance "
-                          "with the API")
-
-            if url is not None:
-                raise ValueError("The parameters 'url' and 'webhook_url' are mutually exclusive")
-
-            url = kwargs['webhook_url']
-            del kwargs['webhook_url']
-
-        data = {}
-
-        if url is not None:
-            data['url'] = url
-        if certificate:
-            data['certificate'] = certificate
-        if max_connections is not None:
-            data['max_connections'] = max_connections
-        if allowed_updates is not None:
-            data['allowed_updates'] = allowed_updates
-        data.update(kwargs)
-
-        result = self._request.post(url_, data, timeout=timeout)
-
-        return result
-
-    @log
-    def delete_webhook(self, timeout=None, **kwargs):
-        """
-        Use this method to remove webhook integration if you decide to switch back to
-        getUpdates. Requires no parameters.
-
-        Args:
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool` On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/deleteWebhook'.format(self.base_url)
-
-        data = kwargs
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def leave_chat(self, chat_id, timeout=None, **kwargs):
-        """Use this method for your bot to leave a group, supergroup or channel.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool` On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/leaveChat'.format(self.base_url)
-
-        data = {'chat_id': chat_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def get_chat(self, chat_id, timeout=None, **kwargs):
-        """
-        Use this method to get up to date information about the chat (current name of the user for
-        one-on-one conversations, current username of a user, group or channel, etc.).
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Chat`
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getChat'.format(self.base_url)
-
-        data = {'chat_id': chat_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return Chat.de_json(result, self)
-
-    @log
-    def get_chat_administrators(self, chat_id, timeout=None, **kwargs):
-        """
-        Use this method to get a list of administrators in a chat. On success, returns an Array of
-        ChatMember objects that contains information about all chat administrators except other
-        bots. If the chat is a group or a supergroup and no administrators were appointed,
-        only the creator will be returned.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            List[:class:`telegram.ChatMember`]
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getChatAdministrators'.format(self.base_url)
-
-        data = {'chat_id': chat_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return [ChatMember.de_json(x, self) for x in result]
-
-    @log
-    def get_chat_members_count(self, chat_id, timeout=None, **kwargs):
-        """Use this method to get the number of members in a chat
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            int: Number of members in the chat.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getChatMembersCount'.format(self.base_url)
-
-        data = {'chat_id': chat_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def get_chat_member(self, chat_id, user_id, timeout=None, **kwargs):
-        """Use this method to get information about a member of a chat.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            user_id (:obj:`int`): Unique identifier of the target user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.ChatMember`
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getChatMember'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'user_id': user_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return ChatMember.de_json(result, self)
-
-    @log
-    def set_chat_sticker_set(self, chat_id, sticker_set_name, timeout=None, **kwargs):
-        """Use this method to set a new group sticker set for a supergroup.
-        The bot must be an administrator in the chat for this to work and must have the appropriate
-        admin rights. Use the field :attr:`telegram.Chat.can_set_sticker_set` optionally returned
-        in :attr:`get_chat` requests to check if the bot can use this method.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target supergroup (in the format @supergroupusername).
-            sticker_set_name (:obj:`str`): Name of the sticker set to be set as the group
-                sticker set.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-
-        Returns:
-            :obj:`bool`: True on success.
-        """
-
-        url = '{0}/setChatStickerSet'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'sticker_set_name': sticker_set_name}
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def delete_chat_sticker_set(self, chat_id, timeout=None, **kwargs):
-        """Use this method to delete a group sticker set from a supergroup. The bot must be an
-        administrator in the chat for this to work and must have the appropriate admin rights.
-        Use the field :attr:`telegram.Chat.can_set_sticker_set` optionally returned in
-        :attr:`get_chat` requests to check if the bot can use this method.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target supergroup (in the format @supergroupusername).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-             :obj:`bool`: True on success.
-        """
-
-        url = '{0}/deleteChatStickerSet'.format(self.base_url)
-
-        data = {'chat_id': chat_id}
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    def get_webhook_info(self, timeout=None, **kwargs):
-        """Use this method to get current webhook status. Requires no parameters.
-
-        If the bot is using getUpdates, will return an object with the url field empty.
-
-        Args:
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.WebhookInfo`
-
-        """
-        url = '{0}/getWebhookInfo'.format(self.base_url)
-
-        data = kwargs
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return WebhookInfo.de_json(result, self)
-
-    @log
-    @message
-    def set_game_score(self,
-                       user_id,
-                       score,
-                       chat_id=None,
-                       message_id=None,
-                       inline_message_id=None,
-                       force=None,
-                       disable_edit_message=None,
-                       timeout=None,
-                       **kwargs):
-        """
-        Use this method to set the score of the specified user in a game. On success, if the
-        message was sent by the bot, returns the edited Message, otherwise returns True. Returns
-        an error, if the new score is not greater than the user's current score in the chat and
-        force is False.
-
-        Args:
-            user_id (:obj:`int`): User identifier.
-            score (:obj:`int`): New score, must be non-negative.
-            force (:obj:`bool`, optional): Pass True, if the high score is allowed to decrease.
-                This can be useful when fixing mistakes or banning cheaters
-            disable_edit_message (:obj:`bool`, optional): Pass True, if the game message should not
-                be automatically edited to include the current scoreboard.
-            chat_id (int|str, optional): Required if inline_message_id is not specified. Unique
-                identifier for the target chat.
-            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
-                Identifier of the sent message.
-            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
-                specified. Identifier of the inline message.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: The edited message, or if the message wasn't sent by the bot
-            , ``True``.
-
-        Raises:
-            :class:`telegram.TelegramError`: If the new score is not greater than the user's
-            current score in the chat and force is False.
-
-        """
-        url = '{0}/setGameScore'.format(self.base_url)
-
-        data = {'user_id': user_id, 'score': score}
-
-        if chat_id:
-            data['chat_id'] = chat_id
-        if message_id:
-            data['message_id'] = message_id
-        if inline_message_id:
-            data['inline_message_id'] = inline_message_id
-        if force is not None:
-            data['force'] = force
-        if disable_edit_message is not None:
-            data['disable_edit_message'] = disable_edit_message
-
-        return url, data
-
-    @log
-    def get_game_high_scores(self,
-                             user_id,
-                             chat_id=None,
-                             message_id=None,
-                             inline_message_id=None,
-                             timeout=None,
-                             **kwargs):
-        """
-        Use this method to get data for high score tables. Will return the score of the specified
-        user and several of his neighbors in a game
-
-        Args:
-            user_id (:obj:`int`): User identifier.
-            chat_id (:obj:`int` | :obj:`str`, optional): Required if inline_message_id is not
-                specified. Unique identifier for the target chat.
-            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
-                Identifier of the sent message.
-            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
-                specified. Identifier of the inline message.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            List[:class:`telegram.GameHighScore`]
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getGameHighScores'.format(self.base_url)
-
-        data = {'user_id': user_id}
-
-        if chat_id:
-            data['chat_id'] = chat_id
-        if message_id:
-            data['message_id'] = message_id
-        if inline_message_id:
-            data['inline_message_id'] = inline_message_id
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return [GameHighScore.de_json(hs, self) for hs in result]
-
-    @log
-    @message
-    def send_invoice(self,
-                     chat_id,
-                     title,
-                     description,
-                     payload,
-                     provider_token,
-                     start_parameter,
-                     currency,
-                     prices,
-                     photo_url=None,
-                     photo_size=None,
-                     photo_width=None,
-                     photo_height=None,
-                     need_name=None,
-                     need_phone_number=None,
-                     need_email=None,
-                     need_shipping_address=None,
-                     is_flexible=None,
-                     disable_notification=False,
-                     reply_to_message_id=None,
-                     reply_markup=None,
-                     timeout=None,
-                     **kwargs):
-        """Use this method to send invoices.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target private chat.
-            title (:obj:`str`): Product name.
-            description (:obj:`str`): Product description.
-            payload (:obj:`str`): Bot-defined invoice payload, 1-128 bytes. This will not be
-                displayed to the user, use for your internal processes.
-            provider_token (:obj:`str`): Payments provider token, obtained via Botfather.
-            start_parameter (:obj:`str`): Unique deep-linking parameter that can be used to
-                generate this invoice when used as a start parameter.
-            currency (:obj:`str`): Three-letter ISO 4217 currency code.
-            prices (List[:class:`telegram.LabeledPrice`)]: Price breakdown, a list of components
-                (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.).
-            photo_url (:obj:`str`, optional): URL of the product photo for the invoice. Can be a
-                photo of the goods or a marketing image for a service. People like it better when
-                they see what they are paying for.
-            photo_size (:obj:`str`, optional): Photo size.
-            photo_width (:obj:`int`, optional): Photo width.
-            photo_height (:obj:`int`, optional): Photo height.
-            need_name (:obj:`bool`, optional): Pass True, if you require the user's full name to
-                complete the order.
-            need_phone_number (:obj:`bool`, optional): Pass True, if you require the user's
-                phone number to complete the order.
-            need_email (:obj:`bool`, optional): Pass True, if you require the user's email to
-                complete the order.
-            need_shipping_address (:obj:`bool`, optional): Pass True, if you require the user's
-                shipping address to complete the order.
-            is_flexible (:obj:`bool`, optional): Pass True, if the final price depends on the
-                shipping method.
-            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
-                receive a notification with no sound.
-            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
-                original message.
-            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options.
-                An inlinekeyboard. If empty, one 'Pay total price' button will be shown.
-                If not empty, the first button must be a Pay button.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.Message`: On success, the sent Message is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/sendInvoice'.format(self.base_url)
-
-        data = {
-            'chat_id': chat_id,
-            'title': title,
-            'description': description,
-            'payload': payload,
-            'provider_token': provider_token,
-            'start_parameter': start_parameter,
-            'currency': currency,
-            'prices': [p.to_dict() for p in prices]
-        }
-
-        if photo_url is not None:
-            data['photo_url'] = photo_url
-        if photo_size is not None:
-            data['photo_size'] = photo_size
-        if photo_width is not None:
-            data['photo_width'] = photo_width
-        if photo_height is not None:
-            data['photo_height'] = photo_height
-        if need_name is not None:
-            data['need_name'] = need_name
-        if need_phone_number is not None:
-            data['need_phone_number'] = need_phone_number
-        if need_email is not None:
-            data['need_email'] = need_email
-        if need_shipping_address is not None:
-            data['need_shipping_address'] = need_shipping_address
-        if is_flexible is not None:
-            data['is_flexible'] = is_flexible
-
-        return url, data
-
-    @log
-    def answer_shipping_query(self,
-                              shipping_query_id,
-                              ok,
-                              shipping_options=None,
-                              error_message=None,
-                              timeout=None,
-                              **kwargs):
-        """
-        If you sent an invoice requesting a shipping address and the parameter is_flexible was
-        specified, the Bot API will send an Update with a shipping_query field to the bot. Use
-        this method to reply to shipping queries.
-
-        Args:
-            shipping_query_id (:obj:`str`): Unique identifier for the query to be answered.
-            ok (:obj:`bool`): Specify True if delivery to the specified address is possible and
-                False if there are any problems (for example, if delivery to the specified address
-                is not possible).
-            shipping_options (List[:class:`telegram.ShippingOption`]), optional]: Required if ok is
-                True. A JSON-serialized array of available shipping options.
-            error_message (:obj:`str`, optional): Required if ok is False. Error message in
-                human readable form that explains why it is impossible to complete the order (e.g.
-                "Sorry, delivery to your desired address is unavailable"). Telegram will display
-                this message to the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool`; On success, True is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        ok = bool(ok)
-
-        if ok and (shipping_options is None or error_message is not None):
-            raise TelegramError(
-                'answerShippingQuery: If ok is True, shipping_options '
-                'should not be empty and there should not be error_message')
-
-        if not ok and (shipping_options is not None or error_message is None):
-            raise TelegramError(
-                'answerShippingQuery: If ok is False, error_message '
-                'should not be empty and there should not be shipping_options')
-
-        url_ = '{0}/answerShippingQuery'.format(self.base_url)
-
-        data = {'shipping_query_id': shipping_query_id, 'ok': ok}
-
-        if ok:
-            data['shipping_options'] = [option.to_dict() for option in shipping_options]
-        if error_message is not None:
-            data['error_message'] = error_message
-        data.update(kwargs)
-
-        result = self._request.post(url_, data, timeout=timeout)
-
-        return result
-
-    @log
-    def answer_pre_checkout_query(self, pre_checkout_query_id, ok,
-                                  error_message=None, timeout=None, **kwargs):
-        """
-        Once the user has confirmed their payment and shipping details, the Bot API sends the final
-        confirmation in the form of an Update with the field pre_checkout_query. Use this method to
-        respond to such pre-checkout queries.
-
-        Note:
-            The Bot API must receive an answer within 10 seconds after the pre-checkout
-            query was sent.
-
-        Args:
-            pre_checkout_query_id (:obj:`str`): Unique identifier for the query to be answered.
-            ok (:obj:`bool`): Specify True if everything is alright (goods are available, etc.) and
-                the bot is ready to proceed with the order. Use False if there are any problems.
-            error_message (:obj:`str`, optional): Required if ok is False. Error message in  human
-                readable form that explains the reason for failure to proceed with the checkout
-                (e.g. "Sorry, somebody just bought the last of our amazing black T-shirts while you
-                were busy filling out your payment details. Please choose a different color or
-                garment!"). Telegram will display this message to the user.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool`: On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        ok = bool(ok)
-
-        if not (ok ^ (error_message is not None)):
-            raise TelegramError(
-                'answerPreCheckoutQuery: If ok is True, there should '
-                'not be error_message; if ok is False, error_message '
-                'should not be empty')
-
-        url_ = '{0}/answerPreCheckoutQuery'.format(self.base_url)
-
-        data = {'pre_checkout_query_id': pre_checkout_query_id, 'ok': ok}
-
-        if error_message is not None:
-            data['error_message'] = error_message
-        data.update(kwargs)
-
-        result = self._request.post(url_, data, timeout=timeout)
-
-        return result
-
-    @log
-    def restrict_chat_member(self, chat_id, user_id, until_date=None, can_send_messages=None,
-                             can_send_media_messages=None, can_send_other_messages=None,
-                             can_add_web_page_previews=None, timeout=None, **kwargs):
-        """
-        Use this method to restrict a user in a supergroup. The bot must be an administrator in
-        the supergroup for this to work and must have the appropriate admin rights. Pass True for
-        all boolean parameters to lift restrictions from a user.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target supergroup (in the format @supergroupusername).
-            user_id (:obj:`int`): Unique identifier of the target user.
-            until_date (:obj:`int` | :obj:`datetime.datetime`, optional): Date when restrictions
-                will be lifted for the user, unix time. If user is restricted for more than 366
-                days or less than 30 seconds from the current time, they are considered to be
-                restricted forever.
-            can_send_messages (:obj:`bool`, optional): Pass True, if the user can send text
-                messages, contacts, locations and venues.
-            can_send_media_messages (:obj:`bool`, optional): Pass True, if the user can send
-                audios, documents, photos, videos, video notes and voice notes, implies
-                can_send_messages.
-            can_send_other_messages (:obj:`bool`, optional): Pass True, if the user can send
-                animations, games, stickers and use inline bots, implies can_send_media_messages.
-            can_add_web_page_previews (:obj:`bool`, optional): Pass True, if the user may add
-                web page previews to their messages, implies can_send_media_messages.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Returns:
-            :obj:`bool`: Returns True on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/restrictChatMember'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'user_id': user_id}
-
-        if until_date is not None:
-            if isinstance(until_date, datetime):
-                until_date = to_timestamp(until_date)
-            data['until_date'] = until_date
-        if can_send_messages is not None:
-            data['can_send_messages'] = can_send_messages
-        if can_send_media_messages is not None:
-            data['can_send_media_messages'] = can_send_media_messages
-        if can_send_other_messages is not None:
-            data['can_send_other_messages'] = can_send_other_messages
-        if can_add_web_page_previews is not None:
-            data['can_add_web_page_previews'] = can_add_web_page_previews
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def promote_chat_member(self, chat_id, user_id, can_change_info=None,
-                            can_post_messages=None, can_edit_messages=None,
-                            can_delete_messages=None, can_invite_users=None,
-                            can_restrict_members=None, can_pin_messages=None,
-                            can_promote_members=None, timeout=None, **kwargs):
-        """
-        Use this method to promote or demote a user in a supergroup or a channel. The bot must be
-        an administrator in the chat for this to work and must have the appropriate admin rights.
-        Pass False for all boolean parameters to demote a user
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target supergroup (in the format @supergroupusername).
-            user_id (:obj:`int`): Unique identifier of the target user.
-            can_change_info (:obj:`bool`, optional): Pass True, if the administrator can change
-                chat title, photo and other settings.
-            can_post_messages (:obj:`bool`, optional): Pass True, if the administrator can
-                create channel posts, channels only.
-            can_edit_messages (:obj:`bool`, optional): Pass True, if the administrator can edit
-                messages of other users, channels only.
-            can_delete_messages (:obj:`bool`, optional): Pass True, if the administrator can
-                delete messages of other users.
-            can_invite_users (:obj:`bool`, optional): Pass True, if the administrator can invite
-                new users to the chat.
-            can_restrict_members (:obj:`bool`, optional): Pass True, if the administrator can
-                restrict, ban or unban chat members.
-            can_pin_messages (:obj:`bool`, optional): Pass True, if the administrator can pin
-                messages, supergroups only.
-            can_promote_members (:obj:`bool`, optional): Pass True, if the administrator can add
-                new administrators with a subset of his own privileges or demote administrators
-                that he has promoted, directly or indirectly (promoted by administrators that were
-                appointed by him).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Returns:
-            :obj:`bool`: Returns True on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/promoteChatMember'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'user_id': user_id}
-
-        if can_change_info is not None:
-            data['can_change_info'] = can_change_info
-        if can_post_messages is not None:
-            data['can_post_messages'] = can_post_messages
-        if can_edit_messages is not None:
-            data['can_edit_messages'] = can_edit_messages
-        if can_delete_messages is not None:
-            data['can_delete_messages'] = can_delete_messages
-        if can_invite_users is not None:
-            data['can_invite_users'] = can_invite_users
-        if can_restrict_members is not None:
-            data['can_restrict_members'] = can_restrict_members
-        if can_pin_messages is not None:
-            data['can_pin_messages'] = can_pin_messages
-        if can_promote_members is not None:
-            data['can_promote_members'] = can_promote_members
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def export_chat_invite_link(self, chat_id, timeout=None, **kwargs):
-        """
-        Use this method to export an invite link to a supergroup or a channel. The bot must be an
-        administrator in the chat for this to work and must have the appropriate admin rights.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Returns:
-            :obj:`str`: Exported invite link on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/exportChatInviteLink'.format(self.base_url)
-
-        data = {'chat_id': chat_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def set_chat_photo(self, chat_id, photo, timeout=None, **kwargs):
-        """Use this method to set a new profile photo for the chat.
-
-        Photos can't be changed for private chats. The bot must be an administrator in the chat
-        for this to work and must have the appropriate admin rights.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            photo (`telegram.InputFile`): New chat photo.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Note:
-            In regular groups (non-supergroups), this method will only work if the
-            'All Members Are Admins' setting is off in the target group.
-
-        Returns:
-            :obj:`bool`: Returns True on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/setChatPhoto'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'photo': photo}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def delete_chat_photo(self, chat_id, timeout=None, **kwargs):
-        """
-        Use this method to delete a chat photo. Photos can't be changed for private chats. The bot
-        must be an administrator in the chat for this to work and must have the appropriate admin
-        rights.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Note:
-            In regular groups (non-supergroups), this method will only work if the
-            'All Members Are Admins' setting is off in the target group.
-
-        Returns:
-            :obj:`bool`: Returns ``True`` on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/deleteChatPhoto'.format(self.base_url)
-
-        data = {'chat_id': chat_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def set_chat_title(self, chat_id, title, timeout=None, **kwargs):
-        """
-        Use this method to change the title of a chat. Titles can't be changed for private chats.
-        The bot must be an administrator in the chat for this to work and must have the appropriate
-        admin rights.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            title (:obj:`str`): New chat title, 1-255 characters.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Note:
-            In regular groups (non-supergroups), this method will only work if the
-            'All Members Are Admins' setting is off in the target group.
-
-        Returns:
-            :obj:`bool`: Returns ``True`` on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/setChatTitle'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'title': title}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def set_chat_description(self, chat_id, description, timeout=None, **kwargs):
-        """
-        Use this method to change the description of a supergroup or a channel. The bot must be an
-        administrator in the chat for this to work and must have the appropriate admin rights.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            description (:obj:`str`): New chat description, 1-255 characters.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Returns:
-            :obj:`bool`: Returns ``True`` on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/setChatDescription'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'description': description}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def pin_chat_message(self, chat_id, message_id, disable_notification=None, timeout=None,
-                         **kwargs):
-        """
-        Use this method to pin a message in a supergroup. The bot must be an administrator in the
-        chat for this to work and must have the appropriate admin rights.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            message_id (:obj:`int`): Identifier of a message to pin.
-            disable_notification (:obj:`bool`, optional): Pass True, if it is not necessary to send
-                a notification to all group members about the new pinned message.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Returns:
-            :obj:`bool`: Returns ``True`` on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/pinChatMessage'.format(self.base_url)
-
-        data = {'chat_id': chat_id, 'message_id': message_id}
-
-        if disable_notification is not None:
-            data['disable_notification'] = disable_notification
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def unpin_chat_message(self, chat_id, timeout=None, **kwargs):
-        """
-        Use this method to unpin a message in a supergroup. The bot must be an administrator in the
-        chat for this to work and must have the appropriate admin rights.
-
-        Args:
-            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
-                of the target`channel (in the format @channelusername).
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments
-
-        Returns:
-            :obj:`bool`: Returns ``True`` on success.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/unpinChatMessage'.format(self.base_url)
-
-        data = {'chat_id': chat_id}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def get_sticker_set(self, name, timeout=None, **kwargs):
-        """Use this method to get a sticker set.
-
-        Args:
-            name (:obj:`str`): Short name of the sticker set that is used in t.me/addstickers/
-                URLs (e.g., animals)
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during
-                creation of the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.StickerSet`
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/getStickerSet'.format(self.base_url)
-
-        data = {'name': name}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return StickerSet.de_json(result, self)
-
-    @log
-    def upload_sticker_file(self, user_id, png_sticker, timeout=None, **kwargs):
-        """
-        Use this method to upload a .png file with a sticker for later use in
-        :attr:`create_new_sticker_set` and :attr:`add_sticker_to_set` methods (can be used multiple
-        times).
-
-        Note:
-            The png_sticker argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            user_id (:obj:`int`): User identifier of sticker file owner.
-            png_sticker (:obj:`str` | `filelike object`): Png image with the sticker,
-                must be up to 512 kilobytes in size, dimensions must not exceed 512px,
-                and either width or height must be exactly 512px.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during
-                creation of the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :class:`telegram.File`: The uploaded File
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/uploadStickerFile'.format(self.base_url)
-
-        data = {'user_id': user_id, 'png_sticker': png_sticker}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return File.de_json(result, self)
-
-    @log
-    def create_new_sticker_set(self, user_id, name, title, png_sticker, emojis,
-                               contains_masks=None, mask_position=None, timeout=None, **kwargs):
-        """Use this method to create new sticker set owned by a user.
-
-        The bot will be able to edit the created sticker set.
-
-        Note:
-            The png_sticker argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            user_id (:obj:`int`): User identifier of created sticker set owner.
-            name (:obj:`str`): Short name of sticker set, to be used in t.me/addstickers/ URLs
-                (e.g., animals). Can contain only english letters, digits and underscores.
-                Must begin with a letter, can't contain consecutive underscores and
-                must end in "_by_<bot username>". <bot_username> is case insensitive.
-                1-64 characters.
-            title (:obj:`str`): Sticker set title, 1-64 characters.
-            png_sticker (:obj:`str` | `filelike object`): Png image with the sticker, must be up
-                to 512 kilobytes in size, dimensions must not exceed 512px,
-                and either width or height must be exactly 512px. Pass a file_id as a String to
-                send a file that already exists on the Telegram servers, pass an HTTP URL as a
-                String for Telegram to get a file from the Internet, or upload a new one
-                using multipart/form-data.
-            emojis (:obj:`str`): One or more emoji corresponding to the sticker.
-            contains_masks (:obj:`bool`, optional): Pass True, if a set of mask stickers should be
-                created.
-            mask_position (:class:`telegram.MaskPosition`, optional): Position where the mask
-                should be placed on faces.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during
-                creation of the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool`: On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/createNewStickerSet'.format(self.base_url)
-
-        data = {'user_id': user_id, 'name': name, 'title': title, 'png_sticker': png_sticker,
-                'emojis': emojis}
-
-        if contains_masks is not None:
-            data['contains_masks'] = contains_masks
-        if mask_position is not None:
-            data['mask_position'] = mask_position
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def add_sticker_to_set(self, user_id, name, png_sticker, emojis, mask_position=None,
-                           timeout=None, **kwargs):
-        """Use this method to add a new sticker to a set created by the bot.
-
-        Note:
-            The png_sticker argument can be either a file_id, an URL or a file from disk
-            ``open(filename, 'rb')``
-
-        Args:
-            user_id (:obj:`int`): User identifier of created sticker set owner.
-            name (:obj:`str`): Sticker set name.
-            png_sticker (:obj:`str` | `filelike object`): Png image with the sticker, must be up
-                to 512 kilobytes in size, dimensions must not exceed 512px,
-                and either width or height must be exactly 512px. Pass a file_id as a String to
-                send a file that already exists on the Telegram servers, pass an HTTP URL as a
-                String for Telegram to get a file from the Internet, or upload a new one
-                using multipart/form-data.
-            emojis (:obj:`str`): One or more emoji corresponding to the sticker.
-            mask_position (:class:`telegram.MaskPosition`, optional): Position where the mask
-                should beplaced on faces.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during
-                creation of the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool`: On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/addStickerToSet'.format(self.base_url)
-
-        data = {'user_id': user_id, 'name': name, 'png_sticker': png_sticker, 'emojis': emojis}
-
-        if mask_position is not None:
-            data['mask_position'] = mask_position
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def set_sticker_position_in_set(self, sticker, position, timeout=None, **kwargs):
-        """Use this method to move a sticker in a set created by the bot to a specific position.
-
-        Args:
-            sticker (:obj:`str`): File identifier of the sticker.
-            position (:obj:`int`): New sticker position in the set, zero-based.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during
-                creation of the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool`: On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/setStickerPositionInSet'.format(self.base_url)
-
-        data = {'sticker': sticker, 'position': position}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    @log
-    def delete_sticker_from_set(self, sticker, timeout=None, **kwargs):
-        """Use this method to delete a sticker from a set created by the bot.
-
-        Args:
-            sticker (:obj:`str`): File identifier of the sticker.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during
-                creation of the connection pool).
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        Returns:
-            :obj:`bool`: On success, ``True`` is returned.
-
-        Raises:
-            :class:`telegram.TelegramError`
-
-        """
-        url = '{0}/deleteStickerFromSet'.format(self.base_url)
-
-        data = {'sticker': sticker}
-        data.update(kwargs)
-
-        result = self._request.post(url, data, timeout=timeout)
-
-        return result
-
-    def to_dict(self):
-        data = {'id': self.id, 'username': self.username, 'first_name': self.username}
-
-        if self.last_name:
-            data['last_name'] = self.last_name
-
-        return data
-
-    def __reduce__(self):
-        return (self.__class__, (self.token, self.base_url.replace(self.token, ''),
-                                 self.base_file_url.replace(self.token, '')))
-
-    # camelCase aliases
-    getMe = get_me
-    sendMessage = send_message
-    deleteMessage = delete_message
-    forwardMessage = forward_message
-    sendPhoto = send_photo
-    sendAudio = send_audio
-    sendDocument = send_document
-    sendSticker = send_sticker
-    sendVideo = send_video
-    sendVoice = send_voice
-    sendVideoNote = send_video_note
-    sendLocation = send_location
-    editMessageLiveLocation = edit_message_live_location
-    stopMessageLiveLocation = stop_message_live_location
-    sendVenue = send_venue
-    sendContact = send_contact
-    sendGame = send_game
-    sendChatAction = send_chat_action
-    answerInlineQuery = answer_inline_query
-    getUserProfilePhotos = get_user_profile_photos
-    getFile = get_file
-    kickChatMember = kick_chat_member
-    unbanChatMember = unban_chat_member
-    answerCallbackQuery = answer_callback_query
-    editMessageText = edit_message_text
-    editMessageCaption = edit_message_caption
-    editMessageReplyMarkup = edit_message_reply_markup
-    getUpdates = get_updates
-    setWebhook = set_webhook
-    deleteWebhook = delete_webhook
-    leaveChat = leave_chat
-    getChat = get_chat
-    getChatAdministrators = get_chat_administrators
-    getChatMember = get_chat_member
-    setChatStickerSet = set_chat_sticker_set
-    deleteChatStickerSet = delete_chat_sticker_set
-    getChatMembersCount = get_chat_members_count
-    getWebhookInfo = get_webhook_info
-    setGameScore = set_game_score
-    getGameHighScores = get_game_high_scores
-    sendInvoice = send_invoice
-    answerShippingQuery = answer_shipping_query
-    answerPreCheckoutQuery = answer_pre_checkout_query
-    restrictChatMember = restrict_chat_member
-    promoteChatMember = promote_chat_member
-    exportChatInviteLink = export_chat_invite_link
-    setChatPhoto = set_chat_photo
-    deleteChatPhoto = delete_chat_photo
-    setChatTitle = set_chat_title
-    setChatDescription = set_chat_description
-    pinChatMessage = pin_chat_message
-    unpinChatMessage = unpin_chat_message
-    getStickerSet = get_sticker_set
-    uploadStickerFile = upload_sticker_file
-    createNewStickerSet = create_new_sticker_set
-    addStickerToSet = add_sticker_to_set
-    setStickerPositionInSet = set_sticker_position_in_set
-    deleteStickerFromSet = delete_sticker_from_set
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+# pylint: disable=E0611,E0213,E1102,C0103,E1101,W0613,R0913,R0904
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Bot."""
+
+import functools
+import json
+import logging
+import warnings
+from datetime import datetime
+
+from future.utils import string_types
+
+from telegram import (User, Message, Update, Chat, ChatMember, UserProfilePhotos, File,
+                      ReplyMarkup, TelegramObject, WebhookInfo, GameHighScore, StickerSet,
+                      PhotoSize, Audio, Document, Sticker, Video, Voice, VideoNote, Location,
+                      Venue, Contact)
+from telegram.error import InvalidToken, TelegramError
+from telegram.utils.helpers import to_timestamp
+from telegram.utils.request import Request
+
+logging.getLogger(__name__).addHandler(logging.NullHandler())
+
+
+def info(func):
+    @functools.wraps(func)
+    def decorator(self, *args, **kwargs):
+        if not self.bot:
+            self.get_me()
+
+        result = func(self, *args, **kwargs)
+        return result
+
+    return decorator
+
+
+def log(func):
+    logger = logging.getLogger(func.__module__)
+
+    @functools.wraps(func)
+    def decorator(self, *args, **kwargs):
+        logger.debug('Entering: %s', func.__name__)
+        result = func(self, *args, **kwargs)
+        logger.debug(result)
+        logger.debug('Exiting: %s', func.__name__)
+        return result
+
+    return decorator
+
+
+def message(func):
+    @functools.wraps(func)
+    def decorator(self, *args, **kwargs):
+        url, data = func(self, *args, **kwargs)
+        if kwargs.get('reply_to_message_id'):
+            data['reply_to_message_id'] = kwargs.get('reply_to_message_id')
+
+        if kwargs.get('disable_notification'):
+            data['disable_notification'] = kwargs.get('disable_notification')
+
+        if kwargs.get('reply_markup'):
+            reply_markup = kwargs.get('reply_markup')
+            if isinstance(reply_markup, ReplyMarkup):
+                data['reply_markup'] = reply_markup.to_json()
+            else:
+                data['reply_markup'] = reply_markup
+
+        result = self._request.post(url, data, timeout=kwargs.get('timeout'))
+
+        if result is True:
+            return result
+
+        return Message.de_json(result, self)
+
+    return decorator
+
+
+class Bot(TelegramObject):
+    """This object represents a Telegram Bot.
+
+    Args:
+        token (:obj:`str`): Bot's unique authentication.
+        base_url (:obj:`str`, optional): Telegram Bot API service URL.
+        base_file_url (:obj:`str`, optional): Telegram Bot API file URL.
+        request (:obj:`telegram.utils.request.Request`, optional): Pre initialized
+            :obj:`telegram.utils.request.Request`.
+
+    """
+
+    def __init__(self, token, base_url=None, base_file_url=None, request=None):
+        self.token = self._validate_token(token)
+
+        if base_url is None:
+            base_url = 'https://api.telegram.org/bot'
+
+        if base_file_url is None:
+            base_file_url = 'https://api.telegram.org/file/bot'
+
+        self.base_url = str(base_url) + str(self.token)
+        self.base_file_url = str(base_file_url) + str(self.token)
+        self.bot = None
+        self._request = request or Request()
+        self.logger = logging.getLogger(__name__)
+
+    @property
+    def request(self):
+        return self._request
+
+    @staticmethod
+    def _validate_token(token):
+        """A very basic validation on token."""
+        if any(x.isspace() for x in token):
+            raise InvalidToken()
+
+        left, sep, _right = token.partition(':')
+        if (not sep) or (not left.isdigit()) or (len(left) < 3):
+            raise InvalidToken()
+
+        return token
+
+    @property
+    @info
+    def id(self):
+        """:obj:`int`: Unique identifier for this bot."""
+
+        return self.bot.id
+
+    @property
+    @info
+    def first_name(self):
+        """:obj:`str`: Bot's first name."""
+
+        return self.bot.first_name
+
+    @property
+    @info
+    def last_name(self):
+        """:obj:`str`: Optional. Bot's last name."""
+
+        return self.bot.last_name
+
+    @property
+    @info
+    def username(self):
+        """:obj:`str`: Bot's username."""
+
+        return self.bot.username
+
+    @property
+    def name(self):
+        """:obj:`str`: Bot's @username."""
+
+        return '@{0}'.format(self.username)
+
+    @log
+    def get_me(self, timeout=None, **kwargs):
+        """A simple method for testing your bot's auth token. Requires no parameters.
+
+        Args:
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+
+        Returns:
+            :class:`telegram.User`: A :class:`telegram.User` instance representing that bot if the
+            credentials are valid, :obj:`None` otherwise.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getMe'.format(self.base_url)
+
+        result = self._request.get(url, timeout=timeout)
+
+        self.bot = User.de_json(result, self)
+
+        return self.bot
+
+    @log
+    @message
+    def send_message(self,
+                     chat_id,
+                     text,
+                     parse_mode=None,
+                     disable_web_page_preview=None,
+                     disable_notification=False,
+                     reply_to_message_id=None,
+                     reply_markup=None,
+                     timeout=None,
+                     **kwargs):
+        """Use this method to send text messages.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            text (:obj:`str`): Text of the message to be sent. Max 4096 characters. Also found as
+                :attr:`telegram.constants.MAX_MESSAGE_LENGTH`.
+            parse_mode (:obj:`str`): Send Markdown or HTML, if you want Telegram apps to show bold,
+                italic, fixed-width text or inline URLs in your bot's message. See the constants in
+                :class:`telegram.ParseMode` for the available modes.
+            disable_web_page_preview (:obj:`bool`, optional): Disables link previews for links in
+                this message.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options.
+                A JSON-serialized object for an inline keyboard, custom reply keyboard,
+                instructions to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendMessage'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'text': text}
+
+        if parse_mode:
+            data['parse_mode'] = parse_mode
+        if disable_web_page_preview:
+            data['disable_web_page_preview'] = disable_web_page_preview
+
+        return url, data
+
+    @log
+    def delete_message(self, chat_id, message_id, timeout=None, **kwargs):
+        """
+        Use this method to delete a message. A message can only be deleted if it was sent less
+        than 48 hours ago. Any such recently sent outgoing message may be deleted. Additionally,
+        if the bot is an administrator in a group chat, it can delete any message. If the bot is
+        an administrator in a supergroup, it can delete messages from any other user and service
+        messages about people joining or leaving the group (other types of service messages may
+        only be removed by the group creator). In channels, bots can only remove their own
+        messages.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            message_id (:obj:`int`): Identifier of the message to delete.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+            the read timeout
+                from the server (instead of the one specified during creation of the connection
+                pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool`: On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/deleteMessage'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'message_id': message_id}
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    @message
+    def forward_message(self,
+                        chat_id,
+                        from_chat_id,
+                        message_id,
+                        disable_notification=False,
+                        timeout=None,
+                        **kwargs):
+        """Use this method to forward messages of any kind.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            from_chat_id (:obj:`int` | :obj:`str`): Unique identifier for the chat where the
+                original message was sent (or channel username in the format @channelusername).
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            message_id (:obj:`int`): Message identifier in the chat specified in from_chat_id.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+            the read timeout
+                from the server (instead of the one specified during creation of the connection
+                pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/forwardMessage'.format(self.base_url)
+
+        data = {}
+
+        if chat_id:
+            data['chat_id'] = chat_id
+        if from_chat_id:
+            data['from_chat_id'] = from_chat_id
+        if message_id:
+            data['message_id'] = message_id
+
+        return url, data
+
+    @log
+    @message
+    def send_photo(self,
+                   chat_id,
+                   photo,
+                   caption=None,
+                   disable_notification=False,
+                   reply_to_message_id=None,
+                   reply_markup=None,
+                   timeout=20,
+                   **kwargs):
+        """Use this method to send photos.
+
+        Note:
+            The photo argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            photo (:obj:`str` | `filelike object` | :class:`telegram.PhotoSize`): Photo to send.
+                Pass a file_id as String to send a photo that exists on the Telegram servers
+                (recommended), pass an HTTP URL as a String for Telegram to get a photo from the
+                Internet, or upload a new photo using multipart/form-data. Lastly you can pass
+                an existing :class:`telegram.PhotoSize` object to send.
+            caption (:obj:`str`, optional): Photo caption (may also be used when resending photos
+                by file_id), 0-200 characters.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendPhoto'.format(self.base_url)
+
+        if isinstance(photo, PhotoSize):
+            photo = photo.file_id
+
+        data = {'chat_id': chat_id, 'photo': photo}
+
+        if caption:
+            data['caption'] = caption
+
+        return url, data
+
+    @log
+    @message
+    def send_audio(self,
+                   chat_id,
+                   audio,
+                   duration=None,
+                   performer=None,
+                   title=None,
+                   caption=None,
+                   disable_notification=False,
+                   reply_to_message_id=None,
+                   reply_markup=None,
+                   timeout=20,
+                   **kwargs):
+        """
+        Use this method to send audio files, if you want Telegram clients to display them in the
+        music player. Your audio must be in the .mp3 format. On success, the sent Message is
+        returned. Bots can currently send audio files of up to 50 MB in size, this limit may be
+        changed in the future.
+
+        For sending voice messages, use the sendVoice method instead.
+
+        Note:
+            The audio argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            audio (:obj:`str` | `filelike object` | :class:`telegram.Audio`): Audio file to send.
+                Pass a file_id as String to send an audio file that exists on the Telegram servers
+                (recommended), pass an HTTP URL as a String for Telegram to get an audio file from
+                the Internet, or upload a new one using multipart/form-data. Lastly you can pass
+                an existing :class:`telegram.Audio` object to send.
+            caption (:obj:`str`, optional): Audio caption, 0-200 characters.
+            duration (:obj:`int`, optional): Duration of sent audio in seconds.
+            performer (:obj:`str`, optional): Performer.
+            title (:obj:`str`, optional): Track name.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendAudio'.format(self.base_url)
+
+        if isinstance(audio, Audio):
+            audio = audio.file_id
+
+        data = {'chat_id': chat_id, 'audio': audio}
+
+        if duration:
+            data['duration'] = duration
+        if performer:
+            data['performer'] = performer
+        if title:
+            data['title'] = title
+        if caption:
+            data['caption'] = caption
+
+        return url, data
+
+    @log
+    @message
+    def send_document(self,
+                      chat_id,
+                      document,
+                      filename=None,
+                      caption=None,
+                      disable_notification=False,
+                      reply_to_message_id=None,
+                      reply_markup=None,
+                      timeout=20,
+                      **kwargs):
+        """Use this method to send general files.
+
+        Note:
+            The document argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            document (:obj:`str` | `filelike object` | :class:`telegram.Document`): File to send.
+                Pass a file_id as String to send a file that exists on the Telegram servers
+                (recommended), pass an HTTP URL as a String for Telegram to get a file from the
+                Internet, or upload a new one using multipart/form-data. Lastly you can pass
+                an existing :class:`telegram.Document` object to send.
+            filename (:obj:`str`, optional): File name that shows in telegram message (it is useful
+                when you send file generated by temp module, for example). Undocumented.
+            caption (:obj:`str`, optional): Document caption (may also be used when resending
+                documents by file_id), 0-200 characters.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendDocument'.format(self.base_url)
+
+        if isinstance(document, Document):
+            document = document.file_id
+
+        data = {'chat_id': chat_id, 'document': document}
+
+        if filename:
+            data['filename'] = filename
+        if caption:
+            data['caption'] = caption
+
+        return url, data
+
+    @log
+    @message
+    def send_sticker(self,
+                     chat_id,
+                     sticker,
+                     disable_notification=False,
+                     reply_to_message_id=None,
+                     reply_markup=None,
+                     timeout=None,
+                     **kwargs):
+        """Use this method to send .webp stickers.
+
+        Note:
+            The sticker argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            sticker (:obj:`str` | `filelike object` :class:`telegram.Sticker`): Sticker to send.
+                Pass a file_id as String to send a file that exists on the Telegram servers
+                (recommended), pass an HTTP URL as a String for Telegram to get a .webp file from
+                the Internet, or upload a new one using multipart/form-data. Lastly you can pass
+                an existing :class:`telegram.Sticker` object to send.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendSticker'.format(self.base_url)
+
+        if isinstance(sticker, Sticker):
+            sticker = sticker.file_id
+
+        data = {'chat_id': chat_id, 'sticker': sticker}
+
+        return url, data
+
+    @log
+    @message
+    def send_video(self,
+                   chat_id,
+                   video,
+                   duration=None,
+                   caption=None,
+                   disable_notification=False,
+                   reply_to_message_id=None,
+                   reply_markup=None,
+                   timeout=20,
+                   width=None,
+                   height=None,
+                   **kwargs):
+        """
+        Use this method to send video files, Telegram clients support mp4 videos
+        (other formats may be sent as Document).
+
+        Note:
+            The video argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            video (:obj:`str` | `filelike object` | :class:`telegram.Video`): Video file to send.
+                Pass a file_id as String to send an video file that exists on the Telegram servers
+                (recommended), pass an HTTP URL as a String for Telegram to get an video file from
+                the Internet, or upload a new one using multipart/form-data. Lastly you can pass
+                an existing :class:`telegram.Video` object to send.
+            duration (:obj:`int`, optional): Duration of sent video in seconds.
+            width (:obj:`int`, optional): Video width.
+            height (:obj:`int`, optional): Video height.
+            caption (:obj:`str`, optional): Video caption (may also be used when resending videos
+                by file_id), 0-200 characters.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendVideo'.format(self.base_url)
+
+        if isinstance(video, Video):
+            video = video.file_id
+
+        data = {'chat_id': chat_id, 'video': video}
+
+        if duration:
+            data['duration'] = duration
+        if caption:
+            data['caption'] = caption
+        if width:
+            data['width'] = width
+        if height:
+            data['height'] = height
+
+        return url, data
+
+    @log
+    @message
+    def send_voice(self,
+                   chat_id,
+                   voice,
+                   duration=None,
+                   caption=None,
+                   disable_notification=False,
+                   reply_to_message_id=None,
+                   reply_markup=None,
+                   timeout=20,
+                   **kwargs):
+        """
+        Use this method to send audio files, if you want Telegram clients to display the file
+        as a playable voice message. For this to work, your audio must be in an .ogg file
+        encoded with OPUS (other formats may be sent as Audio or Document).
+
+        Note:
+            The voice argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            voice (:obj:`str` | `filelike object` | :class:`telegram.Voice`): Voice file to send.
+                Pass a file_id as String to send an voice file that exists on the Telegram servers
+                (recommended), pass an HTTP URL as a String for Telegram to get an voice file from
+                the Internet, or upload a new one using multipart/form-data. Lastly you can pass
+                an existing :class:`telegram.Voice` object to send.
+            caption (:obj:`str`, optional): Voice message caption, 0-200 characters.
+            duration (:obj:`int`, optional): Duration of the voice message in seconds.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard,
+                instructions to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendVoice'.format(self.base_url)
+
+        if isinstance(voice, Voice):
+            voice = voice.file_id
+
+        data = {'chat_id': chat_id, 'voice': voice}
+
+        if duration:
+            data['duration'] = duration
+        if caption:
+            data['caption'] = caption
+
+        return url, data
+
+    @log
+    @message
+    def send_video_note(self,
+                        chat_id,
+                        video_note,
+                        duration=None,
+                        length=None,
+                        disable_notification=False,
+                        reply_to_message_id=None,
+                        reply_markup=None,
+                        timeout=20,
+                        **kwargs):
+        """Use this method to send video messages.
+
+        Note:
+            The video_note argument can be either a file_id or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            video_note (:obj:`str` | `filelike object` | :class:`telegram.VideoNote`): Video note
+                to send. Pass a file_id as String to send a video note that exists on the Telegram
+                servers (recommended) or upload a new video using multipart/form-data. Or you can
+                pass an existing :class:`telegram.VideoNote` object to send. Sending video notes by
+                a URL is currently unsupported.
+            duration (:obj:`int`, optional): Duration of sent video in seconds.
+            length (:obj:`int`, optional): Video width and height
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard,
+                instructions to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendVideoNote'.format(self.base_url)
+
+        if isinstance(video_note, VideoNote):
+            video_note = video_note.file_id
+
+        data = {'chat_id': chat_id, 'video_note': video_note}
+
+        if duration is not None:
+            data['duration'] = duration
+        if length is not None:
+            data['length'] = length
+
+        return url, data
+
+    @log
+    def send_media_group(self,
+                         chat_id,
+                         media,
+                         disable_notification=None,
+                         reply_to_message_id=None,
+                         timeout=20,
+                         **kwargs):
+        """Use this method to send a group of photos or videos as an album.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            media (List[:class:`telegram.InputMedia`]): An array describing photos and videos to be
+                sent, must include 2–10 items.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            timeout (:obj:`int` | :obj:`float`, optional): Send file timeout (default: 20 seconds).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            List[:class:`telegram.Message`]: An array of the sent Messages.
+
+        Raises:
+            :class:`telegram.TelegramError`
+        """
+        # TODO: Make InputMediaPhoto, InputMediaVideo and send_media_group work with new files
+
+        url = '{0}/sendMediaGroup'.format(self.base_url)
+
+        media = [med.to_dict() for med in media]
+
+        data = {'chat_id': chat_id, 'media': media}
+
+        if reply_to_message_id:
+            data['reply_to_message_id'] = reply_to_message_id
+        if disable_notification:
+            data['disable_notification'] = disable_notification
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return [Message.de_json(res, self) for res in result]
+
+    @log
+    @message
+    def send_location(self,
+                      chat_id,
+                      latitude=None,
+                      longitude=None,
+                      disable_notification=False,
+                      reply_to_message_id=None,
+                      reply_markup=None,
+                      timeout=None,
+                      location=None,
+                      live_period=None,
+                      **kwargs):
+        """Use this method to send point on the map.
+
+        Note:
+            You can either supply a :obj:`latitude` and :obj:`longitude` or a :obj:`location`.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            latitude (:obj:`float`, optional): Latitude of location.
+            longitude (:obj:`float`, optional): Longitude of location.
+            location (:class:`telegram.Location`, optional): The location to send.
+            live_period (:obj:`int`, optional): Period in seconds for which the location will be
+                updated, should be between 60 and 86400.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                    original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard,
+                instructions to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendLocation'.format(self.base_url)
+
+        if not (all([latitude, longitude]) or location):
+            raise ValueError("Either location or latitude and longitude must be passed as"
+                             "argument.")
+
+        if not ((latitude is not None or longitude is not None) ^ bool(location)):
+            raise ValueError("Either location or latitude and longitude must be passed as"
+                             "argument. Not both.")
+
+        if isinstance(location, Location):
+            latitude = location.latitude
+            longitude = location.longitude
+
+        data = {'chat_id': chat_id, 'latitude': latitude, 'longitude': longitude}
+
+        if live_period:
+            data['live_period'] = live_period
+
+        return url, data
+
+    @log
+    @message
+    def edit_message_live_location(self,
+                                   chat_id=None,
+                                   message_id=None,
+                                   inline_message_id=None,
+                                   latitude=None,
+                                   longitude=None,
+                                   location=None,
+                                   reply_markup=None,
+                                   **kwargs):
+        """Use this method to edit live location messages sent by the bot or via the bot
+        (for inline bots). A location can be edited until its :attr:`live_period` expires or
+        editing is explicitly disabled by a call to :attr:`stop_message_live_location`.
+
+        Note:
+            You can either supply a :obj:`latitude` and :obj:`longitude` or a :obj:`location`.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
+                Identifier of the sent message.
+            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
+                specified. Identifier of the inline message.
+            latitude (:obj:`float`, optional): Latitude of location.
+            longitude (:obj:`float`, optional): Longitude of location.
+            location (:class:`telegram.Location`, optional): The location to send.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+
+        Returns:
+             :class:`telegram.Message`: On success the edited message.
+        """
+
+        url = '{0}/editMessageLiveLocation'.format(self.base_url)
+
+        if not (all([latitude, longitude]) or location):
+            raise ValueError("Either location or latitude and longitude must be passed as"
+                             "argument.")
+        if not ((latitude is not None or longitude is not None) ^ bool(location)):
+            raise ValueError("Either location or latitude and longitude must be passed as"
+                             "argument. Not both.")
+
+        if isinstance(location, Location):
+            latitude = location.latitude
+            longitude = location.longitude
+
+        data = {'latitude': latitude, 'longitude': longitude}
+
+        if chat_id:
+            data['chat_id'] = chat_id
+        if message_id:
+            data['message_id'] = message_id
+        if inline_message_id:
+            data['inline_message_id'] = inline_message_id
+
+        return url, data
+
+    @log
+    @message
+    def stop_message_live_location(self,
+                                   chat_id=None,
+                                   message_id=None,
+                                   inline_message_id=None,
+                                   reply_markup=None,
+                                   **kwargs):
+        """Use this method to stop updating a live location message sent by the bot or via the bot
+        (for inline bots) before live_period expires.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
+                Identifier of the sent message.
+            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
+                specified. Identifier of the inline message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+
+        Returns:
+            :class:`telegram.Message`: On success the edited message.
+        """
+
+        url = '{0}/stopMessageLiveLocation'.format(self.base_url)
+
+        data = {}
+
+        if chat_id:
+            data['chat_id'] = chat_id
+        if message_id:
+            data['message_id'] = message_id
+        if inline_message_id:
+            data['inline_message_id'] = inline_message_id
+
+        return url, data
+
+    @log
+    @message
+    def send_venue(self,
+                   chat_id,
+                   latitude=None,
+                   longitude=None,
+                   title=None,
+                   address=None,
+                   foursquare_id=None,
+                   disable_notification=False,
+                   reply_to_message_id=None,
+                   reply_markup=None,
+                   timeout=None,
+                   venue=None,
+                   **kwargs):
+        """Use this method to send information about a venue.
+
+        Note:
+            you can either supply :obj:`venue`, or :obj:`latitude`, :obj:`longitude`,
+            :obj:`title` and :obj:`address` and optionally :obj:`foursquare_id`.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            latitude (:obj:`float`, optional): Latitude of venue.
+            longitude (:obj:`float`, optional): Longitude of venue.
+            title (:obj:`str`, optional): Name of the venue.
+            address (:obj:`str`, optional): Address of the venue.
+            foursquare_id (:obj:`str`, optional): Foursquare identifier of the venue.
+            venue (:class:`telegram.Venue`, optional): The venue to send.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendVenue'.format(self.base_url)
+
+        if not (venue or all([latitude, longitude, address, title])):
+            raise ValueError("Either venue or latitude, longitude, address and title must be"
+                             "passed as arguments.")
+
+        if isinstance(venue, Venue):
+            latitude = venue.location.latitude
+            longitude = venue.location.longitude
+            address = venue.address
+            title = venue.title
+            foursquare_id = venue.foursquare_id
+
+        data = {
+            'chat_id': chat_id,
+            'latitude': latitude,
+            'longitude': longitude,
+            'address': address,
+            'title': title
+        }
+
+        if foursquare_id:
+            data['foursquare_id'] = foursquare_id
+
+        return url, data
+
+    @log
+    @message
+    def send_contact(self,
+                     chat_id,
+                     phone_number=None,
+                     first_name=None,
+                     last_name=None,
+                     disable_notification=False,
+                     reply_to_message_id=None,
+                     reply_markup=None,
+                     timeout=None,
+                     contact=None,
+                     **kwargs):
+        """Use this method to send phone contacts.
+
+        Note:
+            You can either supply :obj:`contact` or :obj:`phone_number` and :obj:`first_name`
+            with optionally :obj:`last_name`.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            phone_number (:obj:`str`, optional): Contact's phone number.
+            first_name (:obj:`str`, optional): Contact's first name.
+            last_name (:obj:`str`, optional): Contact's last name.
+            contact (:class:`telegram.Contact`, optional): The contact to send.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendContact'.format(self.base_url)
+
+        if (not contact) and (not all([phone_number, first_name])):
+            raise ValueError("Either contact or phone_number and first_name must be passed as"
+                             "arguments.")
+
+        if isinstance(contact, Contact):
+            phone_number = contact.phone_number
+            first_name = contact.first_name
+            last_name = contact.last_name
+
+        data = {'chat_id': chat_id, 'phone_number': phone_number, 'first_name': first_name}
+
+        if last_name:
+            data['last_name'] = last_name
+
+        return url, data
+
+    @log
+    @message
+    def send_game(self,
+                  chat_id,
+                  game_short_name,
+                  disable_notification=False,
+                  reply_to_message_id=None,
+                  reply_markup=None,
+                  timeout=None,
+                  **kwargs):
+        """Use this method to send a game.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            game_short_name (:obj:`str`): Short name of the game, serves as the unique identifier
+                for the game. Set up your games via Botfather.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendGame'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'game_short_name': game_short_name}
+
+        return url, data
+
+    @log
+    def send_chat_action(self, chat_id, action, timeout=None, **kwargs):
+        """
+        Use this method when you need to tell the user that something is happening on the bot's
+        side. The status is set for 5 seconds or less (when a message arrives from your bot,
+        Telegram clients clear its typing status).
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            action(:class:`telegram.ChatAction` | :obj:`str`): Type of action to broadcast. Choose
+                one, depending on what the user is about to receive. For convenience look at the
+                constants in :class:`telegram.ChatAction`
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool`: ``True`` on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendChatAction'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'action': action}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def answer_inline_query(self,
+                            inline_query_id,
+                            results,
+                            cache_time=300,
+                            is_personal=None,
+                            next_offset=None,
+                            switch_pm_text=None,
+                            switch_pm_parameter=None,
+                            timeout=None,
+                            **kwargs):
+        """
+        Use this method to send answers to an inline query. No more than 50 results per query are
+        allowed.
+
+        Args:
+            inline_query_id (:obj:`str`): Unique identifier for the answered query.
+            results (List[:class:`telegram.InlineQueryResult`)]: A list of results for the inline
+                query.
+            cache_time (:obj:`int`, optional): The maximum amount of time in seconds that the
+                result of the inline query may be cached on the server. Defaults to 300.
+            is_personal (:obj:`bool`, optional): Pass True, if results may be cached on the server
+                side only for the user that sent the query. By default, results may be returned to
+                any user who sends the same query.
+            next_offset (:obj:`str`, optional): Pass the offset that a client should send in the
+                next query with the same text to receive more results. Pass an empty string if
+                there are no more results or if you don't support pagination. Offset length can't
+                exceed 64 bytes.
+            switch_pm_text (:obj:`str`, optional): If passed, clients will display a button with
+                specified text that switches the user to a private chat with the bot and sends the
+                bot a start message with the parameter switch_pm_parameter.
+            switch_pm_parameter (:obj:`str`, optional): Deep-linking parameter for the /start
+                message sent to the bot when user presses the switch button. 1-64 characters,
+                only A-Z, a-z, 0-9, _ and - are allowed.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                he read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Example:
+            An inline bot that sends YouTube videos can ask the user to connect the bot to their
+            YouTube account to adapt search results accordingly. To do this, it displays a
+            'Connect your YouTube account' button above the results, or even before showing any.
+            The user presses the button, switches to a private chat with the bot and, in doing so,
+            passes a start parameter that instructs the bot to return an oauth link. Once done, the
+            bot can offer a switch_inline button so that the user can easily return to the chat
+            where they wanted to use the bot's inline capabilities.
+
+        Returns:
+            :obj:`bool` On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/answerInlineQuery'.format(self.base_url)
+
+        results = [res.to_dict() for res in results]
+
+        data = {'inline_query_id': inline_query_id, 'results': results}
+
+        if cache_time or cache_time == 0:
+            data['cache_time'] = cache_time
+        if is_personal:
+            data['is_personal'] = is_personal
+        if next_offset is not None:
+            data['next_offset'] = next_offset
+        if switch_pm_text:
+            data['switch_pm_text'] = switch_pm_text
+        if switch_pm_parameter:
+            data['switch_pm_parameter'] = switch_pm_parameter
+
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def get_user_profile_photos(self, user_id, offset=None, limit=100, timeout=None, **kwargs):
+        """Use this method to get a list of profile pictures for a user.
+
+        Args:
+            user_id (:obj:`int`): Unique identifier of the target user.
+            offset (:obj:`int`, optional): Sequential number of the first photo to be returned.
+                By default, all photos are returned.
+            limit (:obj:`int`, optional): Limits the number of photos to be retrieved. Values
+                between 1-100 are accepted. Defaults to 100.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.UserProfilePhotos`
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getUserProfilePhotos'.format(self.base_url)
+
+        data = {'user_id': user_id}
+
+        if offset is not None:
+            data['offset'] = offset
+        if limit:
+            data['limit'] = limit
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return UserProfilePhotos.de_json(result, self)
+
+    @log
+    def get_file(self, file_id, timeout=None, **kwargs):
+        """
+        Use this method to get basic info about a file and prepare it for downloading. For the
+        moment, bots can download files of up to 20MB in size. The file can then be downloaded
+        with :attr:`telegram.File.download`. It is guaranteed that the link will be
+        valid for at least 1 hour. When the link expires, a new one can be requested by
+        calling getFile again.
+
+        Args:
+            file_id (:obj:`str`): File identifier to get info about.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.File`
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getFile'.format(self.base_url)
+
+        data = {'file_id': file_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        if result.get('file_path'):
+            result['file_path'] = '%s/%s' % (self.base_file_url, result['file_path'])
+
+        return File.de_json(result, self)
+
+    @log
+    def kick_chat_member(self, chat_id, user_id, timeout=None, until_date=None, **kwargs):
+        """
+        Use this method to kick a user from a group or a supergroup. In the case of supergroups,
+        the user will not be able to return to the group on their own using invite links, etc.,
+        unless unbanned first. The bot must be an administrator in the group for this to work.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or  username
+                of the target channel (in the format @channelusername).
+            user_id (:obj:`int`): Unique identifier of the target user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            until_date (:obj:`int` | :obj:`datetime.datetime`, optional): Date when the user will
+                be unbanned, unix time. If user is banned for more than 366 days or less than 30
+                seconds from the current time they are considered to be banned forever.
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Note:
+            In regular groups (non-supergroups), this method will only work if the
+            'All Members Are Admins' setting is off in the target group. Otherwise
+            members may only be removed by the group's creator or by the member that added them.
+
+        Returns:
+            :obj:`bool` On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/kickChatMember'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'user_id': user_id}
+        data.update(kwargs)
+
+        if until_date is not None:
+            if isinstance(until_date, datetime):
+                until_date = to_timestamp(until_date)
+            data['until_date'] = until_date
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def unban_chat_member(self, chat_id, user_id, timeout=None, **kwargs):
+        """Use this method to unban a previously kicked user in a supergroup.
+
+        The user will not return to the group automatically, but will be able to join via link,
+        etc. The bot must be an administrator in the group for this to work.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            user_id (:obj:`int`): Unique identifier of the target user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool` On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/unbanChatMember'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'user_id': user_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def answer_callback_query(self,
+                              callback_query_id,
+                              text=None,
+                              show_alert=False,
+                              url=None,
+                              cache_time=None,
+                              timeout=None,
+                              **kwargs):
+        """
+        Use this method to send answers to callback queries sent from inline keyboards. The answer
+        will be displayed to the user as a notification at the top of the chat screen or as an
+        alert.
+        Alternatively, the user can be redirected to the specified Game URL. For this option to
+        work, you must first create a game for your bot via BotFather and accept the terms.
+        Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with
+        a parameter.
+
+        Args:
+            callback_query_id (:obj:`str`): Unique identifier for the query to be answered.
+            text (:obj:`str`, optional): Text of the notification. If not specified, nothing will
+                be shown to the user, 0-200 characters.
+            show_alert (:obj:`bool`, optional): If true, an alert will be shown by the client
+                instead of a notification at the top of the chat screen. Defaults to false.
+            url (:obj:`str`, optional): URL that will be opened by the user's client. If you have
+                created a Game and accepted the conditions via @Botfather, specify the URL that
+                opens your game - note that this will only work if the query comes from a callback
+                game button. Otherwise, you may use links like t.me/your_bot?start=XXXX that open
+                your bot with a parameter.
+            cache_time (:obj:`int`, optional): The maximum amount of time in seconds that the
+                result of the callback query may be cached client-side. Defaults to 0.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool` On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url_ = '{0}/answerCallbackQuery'.format(self.base_url)
+
+        data = {'callback_query_id': callback_query_id}
+
+        if text:
+            data['text'] = text
+        if show_alert:
+            data['show_alert'] = show_alert
+        if url:
+            data['url'] = url
+        if cache_time is not None:
+            data['cache_time'] = cache_time
+        data.update(kwargs)
+
+        result = self._request.post(url_, data, timeout=timeout)
+
+        return result
+
+    @log
+    @message
+    def edit_message_text(self,
+                          text,
+                          chat_id=None,
+                          message_id=None,
+                          inline_message_id=None,
+                          parse_mode=None,
+                          disable_web_page_preview=None,
+                          reply_markup=None,
+                          timeout=None,
+                          **kwargs):
+        """
+        Use this method to edit text and game messages sent by the bot or via the bot (for inline
+        bots).
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target channel (in the format @channelusername).
+            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
+                Identifier of the sent message.
+            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
+                specified. Identifier of the inline message.
+            text (:obj:`str`): New text of the message.
+            parse_mode (:obj:`str`): Send Markdown or HTML, if you want Telegram apps to show bold,
+                italic, fixed-width text or inline URLs in your bot's message. See the constants in
+                :class:`telegram.ParseMode` for the available modes.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
+            edited Message is returned, otherwise ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/editMessageText'.format(self.base_url)
+
+        data = {'text': text}
+
+        if chat_id:
+            data['chat_id'] = chat_id
+        if message_id:
+            data['message_id'] = message_id
+        if inline_message_id:
+            data['inline_message_id'] = inline_message_id
+        if parse_mode:
+            data['parse_mode'] = parse_mode
+        if disable_web_page_preview:
+            data['disable_web_page_preview'] = disable_web_page_preview
+
+        return url, data
+
+    @log
+    @message
+    def edit_message_caption(self,
+                             chat_id=None,
+                             message_id=None,
+                             inline_message_id=None,
+                             caption=None,
+                             reply_markup=None,
+                             timeout=None,
+                             **kwargs):
+        """
+        Use this method to edit captions of messages sent by the bot or via the bot
+        (for inline bots).
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
+                Identifier of the sent message.
+            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
+                specified. Identifier of the inline message.
+            caption (:obj:`str`, optional): New caption of the message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
+            edited Message is returned, otherwise ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        if inline_message_id is None and (chat_id is None or message_id is None):
+            raise ValueError(
+                'edit_message_caption: Both chat_id and message_id are required when '
+                'inline_message_id is not specified')
+
+        url = '{0}/editMessageCaption'.format(self.base_url)
+
+        data = {}
+
+        if caption:
+            data['caption'] = caption
+        if chat_id:
+            data['chat_id'] = chat_id
+        if message_id:
+            data['message_id'] = message_id
+        if inline_message_id:
+            data['inline_message_id'] = inline_message_id
+
+        return url, data
+
+    @log
+    @message
+    def edit_message_reply_markup(self,
+                                  chat_id=None,
+                                  message_id=None,
+                                  inline_message_id=None,
+                                  reply_markup=None,
+                                  timeout=None,
+                                  **kwargs):
+        """
+        Use this method to edit only the reply markup of messages sent by the bot or via the bot
+        (for inline bots).
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
+                Identifier of the sent message.
+            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
+                specified. Identifier of the inline message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options. A
+                JSON-serialized object for an inline keyboard, custom reply keyboard, instructions
+                to remove reply keyboard or to force a reply from the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
+            editedMessage is returned, otherwise ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        if inline_message_id is None and (chat_id is None or message_id is None):
+            raise ValueError(
+                'edit_message_reply_markup: Both chat_id and message_id are required when '
+                'inline_message_id is not specified')
+
+        url = '{0}/editMessageReplyMarkup'.format(self.base_url)
+
+        data = {}
+
+        if chat_id:
+            data['chat_id'] = chat_id
+        if message_id:
+            data['message_id'] = message_id
+        if inline_message_id:
+            data['inline_message_id'] = inline_message_id
+
+        return url, data
+
+    @log
+    def get_updates(self,
+                    offset=None,
+                    limit=100,
+                    timeout=0,
+                    network_delay=None,
+                    read_latency=2.,
+                    allowed_updates=None,
+                    **kwargs):
+        """Use this method to receive incoming updates using long polling.
+
+        Args:
+            offset (:obj:`int`, optional): Identifier of the first update to be returned. Must be
+                greater by one than the highest among the identifiers of previously received
+                updates. By default, updates starting with the earliest unconfirmed update are
+                returned. An update is considered confirmed as soon as getUpdates is called with an
+                offset higher than its update_id. The negative offset can be specified to retrieve
+                updates starting from -offset update from the end of the updates queue. All
+                previous updates will forgotten.
+            limit (:obj:`int`, optional): Limits the number of updates to be retrieved. Values
+                between 1-100 are accepted. Defaults to 100.
+            timeout (:obj:`int`, optional): Timeout in seconds for long polling. Defaults to 0,
+                i.e. usual short polling. Should be positive, short polling should be used for
+                testing purposes only.
+            allowed_updates (List[:obj:`str`]), optional): List the types of updates you want your
+                bot to receive. For example, specify ["message", "edited_channel_post",
+                "callback_query"] to only receive updates of these types. See
+                :class:`telegram.Update` for a complete list of available update types.
+                Specify an empty list to receive all updates regardless of type (default). If not
+                specified, the previous setting will be used. Please note that this parameter
+                doesn't affect updates created before the call to the get_updates, so unwanted
+                updates may be received for a short period of time.
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Notes:
+            1. This method will not work if an outgoing webhook is set up.
+            2. In order to avoid getting duplicate updates, recalculate offset after each
+               server response.
+            3. To take full advantage of this library take a look at :class:`telegram.ext.Updater`
+
+        Returns:
+            List[:class:`telegram.Update`]
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getUpdates'.format(self.base_url)
+
+        if network_delay is not None:
+            warnings.warn('network_delay is deprecated, use read_latency instead')
+            read_latency = network_delay
+
+        data = {'timeout': timeout}
+
+        if offset:
+            data['offset'] = offset
+        if limit:
+            data['limit'] = limit
+        if allowed_updates is not None:
+            data['allowed_updates'] = allowed_updates
+        data.update(kwargs)
+
+        # Ideally we'd use an aggressive read timeout for the polling. However,
+        # * Short polling should return within 2 seconds.
+        # * Long polling poses a different problem: the connection might have been dropped while
+        #   waiting for the server to return and there's no way of knowing the connection had been
+        #   dropped in real time.
+        result = self._request.post(url, data, timeout=float(read_latency) + float(timeout))
+
+        if result:
+            self.logger.debug('Getting updates: %s', [u['update_id'] for u in result])
+        else:
+            self.logger.debug('No new updates found.')
+
+        return [Update.de_json(u, self) for u in result]
+
+    @log
+    def set_webhook(self,
+                    url=None,
+                    certificate=None,
+                    timeout=None,
+                    max_connections=40,
+                    allowed_updates=None,
+                    **kwargs):
+        """
+        Use this method to specify a url and receive incoming updates via an outgoing webhook.
+        Whenever there is an update for the bot, we will send an HTTPS POST request to the
+        specified url, containing a JSON-serialized Update. In case of an unsuccessful request,
+        we will give up after a reasonable amount of attempts.
+
+        If you'd like to make sure that the Webhook request comes from Telegram, we recommend
+        using a secret path in the URL, e.g. https://www.example.com/<token>. Since nobody else
+        knows your bot's token, you can be pretty sure it's us.
+
+        Note:
+            The certificate argument should be a file from disk ``open(filename, 'rb')``.
+
+        Args:
+            url (:obj:`str`): HTTPS url to send updates to. Use an empty string to remove webhook
+                integration.
+            certificate (:obj:`filelike`): Upload your public key certificate so that the root
+                certificate in use can be checked. See our self-signed guide for details.
+                (https://goo.gl/rw7w6Y)
+            max_connections (:obj:`int`, optional): Maximum allowed number of simultaneous HTTPS
+                connections to the webhook for update delivery, 1-100. Defaults to 40. Use lower
+                values to limit the load on your bot's server, and higher values to increase your
+                bot's throughput.
+            allowed_updates (List[:obj:`str`], optional): List the types of updates you want your
+                bot to receive. For example, specify ["message", "edited_channel_post",
+                "callback_query"] to only receive updates of these types. See
+                :class:`telegram.Update` for a complete list of available update types. Specify an
+                empty list to receive all updates regardless of type (default). If not specified,
+                the previous setting will be used. Please note that this parameter doesn't affect
+                updates created before the call to the set_webhook, so unwanted updates may be
+                received for a short period of time.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Note:
+            1. You will not be able to receive updates using get_updates for as long as an outgoing
+               webhook is set up.
+            2. To use a self-signed certificate, you need to upload your public key certificate
+               using certificate parameter. Please upload as InputFile, sending a String will not
+               work.
+            3. Ports currently supported for Webhooks: 443, 80, 88, 8443.
+
+        Returns:
+            :obj:`bool` On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url_ = '{0}/setWebhook'.format(self.base_url)
+
+        # Backwards-compatibility: 'url' used to be named 'webhook_url'
+        if 'webhook_url' in kwargs:  # pragma: no cover
+            warnings.warn("The 'webhook_url' parameter has been renamed to 'url' in accordance "
+                          "with the API")
+
+            if url is not None:
+                raise ValueError("The parameters 'url' and 'webhook_url' are mutually exclusive")
+
+            url = kwargs['webhook_url']
+            del kwargs['webhook_url']
+
+        data = {}
+
+        if url is not None:
+            data['url'] = url
+        if certificate:
+            data['certificate'] = certificate
+        if max_connections is not None:
+            data['max_connections'] = max_connections
+        if allowed_updates is not None:
+            data['allowed_updates'] = allowed_updates
+        data.update(kwargs)
+
+        result = self._request.post(url_, data, timeout=timeout)
+
+        return result
+
+    @log
+    def delete_webhook(self, timeout=None, **kwargs):
+        """
+        Use this method to remove webhook integration if you decide to switch back to
+        getUpdates. Requires no parameters.
+
+        Args:
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool` On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/deleteWebhook'.format(self.base_url)
+
+        data = kwargs
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def leave_chat(self, chat_id, timeout=None, **kwargs):
+        """Use this method for your bot to leave a group, supergroup or channel.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool` On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/leaveChat'.format(self.base_url)
+
+        data = {'chat_id': chat_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def get_chat(self, chat_id, timeout=None, **kwargs):
+        """
+        Use this method to get up to date information about the chat (current name of the user for
+        one-on-one conversations, current username of a user, group or channel, etc.).
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Chat`
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getChat'.format(self.base_url)
+
+        data = {'chat_id': chat_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return Chat.de_json(result, self)
+
+    @log
+    def get_chat_administrators(self, chat_id, timeout=None, **kwargs):
+        """
+        Use this method to get a list of administrators in a chat. On success, returns an Array of
+        ChatMember objects that contains information about all chat administrators except other
+        bots. If the chat is a group or a supergroup and no administrators were appointed,
+        only the creator will be returned.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            List[:class:`telegram.ChatMember`]
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getChatAdministrators'.format(self.base_url)
+
+        data = {'chat_id': chat_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return [ChatMember.de_json(x, self) for x in result]
+
+    @log
+    def get_chat_members_count(self, chat_id, timeout=None, **kwargs):
+        """Use this method to get the number of members in a chat
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            int: Number of members in the chat.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getChatMembersCount'.format(self.base_url)
+
+        data = {'chat_id': chat_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def get_chat_member(self, chat_id, user_id, timeout=None, **kwargs):
+        """Use this method to get information about a member of a chat.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            user_id (:obj:`int`): Unique identifier of the target user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.ChatMember`
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getChatMember'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'user_id': user_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return ChatMember.de_json(result, self)
+
+    @log
+    def set_chat_sticker_set(self, chat_id, sticker_set_name, timeout=None, **kwargs):
+        """Use this method to set a new group sticker set for a supergroup.
+        The bot must be an administrator in the chat for this to work and must have the appropriate
+        admin rights. Use the field :attr:`telegram.Chat.can_set_sticker_set` optionally returned
+        in :attr:`get_chat` requests to check if the bot can use this method.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target supergroup (in the format @supergroupusername).
+            sticker_set_name (:obj:`str`): Name of the sticker set to be set as the group
+                sticker set.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+
+        Returns:
+            :obj:`bool`: True on success.
+        """
+
+        url = '{0}/setChatStickerSet'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'sticker_set_name': sticker_set_name}
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def delete_chat_sticker_set(self, chat_id, timeout=None, **kwargs):
+        """Use this method to delete a group sticker set from a supergroup. The bot must be an
+        administrator in the chat for this to work and must have the appropriate admin rights.
+        Use the field :attr:`telegram.Chat.can_set_sticker_set` optionally returned in
+        :attr:`get_chat` requests to check if the bot can use this method.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target supergroup (in the format @supergroupusername).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+             :obj:`bool`: True on success.
+        """
+
+        url = '{0}/deleteChatStickerSet'.format(self.base_url)
+
+        data = {'chat_id': chat_id}
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    def get_webhook_info(self, timeout=None, **kwargs):
+        """Use this method to get current webhook status. Requires no parameters.
+
+        If the bot is using getUpdates, will return an object with the url field empty.
+
+        Args:
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.WebhookInfo`
+
+        """
+        url = '{0}/getWebhookInfo'.format(self.base_url)
+
+        data = kwargs
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return WebhookInfo.de_json(result, self)
+
+    @log
+    @message
+    def set_game_score(self,
+                       user_id,
+                       score,
+                       chat_id=None,
+                       message_id=None,
+                       inline_message_id=None,
+                       force=None,
+                       disable_edit_message=None,
+                       timeout=None,
+                       **kwargs):
+        """
+        Use this method to set the score of the specified user in a game. On success, if the
+        message was sent by the bot, returns the edited Message, otherwise returns True. Returns
+        an error, if the new score is not greater than the user's current score in the chat and
+        force is False.
+
+        Args:
+            user_id (:obj:`int`): User identifier.
+            score (:obj:`int`): New score, must be non-negative.
+            force (:obj:`bool`, optional): Pass True, if the high score is allowed to decrease.
+                This can be useful when fixing mistakes or banning cheaters
+            disable_edit_message (:obj:`bool`, optional): Pass True, if the game message should not
+                be automatically edited to include the current scoreboard.
+            chat_id (int|str, optional): Required if inline_message_id is not specified. Unique
+                identifier for the target chat.
+            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
+                Identifier of the sent message.
+            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
+                specified. Identifier of the inline message.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: The edited message, or if the message wasn't sent by the bot
+            , ``True``.
+
+        Raises:
+            :class:`telegram.TelegramError`: If the new score is not greater than the user's
+            current score in the chat and force is False.
+
+        """
+        url = '{0}/setGameScore'.format(self.base_url)
+
+        data = {'user_id': user_id, 'score': score}
+
+        if chat_id:
+            data['chat_id'] = chat_id
+        if message_id:
+            data['message_id'] = message_id
+        if inline_message_id:
+            data['inline_message_id'] = inline_message_id
+        if force is not None:
+            data['force'] = force
+        if disable_edit_message is not None:
+            data['disable_edit_message'] = disable_edit_message
+
+        return url, data
+
+    @log
+    def get_game_high_scores(self,
+                             user_id,
+                             chat_id=None,
+                             message_id=None,
+                             inline_message_id=None,
+                             timeout=None,
+                             **kwargs):
+        """
+        Use this method to get data for high score tables. Will return the score of the specified
+        user and several of his neighbors in a game
+
+        Args:
+            user_id (:obj:`int`): User identifier.
+            chat_id (:obj:`int` | :obj:`str`, optional): Required if inline_message_id is not
+                specified. Unique identifier for the target chat.
+            message_id (:obj:`int`, optional): Required if inline_message_id is not specified.
+                Identifier of the sent message.
+            inline_message_id (:obj:`str`, optional): Required if chat_id and message_id are not
+                specified. Identifier of the inline message.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            List[:class:`telegram.GameHighScore`]
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getGameHighScores'.format(self.base_url)
+
+        data = {'user_id': user_id}
+
+        if chat_id:
+            data['chat_id'] = chat_id
+        if message_id:
+            data['message_id'] = message_id
+        if inline_message_id:
+            data['inline_message_id'] = inline_message_id
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return [GameHighScore.de_json(hs, self) for hs in result]
+
+    @log
+    @message
+    def send_invoice(self,
+                     chat_id,
+                     title,
+                     description,
+                     payload,
+                     provider_token,
+                     start_parameter,
+                     currency,
+                     prices,
+                     photo_url=None,
+                     photo_size=None,
+                     photo_width=None,
+                     photo_height=None,
+                     need_name=None,
+                     need_phone_number=None,
+                     need_email=None,
+                     need_shipping_address=None,
+                     is_flexible=None,
+                     disable_notification=False,
+                     reply_to_message_id=None,
+                     reply_markup=None,
+                     provider_data=None,
+                     timeout=None,
+                     **kwargs):
+        """Use this method to send invoices.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target private chat.
+            title (:obj:`str`): Product name.
+            description (:obj:`str`): Product description.
+            payload (:obj:`str`): Bot-defined invoice payload, 1-128 bytes. This will not be
+                displayed to the user, use for your internal processes.
+            provider_token (:obj:`str`): Payments provider token, obtained via Botfather.
+            start_parameter (:obj:`str`): Unique deep-linking parameter that can be used to
+                generate this invoice when used as a start parameter.
+            currency (:obj:`str`): Three-letter ISO 4217 currency code.
+            prices (List[:class:`telegram.LabeledPrice`)]: Price breakdown, a list of components
+                (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.).
+            provider_data (:obj:`str` | :obj:`object`, optional): JSON-encoded data about the
+                invoice, which will be shared with the payment provider. A detailed description of
+                required fields should be provided by the payment provider. When an object is
+                passed, it will be encoded as JSON.
+            photo_url (:obj:`str`, optional): URL of the product photo for the invoice. Can be a
+                photo of the goods or a marketing image for a service. People like it better when
+                they see what they are paying for.
+            photo_size (:obj:`str`, optional): Photo size.
+            photo_width (:obj:`int`, optional): Photo width.
+            photo_height (:obj:`int`, optional): Photo height.
+            need_name (:obj:`bool`, optional): Pass True, if you require the user's full name to
+                complete the order.
+            need_phone_number (:obj:`bool`, optional): Pass True, if you require the user's
+                phone number to complete the order.
+            need_email (:obj:`bool`, optional): Pass True, if you require the user's email to
+                complete the order.
+            need_shipping_address (:obj:`bool`, optional): Pass True, if you require the user's
+                shipping address to complete the order.
+            is_flexible (:obj:`bool`, optional): Pass True, if the final price depends on the
+                shipping method.
+            disable_notification (:obj:`bool`, optional): Sends the message silently. Users will
+                receive a notification with no sound.
+            reply_to_message_id (:obj:`int`, optional): If the message is a reply, ID of the
+                original message.
+            reply_markup (:class:`telegram.ReplyMarkup`, optional): Additional interface options.
+                An inlinekeyboard. If empty, one 'Pay total price' button will be shown.
+                If not empty, the first button must be a Pay button.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.Message`: On success, the sent Message is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/sendInvoice'.format(self.base_url)
+
+        data = {
+            'chat_id': chat_id,
+            'title': title,
+            'description': description,
+            'payload': payload,
+            'provider_token': provider_token,
+            'start_parameter': start_parameter,
+            'currency': currency,
+            'prices': [p.to_dict() for p in prices]
+        }
+        if provider_data is not None:
+            if isinstance(provider_data, string_types):
+                data['provider_data'] = provider_data
+            else:
+                data['provider_data'] = json.dumps(provider_data)
+        if photo_url is not None:
+            data['photo_url'] = photo_url
+        if photo_size is not None:
+            data['photo_size'] = photo_size
+        if photo_width is not None:
+            data['photo_width'] = photo_width
+        if photo_height is not None:
+            data['photo_height'] = photo_height
+        if need_name is not None:
+            data['need_name'] = need_name
+        if need_phone_number is not None:
+            data['need_phone_number'] = need_phone_number
+        if need_email is not None:
+            data['need_email'] = need_email
+        if need_shipping_address is not None:
+            data['need_shipping_address'] = need_shipping_address
+        if is_flexible is not None:
+            data['is_flexible'] = is_flexible
+
+        return url, data
+
+    @log
+    def answer_shipping_query(self,
+                              shipping_query_id,
+                              ok,
+                              shipping_options=None,
+                              error_message=None,
+                              timeout=None,
+                              **kwargs):
+        """
+        If you sent an invoice requesting a shipping address and the parameter is_flexible was
+        specified, the Bot API will send an Update with a shipping_query field to the bot. Use
+        this method to reply to shipping queries.
+
+        Args:
+            shipping_query_id (:obj:`str`): Unique identifier for the query to be answered.
+            ok (:obj:`bool`): Specify True if delivery to the specified address is possible and
+                False if there are any problems (for example, if delivery to the specified address
+                is not possible).
+            shipping_options (List[:class:`telegram.ShippingOption`]), optional]: Required if ok is
+                True. A JSON-serialized array of available shipping options.
+            error_message (:obj:`str`, optional): Required if ok is False. Error message in
+                human readable form that explains why it is impossible to complete the order (e.g.
+                "Sorry, delivery to your desired address is unavailable"). Telegram will display
+                this message to the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool`; On success, True is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        ok = bool(ok)
+
+        if ok and (shipping_options is None or error_message is not None):
+            raise TelegramError(
+                'answerShippingQuery: If ok is True, shipping_options '
+                'should not be empty and there should not be error_message')
+
+        if not ok and (shipping_options is not None or error_message is None):
+            raise TelegramError(
+                'answerShippingQuery: If ok is False, error_message '
+                'should not be empty and there should not be shipping_options')
+
+        url_ = '{0}/answerShippingQuery'.format(self.base_url)
+
+        data = {'shipping_query_id': shipping_query_id, 'ok': ok}
+
+        if ok:
+            data['shipping_options'] = [option.to_dict() for option in shipping_options]
+        if error_message is not None:
+            data['error_message'] = error_message
+        data.update(kwargs)
+
+        result = self._request.post(url_, data, timeout=timeout)
+
+        return result
+
+    @log
+    def answer_pre_checkout_query(self, pre_checkout_query_id, ok,
+                                  error_message=None, timeout=None, **kwargs):
+        """
+        Once the user has confirmed their payment and shipping details, the Bot API sends the final
+        confirmation in the form of an Update with the field pre_checkout_query. Use this method to
+        respond to such pre-checkout queries.
+
+        Note:
+            The Bot API must receive an answer within 10 seconds after the pre-checkout
+            query was sent.
+
+        Args:
+            pre_checkout_query_id (:obj:`str`): Unique identifier for the query to be answered.
+            ok (:obj:`bool`): Specify True if everything is alright (goods are available, etc.) and
+                the bot is ready to proceed with the order. Use False if there are any problems.
+            error_message (:obj:`str`, optional): Required if ok is False. Error message in  human
+                readable form that explains the reason for failure to proceed with the checkout
+                (e.g. "Sorry, somebody just bought the last of our amazing black T-shirts while you
+                were busy filling out your payment details. Please choose a different color or
+                garment!"). Telegram will display this message to the user.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool`: On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        ok = bool(ok)
+
+        if not (ok ^ (error_message is not None)):
+            raise TelegramError(
+                'answerPreCheckoutQuery: If ok is True, there should '
+                'not be error_message; if ok is False, error_message '
+                'should not be empty')
+
+        url_ = '{0}/answerPreCheckoutQuery'.format(self.base_url)
+
+        data = {'pre_checkout_query_id': pre_checkout_query_id, 'ok': ok}
+
+        if error_message is not None:
+            data['error_message'] = error_message
+        data.update(kwargs)
+
+        result = self._request.post(url_, data, timeout=timeout)
+
+        return result
+
+    @log
+    def restrict_chat_member(self, chat_id, user_id, until_date=None, can_send_messages=None,
+                             can_send_media_messages=None, can_send_other_messages=None,
+                             can_add_web_page_previews=None, timeout=None, **kwargs):
+        """
+        Use this method to restrict a user in a supergroup. The bot must be an administrator in
+        the supergroup for this to work and must have the appropriate admin rights. Pass True for
+        all boolean parameters to lift restrictions from a user.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target supergroup (in the format @supergroupusername).
+            user_id (:obj:`int`): Unique identifier of the target user.
+            until_date (:obj:`int` | :obj:`datetime.datetime`, optional): Date when restrictions
+                will be lifted for the user, unix time. If user is restricted for more than 366
+                days or less than 30 seconds from the current time, they are considered to be
+                restricted forever.
+            can_send_messages (:obj:`bool`, optional): Pass True, if the user can send text
+                messages, contacts, locations and venues.
+            can_send_media_messages (:obj:`bool`, optional): Pass True, if the user can send
+                audios, documents, photos, videos, video notes and voice notes, implies
+                can_send_messages.
+            can_send_other_messages (:obj:`bool`, optional): Pass True, if the user can send
+                animations, games, stickers and use inline bots, implies can_send_media_messages.
+            can_add_web_page_previews (:obj:`bool`, optional): Pass True, if the user may add
+                web page previews to their messages, implies can_send_media_messages.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Returns:
+            :obj:`bool`: Returns True on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/restrictChatMember'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'user_id': user_id}
+
+        if until_date is not None:
+            if isinstance(until_date, datetime):
+                until_date = to_timestamp(until_date)
+            data['until_date'] = until_date
+        if can_send_messages is not None:
+            data['can_send_messages'] = can_send_messages
+        if can_send_media_messages is not None:
+            data['can_send_media_messages'] = can_send_media_messages
+        if can_send_other_messages is not None:
+            data['can_send_other_messages'] = can_send_other_messages
+        if can_add_web_page_previews is not None:
+            data['can_add_web_page_previews'] = can_add_web_page_previews
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def promote_chat_member(self, chat_id, user_id, can_change_info=None,
+                            can_post_messages=None, can_edit_messages=None,
+                            can_delete_messages=None, can_invite_users=None,
+                            can_restrict_members=None, can_pin_messages=None,
+                            can_promote_members=None, timeout=None, **kwargs):
+        """
+        Use this method to promote or demote a user in a supergroup or a channel. The bot must be
+        an administrator in the chat for this to work and must have the appropriate admin rights.
+        Pass False for all boolean parameters to demote a user
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target supergroup (in the format @supergroupusername).
+            user_id (:obj:`int`): Unique identifier of the target user.
+            can_change_info (:obj:`bool`, optional): Pass True, if the administrator can change
+                chat title, photo and other settings.
+            can_post_messages (:obj:`bool`, optional): Pass True, if the administrator can
+                create channel posts, channels only.
+            can_edit_messages (:obj:`bool`, optional): Pass True, if the administrator can edit
+                messages of other users, channels only.
+            can_delete_messages (:obj:`bool`, optional): Pass True, if the administrator can
+                delete messages of other users.
+            can_invite_users (:obj:`bool`, optional): Pass True, if the administrator can invite
+                new users to the chat.
+            can_restrict_members (:obj:`bool`, optional): Pass True, if the administrator can
+                restrict, ban or unban chat members.
+            can_pin_messages (:obj:`bool`, optional): Pass True, if the administrator can pin
+                messages, supergroups only.
+            can_promote_members (:obj:`bool`, optional): Pass True, if the administrator can add
+                new administrators with a subset of his own privileges or demote administrators
+                that he has promoted, directly or indirectly (promoted by administrators that were
+                appointed by him).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Returns:
+            :obj:`bool`: Returns True on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/promoteChatMember'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'user_id': user_id}
+
+        if can_change_info is not None:
+            data['can_change_info'] = can_change_info
+        if can_post_messages is not None:
+            data['can_post_messages'] = can_post_messages
+        if can_edit_messages is not None:
+            data['can_edit_messages'] = can_edit_messages
+        if can_delete_messages is not None:
+            data['can_delete_messages'] = can_delete_messages
+        if can_invite_users is not None:
+            data['can_invite_users'] = can_invite_users
+        if can_restrict_members is not None:
+            data['can_restrict_members'] = can_restrict_members
+        if can_pin_messages is not None:
+            data['can_pin_messages'] = can_pin_messages
+        if can_promote_members is not None:
+            data['can_promote_members'] = can_promote_members
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def export_chat_invite_link(self, chat_id, timeout=None, **kwargs):
+        """
+        Use this method to export an invite link to a supergroup or a channel. The bot must be an
+        administrator in the chat for this to work and must have the appropriate admin rights.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Returns:
+            :obj:`str`: Exported invite link on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/exportChatInviteLink'.format(self.base_url)
+
+        data = {'chat_id': chat_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def set_chat_photo(self, chat_id, photo, timeout=None, **kwargs):
+        """Use this method to set a new profile photo for the chat.
+
+        Photos can't be changed for private chats. The bot must be an administrator in the chat
+        for this to work and must have the appropriate admin rights.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            photo (`telegram.InputFile`): New chat photo.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Note:
+            In regular groups (non-supergroups), this method will only work if the
+            'All Members Are Admins' setting is off in the target group.
+
+        Returns:
+            :obj:`bool`: Returns True on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/setChatPhoto'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'photo': photo}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def delete_chat_photo(self, chat_id, timeout=None, **kwargs):
+        """
+        Use this method to delete a chat photo. Photos can't be changed for private chats. The bot
+        must be an administrator in the chat for this to work and must have the appropriate admin
+        rights.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Note:
+            In regular groups (non-supergroups), this method will only work if the
+            'All Members Are Admins' setting is off in the target group.
+
+        Returns:
+            :obj:`bool`: Returns ``True`` on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/deleteChatPhoto'.format(self.base_url)
+
+        data = {'chat_id': chat_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def set_chat_title(self, chat_id, title, timeout=None, **kwargs):
+        """
+        Use this method to change the title of a chat. Titles can't be changed for private chats.
+        The bot must be an administrator in the chat for this to work and must have the appropriate
+        admin rights.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            title (:obj:`str`): New chat title, 1-255 characters.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Note:
+            In regular groups (non-supergroups), this method will only work if the
+            'All Members Are Admins' setting is off in the target group.
+
+        Returns:
+            :obj:`bool`: Returns ``True`` on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/setChatTitle'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'title': title}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def set_chat_description(self, chat_id, description, timeout=None, **kwargs):
+        """
+        Use this method to change the description of a supergroup or a channel. The bot must be an
+        administrator in the chat for this to work and must have the appropriate admin rights.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            description (:obj:`str`): New chat description, 1-255 characters.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Returns:
+            :obj:`bool`: Returns ``True`` on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/setChatDescription'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'description': description}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def pin_chat_message(self, chat_id, message_id, disable_notification=None, timeout=None,
+                         **kwargs):
+        """
+        Use this method to pin a message in a supergroup. The bot must be an administrator in the
+        chat for this to work and must have the appropriate admin rights.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            message_id (:obj:`int`): Identifier of a message to pin.
+            disable_notification (:obj:`bool`, optional): Pass True, if it is not necessary to send
+                a notification to all group members about the new pinned message.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Returns:
+            :obj:`bool`: Returns ``True`` on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/pinChatMessage'.format(self.base_url)
+
+        data = {'chat_id': chat_id, 'message_id': message_id}
+
+        if disable_notification is not None:
+            data['disable_notification'] = disable_notification
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def unpin_chat_message(self, chat_id, timeout=None, **kwargs):
+        """
+        Use this method to unpin a message in a supergroup. The bot must be an administrator in the
+        chat for this to work and must have the appropriate admin rights.
+
+        Args:
+            chat_id (:obj:`int` | :obj:`str`): Unique identifier for the target chat or username
+                of the target`channel (in the format @channelusername).
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments
+
+        Returns:
+            :obj:`bool`: Returns ``True`` on success.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/unpinChatMessage'.format(self.base_url)
+
+        data = {'chat_id': chat_id}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def get_sticker_set(self, name, timeout=None, **kwargs):
+        """Use this method to get a sticker set.
+
+        Args:
+            name (:obj:`str`): Short name of the sticker set that is used in t.me/addstickers/
+                URLs (e.g., animals)
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during
+                creation of the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.StickerSet`
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/getStickerSet'.format(self.base_url)
+
+        data = {'name': name}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return StickerSet.de_json(result, self)
+
+    @log
+    def upload_sticker_file(self, user_id, png_sticker, timeout=None, **kwargs):
+        """
+        Use this method to upload a .png file with a sticker for later use in
+        :attr:`create_new_sticker_set` and :attr:`add_sticker_to_set` methods (can be used multiple
+        times).
+
+        Note:
+            The png_sticker argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            user_id (:obj:`int`): User identifier of sticker file owner.
+            png_sticker (:obj:`str` | `filelike object`): Png image with the sticker,
+                must be up to 512 kilobytes in size, dimensions must not exceed 512px,
+                and either width or height must be exactly 512px.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during
+                creation of the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :class:`telegram.File`: The uploaded File
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/uploadStickerFile'.format(self.base_url)
+
+        data = {'user_id': user_id, 'png_sticker': png_sticker}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return File.de_json(result, self)
+
+    @log
+    def create_new_sticker_set(self, user_id, name, title, png_sticker, emojis,
+                               contains_masks=None, mask_position=None, timeout=None, **kwargs):
+        """Use this method to create new sticker set owned by a user.
+
+        The bot will be able to edit the created sticker set.
+
+        Note:
+            The png_sticker argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            user_id (:obj:`int`): User identifier of created sticker set owner.
+            name (:obj:`str`): Short name of sticker set, to be used in t.me/addstickers/ URLs
+                (e.g., animals). Can contain only english letters, digits and underscores.
+                Must begin with a letter, can't contain consecutive underscores and
+                must end in "_by_<bot username>". <bot_username> is case insensitive.
+                1-64 characters.
+            title (:obj:`str`): Sticker set title, 1-64 characters.
+            png_sticker (:obj:`str` | `filelike object`): Png image with the sticker, must be up
+                to 512 kilobytes in size, dimensions must not exceed 512px,
+                and either width or height must be exactly 512px. Pass a file_id as a String to
+                send a file that already exists on the Telegram servers, pass an HTTP URL as a
+                String for Telegram to get a file from the Internet, or upload a new one
+                using multipart/form-data.
+            emojis (:obj:`str`): One or more emoji corresponding to the sticker.
+            contains_masks (:obj:`bool`, optional): Pass True, if a set of mask stickers should be
+                created.
+            mask_position (:class:`telegram.MaskPosition`, optional): Position where the mask
+                should be placed on faces.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during
+                creation of the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool`: On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/createNewStickerSet'.format(self.base_url)
+
+        data = {'user_id': user_id, 'name': name, 'title': title, 'png_sticker': png_sticker,
+                'emojis': emojis}
+
+        if contains_masks is not None:
+            data['contains_masks'] = contains_masks
+        if mask_position is not None:
+            data['mask_position'] = mask_position
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def add_sticker_to_set(self, user_id, name, png_sticker, emojis, mask_position=None,
+                           timeout=None, **kwargs):
+        """Use this method to add a new sticker to a set created by the bot.
+
+        Note:
+            The png_sticker argument can be either a file_id, an URL or a file from disk
+            ``open(filename, 'rb')``
+
+        Args:
+            user_id (:obj:`int`): User identifier of created sticker set owner.
+            name (:obj:`str`): Sticker set name.
+            png_sticker (:obj:`str` | `filelike object`): Png image with the sticker, must be up
+                to 512 kilobytes in size, dimensions must not exceed 512px,
+                and either width or height must be exactly 512px. Pass a file_id as a String to
+                send a file that already exists on the Telegram servers, pass an HTTP URL as a
+                String for Telegram to get a file from the Internet, or upload a new one
+                using multipart/form-data.
+            emojis (:obj:`str`): One or more emoji corresponding to the sticker.
+            mask_position (:class:`telegram.MaskPosition`, optional): Position where the mask
+                should beplaced on faces.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during
+                creation of the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool`: On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/addStickerToSet'.format(self.base_url)
+
+        data = {'user_id': user_id, 'name': name, 'png_sticker': png_sticker, 'emojis': emojis}
+
+        if mask_position is not None:
+            data['mask_position'] = mask_position
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def set_sticker_position_in_set(self, sticker, position, timeout=None, **kwargs):
+        """Use this method to move a sticker in a set created by the bot to a specific position.
+
+        Args:
+            sticker (:obj:`str`): File identifier of the sticker.
+            position (:obj:`int`): New sticker position in the set, zero-based.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during
+                creation of the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool`: On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/setStickerPositionInSet'.format(self.base_url)
+
+        data = {'sticker': sticker, 'position': position}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    @log
+    def delete_sticker_from_set(self, sticker, timeout=None, **kwargs):
+        """Use this method to delete a sticker from a set created by the bot.
+
+        Args:
+            sticker (:obj:`str`): File identifier of the sticker.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during
+                creation of the connection pool).
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        Returns:
+            :obj:`bool`: On success, ``True`` is returned.
+
+        Raises:
+            :class:`telegram.TelegramError`
+
+        """
+        url = '{0}/deleteStickerFromSet'.format(self.base_url)
+
+        data = {'sticker': sticker}
+        data.update(kwargs)
+
+        result = self._request.post(url, data, timeout=timeout)
+
+        return result
+
+    def to_dict(self):
+        data = {'id': self.id, 'username': self.username, 'first_name': self.username}
+
+        if self.last_name:
+            data['last_name'] = self.last_name
+
+        return data
+
+    def __reduce__(self):
+        return (self.__class__, (self.token, self.base_url.replace(self.token, ''),
+                                 self.base_file_url.replace(self.token, '')))
+
+    # camelCase aliases
+    getMe = get_me
+    sendMessage = send_message
+    deleteMessage = delete_message
+    forwardMessage = forward_message
+    sendPhoto = send_photo
+    sendAudio = send_audio
+    sendDocument = send_document
+    sendSticker = send_sticker
+    sendVideo = send_video
+    sendVoice = send_voice
+    sendVideoNote = send_video_note
+    sendMediaGroup = send_media_group
+    sendLocation = send_location
+    editMessageLiveLocation = edit_message_live_location
+    stopMessageLiveLocation = stop_message_live_location
+    sendVenue = send_venue
+    sendContact = send_contact
+    sendGame = send_game
+    sendChatAction = send_chat_action
+    answerInlineQuery = answer_inline_query
+    getUserProfilePhotos = get_user_profile_photos
+    getFile = get_file
+    kickChatMember = kick_chat_member
+    unbanChatMember = unban_chat_member
+    answerCallbackQuery = answer_callback_query
+    editMessageText = edit_message_text
+    editMessageCaption = edit_message_caption
+    editMessageReplyMarkup = edit_message_reply_markup
+    getUpdates = get_updates
+    setWebhook = set_webhook
+    deleteWebhook = delete_webhook
+    leaveChat = leave_chat
+    getChat = get_chat
+    getChatAdministrators = get_chat_administrators
+    getChatMember = get_chat_member
+    setChatStickerSet = set_chat_sticker_set
+    deleteChatStickerSet = delete_chat_sticker_set
+    getChatMembersCount = get_chat_members_count
+    getWebhookInfo = get_webhook_info
+    setGameScore = set_game_score
+    getGameHighScores = get_game_high_scores
+    sendInvoice = send_invoice
+    answerShippingQuery = answer_shipping_query
+    answerPreCheckoutQuery = answer_pre_checkout_query
+    restrictChatMember = restrict_chat_member
+    promoteChatMember = promote_chat_member
+    exportChatInviteLink = export_chat_invite_link
+    setChatPhoto = set_chat_photo
+    deleteChatPhoto = delete_chat_photo
+    setChatTitle = set_chat_title
+    setChatDescription = set_chat_description
+    pinChatMessage = pin_chat_message
+    unpinChatMessage = unpin_chat_message
+    getStickerSet = get_sticker_set
+    uploadStickerFile = upload_sticker_file
+    createNewStickerSet = create_new_sticker_set
+    addStickerToSet = add_sticker_to_set
+    setStickerPositionInSet = set_sticker_position_in_set
+    deleteStickerFromSet = delete_sticker_from_set
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `python-telegram-bot-8.1.1/telegram/callbackquery.py` & `python-telegram-bot-9.0.0/telegram/callbackquery.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,196 +1,196 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram CallbackQuery"""
-
-from telegram import TelegramObject, Message, User
-
-
-class CallbackQuery(TelegramObject):
-    """
-    This object represents an incoming callback query from a callback button in an inline keyboard.
-
-    If the button that originated the query was attached to a message sent by the bot, the field
-    :attr:`message` will be present. If the button was attached to a message sent via the bot (in
-    inline mode), the field :attr:`inline_message_id` will be present.
-
-    Note:
-        * In Python `from` is a reserved word, use `from_user` instead.
-        * Exactly one of the fields :attr:`data` or :attr:`game_short_name` will be present.
-
-    Attributes:
-        id (:obj:`str`): Unique identifier for this query.
-        from_user (:class:`telegram.User`): Sender.
-        message (:class:`telegram.Message`): Optional. Message with the callback button that
-            originated the query.
-        inline_message_id (:obj:`str`): Optional. Identifier of the message sent via the bot in
-                inline mode, that originated the query.
-        chat_instance (:obj:`str`): Optional. Global identifier, uniquely corresponding to the chat
-            to which the message with the callback button was sent.
-        data (:obj:`str`): Optional. Data associated with the callback button.
-        game_short_name (:obj:`str`): Optional. Short name of a Game to be returned.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this query.
-        from_user (:class:`telegram.User`): Sender.
-        message (:class:`telegram.Message`, optional): Message with the callback button that
-            originated the query. Note that message content and message date will not be available
-            if the message is too old.
-        inline_message_id (:obj:`str`, optional): Identifier of the message sent via the bot in
-            inline mode, that originated the query.
-        chat_instance (:obj:`str`, optional): Global identifier, uniquely corresponding to the chat
-            to which the message with the callback button was sent. Useful for high scores in
-            games.
-        data (:obj:`str`, optional): Data associated with the callback button. Be aware that a bad
-            client can send arbitrary data in this field.
-        game_short_name (:obj:`str`, optional): Short name of a Game to be returned, serves as
-            the unique identifier for the game
-
-    Note:
-        After the user presses an inline button, Telegram clients will display a progress bar
-        until you call :attr:`answer`. It is, therefore, necessary to react
-        by calling :attr:`telegram.Bot.answer_callback_query` even if no notification to the user
-        is needed (e.g., without specifying any of the optional parameters).
-
-    """
-
-    def __init__(self,
-                 id,
-                 from_user,
-                 chat_instance,
-                 message=None,
-                 data=None,
-                 inline_message_id=None,
-                 game_short_name=None,
-                 bot=None,
-                 **kwargs):
-        # Required
-        self.id = id
-        self.from_user = from_user
-        self.chat_instance = chat_instance
-        # Optionals
-        self.message = message
-        self.data = data
-        self.inline_message_id = inline_message_id
-        self.game_short_name = game_short_name
-
-        self.bot = bot
-
-        self._id_attrs = (self.id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(CallbackQuery, cls).de_json(data, bot)
-
-        data['from_user'] = User.de_json(data.get('from'), bot)
-        data['message'] = Message.de_json(data.get('message'), bot)
-
-        return cls(bot=bot, **data)
-
-    def to_dict(self):
-        data = super(CallbackQuery, self).to_dict()
-
-        # Required
-        data['from'] = data.pop('from_user', None)
-        return data
-
-    def answer(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.answer_callback_query(update.callback_query.id, *args, **kwargs)
-
-        Returns:
-            :obj:`bool`: On success, ``True`` is returned.
-
-        """
-        return self.bot.answerCallbackQuery(self.id, *args, **kwargs)
-
-    def edit_message_text(self, *args, **kwargs):
-        """Shortcut for either::
-
-            bot.edit_message_text(chat_id=update.callback_query.message.chat_id,
-                                message_id=update.callback_query.message.message_id,
-                                *args, **kwargs)
-
-        or::
-
-            bot.edit_message_text(inline_message_id=update.callback_query.inline_message_id,
-                                *args, **kwargs)
-
-        Returns:
-            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
-            edited Message is returned, otherwise ``True`` is returned.
-
-        """
-        if self.inline_message_id:
-            return self.bot.edit_message_text(
-                inline_message_id=self.inline_message_id, *args, **kwargs)
-        else:
-            return self.bot.edit_message_text(
-                chat_id=self.message.chat_id, message_id=self.message.message_id, *args, **kwargs)
-
-    def edit_message_caption(self, *args, **kwargs):
-        """Shortcut for either::
-
-            bot.edit_message_caption(chat_id=update.callback_query.message.chat_id,
-                                   message_id=update.callback_query.message.message_id,
-                                   *args, **kwargs)
-
-        or::
-
-            bot.edit_message_caption(inline_message_id=update.callback_query.inline_message_id,
-                                   *args, **kwargs)
-
-        Returns:
-            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
-            edited Message is returned, otherwise ``True`` is returned.
-
-        """
-        if self.inline_message_id:
-            return self.bot.edit_message_caption(
-                inline_message_id=self.inline_message_id, *args, **kwargs)
-        else:
-            return self.bot.edit_message_caption(
-                chat_id=self.message.chat_id, message_id=self.message.message_id, *args, **kwargs)
-
-    def edit_message_reply_markup(self, *args, **kwargs):
-        """Shortcut for either::
-
-            bot.edit_message_replyMarkup(chat_id=update.callback_query.message.chat_id,
-                                       message_id=update.callback_query.message.message_id,
-                                       *args, **kwargs)
-
-        or::
-
-            bot.edit_message_reply_markup(inline_message_id=update.callback_query.inline_message_id,
-                                       *args, **kwargs)
-
-        Returns:
-            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
-            edited Message is returned, otherwise ``True`` is returned.
-
-        """
-        if self.inline_message_id:
-            return self.bot.edit_message_reply_markup(
-                inline_message_id=self.inline_message_id, *args, **kwargs)
-        else:
-            return self.bot.edit_message_reply_markup(
-                chat_id=self.message.chat_id, message_id=self.message.message_id, *args, **kwargs)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram CallbackQuery"""
+
+from telegram import TelegramObject, Message, User
+
+
+class CallbackQuery(TelegramObject):
+    """
+    This object represents an incoming callback query from a callback button in an inline keyboard.
+
+    If the button that originated the query was attached to a message sent by the bot, the field
+    :attr:`message` will be present. If the button was attached to a message sent via the bot (in
+    inline mode), the field :attr:`inline_message_id` will be present.
+
+    Note:
+        * In Python `from` is a reserved word, use `from_user` instead.
+        * Exactly one of the fields :attr:`data` or :attr:`game_short_name` will be present.
+
+    Attributes:
+        id (:obj:`str`): Unique identifier for this query.
+        from_user (:class:`telegram.User`): Sender.
+        message (:class:`telegram.Message`): Optional. Message with the callback button that
+            originated the query.
+        inline_message_id (:obj:`str`): Optional. Identifier of the message sent via the bot in
+                inline mode, that originated the query.
+        chat_instance (:obj:`str`): Optional. Global identifier, uniquely corresponding to the chat
+            to which the message with the callback button was sent.
+        data (:obj:`str`): Optional. Data associated with the callback button.
+        game_short_name (:obj:`str`): Optional. Short name of a Game to be returned.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this query.
+        from_user (:class:`telegram.User`): Sender.
+        message (:class:`telegram.Message`, optional): Message with the callback button that
+            originated the query. Note that message content and message date will not be available
+            if the message is too old.
+        inline_message_id (:obj:`str`, optional): Identifier of the message sent via the bot in
+            inline mode, that originated the query.
+        chat_instance (:obj:`str`, optional): Global identifier, uniquely corresponding to the chat
+            to which the message with the callback button was sent. Useful for high scores in
+            games.
+        data (:obj:`str`, optional): Data associated with the callback button. Be aware that a bad
+            client can send arbitrary data in this field.
+        game_short_name (:obj:`str`, optional): Short name of a Game to be returned, serves as
+            the unique identifier for the game
+
+    Note:
+        After the user presses an inline button, Telegram clients will display a progress bar
+        until you call :attr:`answer`. It is, therefore, necessary to react
+        by calling :attr:`telegram.Bot.answer_callback_query` even if no notification to the user
+        is needed (e.g., without specifying any of the optional parameters).
+
+    """
+
+    def __init__(self,
+                 id,
+                 from_user,
+                 chat_instance,
+                 message=None,
+                 data=None,
+                 inline_message_id=None,
+                 game_short_name=None,
+                 bot=None,
+                 **kwargs):
+        # Required
+        self.id = id
+        self.from_user = from_user
+        self.chat_instance = chat_instance
+        # Optionals
+        self.message = message
+        self.data = data
+        self.inline_message_id = inline_message_id
+        self.game_short_name = game_short_name
+
+        self.bot = bot
+
+        self._id_attrs = (self.id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(CallbackQuery, cls).de_json(data, bot)
+
+        data['from_user'] = User.de_json(data.get('from'), bot)
+        data['message'] = Message.de_json(data.get('message'), bot)
+
+        return cls(bot=bot, **data)
+
+    def to_dict(self):
+        data = super(CallbackQuery, self).to_dict()
+
+        # Required
+        data['from'] = data.pop('from_user', None)
+        return data
+
+    def answer(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.answer_callback_query(update.callback_query.id, *args, **kwargs)
+
+        Returns:
+            :obj:`bool`: On success, ``True`` is returned.
+
+        """
+        return self.bot.answerCallbackQuery(self.id, *args, **kwargs)
+
+    def edit_message_text(self, *args, **kwargs):
+        """Shortcut for either::
+
+            bot.edit_message_text(chat_id=update.callback_query.message.chat_id,
+                                message_id=update.callback_query.message.message_id,
+                                *args, **kwargs)
+
+        or::
+
+            bot.edit_message_text(inline_message_id=update.callback_query.inline_message_id,
+                                *args, **kwargs)
+
+        Returns:
+            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
+            edited Message is returned, otherwise ``True`` is returned.
+
+        """
+        if self.inline_message_id:
+            return self.bot.edit_message_text(
+                inline_message_id=self.inline_message_id, *args, **kwargs)
+        else:
+            return self.bot.edit_message_text(
+                chat_id=self.message.chat_id, message_id=self.message.message_id, *args, **kwargs)
+
+    def edit_message_caption(self, *args, **kwargs):
+        """Shortcut for either::
+
+            bot.edit_message_caption(chat_id=update.callback_query.message.chat_id,
+                                   message_id=update.callback_query.message.message_id,
+                                   *args, **kwargs)
+
+        or::
+
+            bot.edit_message_caption(inline_message_id=update.callback_query.inline_message_id,
+                                   *args, **kwargs)
+
+        Returns:
+            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
+            edited Message is returned, otherwise ``True`` is returned.
+
+        """
+        if self.inline_message_id:
+            return self.bot.edit_message_caption(
+                inline_message_id=self.inline_message_id, *args, **kwargs)
+        else:
+            return self.bot.edit_message_caption(
+                chat_id=self.message.chat_id, message_id=self.message.message_id, *args, **kwargs)
+
+    def edit_message_reply_markup(self, *args, **kwargs):
+        """Shortcut for either::
+
+            bot.edit_message_replyMarkup(chat_id=update.callback_query.message.chat_id,
+                                       message_id=update.callback_query.message.message_id,
+                                       *args, **kwargs)
+
+        or::
+
+            bot.edit_message_reply_markup(inline_message_id=update.callback_query.inline_message_id,
+                                       *args, **kwargs)
+
+        Returns:
+            :class:`telegram.Message`: On success, if edited message is sent by the bot, the
+            edited Message is returned, otherwise ``True`` is returned.
+
+        """
+        if self.inline_message_id:
+            return self.bot.edit_message_reply_markup(
+                inline_message_id=self.inline_message_id, *args, **kwargs)
+        else:
+            return self.bot.edit_message_reply_markup(
+                chat_id=self.message.chat_id, message_id=self.message.message_id, *args, **kwargs)
```

### Comparing `python-telegram-bot-8.1.1/telegram/chat.py` & `python-telegram-bot-9.0.0/telegram/chat.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,214 +1,214 @@
-#!/usr/bin/env python
-# pylint: disable=C0103,W0622
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Chat."""
-
-from telegram import TelegramObject, ChatPhoto
-
-
-class Chat(TelegramObject):
-    """This object represents a chat.
-
-    Attributes:
-        id (:obj:`int`): Unique identifier for this chat.
-        type (:obj:`str`): Type of chat.
-        title (:obj:`str`): Optional. Title, for supergroups, channels and group chats.
-        username (:obj:`str`): Optional. Username.
-        first_name (:obj:`str`): Optional. First name of the other party in a private chat.
-        last_name (:obj:`str`): Optional. Last name of the other party in a private chat.
-        all_members_are_administrators (:obj:`bool`): Optional.
-        photo (:class:`telegram.ChatPhoto`): Optional. Chat photo.
-        description (:obj:`str`): Optional. Description, for supergroups and channel chats.
-        invite_link (:obj:`str`): Optional. Chat invite link, for supergroups and channel chats.
-        pinned_message (:class:`telegram.Message`): Optional. Pinned message, for supergroups.
-            Returned only in get_chat.
-        sticker_set_name (:obj:`str`): Optional. For supergroups, name of Group sticker set.
-        can_set_sticker_set (:obj:`bool`): Optional. ``True``, if the bot can change group the
-            sticker set.
-
-    Args:
-        id (:obj:`int`): Unique identifier for this chat. This number may be greater than 32 bits
-            and some programming languages may have difficulty/silent defects in interpreting it.
-            But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float
-            type are safe for storing this identifier.
-        type (:obj:`str`): Type of chat, can be either 'private', 'group', 'supergroup' or
-            'channel'.
-        title (:obj:`str`, optional): Title, for supergroups, channels and group chats.
-        username(:obj:`str`, optional): Username, for private chats, supergroups and channels if
-            available.
-        first_name(:obj:`str`, optional): First name of the other party in a private chat.
-        last_name(:obj:`str`, optional): Last name of the other party in a private chat.
-        all_members_are_administrators (:obj:`bool`, optional): True if a group has `All Members
-            Are Admins` enabled.
-        photo (:class:`telegram.ChatPhoto`, optional): Chat photo. Returned only in getChat.
-        description (:obj:`str`, optional): Description, for supergroups and channel chats.
-            Returned only in get_chat.
-        invite_link (:obj:`str`, optional): Chat invite link, for supergroups and channel chats.
-            Returned only in get_chat.
-        pinned_message (:class:`telegram.Message`, optional): Pinned message, for supergroups.
-            Returned only in get_chat.
-        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
-        sticker_set_name (:obj:`str`, optional): For supergroups, name of Group sticker set.
-            Returned only in get_chat.
-        can_set_sticker_set (:obj:`bool`, optional): ``True``, if the bot can change group the
-            sticker set. Returned only in get_chat.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    PRIVATE = 'private'
-    """:obj:`str`: 'private'"""
-    GROUP = 'group'
-    """:obj:`str`: 'group'"""
-    SUPERGROUP = 'supergroup'
-    """:obj:`str`: 'supergroup'"""
-    CHANNEL = 'channel'
-    """:obj:`str`: 'channel'"""
-
-    def __init__(self,
-                 id,
-                 type,
-                 title=None,
-                 username=None,
-                 first_name=None,
-                 last_name=None,
-                 all_members_are_administrators=None,
-                 bot=None,
-                 photo=None,
-                 description=None,
-                 invite_link=None,
-                 pinned_message=None,
-                 sticker_set_name=None,
-                 can_set_sticker_set=None,
-                 **kwargs):
-        # Required
-        self.id = int(id)
-        self.type = type
-        # Optionals
-        self.title = title
-        self.username = username
-        self.first_name = first_name
-        self.last_name = last_name
-        self.all_members_are_administrators = all_members_are_administrators
-        self.photo = photo
-        self.description = description
-        self.invite_link = invite_link
-        self.pinned_message = pinned_message
-        self.sticker_set_name = sticker_set_name
-        self.can_set_sticker_set = can_set_sticker_set
-
-        self.bot = bot
-        self._id_attrs = (self.id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data['photo'] = ChatPhoto.de_json(data.get('photo'), bot)
-        from telegram import Message
-        data['pinned_message'] = Message.de_json(data.get('pinned_message'), bot)
-
-        return cls(bot=bot, **data)
-
-    def send_action(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_chat_action(update.message.chat.id, *args, **kwargs)
-
-        Returns:
-            :obj:`bool`: If the action was sent successfully.
-
-        """
-
-        return self.bot.send_chat_action(self.id, *args, **kwargs)
-
-    def leave(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.leave_chat(update.message.chat.id, *args, **kwargs)
-
-        Returns:
-            :obj:`bool` If the action was sent successfully.
-
-        """
-        return self.bot.leave_chat(self.id, *args, **kwargs)
-
-    def get_administrators(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.get_chat_administrators(update.message.chat.id, *args, **kwargs)
-
-        Returns:
-            List[:class:`telegram.ChatMember`]: A list of administrators in a chat. An Array of
-            :class:`telegram.ChatMember` objects that contains information about all
-            chat administrators except other bots. If the chat is a group or a supergroup
-            and no administrators were appointed, only the creator will be returned
-
-        """
-        return self.bot.get_chat_administrators(self.id, *args, **kwargs)
-
-    def get_members_count(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.get_chat_members_count(update.message.chat.id, *args, **kwargs)
-
-        Returns:
-            :obj:`int`
-
-        """
-        return self.bot.get_chat_members_count(self.id, *args, **kwargs)
-
-    def get_member(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.get_chat_member(update.message.chat.id, *args, **kwargs)
-
-        Returns:
-            :class:`telegram.ChatMember`
-
-        """
-        return self.bot.get_chat_member(self.id, *args, **kwargs)
-
-    def kick_member(self, *args, **kwargs):
-        """Shortcut for::
-
-                bot.kick_chat_member(update.message.chat.id, *args, **kwargs)
-
-        Returns:
-            :obj:`bool`: If the action was sent succesfully.
-
-        Note:
-            This method will only work if the `All Members Are Admins` setting is off in the
-            target group. Otherwise members may only be removed by the group's creator or by the
-            member that added them.
-
-        """
-        return self.bot.kick_chat_member(self.id, *args, **kwargs)
-
-    def unban_member(self, *args, **kwargs):
-        """Shortcut for::
-
-                bot.unban_chat_member(update.message.chat.id, *args, **kwargs)
-
-        Returns:
-            :obj:`bool`: If the action was sent successfully.
-
-        """
-        return self.bot.unban_chat_member(self.id, *args, **kwargs)
+#!/usr/bin/env python
+# pylint: disable=C0103,W0622
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Chat."""
+
+from telegram import TelegramObject, ChatPhoto
+
+
+class Chat(TelegramObject):
+    """This object represents a chat.
+
+    Attributes:
+        id (:obj:`int`): Unique identifier for this chat.
+        type (:obj:`str`): Type of chat.
+        title (:obj:`str`): Optional. Title, for supergroups, channels and group chats.
+        username (:obj:`str`): Optional. Username.
+        first_name (:obj:`str`): Optional. First name of the other party in a private chat.
+        last_name (:obj:`str`): Optional. Last name of the other party in a private chat.
+        all_members_are_administrators (:obj:`bool`): Optional.
+        photo (:class:`telegram.ChatPhoto`): Optional. Chat photo.
+        description (:obj:`str`): Optional. Description, for supergroups and channel chats.
+        invite_link (:obj:`str`): Optional. Chat invite link, for supergroups and channel chats.
+        pinned_message (:class:`telegram.Message`): Optional. Pinned message, for supergroups.
+            Returned only in get_chat.
+        sticker_set_name (:obj:`str`): Optional. For supergroups, name of Group sticker set.
+        can_set_sticker_set (:obj:`bool`): Optional. ``True``, if the bot can change group the
+            sticker set.
+
+    Args:
+        id (:obj:`int`): Unique identifier for this chat. This number may be greater than 32 bits
+            and some programming languages may have difficulty/silent defects in interpreting it.
+            But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float
+            type are safe for storing this identifier.
+        type (:obj:`str`): Type of chat, can be either 'private', 'group', 'supergroup' or
+            'channel'.
+        title (:obj:`str`, optional): Title, for supergroups, channels and group chats.
+        username(:obj:`str`, optional): Username, for private chats, supergroups and channels if
+            available.
+        first_name(:obj:`str`, optional): First name of the other party in a private chat.
+        last_name(:obj:`str`, optional): Last name of the other party in a private chat.
+        all_members_are_administrators (:obj:`bool`, optional): True if a group has `All Members
+            Are Admins` enabled.
+        photo (:class:`telegram.ChatPhoto`, optional): Chat photo. Returned only in getChat.
+        description (:obj:`str`, optional): Description, for supergroups and channel chats.
+            Returned only in get_chat.
+        invite_link (:obj:`str`, optional): Chat invite link, for supergroups and channel chats.
+            Returned only in get_chat.
+        pinned_message (:class:`telegram.Message`, optional): Pinned message, for supergroups.
+            Returned only in get_chat.
+        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
+        sticker_set_name (:obj:`str`, optional): For supergroups, name of Group sticker set.
+            Returned only in get_chat.
+        can_set_sticker_set (:obj:`bool`, optional): ``True``, if the bot can change group the
+            sticker set. Returned only in get_chat.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    PRIVATE = 'private'
+    """:obj:`str`: 'private'"""
+    GROUP = 'group'
+    """:obj:`str`: 'group'"""
+    SUPERGROUP = 'supergroup'
+    """:obj:`str`: 'supergroup'"""
+    CHANNEL = 'channel'
+    """:obj:`str`: 'channel'"""
+
+    def __init__(self,
+                 id,
+                 type,
+                 title=None,
+                 username=None,
+                 first_name=None,
+                 last_name=None,
+                 all_members_are_administrators=None,
+                 bot=None,
+                 photo=None,
+                 description=None,
+                 invite_link=None,
+                 pinned_message=None,
+                 sticker_set_name=None,
+                 can_set_sticker_set=None,
+                 **kwargs):
+        # Required
+        self.id = int(id)
+        self.type = type
+        # Optionals
+        self.title = title
+        self.username = username
+        self.first_name = first_name
+        self.last_name = last_name
+        self.all_members_are_administrators = all_members_are_administrators
+        self.photo = photo
+        self.description = description
+        self.invite_link = invite_link
+        self.pinned_message = pinned_message
+        self.sticker_set_name = sticker_set_name
+        self.can_set_sticker_set = can_set_sticker_set
+
+        self.bot = bot
+        self._id_attrs = (self.id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data['photo'] = ChatPhoto.de_json(data.get('photo'), bot)
+        from telegram import Message
+        data['pinned_message'] = Message.de_json(data.get('pinned_message'), bot)
+
+        return cls(bot=bot, **data)
+
+    def send_action(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_chat_action(update.message.chat.id, *args, **kwargs)
+
+        Returns:
+            :obj:`bool`: If the action was sent successfully.
+
+        """
+
+        return self.bot.send_chat_action(self.id, *args, **kwargs)
+
+    def leave(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.leave_chat(update.message.chat.id, *args, **kwargs)
+
+        Returns:
+            :obj:`bool` If the action was sent successfully.
+
+        """
+        return self.bot.leave_chat(self.id, *args, **kwargs)
+
+    def get_administrators(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.get_chat_administrators(update.message.chat.id, *args, **kwargs)
+
+        Returns:
+            List[:class:`telegram.ChatMember`]: A list of administrators in a chat. An Array of
+            :class:`telegram.ChatMember` objects that contains information about all
+            chat administrators except other bots. If the chat is a group or a supergroup
+            and no administrators were appointed, only the creator will be returned
+
+        """
+        return self.bot.get_chat_administrators(self.id, *args, **kwargs)
+
+    def get_members_count(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.get_chat_members_count(update.message.chat.id, *args, **kwargs)
+
+        Returns:
+            :obj:`int`
+
+        """
+        return self.bot.get_chat_members_count(self.id, *args, **kwargs)
+
+    def get_member(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.get_chat_member(update.message.chat.id, *args, **kwargs)
+
+        Returns:
+            :class:`telegram.ChatMember`
+
+        """
+        return self.bot.get_chat_member(self.id, *args, **kwargs)
+
+    def kick_member(self, *args, **kwargs):
+        """Shortcut for::
+
+                bot.kick_chat_member(update.message.chat.id, *args, **kwargs)
+
+        Returns:
+            :obj:`bool`: If the action was sent succesfully.
+
+        Note:
+            This method will only work if the `All Members Are Admins` setting is off in the
+            target group. Otherwise members may only be removed by the group's creator or by the
+            member that added them.
+
+        """
+        return self.bot.kick_chat_member(self.id, *args, **kwargs)
+
+    def unban_member(self, *args, **kwargs):
+        """Shortcut for::
+
+                bot.unban_chat_member(update.message.chat.id, *args, **kwargs)
+
+        Returns:
+            :obj:`bool`: If the action was sent successfully.
+
+        """
+        return self.bot.unban_chat_member(self.id, *args, **kwargs)
```

### Comparing `python-telegram-bot-8.1.1/telegram/chataction.py` & `python-telegram-bot-9.0.0/telegram/chataction.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-#!/usr/bin/env python
-# pylint: disable=R0903
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ChatAction."""
-
-
-class ChatAction(object):
-    """Helper class to provide constants for different chatactions."""
-
-    FIND_LOCATION = 'find_location'
-    """:obj:`str`: 'find_location'"""
-    RECORD_AUDIO = 'record_audio'
-    """:obj:`str`: 'record_audio'"""
-    RECORD_VIDEO = 'record_video'
-    """:obj:`str`: 'record_video'"""
-    RECORD_VIDEO_NOTE = 'record_video_note'
-    """:obj:`str`: 'record_video_note'"""
-    TYPING = 'typing'
-    """:obj:`str`: 'typing'"""
-    UPLOAD_AUDIO = 'upload_audio'
-    """:obj:`str`: 'upload_audio'"""
-    UPLOAD_DOCUMENT = 'upload_document'
-    """:obj:`str`: 'upload_document'"""
-    UPLOAD_PHOTO = 'upload_photo'
-    """:obj:`str`: 'upload_photo'"""
-    UPLOAD_VIDEO = 'upload_video'
-    """:obj:`str`: 'upload_video'"""
-    UPLOAD_VIDEO_NOTE = 'upload_video_note'
-    """:obj:`str`: 'upload_video_note'"""
+#!/usr/bin/env python
+# pylint: disable=R0903
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ChatAction."""
+
+
+class ChatAction(object):
+    """Helper class to provide constants for different chatactions."""
+
+    FIND_LOCATION = 'find_location'
+    """:obj:`str`: 'find_location'"""
+    RECORD_AUDIO = 'record_audio'
+    """:obj:`str`: 'record_audio'"""
+    RECORD_VIDEO = 'record_video'
+    """:obj:`str`: 'record_video'"""
+    RECORD_VIDEO_NOTE = 'record_video_note'
+    """:obj:`str`: 'record_video_note'"""
+    TYPING = 'typing'
+    """:obj:`str`: 'typing'"""
+    UPLOAD_AUDIO = 'upload_audio'
+    """:obj:`str`: 'upload_audio'"""
+    UPLOAD_DOCUMENT = 'upload_document'
+    """:obj:`str`: 'upload_document'"""
+    UPLOAD_PHOTO = 'upload_photo'
+    """:obj:`str`: 'upload_photo'"""
+    UPLOAD_VIDEO = 'upload_video'
+    """:obj:`str`: 'upload_video'"""
+    UPLOAD_VIDEO_NOTE = 'upload_video_note'
+    """:obj:`str`: 'upload_video_note'"""
```

### Comparing `python-telegram-bot-8.1.1/telegram/chatmember.py` & `python-telegram-bot-9.0.0/telegram/chatmember.py`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,152 +1,152 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ChatMember."""
-
-from telegram import User, TelegramObject
-from telegram.utils.helpers import to_timestamp, from_timestamp
-
-
-class ChatMember(TelegramObject):
-    """This object contains information about one member of the chat.
-
-    Attributes:
-        user (:class:`telegram.User`): Information about the user.
-        status (:obj:`str`): The member's status in the chat.
-        until_date (:class:`datetime.datetime`): Optional. Date when restrictions will be lifted
-            for this user.
-        can_be_edited (:obj:`bool`): Optional. If the bot is allowed to edit administrator
-            privileges of that user.
-        can_change_info (:obj:`bool`): Optional. If the administrator can change the chat title,
-            photo and other settings.
-        can_post_messages (:obj:`bool`): Optional. If the administrator can post in the channel.
-        can_edit_messages (:obj:`bool`): Optional. If the administrator can edit messages of other
-            users.
-        can_delete_messages (:obj:`bool`): Optional. If the administrator can delete messages of
-            other users.
-        can_invite_users (:obj:`bool`): Optional. If the administrator can invite new users to the
-            chat.
-        can_restrict_members (:obj:`bool`): Optional. If the administrator can restrict, ban or
-            unban chat members.
-        can_pin_messages (:obj:`bool`): Optional. If the administrator can pin messages.
-        can_promote_members (:obj:`bool`): Optional. If the administrator can add new
-            administrators.
-        can_send_messages (:obj:`bool`): Optional. If the user can send text messages, contacts,
-            locations and venues.
-        can_send_media_messages (:obj:`bool`): Optional. If the user can send media messages,
-            implies can_send_messages.
-        can_send_other_messages (:obj:`bool`): Optional. If the user can send animations, games,
-            stickers and use inline bots, implies can_send_media_messages.
-        can_add_web_page_previews (:obj:`bool`): Optional. If user may add web page previews to his
-            messages, implies can_send_media_messages
-
-    Args:
-        user (:class:`telegram.User`): Information about the user.
-        status (:obj:`str`): The member's status in the chat. Can be 'creator', 'administrator',
-            'member', 'restricted', 'left' or 'kicked'.
-        until_date (:class:`datetime.datetime`, optional): Restricted and kicked only. Date when
-            restrictions will be lifted for this user.
-        can_be_edited (:obj:`bool`, optional): Administrators only. True, if the bot is allowed to
-            edit administrator privileges of that user.
-        can_change_info (:obj:`bool`, optional): Administrators only. True, if the administrator
-            can change the chat title, photo and other settings.
-        can_post_messages (:obj:`bool`, optional): Administrators only. True, if the administrator
-            can post in the channel, channels only.
-        can_edit_messages (:obj:`bool`, optional): Administrators only. True, if the administrator
-            can edit messages of other users, channels only.
-        can_delete_messages (:obj:`bool`, optional): Administrators only. True, if the
-            administrator can delete messages of other user.
-        can_invite_users (:obj:`bool`, optional): Administrators only. True, if the administrator
-            can invite new users to the chat.
-        can_restrict_members (:obj:`bool`, optional): Administrators only. True, if the
-            administrator can restrict, ban or unban chat members.
-        can_pin_messages (:obj:`bool`, optional): Administrators only. True, if the administrator
-            can pin messages, supergroups only.
-        can_promote_members (:obj:`bool`, optional): Administrators only. True, if the
-            administrator can add new administrators with a subset of his own privileges or demote
-            administrators that he has promoted, directly or indirectly (promoted by administrators
-            that were appointed by the user).
-        can_send_messages (:obj:`bool`, optional): Restricted only. True, if the user can send text
-            messages, contacts, locations and venues.
-        can_send_media_messages (:obj:`bool`, optional): Restricted only. True, if the user can
-            send audios, documents, photos, videos, video notes and voice notes, implies
-            can_send_messages.
-        can_send_other_messages (:obj:`bool`, optional): Restricted only. True, if the user can
-            send animations, games, stickers and use inline bots, implies can_send_media_messages.
-        can_add_web_page_previews (:obj:`bool`, optional): Restricted only. True, if user may add
-            web page previews to his messages, implies can_send_media_messages.
-
-    """
-    ADMINISTRATOR = 'administrator'
-    """:obj:`str`: 'administrator'"""
-    CREATOR = 'creator'
-    """:obj:`str`: 'creator'"""
-    KICKED = 'kicked'
-    """:obj:`str`: 'kicked'"""
-    LEFT = 'left'
-    """:obj:`str`: 'left'"""
-    MEMBER = 'member'
-    """:obj:`str`: 'member'"""
-    RESTRICTED = 'restricted'
-    """:obj:`str`: 'restricted'"""
-
-    def __init__(self, user, status, until_date=None, can_be_edited=None,
-                 can_change_info=None, can_post_messages=None, can_edit_messages=None,
-                 can_delete_messages=None, can_invite_users=None,
-                 can_restrict_members=None, can_pin_messages=None,
-                 can_promote_members=None, can_send_messages=None,
-                 can_send_media_messages=None, can_send_other_messages=None,
-                 can_add_web_page_previews=None, **kwargs):
-        # Required
-        self.user = user
-        self.status = status
-        self.until_date = until_date
-        self.can_be_edited = can_be_edited
-        self.can_change_info = can_change_info
-        self.can_post_messages = can_post_messages
-        self.can_edit_messages = can_edit_messages
-        self.can_delete_messages = can_delete_messages
-        self.can_invite_users = can_invite_users
-        self.can_restrict_members = can_restrict_members
-        self.can_pin_messages = can_pin_messages
-        self.can_promote_members = can_promote_members
-        self.can_send_messages = can_send_messages
-        self.can_send_media_messages = can_send_media_messages
-        self.can_send_other_messages = can_send_other_messages
-        self.can_add_web_page_previews = can_add_web_page_previews
-
-        self._id_attrs = (self.user, self.status)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(ChatMember, cls).de_json(data, bot)
-
-        data['user'] = User.de_json(data.get('user'), bot)
-        data['until_date'] = from_timestamp(data.get('until_date', None))
-
-        return cls(**data)
-
-    def to_dict(self):
-        data = super(ChatMember, self).to_dict()
-
-        data['until_date'] = to_timestamp(self.until_date)
-
-        return data
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ChatMember."""
+
+from telegram import User, TelegramObject
+from telegram.utils.helpers import to_timestamp, from_timestamp
+
+
+class ChatMember(TelegramObject):
+    """This object contains information about one member of the chat.
+
+    Attributes:
+        user (:class:`telegram.User`): Information about the user.
+        status (:obj:`str`): The member's status in the chat.
+        until_date (:class:`datetime.datetime`): Optional. Date when restrictions will be lifted
+            for this user.
+        can_be_edited (:obj:`bool`): Optional. If the bot is allowed to edit administrator
+            privileges of that user.
+        can_change_info (:obj:`bool`): Optional. If the administrator can change the chat title,
+            photo and other settings.
+        can_post_messages (:obj:`bool`): Optional. If the administrator can post in the channel.
+        can_edit_messages (:obj:`bool`): Optional. If the administrator can edit messages of other
+            users.
+        can_delete_messages (:obj:`bool`): Optional. If the administrator can delete messages of
+            other users.
+        can_invite_users (:obj:`bool`): Optional. If the administrator can invite new users to the
+            chat.
+        can_restrict_members (:obj:`bool`): Optional. If the administrator can restrict, ban or
+            unban chat members.
+        can_pin_messages (:obj:`bool`): Optional. If the administrator can pin messages.
+        can_promote_members (:obj:`bool`): Optional. If the administrator can add new
+            administrators.
+        can_send_messages (:obj:`bool`): Optional. If the user can send text messages, contacts,
+            locations and venues.
+        can_send_media_messages (:obj:`bool`): Optional. If the user can send media messages,
+            implies can_send_messages.
+        can_send_other_messages (:obj:`bool`): Optional. If the user can send animations, games,
+            stickers and use inline bots, implies can_send_media_messages.
+        can_add_web_page_previews (:obj:`bool`): Optional. If user may add web page previews to his
+            messages, implies can_send_media_messages
+
+    Args:
+        user (:class:`telegram.User`): Information about the user.
+        status (:obj:`str`): The member's status in the chat. Can be 'creator', 'administrator',
+            'member', 'restricted', 'left' or 'kicked'.
+        until_date (:class:`datetime.datetime`, optional): Restricted and kicked only. Date when
+            restrictions will be lifted for this user.
+        can_be_edited (:obj:`bool`, optional): Administrators only. True, if the bot is allowed to
+            edit administrator privileges of that user.
+        can_change_info (:obj:`bool`, optional): Administrators only. True, if the administrator
+            can change the chat title, photo and other settings.
+        can_post_messages (:obj:`bool`, optional): Administrators only. True, if the administrator
+            can post in the channel, channels only.
+        can_edit_messages (:obj:`bool`, optional): Administrators only. True, if the administrator
+            can edit messages of other users, channels only.
+        can_delete_messages (:obj:`bool`, optional): Administrators only. True, if the
+            administrator can delete messages of other user.
+        can_invite_users (:obj:`bool`, optional): Administrators only. True, if the administrator
+            can invite new users to the chat.
+        can_restrict_members (:obj:`bool`, optional): Administrators only. True, if the
+            administrator can restrict, ban or unban chat members.
+        can_pin_messages (:obj:`bool`, optional): Administrators only. True, if the administrator
+            can pin messages, supergroups only.
+        can_promote_members (:obj:`bool`, optional): Administrators only. True, if the
+            administrator can add new administrators with a subset of his own privileges or demote
+            administrators that he has promoted, directly or indirectly (promoted by administrators
+            that were appointed by the user).
+        can_send_messages (:obj:`bool`, optional): Restricted only. True, if the user can send text
+            messages, contacts, locations and venues.
+        can_send_media_messages (:obj:`bool`, optional): Restricted only. True, if the user can
+            send audios, documents, photos, videos, video notes and voice notes, implies
+            can_send_messages.
+        can_send_other_messages (:obj:`bool`, optional): Restricted only. True, if the user can
+            send animations, games, stickers and use inline bots, implies can_send_media_messages.
+        can_add_web_page_previews (:obj:`bool`, optional): Restricted only. True, if user may add
+            web page previews to his messages, implies can_send_media_messages.
+
+    """
+    ADMINISTRATOR = 'administrator'
+    """:obj:`str`: 'administrator'"""
+    CREATOR = 'creator'
+    """:obj:`str`: 'creator'"""
+    KICKED = 'kicked'
+    """:obj:`str`: 'kicked'"""
+    LEFT = 'left'
+    """:obj:`str`: 'left'"""
+    MEMBER = 'member'
+    """:obj:`str`: 'member'"""
+    RESTRICTED = 'restricted'
+    """:obj:`str`: 'restricted'"""
+
+    def __init__(self, user, status, until_date=None, can_be_edited=None,
+                 can_change_info=None, can_post_messages=None, can_edit_messages=None,
+                 can_delete_messages=None, can_invite_users=None,
+                 can_restrict_members=None, can_pin_messages=None,
+                 can_promote_members=None, can_send_messages=None,
+                 can_send_media_messages=None, can_send_other_messages=None,
+                 can_add_web_page_previews=None, **kwargs):
+        # Required
+        self.user = user
+        self.status = status
+        self.until_date = until_date
+        self.can_be_edited = can_be_edited
+        self.can_change_info = can_change_info
+        self.can_post_messages = can_post_messages
+        self.can_edit_messages = can_edit_messages
+        self.can_delete_messages = can_delete_messages
+        self.can_invite_users = can_invite_users
+        self.can_restrict_members = can_restrict_members
+        self.can_pin_messages = can_pin_messages
+        self.can_promote_members = can_promote_members
+        self.can_send_messages = can_send_messages
+        self.can_send_media_messages = can_send_media_messages
+        self.can_send_other_messages = can_send_other_messages
+        self.can_add_web_page_previews = can_add_web_page_previews
+
+        self._id_attrs = (self.user, self.status)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(ChatMember, cls).de_json(data, bot)
+
+        data['user'] = User.de_json(data.get('user'), bot)
+        data['until_date'] = from_timestamp(data.get('until_date', None))
+
+        return cls(**data)
+
+    def to_dict(self):
+        data = super(ChatMember, self).to_dict()
+
+        data['until_date'] = to_timestamp(self.until_date)
+
+        return data
```

### Comparing `python-telegram-bot-8.1.1/telegram/choseninlineresult.py` & `python-telegram-bot-9.0.0/telegram/choseninlineresult.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,89 +1,89 @@
-#!/usr/bin/env python
-# pylint: disable=R0902,R0912,R0913
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ChosenInlineResult."""
-
-from telegram import TelegramObject, User, Location
-
-
-class ChosenInlineResult(TelegramObject):
-    """
-    Represents a result of an inline query that was chosen by the user and sent to their chat
-    partner.
-
-    Note:
-        In Python `from` is a reserved word, use `from_user` instead.
-
-    Attributes:
-        result_id (:obj:`str`): The unique identifier for the result that was chosen.
-        from_user (:class:`telegram.User`): The user that chose the result.
-        location (:class:`telegram.Location`): Optional. Sender location.
-        inline_message_id (:obj:`str`): Optional. Identifier of the sent inline message.
-        query (:obj:`str`): The query that was used to obtain the result.
-
-    Args:
-        result_id (:obj:`str`): The unique identifier for the result that was chosen.
-        from_user (:class:`telegram.User`): The user that chose the result.
-        location (:class:`telegram.Location`, optional): Sender location, only for bots that
-            require user location.
-        inline_message_id (:obj:`str`, optional): Identifier of the sent inline message. Available
-            only if there is an inline keyboard attached to the message. Will be also received in
-            callback queries and can be used to edit the message.
-        query (:obj:`str`): The query that was used to obtain the result.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 result_id,
-                 from_user,
-                 query,
-                 location=None,
-                 inline_message_id=None,
-                 **kwargs):
-        # Required
-        self.result_id = result_id
-        self.from_user = from_user
-        self.query = query
-        # Optionals
-        self.location = location
-        self.inline_message_id = inline_message_id
-
-        self._id_attrs = (self.result_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(ChosenInlineResult, cls).de_json(data, bot)
-        # Required
-        data['from_user'] = User.de_json(data.pop('from'), bot)
-        # Optionals
-        data['location'] = Location.de_json(data.get('location'), bot)
-
-        return cls(**data)
-
-    def to_dict(self):
-        data = super(ChosenInlineResult, self).to_dict()
-
-        # Required
-        data['from'] = data.pop('from_user', None)
-
-        return data
+#!/usr/bin/env python
+# pylint: disable=R0902,R0912,R0913
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ChosenInlineResult."""
+
+from telegram import TelegramObject, User, Location
+
+
+class ChosenInlineResult(TelegramObject):
+    """
+    Represents a result of an inline query that was chosen by the user and sent to their chat
+    partner.
+
+    Note:
+        In Python `from` is a reserved word, use `from_user` instead.
+
+    Attributes:
+        result_id (:obj:`str`): The unique identifier for the result that was chosen.
+        from_user (:class:`telegram.User`): The user that chose the result.
+        location (:class:`telegram.Location`): Optional. Sender location.
+        inline_message_id (:obj:`str`): Optional. Identifier of the sent inline message.
+        query (:obj:`str`): The query that was used to obtain the result.
+
+    Args:
+        result_id (:obj:`str`): The unique identifier for the result that was chosen.
+        from_user (:class:`telegram.User`): The user that chose the result.
+        location (:class:`telegram.Location`, optional): Sender location, only for bots that
+            require user location.
+        inline_message_id (:obj:`str`, optional): Identifier of the sent inline message. Available
+            only if there is an inline keyboard attached to the message. Will be also received in
+            callback queries and can be used to edit the message.
+        query (:obj:`str`): The query that was used to obtain the result.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 result_id,
+                 from_user,
+                 query,
+                 location=None,
+                 inline_message_id=None,
+                 **kwargs):
+        # Required
+        self.result_id = result_id
+        self.from_user = from_user
+        self.query = query
+        # Optionals
+        self.location = location
+        self.inline_message_id = inline_message_id
+
+        self._id_attrs = (self.result_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(ChosenInlineResult, cls).de_json(data, bot)
+        # Required
+        data['from_user'] = User.de_json(data.pop('from'), bot)
+        # Optionals
+        data['location'] = Location.de_json(data.get('location'), bot)
+
+        return cls(**data)
+
+    def to_dict(self):
+        data = super(ChosenInlineResult, self).to_dict()
+
+        # Required
+        data['from'] = data.pop('from_user', None)
+
+        return data
```

### Comparing `python-telegram-bot-8.1.1/telegram/constants.py` & `python-telegram-bot-9.0.0/telegram/constants.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-# python-telegram-bot - a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# by the python-telegram-bot contributors <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""Constants in the Telegram network.
-
-The following constants were extracted from the
-`Telegram Bots FAQ <https://core.telegram.org/bots/faq>`_.
-
-Attributes:
-    MAX_MESSAGE_LENGTH (:obj:`int`): 4096
-    MAX_CAPTION_LENGTH (:obj:`int`): 200
-    SUPPORTED_WEBHOOK_PORTS (List[:obj:`int`]): [443, 80, 88, 8443]
-    MAX_FILESIZE_DOWNLOAD (:obj:`int`): In bytes (20MB)
-    MAX_FILESIZE_UPLOAD (:obj:`int`): In bytes (50MB)
-    MAX_MESSAGES_PER_SECOND_PER_CHAT (:obj:`int`): `1`. Telegram may allow short bursts that go
-        over this limit, but eventually you'll begin receiving 429 errors.
-    MAX_MESSAGES_PER_SECOND (:obj:`int`): 30
-    MAX_MESSAGES_PER_MINUTE_PER_GROUP (:obj:`int`): 20
-    MAX_INLINE_QUERY_RESULTS (:obj:`int`): 50
-
-The following constant have been found by experimentation:
-
-Attributes:
-    MAX_MESSAGE_ENTITIES (:obj:`int`): 100 (Beyond this cap telegram will simply ignore further
-        formatting styles)
-
-"""
-
-MAX_MESSAGE_LENGTH = 4096
-MAX_CAPTION_LENGTH = 200
-
-# constants above this line are tested
-
-SUPPORTED_WEBHOOK_PORTS = [443, 80, 88, 8443]
-MAX_FILESIZE_DOWNLOAD = int(20E6)  # (20MB)
-MAX_FILESIZE_UPLOAD = int(50E6)  # (50MB)
-MAX_MESSAGES_PER_SECOND_PER_CHAT = 1
-MAX_MESSAGES_PER_SECOND = 30
-MAX_MESSAGES_PER_MINUTE_PER_GROUP = 20
-MAX_MESSAGE_ENTITIES = 100
-MAX_INLINE_QUERY_RESULTS = 50
+# python-telegram-bot - a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# by the python-telegram-bot contributors <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""Constants in the Telegram network.
+
+The following constants were extracted from the
+`Telegram Bots FAQ <https://core.telegram.org/bots/faq>`_.
+
+Attributes:
+    MAX_MESSAGE_LENGTH (:obj:`int`): 4096
+    MAX_CAPTION_LENGTH (:obj:`int`): 200
+    SUPPORTED_WEBHOOK_PORTS (List[:obj:`int`]): [443, 80, 88, 8443]
+    MAX_FILESIZE_DOWNLOAD (:obj:`int`): In bytes (20MB)
+    MAX_FILESIZE_UPLOAD (:obj:`int`): In bytes (50MB)
+    MAX_MESSAGES_PER_SECOND_PER_CHAT (:obj:`int`): `1`. Telegram may allow short bursts that go
+        over this limit, but eventually you'll begin receiving 429 errors.
+    MAX_MESSAGES_PER_SECOND (:obj:`int`): 30
+    MAX_MESSAGES_PER_MINUTE_PER_GROUP (:obj:`int`): 20
+    MAX_INLINE_QUERY_RESULTS (:obj:`int`): 50
+
+The following constant have been found by experimentation:
+
+Attributes:
+    MAX_MESSAGE_ENTITIES (:obj:`int`): 100 (Beyond this cap telegram will simply ignore further
+        formatting styles)
+
+"""
+
+MAX_MESSAGE_LENGTH = 4096
+MAX_CAPTION_LENGTH = 200
+
+# constants above this line are tested
+
+SUPPORTED_WEBHOOK_PORTS = [443, 80, 88, 8443]
+MAX_FILESIZE_DOWNLOAD = int(20E6)  # (20MB)
+MAX_FILESIZE_UPLOAD = int(50E6)  # (50MB)
+MAX_MESSAGES_PER_SECOND_PER_CHAT = 1
+MAX_MESSAGES_PER_SECOND = 30
+MAX_MESSAGES_PER_MINUTE_PER_GROUP = 20
+MAX_MESSAGE_ENTITIES = 100
+MAX_INLINE_QUERY_RESULTS = 50
```

### Comparing `python-telegram-bot-8.1.1/telegram/error.py` & `python-telegram-bot-9.0.0/telegram/error.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,102 +1,102 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents Telegram errors."""
-
-
-def _lstrip_str(in_s, lstr):
-    """
-    Args:
-        in_s (:obj:`str`): in string
-        lstr (:obj:`str`): substr to strip from left side
-
-    Returns:
-        str:
-
-    """
-    if in_s.startswith(lstr):
-        res = in_s[len(lstr):]
-    else:
-        res = in_s
-    return res
-
-
-class TelegramError(Exception):
-    def __init__(self, message):
-        super(TelegramError, self).__init__()
-
-        msg = _lstrip_str(message, 'Error: ')
-        msg = _lstrip_str(msg, '[Error]: ')
-        msg = _lstrip_str(msg, 'Bad Request: ')
-        if msg != message:
-            # api_error - capitalize the msg...
-            msg = msg.capitalize()
-        self.message = msg
-
-    def __str__(self):
-        return '%s' % (self.message)
-
-
-class Unauthorized(TelegramError):
-    pass
-
-
-class InvalidToken(TelegramError):
-
-    def __init__(self):
-        super(InvalidToken, self).__init__('Invalid token')
-
-
-class NetworkError(TelegramError):
-    pass
-
-
-class BadRequest(NetworkError):
-    pass
-
-
-class TimedOut(NetworkError):
-
-    def __init__(self):
-        super(TimedOut, self).__init__('Timed out')
-
-
-class ChatMigrated(TelegramError):
-    """
-    Args:
-        new_chat_id (:obj:`int`):
-
-    """
-
-    def __init__(self, new_chat_id):
-        super(ChatMigrated,
-              self).__init__('Group migrated to supergroup. New chat id: {}'.format(new_chat_id))
-        self.new_chat_id = new_chat_id
-
-
-class RetryAfter(TelegramError):
-    """
-    Args:
-        retry_after (:obj:`int`):
-
-    """
-
-    def __init__(self, retry_after):
-        super(RetryAfter,
-              self).__init__('Flood control exceeded. Retry in {} seconds'.format(retry_after))
-        self.retry_after = float(retry_after)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents Telegram errors."""
+
+
+def _lstrip_str(in_s, lstr):
+    """
+    Args:
+        in_s (:obj:`str`): in string
+        lstr (:obj:`str`): substr to strip from left side
+
+    Returns:
+        str:
+
+    """
+    if in_s.startswith(lstr):
+        res = in_s[len(lstr):]
+    else:
+        res = in_s
+    return res
+
+
+class TelegramError(Exception):
+    def __init__(self, message):
+        super(TelegramError, self).__init__()
+
+        msg = _lstrip_str(message, 'Error: ')
+        msg = _lstrip_str(msg, '[Error]: ')
+        msg = _lstrip_str(msg, 'Bad Request: ')
+        if msg != message:
+            # api_error - capitalize the msg...
+            msg = msg.capitalize()
+        self.message = msg
+
+    def __str__(self):
+        return '%s' % (self.message)
+
+
+class Unauthorized(TelegramError):
+    pass
+
+
+class InvalidToken(TelegramError):
+
+    def __init__(self):
+        super(InvalidToken, self).__init__('Invalid token')
+
+
+class NetworkError(TelegramError):
+    pass
+
+
+class BadRequest(NetworkError):
+    pass
+
+
+class TimedOut(NetworkError):
+
+    def __init__(self):
+        super(TimedOut, self).__init__('Timed out')
+
+
+class ChatMigrated(TelegramError):
+    """
+    Args:
+        new_chat_id (:obj:`int`):
+
+    """
+
+    def __init__(self, new_chat_id):
+        super(ChatMigrated,
+              self).__init__('Group migrated to supergroup. New chat id: {}'.format(new_chat_id))
+        self.new_chat_id = new_chat_id
+
+
+class RetryAfter(TelegramError):
+    """
+    Args:
+        retry_after (:obj:`int`):
+
+    """
+
+    def __init__(self, retry_after):
+        super(RetryAfter,
+              self).__init__('Flood control exceeded. Retry in {} seconds'.format(retry_after))
+        self.retry_after = float(retry_after)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/callbackqueryhandler.py` & `python-telegram-bot-9.0.0/telegram/ext/inlinequeryhandler.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,143 +1,149 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the CallbackQueryHandler class."""
-
-import re
-
-from future.utils import string_types
-
-from telegram import Update
-from .handler import Handler
-
-
-class CallbackQueryHandler(Handler):
-    """Handler class to handle Telegram callback queries. Optionally based on a regex.
-
-    Read the documentation of the ``re`` module for more information.
-
-    Attributes:
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pattern (:obj:`str` | `Pattern`): Optional. Regex pattern to test
-            :attr:`telegram.CallbackQuery.data` against.
-        pass_groups (:obj:`bool`): Optional. Determines whether ``groups`` will be passed to the
-            callback function.
-        pass_groupdict (:obj:`bool`): Optional. Determines whether ``groupdict``. will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pattern (:obj:`str` | `Pattern`, optional): Regex pattern. If not ``None``, ``re.match``
-            is used on :attr:`telegram.CallbackQuery.data` to determine if an update should be
-            handled by this handler.
-        pass_groups (:obj:`bool`, optional): If the callback should be passed the result of
-            ``re.match(pattern, data).groups()`` as a keyword argument called ``groups``.
-            Default is ``False``
-        pass_groupdict (:obj:`bool`, optional): If the callback should be passed the result of
-            ``re.match(pattern, data).groupdict()`` as a keyword argument called ``groupdict``.
-            Default is ``False``
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-
-    """
-
-    def __init__(self,
-                 callback,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pattern=None,
-                 pass_groups=False,
-                 pass_groupdict=False,
-                 pass_user_data=False,
-                 pass_chat_data=False):
-        super(CallbackQueryHandler, self).__init__(
-            callback,
-            pass_update_queue=pass_update_queue,
-            pass_job_queue=pass_job_queue,
-            pass_user_data=pass_user_data,
-            pass_chat_data=pass_chat_data)
-
-        if isinstance(pattern, string_types):
-            pattern = re.compile(pattern)
-
-        self.pattern = pattern
-        self.pass_groups = pass_groups
-        self.pass_groupdict = pass_groupdict
-
-    def check_update(self, update):
-        """Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        if isinstance(update, Update) and update.callback_query:
-            if self.pattern:
-                if update.callback_query.data:
-                    match = re.match(self.pattern, update.callback_query.data)
-                    return bool(match)
-            else:
-                return True
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-
-        """
-        optional_args = self.collect_optional_args(dispatcher, update)
-        if self.pattern:
-            match = re.match(self.pattern, update.callback_query.data)
-
-            if self.pass_groups:
-                optional_args['groups'] = match.groups()
-            if self.pass_groupdict:
-                optional_args['groupdict'] = match.groupdict()
-
-        return self.callback(dispatcher.bot, update, **optional_args)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+""" This module contains the InlineQueryHandler class """
+import re
+
+from future.utils import string_types
+
+from telegram import Update
+from telegram.utils.deprecate import deprecate
+from .handler import Handler
+
+
+class InlineQueryHandler(Handler):
+    """
+    Handler class to handle Telegram inline queries. Optionally based on a regex. Read the
+    documentation of the ``re`` module for more information.
+
+    Attributes:
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pattern (:obj:`str` | :obj:`Pattern`): Optional. Regex pattern to test
+            :attr:`telegram.InlineQuery.query` against.
+        pass_groups (:obj:`bool`): Optional. Determines whether ``groups`` will be passed to the
+            callback function.
+        pass_groupdict (:obj:`bool`): Optional. Determines whether ``groupdict``. will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pattern (:obj:`str` | :obj:`Pattern`, optional): Regex pattern. If not ``None``,
+            ``re.match`` is used on :attr:`telegram.InlineQuery.query` to determine if an update
+            should be handled by this handler.
+        pass_groups (:obj:`bool`, optional): If the callback should be passed the result of
+            ``re.match(pattern, data).groups()`` as a keyword argument called ``groups``.
+            Default is ``False``
+        pass_groupdict (:obj:`bool`, optional): If the callback should be passed the result of
+            ``re.match(pattern, data).groupdict()`` as a keyword argument called ``groupdict``.
+            Default is ``False``
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+    """
+
+    def __init__(self,
+                 callback,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pattern=None,
+                 pass_groups=False,
+                 pass_groupdict=False,
+                 pass_user_data=False,
+                 pass_chat_data=False):
+        super(InlineQueryHandler, self).__init__(
+            callback,
+            pass_update_queue=pass_update_queue,
+            pass_job_queue=pass_job_queue,
+            pass_user_data=pass_user_data,
+            pass_chat_data=pass_chat_data)
+
+        if isinstance(pattern, string_types):
+            pattern = re.compile(pattern)
+
+        self.pattern = pattern
+        self.pass_groups = pass_groups
+        self.pass_groupdict = pass_groupdict
+
+    def check_update(self, update):
+        """
+        Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+        """
+
+        if isinstance(update, Update) and update.inline_query:
+            if self.pattern:
+                if update.inline_query.query:
+                    match = re.match(self.pattern, update.inline_query.query)
+                    return bool(match)
+            else:
+                return True
+
+    def handle_update(self, update, dispatcher):
+        """
+        Send the update to the :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+        """
+
+        optional_args = self.collect_optional_args(dispatcher, update)
+        if self.pattern:
+            match = re.match(self.pattern, update.inline_query.query)
+
+            if self.pass_groups:
+                optional_args['groups'] = match.groups()
+            if self.pass_groupdict:
+                optional_args['groupdict'] = match.groupdict()
+
+        return self.callback(dispatcher.bot, update, **optional_args)
+
+    # old non-PEP8 Handler methods
+    m = "telegram.InlineQueryHandler."
+    checkUpdate = deprecate(check_update, m + "checkUpdate", m + "check_update")
+    handleUpdate = deprecate(handle_update, m + "handleUpdate", m + "handle_update")
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/choseninlineresulthandler.py` & `python-telegram-bot-9.0.0/telegram/ext/choseninlineresulthandler.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the ChosenInlineResultHandler class."""
-
-from .handler import Handler
-from telegram import Update
-from telegram.utils.deprecate import deprecate
-
-
-class ChosenInlineResultHandler(Handler):
-    """Handler class to handle Telegram updates that contain a chosen inline result.
-
-    Attributes:
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-
-    """
-
-    def __init__(self,
-                 callback,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pass_user_data=False,
-                 pass_chat_data=False):
-        super(ChosenInlineResultHandler, self).__init__(
-            callback,
-            pass_update_queue=pass_update_queue,
-            pass_job_queue=pass_job_queue,
-            pass_user_data=pass_user_data,
-            pass_chat_data=pass_chat_data)
-
-    def check_update(self, update):
-        """Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        return isinstance(update, Update) and update.chosen_inline_result
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-
-        """
-        optional_args = self.collect_optional_args(dispatcher, update)
-
-        return self.callback(dispatcher.bot, update, **optional_args)
-
-    # old non-PEP8 Handler methods
-    m = "telegram.ChosenInlineResultHandler."
-    checkUpdate = deprecate(check_update, m + "checkUpdate", m + "check_update")
-    handleUpdate = deprecate(handle_update, m + "handleUpdate", m + "handle_update")
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the ChosenInlineResultHandler class."""
+
+from .handler import Handler
+from telegram import Update
+from telegram.utils.deprecate import deprecate
+
+
+class ChosenInlineResultHandler(Handler):
+    """Handler class to handle Telegram updates that contain a chosen inline result.
+
+    Attributes:
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+
+    """
+
+    def __init__(self,
+                 callback,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pass_user_data=False,
+                 pass_chat_data=False):
+        super(ChosenInlineResultHandler, self).__init__(
+            callback,
+            pass_update_queue=pass_update_queue,
+            pass_job_queue=pass_job_queue,
+            pass_user_data=pass_user_data,
+            pass_chat_data=pass_chat_data)
+
+    def check_update(self, update):
+        """Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        return isinstance(update, Update) and update.chosen_inline_result
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+
+        """
+        optional_args = self.collect_optional_args(dispatcher, update)
+
+        return self.callback(dispatcher.bot, update, **optional_args)
+
+    # old non-PEP8 Handler methods
+    m = "telegram.ChosenInlineResultHandler."
+    checkUpdate = deprecate(check_update, m + "checkUpdate", m + "check_update")
+    handleUpdate = deprecate(handle_update, m + "handleUpdate", m + "handle_update")
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/commandhandler.py` & `python-telegram-bot-9.0.0/telegram/ext/commandhandler.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,171 +1,171 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the CommandHandler class."""
-import warnings
-
-from future.utils import string_types
-
-from .handler import Handler
-from telegram import Update
-
-
-class CommandHandler(Handler):
-    """Handler class to handle Telegram commands.
-
-    Commands are Telegram messages that start with ``/``, optionally followed by an ``@`` and the
-    bot's name and/or some additional text.
-
-    Attributes:
-        command (:obj:`str` | List[:obj:`str`]): The command or list of commands this handler
-            should listen for.
-        callback (:obj:`callable`): The callback function for this handler.
-        filters (:class:`telegram.ext.BaseFilter`): Optional. Only allow updates with these
-            Filters.
-        allow_edited (:obj:`bool`): Optional. Determines Whether the handler should also accept
-            edited messages.
-        pass_args (:obj:`bool`): Optional. Determines whether the handler should be passed
-            ``args``.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        command (:obj:`str` | List[:obj:`str`]): The command or list of commands this handler
-            should listen for.
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        filters (:class:`telegram.ext.BaseFilter`, optional): A filter inheriting from
-            :class:`telegram.ext.filters.BaseFilter`. Standard filters can be found in
-            :class:`telegram.ext.filters.Filters`. Filters can be combined using bitwise
-            operators (& for and, | for or, ~ for not).
-        allow_edited (:obj:`bool`, optional): Determines whether the handler should also accept
-            edited messages. Default is ``False``.
-        pass_args (:obj:`bool`, optional): Determines whether the handler should be passed the
-            arguments passed to the command as a keyword argument called ``args``. It will contain
-            a list of strings, which is the text following the command split on single or
-            consecutive whitespace characters. Default is ``False``
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-
-    """
-
-    def __init__(self,
-                 command,
-                 callback,
-                 filters=None,
-                 allow_edited=False,
-                 pass_args=False,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pass_user_data=False,
-                 pass_chat_data=False):
-        super(CommandHandler, self).__init__(
-            callback,
-            pass_update_queue=pass_update_queue,
-            pass_job_queue=pass_job_queue,
-            pass_user_data=pass_user_data,
-            pass_chat_data=pass_chat_data)
-
-        if isinstance(command, string_types):
-            self.command = [command.lower()]
-        else:
-            self.command = [x.lower() for x in command]
-        self.filters = filters
-        self.allow_edited = allow_edited
-        self.pass_args = pass_args
-
-        # We put this up here instead of with the rest of checking code
-        # in check_update since we don't wanna spam a ton
-        if isinstance(self.filters, list):
-            warnings.warn('Using a list of filters in MessageHandler is getting '
-                          'deprecated, please use bitwise operators (& and |) '
-                          'instead. More info: https://git.io/vPTbc.')
-
-    def check_update(self, update):
-        """Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        if (isinstance(update, Update)
-                and (update.message or update.edited_message and self.allow_edited)):
-            message = update.message or update.edited_message
-
-            if message.text and message.text.startswith('/') and len(message.text) > 1:
-                command = message.text[1:].split(None, 1)[0].split('@')
-                command.append(
-                    message.bot.username)  # in case the command was send without a username
-
-                if self.filters is None:
-                    res = True
-                elif isinstance(self.filters, list):
-                    res = any(func(message) for func in self.filters)
-                else:
-                    res = self.filters(message)
-
-                return res and (command[0].lower() in self.command
-                                and command[1].lower() == message.bot.username.lower())
-            else:
-                return False
-
-        else:
-            return False
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-
-        """
-        optional_args = self.collect_optional_args(dispatcher, update)
-
-        message = update.message or update.edited_message
-
-        if self.pass_args:
-            optional_args['args'] = message.text.split()[1:]
-
-        return self.callback(dispatcher.bot, update, **optional_args)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the CommandHandler class."""
+import warnings
+
+from future.utils import string_types
+
+from .handler import Handler
+from telegram import Update
+
+
+class CommandHandler(Handler):
+    """Handler class to handle Telegram commands.
+
+    Commands are Telegram messages that start with ``/``, optionally followed by an ``@`` and the
+    bot's name and/or some additional text.
+
+    Attributes:
+        command (:obj:`str` | List[:obj:`str`]): The command or list of commands this handler
+            should listen for.
+        callback (:obj:`callable`): The callback function for this handler.
+        filters (:class:`telegram.ext.BaseFilter`): Optional. Only allow updates with these
+            Filters.
+        allow_edited (:obj:`bool`): Optional. Determines Whether the handler should also accept
+            edited messages.
+        pass_args (:obj:`bool`): Optional. Determines whether the handler should be passed
+            ``args``.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        command (:obj:`str` | List[:obj:`str`]): The command or list of commands this handler
+            should listen for.
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        filters (:class:`telegram.ext.BaseFilter`, optional): A filter inheriting from
+            :class:`telegram.ext.filters.BaseFilter`. Standard filters can be found in
+            :class:`telegram.ext.filters.Filters`. Filters can be combined using bitwise
+            operators (& for and, | for or, ~ for not).
+        allow_edited (:obj:`bool`, optional): Determines whether the handler should also accept
+            edited messages. Default is ``False``.
+        pass_args (:obj:`bool`, optional): Determines whether the handler should be passed the
+            arguments passed to the command as a keyword argument called ``args``. It will contain
+            a list of strings, which is the text following the command split on single or
+            consecutive whitespace characters. Default is ``False``
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+
+    """
+
+    def __init__(self,
+                 command,
+                 callback,
+                 filters=None,
+                 allow_edited=False,
+                 pass_args=False,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pass_user_data=False,
+                 pass_chat_data=False):
+        super(CommandHandler, self).__init__(
+            callback,
+            pass_update_queue=pass_update_queue,
+            pass_job_queue=pass_job_queue,
+            pass_user_data=pass_user_data,
+            pass_chat_data=pass_chat_data)
+
+        if isinstance(command, string_types):
+            self.command = [command.lower()]
+        else:
+            self.command = [x.lower() for x in command]
+        self.filters = filters
+        self.allow_edited = allow_edited
+        self.pass_args = pass_args
+
+        # We put this up here instead of with the rest of checking code
+        # in check_update since we don't wanna spam a ton
+        if isinstance(self.filters, list):
+            warnings.warn('Using a list of filters in MessageHandler is getting '
+                          'deprecated, please use bitwise operators (& and |) '
+                          'instead. More info: https://git.io/vPTbc.')
+
+    def check_update(self, update):
+        """Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        if (isinstance(update, Update)
+                and (update.message or update.edited_message and self.allow_edited)):
+            message = update.message or update.edited_message
+
+            if message.text and message.text.startswith('/') and len(message.text) > 1:
+                command = message.text[1:].split(None, 1)[0].split('@')
+                command.append(
+                    message.bot.username)  # in case the command was send without a username
+
+                if self.filters is None:
+                    res = True
+                elif isinstance(self.filters, list):
+                    res = any(func(message) for func in self.filters)
+                else:
+                    res = self.filters(message)
+
+                return res and (command[0].lower() in self.command
+                                and command[1].lower() == message.bot.username.lower())
+            else:
+                return False
+
+        else:
+            return False
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+
+        """
+        optional_args = self.collect_optional_args(dispatcher, update)
+
+        message = update.message or update.edited_message
+
+        if self.pass_args:
+            optional_args['args'] = message.text.split()[1:]
+
+        return self.callback(dispatcher.bot, update, **optional_args)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/conversationhandler.py` & `python-telegram-bot-9.0.0/telegram/ext/conversationhandler.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,310 +1,310 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the ConversationHandler."""
-
-import logging
-
-from telegram import Update
-from telegram.ext import (Handler, CallbackQueryHandler, InlineQueryHandler,
-                          ChosenInlineResultHandler)
-from telegram.utils.promise import Promise
-
-
-class ConversationHandler(Handler):
-    """
-    A handler to hold a conversation with a single user by managing four collections of other
-    handlers. Note that neither posts in Telegram Channels, nor group interactions with multiple
-    users are managed by instances of this class.
-
-    The first collection, a ``list`` named :attr:`entry_points`, is used to initiate the
-    conversation, for example with a :class:`telegram.ext.CommandHandler` or
-    :class:`telegram.ext.RegexHandler`.
-
-    The second collection, a ``dict`` named :attr:`states`, contains the different conversation
-    steps and one or more associated handlers that should be used if the user sends a message when
-    the conversation with them is currently in that state. You will probably use mostly
-    :class:`telegram.ext.MessageHandler` and :class:`telegram.ext.RegexHandler` here.
-
-    The third collection, a ``list`` named :attr:`fallbacks`, is used if the user is currently in a
-    conversation but the state has either no associated handler or the handler that is associated
-    to the state is inappropriate for the update, for example if the update contains a command, but
-    a regular text message is expected. You could use this for a ``/cancel`` command or to let the
-    user know their message was not recognized.
-
-    The fourth, optional collection of handlers, a ``list`` named :attr:`timed_out_behavior` is
-    used if the wait for ``run_async`` takes longer than defined in :attr:`run_async_timeout`.
-    For example, you can let the user know that they should wait for a bit before they can
-    continue.
-
-    To change the state of conversation, the callback function of a handler must return the new
-    state after responding to the user. If it does not return anything (returning ``None`` by
-    default), the state will not change. To end the conversation, the callback function must
-    return :attr`END` or ``-1``.
-
-    Attributes:
-        entry_points (List[:class:`telegram.ext.Handler`]): A list of ``Handler`` objects that can
-            trigger the start of the conversation.
-        states (Dict[:obj:`object`, List[:class:`telegram.ext.Handler`]]): A :obj:`dict` that
-            defines the different states of conversation a user can be in and one or more
-            associated ``Handler`` objects that should be used in that state.
-        fallbacks (List[:class:`telegram.ext.Handler`]): A list of handlers that might be used if
-            the user is in a conversation, but every handler for their current state returned
-            ``False`` on :attr:`check_update`.
-        allow_reentry (:obj:`bool`): Optional. Determines if a user can restart a conversation with
-            an entry point.
-        run_async_timeout (:obj:`float`): Optional. The time-out for ``run_async`` decorated
-            Handlers.
-        timed_out_behavior (List[:class:`telegram.ext.Handler`]): Optional. A list of handlers that
-            might be used if the wait for ``run_async`` timed out.
-        per_chat (:obj:`bool`): Optional. If the conversationkey should contain the Chat's ID.
-        per_user (:obj:`bool`): Optional. If the conversationkey should contain the User's ID.
-        per_message (:obj:`bool`): Optional. If the conversationkey should contain the Message's
-            ID.
-
-    Args:
-        entry_points (List[:class:`telegram.ext.Handler`]): A list of ``Handler`` objects that can
-            trigger the start of the conversation. The first handler which :attr:`check_update`
-            method returns ``True`` will be used. If all return ``False``, the update is not
-            handled.
-        states (Dict[:obj:`object`, List[:class:`telegram.ext.Handler`]]): A :obj:`dict` that
-            defines the different states of conversation a user can be in and one or more
-            associated ``Handler`` objects that should be used in that state. The first handler
-            which :attr:`check_update` method returns ``True`` will be used.
-        fallbacks (List[:class:`telegram.ext.Handler`]): A list of handlers that might be used if
-            the user is in a conversation, but every handler for their current state returned
-            ``False`` on :attr:`check_update`. The first handler which :attr:`check_update` method
-            returns ``True`` will be used. If all return ``False``, the update is not handled.
-        allow_reentry (:obj:`bool`, optional): If set to ``True``, a user that is currently in a
-            conversation can restart the conversation by triggering one of the entry points.
-        run_async_timeout (:obj:`float`, optional): If the previous handler for this user was
-            running asynchronously using the ``run_async`` decorator, it might not be finished when
-            the next message arrives. This timeout defines how long the conversation handler should
-            wait for the next state to be computed. The default is ``None`` which means it will
-            wait indefinitely.
-        timed_out_behavior (List[:class:`telegram.ext.Handler`], optional): A list of handlers that
-            might be used if the wait for ``run_async`` timed out. The first handler which
-            :attr:`check_update` method returns ``True`` will be used. If all return ``False``,
-            the update is not handled.
-        per_chat (:obj:`bool`, optional): If the conversationkey should contain the Chat's ID.
-            Default is ``True``.
-        per_user (:obj:`bool`, optional): If the conversationkey should contain the User's ID.
-            Default is ``True``.
-        per_message (:obj:`bool`, optional): If the conversationkey should contain the Message's
-            ID. Default is ``False``.
-
-    Raises:
-        ValueError
-
-    """
-    END = -1
-    """:obj:`int`: Used as a constant to return when a conversation is ended."""
-
-    def __init__(self,
-                 entry_points,
-                 states,
-                 fallbacks,
-                 allow_reentry=False,
-                 run_async_timeout=None,
-                 timed_out_behavior=None,
-                 per_chat=True,
-                 per_user=True,
-                 per_message=False):
-
-        self.entry_points = entry_points
-        self.states = states
-        self.fallbacks = fallbacks
-
-        self.allow_reentry = allow_reentry
-        self.run_async_timeout = run_async_timeout
-        self.timed_out_behavior = timed_out_behavior
-        self.per_user = per_user
-        self.per_chat = per_chat
-        self.per_message = per_message
-
-        self.conversations = dict()
-        self.current_conversation = None
-        self.current_handler = None
-
-        self.logger = logging.getLogger(__name__)
-
-        if not any((self.per_user, self.per_chat, self.per_message)):
-            raise ValueError("'per_user', 'per_chat' and 'per_message' can't all be 'False'")
-
-        if self.per_message and not self.per_chat:
-            logging.warning("If 'per_message=True' is used, 'per_chat=True' should also be used, "
-                            "since message IDs are not globally unique.")
-
-        all_handlers = list()
-        all_handlers.extend(entry_points)
-        all_handlers.extend(fallbacks)
-
-        for state_handlers in states.values():
-            all_handlers.extend(state_handlers)
-
-        if self.per_message:
-            for handler in all_handlers:
-                if not isinstance(handler, CallbackQueryHandler):
-                    logging.warning("If 'per_message=True', all entry points and state handlers"
-                                    " must be 'CallbackQueryHandler', since no other handlers "
-                                    "have a message context.")
-        else:
-            for handler in all_handlers:
-                if isinstance(handler, CallbackQueryHandler):
-                    logging.warning("If 'per_message=False', 'CallbackQueryHandler' will not be "
-                                    "tracked for every message.")
-
-        if self.per_chat:
-            for handler in all_handlers:
-                if isinstance(handler, (InlineQueryHandler, ChosenInlineResultHandler)):
-                    logging.warning("If 'per_chat=True', 'InlineQueryHandler' can not be used, "
-                                    "since inline queries have no chat context.")
-
-    def _get_key(self, update):
-        chat = update.effective_chat
-        user = update.effective_user
-
-        key = list()
-
-        if self.per_chat:
-            key.append(chat.id)
-
-        if self.per_user and user is not None:
-            key.append(user.id)
-
-        if self.per_message:
-            key.append(update.callback_query.inline_message_id
-                       or update.callback_query.message.message_id)
-
-        return tuple(key)
-
-    def check_update(self, update):
-        """
-        Determines whether an update should be handled by this conversationhandler, and if so in
-        which state the conversation currently is.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        # Ignore messages in channels
-        if (not isinstance(update, Update) or update.channel_post or self.per_chat
-                and (update.inline_query or update.chosen_inline_result) or self.per_message
-                and not update.callback_query or update.callback_query and self.per_chat
-                and not update.callback_query.message):
-            return False
-
-        key = self._get_key(update)
-        state = self.conversations.get(key)
-
-        # Resolve promises
-        if isinstance(state, tuple) and len(state) is 2 and isinstance(state[1], Promise):
-            self.logger.debug('waiting for promise...')
-
-            old_state, new_state = state
-            error = False
-            try:
-                res = new_state.result(timeout=self.run_async_timeout)
-            except Exception as exc:
-                self.logger.exception("Promise function raised exception")
-                self.logger.exception("{}".format(exc))
-                error = True
-
-            if not error and new_state.done.is_set():
-                self.update_state(res, key)
-                state = self.conversations.get(key)
-
-            else:
-                for candidate in (self.timed_out_behavior or []):
-                    if candidate.check_update(update):
-                        # Save the current user and the selected handler for handle_update
-                        self.current_conversation = key
-                        self.current_handler = candidate
-
-                        return True
-
-                else:
-                    return False
-
-        self.logger.debug('selecting conversation %s with state %s' % (str(key), str(state)))
-
-        handler = None
-
-        # Search entry points for a match
-        if state is None or self.allow_reentry:
-            for entry_point in self.entry_points:
-                if entry_point.check_update(update):
-                    handler = entry_point
-                    break
-
-            else:
-                if state is None:
-                    return False
-
-        # Get the handler list for current state, if we didn't find one yet and we're still here
-        if state is not None and not handler:
-            handlers = self.states.get(state)
-
-            for candidate in (handlers or []):
-                if candidate.check_update(update):
-                    handler = candidate
-                    break
-
-            # Find a fallback handler if all other handlers fail
-            else:
-                for fallback in self.fallbacks:
-                    if fallback.check_update(update):
-                        handler = fallback
-                        break
-
-                else:
-                    return False
-
-        # Save the current user and the selected handler for handle_update
-        self.current_conversation = key
-        self.current_handler = handler
-
-        return True
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the callback for the current state and Handler
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-
-        """
-        new_state = self.current_handler.handle_update(update, dispatcher)
-
-        self.update_state(new_state, self.current_conversation)
-
-    def update_state(self, new_state, key):
-        if new_state == self.END:
-            if key in self.conversations:
-                del self.conversations[key]
-            else:
-                pass
-
-        elif isinstance(new_state, Promise):
-            self.conversations[key] = (self.conversations.get(key), new_state)
-
-        elif new_state is not None:
-            self.conversations[key] = new_state
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the ConversationHandler."""
+
+import logging
+
+from telegram import Update
+from telegram.ext import (Handler, CallbackQueryHandler, InlineQueryHandler,
+                          ChosenInlineResultHandler)
+from telegram.utils.promise import Promise
+
+
+class ConversationHandler(Handler):
+    """
+    A handler to hold a conversation with a single user by managing four collections of other
+    handlers. Note that neither posts in Telegram Channels, nor group interactions with multiple
+    users are managed by instances of this class.
+
+    The first collection, a ``list`` named :attr:`entry_points`, is used to initiate the
+    conversation, for example with a :class:`telegram.ext.CommandHandler` or
+    :class:`telegram.ext.RegexHandler`.
+
+    The second collection, a ``dict`` named :attr:`states`, contains the different conversation
+    steps and one or more associated handlers that should be used if the user sends a message when
+    the conversation with them is currently in that state. You will probably use mostly
+    :class:`telegram.ext.MessageHandler` and :class:`telegram.ext.RegexHandler` here.
+
+    The third collection, a ``list`` named :attr:`fallbacks`, is used if the user is currently in a
+    conversation but the state has either no associated handler or the handler that is associated
+    to the state is inappropriate for the update, for example if the update contains a command, but
+    a regular text message is expected. You could use this for a ``/cancel`` command or to let the
+    user know their message was not recognized.
+
+    The fourth, optional collection of handlers, a ``list`` named :attr:`timed_out_behavior` is
+    used if the wait for ``run_async`` takes longer than defined in :attr:`run_async_timeout`.
+    For example, you can let the user know that they should wait for a bit before they can
+    continue.
+
+    To change the state of conversation, the callback function of a handler must return the new
+    state after responding to the user. If it does not return anything (returning ``None`` by
+    default), the state will not change. To end the conversation, the callback function must
+    return :attr`END` or ``-1``.
+
+    Attributes:
+        entry_points (List[:class:`telegram.ext.Handler`]): A list of ``Handler`` objects that can
+            trigger the start of the conversation.
+        states (Dict[:obj:`object`, List[:class:`telegram.ext.Handler`]]): A :obj:`dict` that
+            defines the different states of conversation a user can be in and one or more
+            associated ``Handler`` objects that should be used in that state.
+        fallbacks (List[:class:`telegram.ext.Handler`]): A list of handlers that might be used if
+            the user is in a conversation, but every handler for their current state returned
+            ``False`` on :attr:`check_update`.
+        allow_reentry (:obj:`bool`): Optional. Determines if a user can restart a conversation with
+            an entry point.
+        run_async_timeout (:obj:`float`): Optional. The time-out for ``run_async`` decorated
+            Handlers.
+        timed_out_behavior (List[:class:`telegram.ext.Handler`]): Optional. A list of handlers that
+            might be used if the wait for ``run_async`` timed out.
+        per_chat (:obj:`bool`): Optional. If the conversationkey should contain the Chat's ID.
+        per_user (:obj:`bool`): Optional. If the conversationkey should contain the User's ID.
+        per_message (:obj:`bool`): Optional. If the conversationkey should contain the Message's
+            ID.
+
+    Args:
+        entry_points (List[:class:`telegram.ext.Handler`]): A list of ``Handler`` objects that can
+            trigger the start of the conversation. The first handler which :attr:`check_update`
+            method returns ``True`` will be used. If all return ``False``, the update is not
+            handled.
+        states (Dict[:obj:`object`, List[:class:`telegram.ext.Handler`]]): A :obj:`dict` that
+            defines the different states of conversation a user can be in and one or more
+            associated ``Handler`` objects that should be used in that state. The first handler
+            which :attr:`check_update` method returns ``True`` will be used.
+        fallbacks (List[:class:`telegram.ext.Handler`]): A list of handlers that might be used if
+            the user is in a conversation, but every handler for their current state returned
+            ``False`` on :attr:`check_update`. The first handler which :attr:`check_update` method
+            returns ``True`` will be used. If all return ``False``, the update is not handled.
+        allow_reentry (:obj:`bool`, optional): If set to ``True``, a user that is currently in a
+            conversation can restart the conversation by triggering one of the entry points.
+        run_async_timeout (:obj:`float`, optional): If the previous handler for this user was
+            running asynchronously using the ``run_async`` decorator, it might not be finished when
+            the next message arrives. This timeout defines how long the conversation handler should
+            wait for the next state to be computed. The default is ``None`` which means it will
+            wait indefinitely.
+        timed_out_behavior (List[:class:`telegram.ext.Handler`], optional): A list of handlers that
+            might be used if the wait for ``run_async`` timed out. The first handler which
+            :attr:`check_update` method returns ``True`` will be used. If all return ``False``,
+            the update is not handled.
+        per_chat (:obj:`bool`, optional): If the conversationkey should contain the Chat's ID.
+            Default is ``True``.
+        per_user (:obj:`bool`, optional): If the conversationkey should contain the User's ID.
+            Default is ``True``.
+        per_message (:obj:`bool`, optional): If the conversationkey should contain the Message's
+            ID. Default is ``False``.
+
+    Raises:
+        ValueError
+
+    """
+    END = -1
+    """:obj:`int`: Used as a constant to return when a conversation is ended."""
+
+    def __init__(self,
+                 entry_points,
+                 states,
+                 fallbacks,
+                 allow_reentry=False,
+                 run_async_timeout=None,
+                 timed_out_behavior=None,
+                 per_chat=True,
+                 per_user=True,
+                 per_message=False):
+
+        self.entry_points = entry_points
+        self.states = states
+        self.fallbacks = fallbacks
+
+        self.allow_reentry = allow_reentry
+        self.run_async_timeout = run_async_timeout
+        self.timed_out_behavior = timed_out_behavior
+        self.per_user = per_user
+        self.per_chat = per_chat
+        self.per_message = per_message
+
+        self.conversations = dict()
+        self.current_conversation = None
+        self.current_handler = None
+
+        self.logger = logging.getLogger(__name__)
+
+        if not any((self.per_user, self.per_chat, self.per_message)):
+            raise ValueError("'per_user', 'per_chat' and 'per_message' can't all be 'False'")
+
+        if self.per_message and not self.per_chat:
+            logging.warning("If 'per_message=True' is used, 'per_chat=True' should also be used, "
+                            "since message IDs are not globally unique.")
+
+        all_handlers = list()
+        all_handlers.extend(entry_points)
+        all_handlers.extend(fallbacks)
+
+        for state_handlers in states.values():
+            all_handlers.extend(state_handlers)
+
+        if self.per_message:
+            for handler in all_handlers:
+                if not isinstance(handler, CallbackQueryHandler):
+                    logging.warning("If 'per_message=True', all entry points and state handlers"
+                                    " must be 'CallbackQueryHandler', since no other handlers "
+                                    "have a message context.")
+        else:
+            for handler in all_handlers:
+                if isinstance(handler, CallbackQueryHandler):
+                    logging.warning("If 'per_message=False', 'CallbackQueryHandler' will not be "
+                                    "tracked for every message.")
+
+        if self.per_chat:
+            for handler in all_handlers:
+                if isinstance(handler, (InlineQueryHandler, ChosenInlineResultHandler)):
+                    logging.warning("If 'per_chat=True', 'InlineQueryHandler' can not be used, "
+                                    "since inline queries have no chat context.")
+
+    def _get_key(self, update):
+        chat = update.effective_chat
+        user = update.effective_user
+
+        key = list()
+
+        if self.per_chat:
+            key.append(chat.id)
+
+        if self.per_user and user is not None:
+            key.append(user.id)
+
+        if self.per_message:
+            key.append(update.callback_query.inline_message_id
+                       or update.callback_query.message.message_id)
+
+        return tuple(key)
+
+    def check_update(self, update):
+        """
+        Determines whether an update should be handled by this conversationhandler, and if so in
+        which state the conversation currently is.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        # Ignore messages in channels
+        if (not isinstance(update, Update) or update.channel_post or self.per_chat
+                and (update.inline_query or update.chosen_inline_result) or self.per_message
+                and not update.callback_query or update.callback_query and self.per_chat
+                and not update.callback_query.message):
+            return False
+
+        key = self._get_key(update)
+        state = self.conversations.get(key)
+
+        # Resolve promises
+        if isinstance(state, tuple) and len(state) is 2 and isinstance(state[1], Promise):
+            self.logger.debug('waiting for promise...')
+
+            old_state, new_state = state
+            error = False
+            try:
+                res = new_state.result(timeout=self.run_async_timeout)
+            except Exception as exc:
+                self.logger.exception("Promise function raised exception")
+                self.logger.exception("{}".format(exc))
+                error = True
+
+            if not error and new_state.done.is_set():
+                self.update_state(res, key)
+                state = self.conversations.get(key)
+
+            else:
+                for candidate in (self.timed_out_behavior or []):
+                    if candidate.check_update(update):
+                        # Save the current user and the selected handler for handle_update
+                        self.current_conversation = key
+                        self.current_handler = candidate
+
+                        return True
+
+                else:
+                    return False
+
+        self.logger.debug('selecting conversation %s with state %s' % (str(key), str(state)))
+
+        handler = None
+
+        # Search entry points for a match
+        if state is None or self.allow_reentry:
+            for entry_point in self.entry_points:
+                if entry_point.check_update(update):
+                    handler = entry_point
+                    break
+
+            else:
+                if state is None:
+                    return False
+
+        # Get the handler list for current state, if we didn't find one yet and we're still here
+        if state is not None and not handler:
+            handlers = self.states.get(state)
+
+            for candidate in (handlers or []):
+                if candidate.check_update(update):
+                    handler = candidate
+                    break
+
+            # Find a fallback handler if all other handlers fail
+            else:
+                for fallback in self.fallbacks:
+                    if fallback.check_update(update):
+                        handler = fallback
+                        break
+
+                else:
+                    return False
+
+        # Save the current user and the selected handler for handle_update
+        self.current_conversation = key
+        self.current_handler = handler
+
+        return True
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the callback for the current state and Handler
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+
+        """
+        new_state = self.current_handler.handle_update(update, dispatcher)
+
+        self.update_state(new_state, self.current_conversation)
+
+    def update_state(self, new_state, key):
+        if new_state == self.END:
+            if key in self.conversations:
+                del self.conversations[key]
+            else:
+                pass
+
+        elif isinstance(new_state, Promise):
+            self.conversations[key] = (self.conversations.get(key), new_state)
+
+        elif new_state is not None:
+            self.conversations[key] = new_state
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/dispatcher.py` & `python-telegram-bot-9.0.0/telegram/ext/dispatcher.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,374 +1,388 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the Dispatcher class."""
-
-import logging
-import weakref
-from functools import wraps
-from threading import Thread, Lock, Event, current_thread, BoundedSemaphore
-from time import sleep
-from uuid import uuid4
-from collections import defaultdict
-
-from queue import Queue, Empty
-
-from future.builtins import range
-
-from telegram import TelegramError
-from telegram.ext.handler import Handler
-from telegram.utils.promise import Promise
-
-logging.getLogger(__name__).addHandler(logging.NullHandler())
-DEFAULT_GROUP = 0
-
-
-def run_async(func):
-    """Function decorator that will run the function in a new thread.
-
-    Will run :attr:`telegram.ext.Dispatcher.run_async`.
-
-    Using this decorator is only possible when only a single Dispatcher exist in the system.
-
-    Note: Use this decorator to run handlers asynchronously.
-
-    """
-    @wraps(func)
-    def async_func(*args, **kwargs):
-        return Dispatcher.get_instance().run_async(func, *args, **kwargs)
-
-    return async_func
-
-
-class DispatcherHandlerStop(Exception):
-    """Raise this in handler to prevent execution any other handler (even in different group)."""
-    pass
-
-
-class Dispatcher(object):
-    """This class dispatches all kinds of updates to its registered handlers.
-
-    Attributes:
-        bot (:class:`telegram.Bot`): The bot object that should be passed to the handlers.
-        update_queue (:obj:`Queue`): The synchronized queue that will contain the updates.
-        job_queue (:class:`telegram.ext.JobQueue`): Optional. The :class:`telegram.ext.JobQueue`
-            instance to pass onto handler callbacks.
-        workers (:obj:`int`): Number of maximum concurrent worker threads for the ``@run_async``
-            decorator.
-
-    Args:
-        bot (:class:`telegram.Bot`): The bot object that should be passed to the handlers.
-        update_queue (:obj:`Queue`): The synchronized queue that will contain the updates.
-        job_queue (:class:`telegram.ext.JobQueue`, optional): The :class:`telegram.ext.JobQueue`
-                instance to pass onto handler callbacks.
-        workers (:obj:`int`, optional): Number of maximum concurrent worker threads for the
-            ``@run_async`` decorator. defaults to 4.
-
-    """
-
-    __singleton_lock = Lock()
-    __singleton_semaphore = BoundedSemaphore()
-    __singleton = None
-    logger = logging.getLogger(__name__)
-
-    def __init__(self, bot, update_queue, workers=4, exception_event=None, job_queue=None):
-        self.bot = bot
-        self.update_queue = update_queue
-        self.job_queue = job_queue
-        self.workers = workers
-
-        self.user_data = defaultdict(dict)
-        """:obj:`dict`: A dictionary handlers can use to store data for the user."""
-        self.chat_data = defaultdict(dict)
-        """:obj:`dict`: A dictionary handlers can use to store data for the chat."""
-        self.handlers = {}
-        """Dict[:obj:`int`, List[:class:`telegram.ext.Handler`]]: Holds the handlers per group."""
-        self.groups = []
-        """List[:obj:`int`]: A list with all groups."""
-        self.error_handlers = []
-        """List[:obj:`callable`]: A list of errorHandlers."""
-
-        self.running = False
-        """:obj:`bool`: Indicates if this dispatcher is running."""
-        self.__stop_event = Event()
-        self.__exception_event = exception_event or Event()
-        self.__async_queue = Queue()
-        self.__async_threads = set()
-
-        # For backward compatibility, we allow a "singleton" mode for the dispatcher. When there's
-        # only one instance of Dispatcher, it will be possible to use the `run_async` decorator.
-        with self.__singleton_lock:
-            if self.__singleton_semaphore.acquire(blocking=0):
-                self._set_singleton(self)
-            else:
-                self._set_singleton(None)
-
-    def _init_async_threads(self, base_name, workers):
-        base_name = '{}_'.format(base_name) if base_name else ''
-
-        for i in range(workers):
-            thread = Thread(target=self._pooled, name='{}{}'.format(base_name, i))
-            self.__async_threads.add(thread)
-            thread.start()
-
-    @classmethod
-    def _set_singleton(cls, val):
-        cls.logger.debug('Setting singleton dispatcher as %s', val)
-        cls.__singleton = weakref.ref(val) if val else None
-
-    @classmethod
-    def get_instance(cls):
-        """Get the singleton instance of this class.
-
-        Returns:
-            :class:`telegram.ext.Dispatcher`
-
-        Raises:
-            RuntimeError
-
-        """
-        if cls.__singleton is not None:
-            return cls.__singleton()
-        else:
-            raise RuntimeError('{} not initialized or multiple instances exist'.format(
-                cls.__name__))
-
-    def _pooled(self):
-        thr_name = current_thread().getName()
-        while 1:
-            promise = self.__async_queue.get()
-
-            # If unpacking fails, the thread pool is being closed from Updater._join_async_threads
-            if not isinstance(promise, Promise):
-                self.logger.debug("Closing run_async thread %s/%d", thr_name,
-                                  len(self.__async_threads))
-                break
-
-            promise.run()
-            if isinstance(promise.exception, DispatcherHandlerStop):
-                self.logger.warning(
-                    'DispatcherHandlerStop is not supported with async functions; func: %s',
-                    promise.pooled_function.__name__)
-
-    def run_async(self, func, *args, **kwargs):
-        """Queue a function (with given args/kwargs) to be run asynchronously.
-
-        Args:
-            func (:obj:`callable`): The function to run in the thread.
-            *args (:obj:`tuple`, optional): Arguments to `func`.
-            **kwargs (:obj:`dict`, optional): Keyword arguments to `func`.
-
-        Returns:
-            Promise
-
-        """
-        # TODO: handle exception in async threads
-        #       set a threading.Event to notify caller thread
-        promise = Promise(func, args, kwargs)
-        self.__async_queue.put(promise)
-        return promise
-
-    def start(self):
-        """Thread target of thread 'dispatcher'.
-
-        Runs in background and processes the update queue.
-
-        """
-        if self.running:
-            self.logger.warning('already running')
-            return
-
-        if self.__exception_event.is_set():
-            msg = 'reusing dispatcher after exception event is forbidden'
-            self.logger.error(msg)
-            raise TelegramError(msg)
-
-        self._init_async_threads(uuid4(), self.workers)
-        self.running = True
-        self.logger.debug('Dispatcher started')
-
-        while 1:
-            try:
-                # Pop update from update queue.
-                update = self.update_queue.get(True, 1)
-            except Empty:
-                if self.__stop_event.is_set():
-                    self.logger.debug('orderly stopping')
-                    break
-                elif self.__exception_event.is_set():
-                    self.logger.critical('stopping due to exception in another thread')
-                    break
-                continue
-
-            self.logger.debug('Processing Update: %s' % update)
-            self.process_update(update)
-
-        self.running = False
-        self.logger.debug('Dispatcher thread stopped')
-
-    def stop(self):
-        """Stops the thread."""
-        if self.running:
-            self.__stop_event.set()
-            while self.running:
-                sleep(0.1)
-            self.__stop_event.clear()
-
-        # async threads must be join()ed only after the dispatcher thread was joined,
-        # otherwise we can still have new async threads dispatched
-        threads = list(self.__async_threads)
-        total = len(threads)
-
-        # Stop all threads in the thread pool by put()ting one non-tuple per thread
-        for i in range(total):
-            self.__async_queue.put(None)
-
-        for i, thr in enumerate(threads):
-            self.logger.debug('Waiting for async thread {0}/{1} to end'.format(i + 1, total))
-            thr.join()
-            self.__async_threads.remove(thr)
-            self.logger.debug('async thread {0}/{1} has ended'.format(i + 1, total))
-
-    @property
-    def has_running_threads(self):
-        return self.running or bool(self.__async_threads)
-
-    def process_update(self, update):
-        """Processes a single update.
-
-        Args:
-            update (:obj:`str` | :class:`telegram.Update` | :class:`telegram.TelegramError`):
-                The update to process.
-
-        """
-        # An error happened while polling
-        if isinstance(update, TelegramError):
-            try:
-                self.dispatch_error(None, update)
-            except Exception:
-                self.logger.exception('An uncaught error was raised while handling the error')
-            return
-
-        for group in self.groups:
-            try:
-                for handler in (x for x in self.handlers[group] if x.check_update(update)):
-                    handler.handle_update(update, self)
-                    break
-
-            # Stop processing with any other handler.
-            except DispatcherHandlerStop:
-                self.logger.debug('Stopping further handlers due to DispatcherHandlerStop')
-                break
-
-            # Dispatch any error.
-            except TelegramError as te:
-                self.logger.warning('A TelegramError was raised while processing the Update')
-
-                try:
-                    self.dispatch_error(update, te)
-                except DispatcherHandlerStop:
-                    self.logger.debug('Error handler stopped further handlers')
-                    break
-                except Exception:
-                    self.logger.exception('An uncaught error was raised while handling the error')
-
-            # Errors should not stop the thread.
-            except Exception:
-                self.logger.exception('An uncaught error was raised while processing the update')
-
-    def add_handler(self, handler, group=DEFAULT_GROUP):
-        """Register a handler.
-
-        TL;DR: Order and priority counts. 0 or 1 handlers per group will be used.
-
-        A handler must be an instance of a subclass of :class:`telegram.ext.Handler`. All handlers
-        are organized in groups with a numeric value. The default group is 0. All groups will be
-        evaluated for handling an update, but only 0 or 1 handler per group will be used. If
-        :class:`telegram.DispatcherHandlerStop` is raised from one of the handlers, no further
-        handlers (regardless of the group) will be called.
-
-        The priority/order of handlers is determined as follows:
-
-          * Priority of the group (lower group number == higher priority)
-          * The first handler in a group which should handle an update (see
-            :attr:`telegram.ext.Handler.check_update`) will be used. Other handlers from the
-            group will not be used. The order in which handlers were added to the group defines the
-            priority.
-
-        Args:
-            handler (:class:`telegram.ext.Handler`): A Handler instance.
-            group (:obj:`int`, optional): The group identifier. Default is 0.
-
-        """
-
-        if not isinstance(handler, Handler):
-            raise TypeError('handler is not an instance of {0}'.format(Handler.__name__))
-        if not isinstance(group, int):
-            raise TypeError('group is not int')
-
-        if group not in self.handlers:
-            self.handlers[group] = list()
-            self.groups.append(group)
-            self.groups = sorted(self.groups)
-
-        self.handlers[group].append(handler)
-
-    def remove_handler(self, handler, group=DEFAULT_GROUP):
-        """Remove a handler from the specified group.
-
-        Args:
-            handler (:class:`telegram.ext.Handler`): A Handler instance.
-            group (:obj:`object`, optional): The group identifier. Default is 0.
-
-        """
-        if handler in self.handlers[group]:
-            self.handlers[group].remove(handler)
-            if not self.handlers[group]:
-                del self.handlers[group]
-                self.groups.remove(group)
-
-    def add_error_handler(self, callback):
-        """Registers an error handler in the Dispatcher.
-
-        Args:
-            callback (:obj:`callable`): A function that takes ``Bot, Update, TelegramError`` as
-                arguments.
-
-        """
-        self.error_handlers.append(callback)
-
-    def remove_error_handler(self, callback):
-        """Removes an error handler.
-
-        Args:
-            callback (:obj:`callable`): The error handler to remove.
-
-        """
-        if callback in self.error_handlers:
-            self.error_handlers.remove(callback)
-
-    def dispatch_error(self, update, error):
-        """Dispatches an error.
-
-        Args:
-            update (:obj:`str` | :class:`telegram.Update` | None): The update that caused the error
-            error (:class:`telegram.TelegramError`): The Telegram error that was raised.
-
-        """
-        for callback in self.error_handlers:
-            callback(self.bot, update, error)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the Dispatcher class."""
+
+import logging
+import weakref
+from functools import wraps
+from threading import Thread, Lock, Event, current_thread, BoundedSemaphore
+from time import sleep
+from uuid import uuid4
+from collections import defaultdict
+
+from queue import Queue, Empty
+
+from future.builtins import range
+
+from telegram import TelegramError
+from telegram.ext.handler import Handler
+from telegram.utils.promise import Promise
+
+logging.getLogger(__name__).addHandler(logging.NullHandler())
+DEFAULT_GROUP = 0
+
+
+def run_async(func):
+    """Function decorator that will run the function in a new thread.
+
+    Will run :attr:`telegram.ext.Dispatcher.run_async`.
+
+    Using this decorator is only possible when only a single Dispatcher exist in the system.
+
+    Note: Use this decorator to run handlers asynchronously.
+
+    """
+    @wraps(func)
+    def async_func(*args, **kwargs):
+        return Dispatcher.get_instance().run_async(func, *args, **kwargs)
+
+    return async_func
+
+
+class DispatcherHandlerStop(Exception):
+    """Raise this in handler to prevent execution any other handler (even in different group)."""
+    pass
+
+
+class Dispatcher(object):
+    """This class dispatches all kinds of updates to its registered handlers.
+
+    Attributes:
+        bot (:class:`telegram.Bot`): The bot object that should be passed to the handlers.
+        update_queue (:obj:`Queue`): The synchronized queue that will contain the updates.
+        job_queue (:class:`telegram.ext.JobQueue`): Optional. The :class:`telegram.ext.JobQueue`
+            instance to pass onto handler callbacks.
+        workers (:obj:`int`): Number of maximum concurrent worker threads for the ``@run_async``
+            decorator.
+
+    Args:
+        bot (:class:`telegram.Bot`): The bot object that should be passed to the handlers.
+        update_queue (:obj:`Queue`): The synchronized queue that will contain the updates.
+        job_queue (:class:`telegram.ext.JobQueue`, optional): The :class:`telegram.ext.JobQueue`
+                instance to pass onto handler callbacks.
+        workers (:obj:`int`, optional): Number of maximum concurrent worker threads for the
+            ``@run_async`` decorator. defaults to 4.
+
+    """
+
+    __singleton_lock = Lock()
+    __singleton_semaphore = BoundedSemaphore()
+    __singleton = None
+    logger = logging.getLogger(__name__)
+
+    def __init__(self, bot, update_queue, workers=4, exception_event=None, job_queue=None):
+        self.bot = bot
+        self.update_queue = update_queue
+        self.job_queue = job_queue
+        self.workers = workers
+
+        self.user_data = defaultdict(dict)
+        """:obj:`dict`: A dictionary handlers can use to store data for the user."""
+        self.chat_data = defaultdict(dict)
+        """:obj:`dict`: A dictionary handlers can use to store data for the chat."""
+        self.handlers = {}
+        """Dict[:obj:`int`, List[:class:`telegram.ext.Handler`]]: Holds the handlers per group."""
+        self.groups = []
+        """List[:obj:`int`]: A list with all groups."""
+        self.error_handlers = []
+        """List[:obj:`callable`]: A list of errorHandlers."""
+
+        self.running = False
+        """:obj:`bool`: Indicates if this dispatcher is running."""
+        self.__stop_event = Event()
+        self.__exception_event = exception_event or Event()
+        self.__async_queue = Queue()
+        self.__async_threads = set()
+
+        # For backward compatibility, we allow a "singleton" mode for the dispatcher. When there's
+        # only one instance of Dispatcher, it will be possible to use the `run_async` decorator.
+        with self.__singleton_lock:
+            if self.__singleton_semaphore.acquire(blocking=0):
+                self._set_singleton(self)
+            else:
+                self._set_singleton(None)
+
+    def _init_async_threads(self, base_name, workers):
+        base_name = '{}_'.format(base_name) if base_name else ''
+
+        for i in range(workers):
+            thread = Thread(target=self._pooled, name='{}{}'.format(base_name, i))
+            self.__async_threads.add(thread)
+            thread.start()
+
+    @classmethod
+    def _set_singleton(cls, val):
+        cls.logger.debug('Setting singleton dispatcher as %s', val)
+        cls.__singleton = weakref.ref(val) if val else None
+
+    @classmethod
+    def get_instance(cls):
+        """Get the singleton instance of this class.
+
+        Returns:
+            :class:`telegram.ext.Dispatcher`
+
+        Raises:
+            RuntimeError
+
+        """
+        if cls.__singleton is not None:
+            return cls.__singleton()
+        else:
+            raise RuntimeError('{} not initialized or multiple instances exist'.format(
+                cls.__name__))
+
+    def _pooled(self):
+        thr_name = current_thread().getName()
+        while 1:
+            promise = self.__async_queue.get()
+
+            # If unpacking fails, the thread pool is being closed from Updater._join_async_threads
+            if not isinstance(promise, Promise):
+                self.logger.debug("Closing run_async thread %s/%d", thr_name,
+                                  len(self.__async_threads))
+                break
+
+            promise.run()
+            if isinstance(promise.exception, DispatcherHandlerStop):
+                self.logger.warning(
+                    'DispatcherHandlerStop is not supported with async functions; func: %s',
+                    promise.pooled_function.__name__)
+
+    def run_async(self, func, *args, **kwargs):
+        """Queue a function (with given args/kwargs) to be run asynchronously.
+
+        Args:
+            func (:obj:`callable`): The function to run in the thread.
+            *args (:obj:`tuple`, optional): Arguments to `func`.
+            **kwargs (:obj:`dict`, optional): Keyword arguments to `func`.
+
+        Returns:
+            Promise
+
+        """
+        # TODO: handle exception in async threads
+        #       set a threading.Event to notify caller thread
+        promise = Promise(func, args, kwargs)
+        self.__async_queue.put(promise)
+        return promise
+
+    def start(self, ready=None):
+        """Thread target of thread 'dispatcher'.
+
+        Runs in background and processes the update queue.
+
+        Args:
+            ready (:obj:`threading.Event`, optional): If specified, the event will be set once the
+                dispatcher is ready.
+
+        """
+        if self.running:
+            self.logger.warning('already running')
+            if ready is not None:
+                ready.set()
+            return
+
+        if self.__exception_event.is_set():
+            msg = 'reusing dispatcher after exception event is forbidden'
+            self.logger.error(msg)
+            raise TelegramError(msg)
+
+        self._init_async_threads(uuid4(), self.workers)
+        self.running = True
+        self.logger.debug('Dispatcher started')
+
+        if ready is not None:
+            ready.set()
+
+        while 1:
+            try:
+                # Pop update from update queue.
+                update = self.update_queue.get(True, 1)
+            except Empty:
+                if self.__stop_event.is_set():
+                    self.logger.debug('orderly stopping')
+                    break
+                elif self.__exception_event.is_set():
+                    self.logger.critical('stopping due to exception in another thread')
+                    break
+                continue
+
+            self.logger.debug('Processing Update: %s' % update)
+            self.process_update(update)
+
+        self.running = False
+        self.logger.debug('Dispatcher thread stopped')
+
+    def stop(self):
+        """Stops the thread."""
+        if self.running:
+            self.__stop_event.set()
+            while self.running:
+                sleep(0.1)
+            self.__stop_event.clear()
+
+        # async threads must be join()ed only after the dispatcher thread was joined,
+        # otherwise we can still have new async threads dispatched
+        threads = list(self.__async_threads)
+        total = len(threads)
+
+        # Stop all threads in the thread pool by put()ting one non-tuple per thread
+        for i in range(total):
+            self.__async_queue.put(None)
+
+        for i, thr in enumerate(threads):
+            self.logger.debug('Waiting for async thread {0}/{1} to end'.format(i + 1, total))
+            thr.join()
+            self.__async_threads.remove(thr)
+            self.logger.debug('async thread {0}/{1} has ended'.format(i + 1, total))
+
+    @property
+    def has_running_threads(self):
+        return self.running or bool(self.__async_threads)
+
+    def process_update(self, update):
+        """Processes a single update.
+
+        Args:
+            update (:obj:`str` | :class:`telegram.Update` | :class:`telegram.TelegramError`):
+                The update to process.
+
+        """
+        # An error happened while polling
+        if isinstance(update, TelegramError):
+            try:
+                self.dispatch_error(None, update)
+            except Exception:
+                self.logger.exception('An uncaught error was raised while handling the error')
+            return
+
+        for group in self.groups:
+            try:
+                for handler in (x for x in self.handlers[group] if x.check_update(update)):
+                    handler.handle_update(update, self)
+                    break
+
+            # Stop processing with any other handler.
+            except DispatcherHandlerStop:
+                self.logger.debug('Stopping further handlers due to DispatcherHandlerStop')
+                break
+
+            # Dispatch any error.
+            except TelegramError as te:
+                self.logger.warning('A TelegramError was raised while processing the Update')
+
+                try:
+                    self.dispatch_error(update, te)
+                except DispatcherHandlerStop:
+                    self.logger.debug('Error handler stopped further handlers')
+                    break
+                except Exception:
+                    self.logger.exception('An uncaught error was raised while handling the error')
+
+            # Errors should not stop the thread.
+            except Exception:
+                self.logger.exception('An uncaught error was raised while processing the update')
+
+    def add_handler(self, handler, group=DEFAULT_GROUP):
+        """Register a handler.
+
+        TL;DR: Order and priority counts. 0 or 1 handlers per group will be used.
+
+        A handler must be an instance of a subclass of :class:`telegram.ext.Handler`. All handlers
+        are organized in groups with a numeric value. The default group is 0. All groups will be
+        evaluated for handling an update, but only 0 or 1 handler per group will be used. If
+        :class:`telegram.DispatcherHandlerStop` is raised from one of the handlers, no further
+        handlers (regardless of the group) will be called.
+
+        The priority/order of handlers is determined as follows:
+
+          * Priority of the group (lower group number == higher priority)
+          * The first handler in a group which should handle an update (see
+            :attr:`telegram.ext.Handler.check_update`) will be used. Other handlers from the
+            group will not be used. The order in which handlers were added to the group defines the
+            priority.
+
+        Args:
+            handler (:class:`telegram.ext.Handler`): A Handler instance.
+            group (:obj:`int`, optional): The group identifier. Default is 0.
+
+        """
+
+        if not isinstance(handler, Handler):
+            raise TypeError('handler is not an instance of {0}'.format(Handler.__name__))
+        if not isinstance(group, int):
+            raise TypeError('group is not int')
+
+        if group not in self.handlers:
+            self.handlers[group] = list()
+            self.groups.append(group)
+            self.groups = sorted(self.groups)
+
+        self.handlers[group].append(handler)
+
+    def remove_handler(self, handler, group=DEFAULT_GROUP):
+        """Remove a handler from the specified group.
+
+        Args:
+            handler (:class:`telegram.ext.Handler`): A Handler instance.
+            group (:obj:`object`, optional): The group identifier. Default is 0.
+
+        """
+        if handler in self.handlers[group]:
+            self.handlers[group].remove(handler)
+            if not self.handlers[group]:
+                del self.handlers[group]
+                self.groups.remove(group)
+
+    def add_error_handler(self, callback):
+        """Registers an error handler in the Dispatcher.
+
+        Args:
+            callback (:obj:`callable`): A function that takes ``Bot, Update, TelegramError`` as
+                arguments.
+
+        """
+        self.error_handlers.append(callback)
+
+    def remove_error_handler(self, callback):
+        """Removes an error handler.
+
+        Args:
+            callback (:obj:`callable`): The error handler to remove.
+
+        """
+        if callback in self.error_handlers:
+            self.error_handlers.remove(callback)
+
+    def dispatch_error(self, update, error):
+        """Dispatches an error.
+
+        Args:
+            update (:obj:`str` | :class:`telegram.Update` | None): The update that caused the error
+            error (:class:`telegram.TelegramError`): The Telegram error that was raised.
+
+        """
+        if self.error_handlers:
+            for callback in self.error_handlers:
+                callback(self.bot, update, error)
+
+        else:
+            self.logger.exception(
+                'No error handlers are registered, logging exception...', exc_info=error)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/handler.py` & `python-telegram-bot-9.0.0/telegram/ext/handler.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,125 +1,125 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the base class for handlers as used by the Dispatcher."""
-
-
-class Handler(object):
-    """The base class for all update handlers. Create custom handlers by inheriting from it.
-
-    Attributes:
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-
-    """
-
-    def __init__(self,
-                 callback,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pass_user_data=False,
-                 pass_chat_data=False):
-        self.callback = callback
-        self.pass_update_queue = pass_update_queue
-        self.pass_job_queue = pass_job_queue
-        self.pass_user_data = pass_user_data
-        self.pass_chat_data = pass_chat_data
-
-    def check_update(self, update):
-        """
-        This method is called to determine if an update should be handled by
-        this handler instance. It should always be overridden.
-
-        Args:
-            update (:obj:`str` | :class:`telegram.Update`): The update to be tested.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        raise NotImplementedError
-
-    def handle_update(self, update, dispatcher):
-        """
-        This method is called if it was determined that an update should indeed
-        be handled by this instance. It should also be overridden, but in most
-        cases call ``self.callback(dispatcher.bot, update)``, possibly along with
-        optional arguments. To work with the ``ConversationHandler``, this method should return the
-        value returned from ``self.callback``
-
-        Args:
-            update (:obj:`str` | :class:`telegram.Update`): The update to be handled.
-            dispatcher (:class:`telegram.ext.Dispatcher`): The dispatcher to collect optional args.
-
-        """
-        raise NotImplementedError
-
-    def collect_optional_args(self, dispatcher, update=None):
-        """Prepares the optional arguments that are the same for all types of handlers.
-
-        Args:
-            dispatcher (:class:`telegram.ext.Dispatcher`): The dispatcher.
-
-        """
-        optional_args = dict()
-
-        if self.pass_update_queue:
-            optional_args['update_queue'] = dispatcher.update_queue
-        if self.pass_job_queue:
-            optional_args['job_queue'] = dispatcher.job_queue
-        if self.pass_user_data or self.pass_chat_data:
-            chat = update.effective_chat
-            user = update.effective_user
-
-            if self.pass_user_data:
-                optional_args['user_data'] = dispatcher.user_data[user.id if user else None]
-
-            if self.pass_chat_data:
-                optional_args['chat_data'] = dispatcher.chat_data[chat.id if chat else None]
-
-        return optional_args
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the base class for handlers as used by the Dispatcher."""
+
+
+class Handler(object):
+    """The base class for all update handlers. Create custom handlers by inheriting from it.
+
+    Attributes:
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+
+    """
+
+    def __init__(self,
+                 callback,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pass_user_data=False,
+                 pass_chat_data=False):
+        self.callback = callback
+        self.pass_update_queue = pass_update_queue
+        self.pass_job_queue = pass_job_queue
+        self.pass_user_data = pass_user_data
+        self.pass_chat_data = pass_chat_data
+
+    def check_update(self, update):
+        """
+        This method is called to determine if an update should be handled by
+        this handler instance. It should always be overridden.
+
+        Args:
+            update (:obj:`str` | :class:`telegram.Update`): The update to be tested.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        raise NotImplementedError
+
+    def handle_update(self, update, dispatcher):
+        """
+        This method is called if it was determined that an update should indeed
+        be handled by this instance. It should also be overridden, but in most
+        cases call ``self.callback(dispatcher.bot, update)``, possibly along with
+        optional arguments. To work with the ``ConversationHandler``, this method should return the
+        value returned from ``self.callback``
+
+        Args:
+            update (:obj:`str` | :class:`telegram.Update`): The update to be handled.
+            dispatcher (:class:`telegram.ext.Dispatcher`): The dispatcher to collect optional args.
+
+        """
+        raise NotImplementedError
+
+    def collect_optional_args(self, dispatcher, update=None):
+        """Prepares the optional arguments that are the same for all types of handlers.
+
+        Args:
+            dispatcher (:class:`telegram.ext.Dispatcher`): The dispatcher.
+
+        """
+        optional_args = dict()
+
+        if self.pass_update_queue:
+            optional_args['update_queue'] = dispatcher.update_queue
+        if self.pass_job_queue:
+            optional_args['job_queue'] = dispatcher.job_queue
+        if self.pass_user_data or self.pass_chat_data:
+            chat = update.effective_chat
+            user = update.effective_user
+
+            if self.pass_user_data:
+                optional_args['user_data'] = dispatcher.user_data[user.id if user else None]
+
+            if self.pass_chat_data:
+                optional_args['chat_data'] = dispatcher.chat_data[chat.id if chat else None]
+
+        return optional_args
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/inlinequeryhandler.py` & `python-telegram-bot-9.0.0/telegram/ext/callbackqueryhandler.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,149 +1,143 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-""" This module contains the InlineQueryHandler class """
-import re
-
-from future.utils import string_types
-
-from telegram import Update
-from telegram.utils.deprecate import deprecate
-from .handler import Handler
-
-
-class InlineQueryHandler(Handler):
-    """
-    Handler class to handle Telegram inline queries. Optionally based on a regex. Read the
-    documentation of the ``re`` module for more information.
-
-    Attributes:
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pattern (:obj:`str` | :obj:`Pattern`): Optional. Regex pattern to test
-            :attr:`telegram.InlineQuery.query` against.
-        pass_groups (:obj:`bool`): Optional. Determines whether ``groups`` will be passed to the
-            callback function.
-        pass_groupdict (:obj:`bool`): Optional. Determines whether ``groupdict``. will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pattern (:obj:`str` | :obj:`Pattern`, optional): Regex pattern. If not ``None``,
-            ``re.match`` is used on :attr:`telegram.InlineQuery.query` to determine if an update
-            should be handled by this handler.
-        pass_groups (:obj:`bool`, optional): If the callback should be passed the result of
-            ``re.match(pattern, data).groups()`` as a keyword argument called ``groups``.
-            Default is ``False``
-        pass_groupdict (:obj:`bool`, optional): If the callback should be passed the result of
-            ``re.match(pattern, data).groupdict()`` as a keyword argument called ``groupdict``.
-            Default is ``False``
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-    """
-
-    def __init__(self,
-                 callback,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pattern=None,
-                 pass_groups=False,
-                 pass_groupdict=False,
-                 pass_user_data=False,
-                 pass_chat_data=False):
-        super(InlineQueryHandler, self).__init__(
-            callback,
-            pass_update_queue=pass_update_queue,
-            pass_job_queue=pass_job_queue,
-            pass_user_data=pass_user_data,
-            pass_chat_data=pass_chat_data)
-
-        if isinstance(pattern, string_types):
-            pattern = re.compile(pattern)
-
-        self.pattern = pattern
-        self.pass_groups = pass_groups
-        self.pass_groupdict = pass_groupdict
-
-    def check_update(self, update):
-        """
-        Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-        """
-
-        if isinstance(update, Update) and update.inline_query:
-            if self.pattern:
-                if update.inline_query.query:
-                    match = re.match(self.pattern, update.inline_query.query)
-                    return bool(match)
-            else:
-                return True
-
-    def handle_update(self, update, dispatcher):
-        """
-        Send the update to the :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-        """
-
-        optional_args = self.collect_optional_args(dispatcher, update)
-        if self.pattern:
-            match = re.match(self.pattern, update.inline_query.query)
-
-            if self.pass_groups:
-                optional_args['groups'] = match.groups()
-            if self.pass_groupdict:
-                optional_args['groupdict'] = match.groupdict()
-
-        return self.callback(dispatcher.bot, update, **optional_args)
-
-    # old non-PEP8 Handler methods
-    m = "telegram.InlineQueryHandler."
-    checkUpdate = deprecate(check_update, m + "checkUpdate", m + "check_update")
-    handleUpdate = deprecate(handle_update, m + "handleUpdate", m + "handle_update")
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the CallbackQueryHandler class."""
+
+import re
+
+from future.utils import string_types
+
+from telegram import Update
+from .handler import Handler
+
+
+class CallbackQueryHandler(Handler):
+    """Handler class to handle Telegram callback queries. Optionally based on a regex.
+
+    Read the documentation of the ``re`` module for more information.
+
+    Attributes:
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pattern (:obj:`str` | `Pattern`): Optional. Regex pattern to test
+            :attr:`telegram.CallbackQuery.data` against.
+        pass_groups (:obj:`bool`): Optional. Determines whether ``groups`` will be passed to the
+            callback function.
+        pass_groupdict (:obj:`bool`): Optional. Determines whether ``groupdict``. will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pattern (:obj:`str` | `Pattern`, optional): Regex pattern. If not ``None``, ``re.match``
+            is used on :attr:`telegram.CallbackQuery.data` to determine if an update should be
+            handled by this handler.
+        pass_groups (:obj:`bool`, optional): If the callback should be passed the result of
+            ``re.match(pattern, data).groups()`` as a keyword argument called ``groups``.
+            Default is ``False``
+        pass_groupdict (:obj:`bool`, optional): If the callback should be passed the result of
+            ``re.match(pattern, data).groupdict()`` as a keyword argument called ``groupdict``.
+            Default is ``False``
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+
+    """
+
+    def __init__(self,
+                 callback,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pattern=None,
+                 pass_groups=False,
+                 pass_groupdict=False,
+                 pass_user_data=False,
+                 pass_chat_data=False):
+        super(CallbackQueryHandler, self).__init__(
+            callback,
+            pass_update_queue=pass_update_queue,
+            pass_job_queue=pass_job_queue,
+            pass_user_data=pass_user_data,
+            pass_chat_data=pass_chat_data)
+
+        if isinstance(pattern, string_types):
+            pattern = re.compile(pattern)
+
+        self.pattern = pattern
+        self.pass_groups = pass_groups
+        self.pass_groupdict = pass_groupdict
+
+    def check_update(self, update):
+        """Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        if isinstance(update, Update) and update.callback_query:
+            if self.pattern:
+                if update.callback_query.data:
+                    match = re.match(self.pattern, update.callback_query.data)
+                    return bool(match)
+            else:
+                return True
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+
+        """
+        optional_args = self.collect_optional_args(dispatcher, update)
+        if self.pattern:
+            match = re.match(self.pattern, update.callback_query.data)
+
+            if self.pass_groups:
+                optional_args['groups'] = match.groups()
+            if self.pass_groupdict:
+                optional_args['groupdict'] = match.groupdict()
+
+        return self.callback(dispatcher.bot, update, **optional_args)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/jobqueue.py` & `python-telegram-bot-9.0.0/telegram/ext/jobqueue.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,513 +1,513 @@
-#!/usr/bin/env python
-# flake8: noqa E501
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes JobQueue and Job."""
-
-import logging
-import time
-import warnings
-import datetime
-import weakref
-from numbers import Number
-from threading import Thread, Lock, Event
-from queue import PriorityQueue, Empty
-
-
-class Days(object):
-    MON, TUE, WED, THU, FRI, SAT, SUN = range(7)
-    EVERY_DAY = tuple(range(7))
-
-
-class JobQueue(object):
-    """This class allows you to periodically perform tasks with the bot.
-
-    Attributes:
-        queue (:obj:`PriorityQueue`): The queue that holds the Jobs.
-        bot (:class:`telegram.Bot`): Bot that's send to the handlers.
-
-    Args:
-        bot (:class:`telegram.Bot`): The bot instance that should be passed to the jobs.
-
-    Deprecated:
-        prevent_autostart (:obj:`bool`, optional): Thread does not start during initialisation.
-        Use `start` method instead.
-
-    """
-
-    def __init__(self, bot, prevent_autostart=None):
-        if prevent_autostart is not None:
-            warnings.warn("prevent_autostart is being deprecated, use `start` method instead.")
-
-        self.queue = PriorityQueue()
-        self.bot = bot
-        self.logger = logging.getLogger(self.__class__.__name__)
-        self.__start_lock = Lock()
-        self.__next_peek_lock = Lock()  # to protect self._next_peek & self.__tick
-        self.__tick = Event()
-        self.__thread = None
-        self._next_peek = None
-        self._running = False
-
-    def put(self, job, next_t=None):
-        """Queue a new job.
-
-        Note:
-            This method is deprecated. Please use: :attr:`run_once`, :attr:`run_daily`
-            or :attr:`run_repeating` instead.
-
-        Args:
-            job (:class:`telegram.ext.Job`): The ``Job`` instance representing the new job.
-            next_t (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta` | :obj:`datetime.datetime` | :obj:`datetime.time`, optional):
-                Time in or at which the job should run for the first time. This parameter will
-                be interpreted depending on its type.
-
-                * :obj:`int` or :obj:`float` will be interpreted as "seconds from now" in which the
-                  job should run.
-                * :obj:`datetime.timedelta` will be interpreted as "time from now" in which the
-                  job should run.
-                * :obj:`datetime.datetime` will be interpreted as a specific date and time at
-                  which the job should run.
-                * :obj:`datetime.time` will be interpreted as a specific time at which the job
-                  should run. This could be either today or, if the time has already passed,
-                  tomorrow.
-
-        """
-
-        warnings.warn("'JobQueue.put' is being deprecated, use 'JobQueue.run_once', "
-                      "'JobQueue.run_daily' or 'JobQueue.run_repeating' instead")
-        if job.job_queue is None:
-            job.job_queue = self
-        self._put(job, next_t=next_t)
-
-    def _put(self, job, next_t=None, last_t=None):
-        if next_t is None:
-            next_t = job.interval
-            if next_t is None:
-                raise ValueError('next_t is None')
-
-        if isinstance(next_t, datetime.datetime):
-            next_t = (next_t - datetime.datetime.now()).total_seconds()
-
-        elif isinstance(next_t, datetime.time):
-            next_datetime = datetime.datetime.combine(datetime.date.today(), next_t)
-
-            if datetime.datetime.now().time() > next_t:
-                next_datetime += datetime.timedelta(days=1)
-
-            next_t = (next_datetime - datetime.datetime.now()).total_seconds()
-
-        elif isinstance(next_t, datetime.timedelta):
-            next_t = next_t.total_seconds()
-
-        next_t += last_t or time.time()
-
-        self.logger.debug('Putting job %s with t=%f', job.name, next_t)
-
-        self.queue.put((next_t, job))
-
-        # Wake up the loop if this job should be executed next
-        self._set_next_peek(next_t)
-
-    def run_once(self, callback, when, context=None, name=None):
-        """Creates a new ``Job`` that runs once and adds it to the queue.
-
-        Args:
-            callback (:obj:`callable`): The callback function that should be executed by the new
-                job. It should take ``bot, job`` as parameters, where ``job`` is the
-                :class:`telegram.ext.Job` instance. It can be used to access it's
-                ``job.context`` or change it to a repeating job.
-            when (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta` | :obj:`datetime.datetime` | :obj:`datetime.time`):
-                Time in or at which the job should run. This parameter will be interpreted
-                depending on its type.
-
-                * :obj:`int` or :obj:`float` will be interpreted as "seconds from now" in which the
-                  job should run.
-                * :obj:`datetime.timedelta` will be interpreted as "time from now" in which the
-                  job should run.
-                * :obj:`datetime.datetime` will be interpreted as a specific date and time at
-                  which the job should run.
-                * :obj:`datetime.time` will be interpreted as a specific time of day at which the
-                  job should run. This could be either today or, if the time has already passed,
-                  tomorrow.
-
-            context (:obj:`object`, optional): Additional data needed for the callback function.
-                Can be accessed through ``job.context`` in the callback. Defaults to ``None``.
-            name (:obj:`str`, optional): The name of the new job. Defaults to
-                ``callback.__name__``.
-
-        Returns:
-            :class:`telegram.ext.Job`: The new ``Job`` instance that has been added to the job
-            queue.
-
-        """
-        job = Job(callback, repeat=False, context=context, name=name, job_queue=self)
-        self._put(job, next_t=when)
-        return job
-
-    def run_repeating(self, callback, interval, first=None, context=None, name=None):
-        """Creates a new ``Job`` that runs once and adds it to the queue.
-
-        Args:
-            callback (:obj:`callable`): The callback function that should be executed by the new
-                job. It should take ``bot, job`` as parameters, where ``job`` is the
-                :class:`telegram.ext.Job` instance. It can be used to access it's
-                ``Job.context`` or change it to a repeating job.
-            interval (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta`): The interval in which
-                the job will run. If it is an :obj:`int` or a :obj:`float`, it will be interpreted
-                as seconds.
-            first (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta` | :obj:`datetime.datetime` | :obj:`datetime.time`, optional):
-                Time in or at which the job should run. This parameter will be interpreted
-                depending on its type.
-
-                * :obj:`int` or :obj:`float` will be interpreted as "seconds from now" in which the
-                  job should run.
-                * :obj:`datetime.timedelta` will be interpreted as "time from now" in which the
-                  job should run.
-                * :obj:`datetime.datetime` will be interpreted as a specific date and time at
-                  which the job should run.
-                * :obj:`datetime.time` will be interpreted as a specific time of day at which the
-                  job should run. This could be either today or, if the time has already passed,
-                  tomorrow.
-
-                Defaults to ``interval``
-            context (:obj:`object`, optional): Additional data needed for the callback function.
-                Can be accessed through ``job.context`` in the callback. Defaults to ``None``.
-            name (:obj:`str`, optional): The name of the new job. Defaults to
-                ``callback.__name__``.
-
-        Returns:
-            :class:`telegram.ext.Job`: The new ``Job`` instance that has been added to the job
-            queue.
-
-        """
-
-        job = Job(callback,
-                  interval=interval,
-                  repeat=True,
-                  context=context,
-                  name=name,
-                  job_queue=self)
-        self._put(job, next_t=first)
-        return job
-
-    def run_daily(self, callback, time, days=Days.EVERY_DAY, context=None, name=None):
-        """Creates a new ``Job`` that runs once and adds it to the queue.
-
-        Args:
-            callback (:obj:`callable`): The callback function that should be executed by the new
-                job. It should take ``bot, job`` as parameters, where ``job`` is the
-                :class:`telegram.ext.Job` instance. It can be used to access it's ``Job.context``
-                or change it to a repeating job.
-            time (:obj:`datetime.time`): Time of day at which the job should run.
-            days (Tuple[:obj:`int`], optional): Defines on which days of the week the job should
-                run. Defaults to ``EVERY_DAY``
-            context (:obj:`object`, optional): Additional data needed for the callback function.
-                Can be accessed through ``job.context`` in the callback. Defaults to ``None``.
-            name (:obj:`str`, optional): The name of the new job. Defaults to
-                ``callback.__name__``.
-
-        Returns:
-            :class:`telegram.ext.Job`: The new ``Job`` instance that has been added to the job
-            queue.
-
-        """
-
-        job = Job(callback,
-                  interval=datetime.timedelta(days=1),
-                  repeat=True,
-                  days=days,
-                  context=context,
-                  name=name,
-                  job_queue=self)
-        self._put(job, next_t=time)
-        return job
-
-    def _set_next_peek(self, t):
-        # """
-        # Set next peek if not defined or `t` is before next peek.
-        # In case the next peek was set, also trigger the `self.__tick` event.
-        # """
-        with self.__next_peek_lock:
-            if not self._next_peek or self._next_peek > t:
-                self._next_peek = t
-                self.__tick.set()
-
-    def tick(self):
-        """Run all jobs that are due and re-enqueue them with their interval."""
-
-        now = time.time()
-
-        self.logger.debug('Ticking jobs with t=%f', now)
-
-        while True:
-            try:
-                t, job = self.queue.get(False)
-            except Empty:
-                break
-
-            self.logger.debug('Peeked at %s with t=%f', job.name, t)
-
-            if t > now:
-                # We can get here in two conditions:
-                # 1. At the second or later pass of the while loop, after we've already
-                #    processed the job(s) we were supposed to at this time.
-                # 2. At the first iteration of the loop only if `self.put()` had triggered
-                #    `self.__tick` because `self._next_peek` wasn't set
-                self.logger.debug("Next task isn't due yet. Finished!")
-                self.queue.put((t, job))
-                self._set_next_peek(t)
-                break
-
-            if job.removed:
-                self.logger.debug('Removing job %s', job.name)
-                continue
-
-            if job.enabled:
-                try:
-                    current_week_day = datetime.datetime.now().weekday()
-                    if any(day == current_week_day for day in job.days):
-                        self.logger.debug('Running job %s', job.name)
-                        job.run(self.bot)
-
-                except:
-                    self.logger.exception('An uncaught error was raised while executing job %s',
-                                          job.name)
-            else:
-                self.logger.debug('Skipping disabled job %s', job.name)
-
-            if job.repeat and not job.removed:
-                self._put(job, last_t=t)
-            else:
-                self.logger.debug('Dropping non-repeating or removed job %s', job.name)
-
-    def start(self):
-        """Starts the job_queue thread."""
-
-        self.__start_lock.acquire()
-
-        if not self._running:
-            self._running = True
-            self.__start_lock.release()
-            self.__thread = Thread(target=self._main_loop, name="job_queue")
-            self.__thread.start()
-            self.logger.debug('%s thread started', self.__class__.__name__)
-        else:
-            self.__start_lock.release()
-
-    def _main_loop(self):
-        """
-        Thread target of thread ``job_queue``. Runs in background and performs ticks on the job
-        queue.
-
-        """
-        while self._running:
-            # self._next_peek may be (re)scheduled during self.tick() or self.put()
-            with self.__next_peek_lock:
-                tmout = self._next_peek - time.time() if self._next_peek else None
-                self._next_peek = None
-                self.__tick.clear()
-
-            self.__tick.wait(tmout)
-
-            # If we were woken up by self.stop(), just bail out
-            if not self._running:
-                break
-
-            self.tick()
-
-        self.logger.debug('%s thread stopped', self.__class__.__name__)
-
-    def stop(self):
-        """Stops the thread."""
-
-        with self.__start_lock:
-            self._running = False
-
-        self.__tick.set()
-        if self.__thread is not None:
-            self.__thread.join()
-
-    def jobs(self):
-        """Returns a tuple of all jobs that are currently in the ``JobQueue``."""
-
-        return tuple(job[1] for job in self.queue.queue if job)
-
-
-class Job(object):
-    """This class encapsulates a Job.
-
-    Attributes:
-        callback (:obj:`callable`): The callback function that should be executed by the new job.
-        context (:obj:`object`): Optional. Additional data needed for the callback function.
-        name (:obj:`str`): Optional. The name of the new job.
-
-    Args:
-        callback (:obj:`callable`): The callback function that should be executed by the new job.
-            It should take ``bot, job`` as parameters, where ``job`` is the
-            :class:`telegram.ext.Job` instance. It can be used to access it's :attr:`context`
-            or change it to a repeating job.
-        interval (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta`, optional): The interval in
-            which the job will run. If it is an :obj:`int` or a :obj:`float`, it will be
-            interpreted as seconds. If you don't set this value, you must set :attr:`repeat` to
-            ``False`` and specify :attr:`next_t` when you put the job into the job queue.
-        repeat (:obj:`bool`, optional): If this job should be periodically execute its callback
-            function (``True``) or only once (``False``). Defaults to ``True``.
-        context (:obj:`object`, optional): Additional data needed for the callback function. Can be
-            accessed through ``job.context`` in the callback. Defaults to ``None``.
-        name (:obj:`str`, optional): The name of the new job. Defaults to ``callback.__name__``.
-        days (Tuple[:obj:`int`], optional): Defines on which days of the week the job should run.
-            Defaults to ``Days.EVERY_DAY``
-        job_queue (:class:`telegram.ext.JobQueue`, optional): The ``JobQueue`` this job belongs to.
-            Only optional for backward compatibility with ``JobQueue.put()``.
-
-    """
-
-    def __init__(self,
-                 callback,
-                 interval=None,
-                 repeat=True,
-                 context=None,
-                 days=Days.EVERY_DAY,
-                 name=None,
-                 job_queue=None):
-
-        self.callback = callback
-        self.context = context
-        self.name = name or callback.__name__
-
-        self._repeat = repeat
-        self._interval = None
-        self.interval = interval
-        self.repeat = repeat
-
-        self._days = None
-        self.days = days
-
-        self._job_queue = weakref.proxy(job_queue) if job_queue is not None else None
-
-        self._remove = Event()
-        self._enabled = Event()
-        self._enabled.set()
-
-    def run(self, bot):
-        """Executes the callback function."""
-
-        self.callback(bot, self)
-
-    def schedule_removal(self):
-        """
-        Schedules this job for removal from the ``JobQueue``. It will be removed without executing
-        its callback function again.
-
-        """
-
-        self._remove.set()
-
-    @property
-    def removed(self):
-        """:obj:`bool`: Whether this job is due to be removed."""
-        return self._remove.is_set()
-
-    @property
-    def enabled(self):
-        """:obj:`bool`: Whether this job is enabled."""
-        return self._enabled.is_set()
-
-    @enabled.setter
-    def enabled(self, status):
-        if status:
-            self._enabled.set()
-        else:
-            self._enabled.clear()
-
-    @property
-    def interval(self):
-        """
-        :obj:`int` | :obj:`float` | :obj:`datetime.timedelta`: Optional. The interval in which the
-            job will run.
-
-        """
-        return self._interval
-
-    @interval.setter
-    def interval(self, interval):
-        if interval is None and self.repeat:
-            raise ValueError("The 'interval' can not be 'None' when 'repeat' is set to 'True'")
-
-        if not (interval is None or isinstance(interval, (Number, datetime.timedelta))):
-            raise ValueError("The 'interval' must be of type 'datetime.timedelta',"
-                             " 'int' or 'float'")
-
-        self._interval = interval
-
-    @property
-    def interval_seconds(self):
-        """:obj:`int`: The interval for this job in seconds."""
-        if isinstance(self.interval, datetime.timedelta):
-            return self.interval.total_seconds()
-        else:
-            return self.interval
-
-    @property
-    def repeat(self):
-        """:obj:`bool`: Optional. If this job should periodically execute its callback function."""
-        return self._repeat
-
-    @repeat.setter
-    def repeat(self, repeat):
-        if self.interval is None and repeat:
-            raise ValueError("'repeat' can not be set to 'True' when no 'interval' is set")
-        self._repeat = repeat
-
-    @property
-    def days(self):
-        """Tuple[:obj:`int`]: Optional. Defines on which days of the week the job should run."""
-
-        return self._days
-
-    @days.setter
-    def days(self, days):
-        if not isinstance(days, tuple):
-            raise ValueError("The 'days' argument should be of type 'tuple'")
-
-        if not all(isinstance(day, int) for day in days):
-            raise ValueError("The elements of the 'days' argument should be of type 'int'")
-
-        if not all(0 <= day <= 6 for day in days):
-            raise ValueError("The elements of the 'days' argument should be from 0 up to and "
-                             "including 6")
-
-        self._days = days
-
-    @property
-    def job_queue(self):
-        """:class:`telegram.ext.JobQueue`: Optional. The ``JobQueue`` this job belongs to."""
-
-        return self._job_queue
-
-    @job_queue.setter
-    def job_queue(self, job_queue):
-        # Property setter for backward compatibility with JobQueue.put()
-        if not self._job_queue:
-            self._job_queue = weakref.proxy(job_queue)
-        else:
-            raise RuntimeError("The 'job_queue' attribute can only be set once.")
-
-    def __lt__(self, other):
-        return False
+#!/usr/bin/env python
+# flake8: noqa E501
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes JobQueue and Job."""
+
+import logging
+import time
+import warnings
+import datetime
+import weakref
+from numbers import Number
+from threading import Thread, Lock, Event
+from queue import PriorityQueue, Empty
+
+
+class Days(object):
+    MON, TUE, WED, THU, FRI, SAT, SUN = range(7)
+    EVERY_DAY = tuple(range(7))
+
+
+class JobQueue(object):
+    """This class allows you to periodically perform tasks with the bot.
+
+    Attributes:
+        queue (:obj:`PriorityQueue`): The queue that holds the Jobs.
+        bot (:class:`telegram.Bot`): Bot that's send to the handlers.
+
+    Args:
+        bot (:class:`telegram.Bot`): The bot instance that should be passed to the jobs.
+
+    Deprecated:
+        prevent_autostart (:obj:`bool`, optional): Thread does not start during initialisation.
+        Use `start` method instead.
+
+    """
+
+    def __init__(self, bot, prevent_autostart=None):
+        if prevent_autostart is not None:
+            warnings.warn("prevent_autostart is being deprecated, use `start` method instead.")
+
+        self.queue = PriorityQueue()
+        self.bot = bot
+        self.logger = logging.getLogger(self.__class__.__name__)
+        self.__start_lock = Lock()
+        self.__next_peek_lock = Lock()  # to protect self._next_peek & self.__tick
+        self.__tick = Event()
+        self.__thread = None
+        self._next_peek = None
+        self._running = False
+
+    def put(self, job, next_t=None):
+        """Queue a new job.
+
+        Note:
+            This method is deprecated. Please use: :attr:`run_once`, :attr:`run_daily`
+            or :attr:`run_repeating` instead.
+
+        Args:
+            job (:class:`telegram.ext.Job`): The ``Job`` instance representing the new job.
+            next_t (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta` | :obj:`datetime.datetime` | :obj:`datetime.time`, optional):
+                Time in or at which the job should run for the first time. This parameter will
+                be interpreted depending on its type.
+
+                * :obj:`int` or :obj:`float` will be interpreted as "seconds from now" in which the
+                  job should run.
+                * :obj:`datetime.timedelta` will be interpreted as "time from now" in which the
+                  job should run.
+                * :obj:`datetime.datetime` will be interpreted as a specific date and time at
+                  which the job should run.
+                * :obj:`datetime.time` will be interpreted as a specific time at which the job
+                  should run. This could be either today or, if the time has already passed,
+                  tomorrow.
+
+        """
+
+        warnings.warn("'JobQueue.put' is being deprecated, use 'JobQueue.run_once', "
+                      "'JobQueue.run_daily' or 'JobQueue.run_repeating' instead")
+        if job.job_queue is None:
+            job.job_queue = self
+        self._put(job, next_t=next_t)
+
+    def _put(self, job, next_t=None, last_t=None):
+        if next_t is None:
+            next_t = job.interval
+            if next_t is None:
+                raise ValueError('next_t is None')
+
+        if isinstance(next_t, datetime.datetime):
+            next_t = (next_t - datetime.datetime.now()).total_seconds()
+
+        elif isinstance(next_t, datetime.time):
+            next_datetime = datetime.datetime.combine(datetime.date.today(), next_t)
+
+            if datetime.datetime.now().time() > next_t:
+                next_datetime += datetime.timedelta(days=1)
+
+            next_t = (next_datetime - datetime.datetime.now()).total_seconds()
+
+        elif isinstance(next_t, datetime.timedelta):
+            next_t = next_t.total_seconds()
+
+        next_t += last_t or time.time()
+
+        self.logger.debug('Putting job %s with t=%f', job.name, next_t)
+
+        self.queue.put((next_t, job))
+
+        # Wake up the loop if this job should be executed next
+        self._set_next_peek(next_t)
+
+    def run_once(self, callback, when, context=None, name=None):
+        """Creates a new ``Job`` that runs once and adds it to the queue.
+
+        Args:
+            callback (:obj:`callable`): The callback function that should be executed by the new
+                job. It should take ``bot, job`` as parameters, where ``job`` is the
+                :class:`telegram.ext.Job` instance. It can be used to access it's
+                ``job.context`` or change it to a repeating job.
+            when (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta` | :obj:`datetime.datetime` | :obj:`datetime.time`):
+                Time in or at which the job should run. This parameter will be interpreted
+                depending on its type.
+
+                * :obj:`int` or :obj:`float` will be interpreted as "seconds from now" in which the
+                  job should run.
+                * :obj:`datetime.timedelta` will be interpreted as "time from now" in which the
+                  job should run.
+                * :obj:`datetime.datetime` will be interpreted as a specific date and time at
+                  which the job should run.
+                * :obj:`datetime.time` will be interpreted as a specific time of day at which the
+                  job should run. This could be either today or, if the time has already passed,
+                  tomorrow.
+
+            context (:obj:`object`, optional): Additional data needed for the callback function.
+                Can be accessed through ``job.context`` in the callback. Defaults to ``None``.
+            name (:obj:`str`, optional): The name of the new job. Defaults to
+                ``callback.__name__``.
+
+        Returns:
+            :class:`telegram.ext.Job`: The new ``Job`` instance that has been added to the job
+            queue.
+
+        """
+        job = Job(callback, repeat=False, context=context, name=name, job_queue=self)
+        self._put(job, next_t=when)
+        return job
+
+    def run_repeating(self, callback, interval, first=None, context=None, name=None):
+        """Creates a new ``Job`` that runs once and adds it to the queue.
+
+        Args:
+            callback (:obj:`callable`): The callback function that should be executed by the new
+                job. It should take ``bot, job`` as parameters, where ``job`` is the
+                :class:`telegram.ext.Job` instance. It can be used to access it's
+                ``Job.context`` or change it to a repeating job.
+            interval (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta`): The interval in which
+                the job will run. If it is an :obj:`int` or a :obj:`float`, it will be interpreted
+                as seconds.
+            first (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta` | :obj:`datetime.datetime` | :obj:`datetime.time`, optional):
+                Time in or at which the job should run. This parameter will be interpreted
+                depending on its type.
+
+                * :obj:`int` or :obj:`float` will be interpreted as "seconds from now" in which the
+                  job should run.
+                * :obj:`datetime.timedelta` will be interpreted as "time from now" in which the
+                  job should run.
+                * :obj:`datetime.datetime` will be interpreted as a specific date and time at
+                  which the job should run.
+                * :obj:`datetime.time` will be interpreted as a specific time of day at which the
+                  job should run. This could be either today or, if the time has already passed,
+                  tomorrow.
+
+                Defaults to ``interval``
+            context (:obj:`object`, optional): Additional data needed for the callback function.
+                Can be accessed through ``job.context`` in the callback. Defaults to ``None``.
+            name (:obj:`str`, optional): The name of the new job. Defaults to
+                ``callback.__name__``.
+
+        Returns:
+            :class:`telegram.ext.Job`: The new ``Job`` instance that has been added to the job
+            queue.
+
+        """
+
+        job = Job(callback,
+                  interval=interval,
+                  repeat=True,
+                  context=context,
+                  name=name,
+                  job_queue=self)
+        self._put(job, next_t=first)
+        return job
+
+    def run_daily(self, callback, time, days=Days.EVERY_DAY, context=None, name=None):
+        """Creates a new ``Job`` that runs once and adds it to the queue.
+
+        Args:
+            callback (:obj:`callable`): The callback function that should be executed by the new
+                job. It should take ``bot, job`` as parameters, where ``job`` is the
+                :class:`telegram.ext.Job` instance. It can be used to access it's ``Job.context``
+                or change it to a repeating job.
+            time (:obj:`datetime.time`): Time of day at which the job should run.
+            days (Tuple[:obj:`int`], optional): Defines on which days of the week the job should
+                run. Defaults to ``EVERY_DAY``
+            context (:obj:`object`, optional): Additional data needed for the callback function.
+                Can be accessed through ``job.context`` in the callback. Defaults to ``None``.
+            name (:obj:`str`, optional): The name of the new job. Defaults to
+                ``callback.__name__``.
+
+        Returns:
+            :class:`telegram.ext.Job`: The new ``Job`` instance that has been added to the job
+            queue.
+
+        """
+
+        job = Job(callback,
+                  interval=datetime.timedelta(days=1),
+                  repeat=True,
+                  days=days,
+                  context=context,
+                  name=name,
+                  job_queue=self)
+        self._put(job, next_t=time)
+        return job
+
+    def _set_next_peek(self, t):
+        # """
+        # Set next peek if not defined or `t` is before next peek.
+        # In case the next peek was set, also trigger the `self.__tick` event.
+        # """
+        with self.__next_peek_lock:
+            if not self._next_peek or self._next_peek > t:
+                self._next_peek = t
+                self.__tick.set()
+
+    def tick(self):
+        """Run all jobs that are due and re-enqueue them with their interval."""
+
+        now = time.time()
+
+        self.logger.debug('Ticking jobs with t=%f', now)
+
+        while True:
+            try:
+                t, job = self.queue.get(False)
+            except Empty:
+                break
+
+            self.logger.debug('Peeked at %s with t=%f', job.name, t)
+
+            if t > now:
+                # We can get here in two conditions:
+                # 1. At the second or later pass of the while loop, after we've already
+                #    processed the job(s) we were supposed to at this time.
+                # 2. At the first iteration of the loop only if `self.put()` had triggered
+                #    `self.__tick` because `self._next_peek` wasn't set
+                self.logger.debug("Next task isn't due yet. Finished!")
+                self.queue.put((t, job))
+                self._set_next_peek(t)
+                break
+
+            if job.removed:
+                self.logger.debug('Removing job %s', job.name)
+                continue
+
+            if job.enabled:
+                try:
+                    current_week_day = datetime.datetime.now().weekday()
+                    if any(day == current_week_day for day in job.days):
+                        self.logger.debug('Running job %s', job.name)
+                        job.run(self.bot)
+
+                except:
+                    self.logger.exception('An uncaught error was raised while executing job %s',
+                                          job.name)
+            else:
+                self.logger.debug('Skipping disabled job %s', job.name)
+
+            if job.repeat and not job.removed:
+                self._put(job, last_t=t)
+            else:
+                self.logger.debug('Dropping non-repeating or removed job %s', job.name)
+
+    def start(self):
+        """Starts the job_queue thread."""
+
+        self.__start_lock.acquire()
+
+        if not self._running:
+            self._running = True
+            self.__start_lock.release()
+            self.__thread = Thread(target=self._main_loop, name="job_queue")
+            self.__thread.start()
+            self.logger.debug('%s thread started', self.__class__.__name__)
+        else:
+            self.__start_lock.release()
+
+    def _main_loop(self):
+        """
+        Thread target of thread ``job_queue``. Runs in background and performs ticks on the job
+        queue.
+
+        """
+        while self._running:
+            # self._next_peek may be (re)scheduled during self.tick() or self.put()
+            with self.__next_peek_lock:
+                tmout = self._next_peek - time.time() if self._next_peek else None
+                self._next_peek = None
+                self.__tick.clear()
+
+            self.__tick.wait(tmout)
+
+            # If we were woken up by self.stop(), just bail out
+            if not self._running:
+                break
+
+            self.tick()
+
+        self.logger.debug('%s thread stopped', self.__class__.__name__)
+
+    def stop(self):
+        """Stops the thread."""
+
+        with self.__start_lock:
+            self._running = False
+
+        self.__tick.set()
+        if self.__thread is not None:
+            self.__thread.join()
+
+    def jobs(self):
+        """Returns a tuple of all jobs that are currently in the ``JobQueue``."""
+
+        return tuple(job[1] for job in self.queue.queue if job)
+
+
+class Job(object):
+    """This class encapsulates a Job.
+
+    Attributes:
+        callback (:obj:`callable`): The callback function that should be executed by the new job.
+        context (:obj:`object`): Optional. Additional data needed for the callback function.
+        name (:obj:`str`): Optional. The name of the new job.
+
+    Args:
+        callback (:obj:`callable`): The callback function that should be executed by the new job.
+            It should take ``bot, job`` as parameters, where ``job`` is the
+            :class:`telegram.ext.Job` instance. It can be used to access it's :attr:`context`
+            or change it to a repeating job.
+        interval (:obj:`int` | :obj:`float` | :obj:`datetime.timedelta`, optional): The interval in
+            which the job will run. If it is an :obj:`int` or a :obj:`float`, it will be
+            interpreted as seconds. If you don't set this value, you must set :attr:`repeat` to
+            ``False`` and specify :attr:`next_t` when you put the job into the job queue.
+        repeat (:obj:`bool`, optional): If this job should be periodically execute its callback
+            function (``True``) or only once (``False``). Defaults to ``True``.
+        context (:obj:`object`, optional): Additional data needed for the callback function. Can be
+            accessed through ``job.context`` in the callback. Defaults to ``None``.
+        name (:obj:`str`, optional): The name of the new job. Defaults to ``callback.__name__``.
+        days (Tuple[:obj:`int`], optional): Defines on which days of the week the job should run.
+            Defaults to ``Days.EVERY_DAY``
+        job_queue (:class:`telegram.ext.JobQueue`, optional): The ``JobQueue`` this job belongs to.
+            Only optional for backward compatibility with ``JobQueue.put()``.
+
+    """
+
+    def __init__(self,
+                 callback,
+                 interval=None,
+                 repeat=True,
+                 context=None,
+                 days=Days.EVERY_DAY,
+                 name=None,
+                 job_queue=None):
+
+        self.callback = callback
+        self.context = context
+        self.name = name or callback.__name__
+
+        self._repeat = repeat
+        self._interval = None
+        self.interval = interval
+        self.repeat = repeat
+
+        self._days = None
+        self.days = days
+
+        self._job_queue = weakref.proxy(job_queue) if job_queue is not None else None
+
+        self._remove = Event()
+        self._enabled = Event()
+        self._enabled.set()
+
+    def run(self, bot):
+        """Executes the callback function."""
+
+        self.callback(bot, self)
+
+    def schedule_removal(self):
+        """
+        Schedules this job for removal from the ``JobQueue``. It will be removed without executing
+        its callback function again.
+
+        """
+
+        self._remove.set()
+
+    @property
+    def removed(self):
+        """:obj:`bool`: Whether this job is due to be removed."""
+        return self._remove.is_set()
+
+    @property
+    def enabled(self):
+        """:obj:`bool`: Whether this job is enabled."""
+        return self._enabled.is_set()
+
+    @enabled.setter
+    def enabled(self, status):
+        if status:
+            self._enabled.set()
+        else:
+            self._enabled.clear()
+
+    @property
+    def interval(self):
+        """
+        :obj:`int` | :obj:`float` | :obj:`datetime.timedelta`: Optional. The interval in which the
+            job will run.
+
+        """
+        return self._interval
+
+    @interval.setter
+    def interval(self, interval):
+        if interval is None and self.repeat:
+            raise ValueError("The 'interval' can not be 'None' when 'repeat' is set to 'True'")
+
+        if not (interval is None or isinstance(interval, (Number, datetime.timedelta))):
+            raise ValueError("The 'interval' must be of type 'datetime.timedelta',"
+                             " 'int' or 'float'")
+
+        self._interval = interval
+
+    @property
+    def interval_seconds(self):
+        """:obj:`int`: The interval for this job in seconds."""
+        if isinstance(self.interval, datetime.timedelta):
+            return self.interval.total_seconds()
+        else:
+            return self.interval
+
+    @property
+    def repeat(self):
+        """:obj:`bool`: Optional. If this job should periodically execute its callback function."""
+        return self._repeat
+
+    @repeat.setter
+    def repeat(self, repeat):
+        if self.interval is None and repeat:
+            raise ValueError("'repeat' can not be set to 'True' when no 'interval' is set")
+        self._repeat = repeat
+
+    @property
+    def days(self):
+        """Tuple[:obj:`int`]: Optional. Defines on which days of the week the job should run."""
+
+        return self._days
+
+    @days.setter
+    def days(self, days):
+        if not isinstance(days, tuple):
+            raise ValueError("The 'days' argument should be of type 'tuple'")
+
+        if not all(isinstance(day, int) for day in days):
+            raise ValueError("The elements of the 'days' argument should be of type 'int'")
+
+        if not all(0 <= day <= 6 for day in days):
+            raise ValueError("The elements of the 'days' argument should be from 0 up to and "
+                             "including 6")
+
+        self._days = days
+
+    @property
+    def job_queue(self):
+        """:class:`telegram.ext.JobQueue`: Optional. The ``JobQueue`` this job belongs to."""
+
+        return self._job_queue
+
+    @job_queue.setter
+    def job_queue(self, job_queue):
+        # Property setter for backward compatibility with JobQueue.put()
+        if not self._job_queue:
+            self._job_queue = weakref.proxy(job_queue)
+        else:
+            raise RuntimeError("The 'job_queue' attribute can only be set once.")
+
+    def __lt__(self, other):
+        return False
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/messagehandler.py` & `python-telegram-bot-9.0.0/telegram/ext/messagehandler.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,169 +1,169 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-# TODO: Remove allow_edited
-"""This module contains the MessageHandler class."""
-import warnings
-
-from telegram import Update
-from .handler import Handler
-
-
-class MessageHandler(Handler):
-    """Handler class to handle telegram messages. They might contain text, media or status updates.
-
-    Attributes:
-        filters (:obj:`Filter`): Only allow updates with these Filters. See
-            :mod:`telegram.ext.filters` for a full list of all available filters.
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-        message_updates (:obj:`bool`): Optional. Should "normal" message updates be handled?
-            Default is ``True``.
-        channel_post_updates (:obj:`bool`): Optional. Should channel posts updates be handled?
-            Default is ``True``.
-        edited_updates (:obj:`bool`): Optional. Should "edited" message updates be handled?
-            Default is ``False``.
-        allow_edited (:obj:`bool`): Optional. If the handler should also accept edited messages.
-            Default is ``False`` - Deprecated. use edited_updates instead.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        filters (:class:`telegram.ext.BaseFilter`, optional): A filter inheriting from
-            :class:`telegram.ext.filters.BaseFilter`. Standard filters can be found in
-            :class:`telegram.ext.filters.Filters`. Filters can be combined using bitwise
-            operators (& for and, | for or, ~ for not).
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-        message_updates (:obj:`bool`, optional): Should "normal" message updates be handled?
-            Default is ``True``.
-        channel_post_updates (:obj:`bool`, optional): Should channel posts updates be handled?
-            Default is ``True``.
-        edited_updates (:obj:`bool`, optional): Should "edited" message updates be handled? Default
-            is ``False``.
-        allow_edited (:obj:`bool`, optional): If the handler should also accept edited messages.
-            Default is ``False`` - Deprecated. use edited_updates instead.
-
-    Raises:
-        ValueError
-
-    """
-
-    def __init__(self,
-                 filters,
-                 callback,
-                 allow_edited=False,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pass_user_data=False,
-                 pass_chat_data=False,
-                 message_updates=True,
-                 channel_post_updates=True,
-                 edited_updates=False):
-        if not message_updates and not channel_post_updates and not edited_updates:
-            raise ValueError(
-                'message_updates, channel_post_updates and edited_updates are all False')
-        if allow_edited:
-            warnings.warn('allow_edited is getting deprecated, please use edited_updates instead')
-            edited_updates = allow_edited
-
-        super(MessageHandler, self).__init__(
-            callback,
-            pass_update_queue=pass_update_queue,
-            pass_job_queue=pass_job_queue,
-            pass_user_data=pass_user_data,
-            pass_chat_data=pass_chat_data)
-        self.filters = filters
-        self.message_updates = message_updates
-        self.channel_post_updates = channel_post_updates
-        self.edited_updates = edited_updates
-
-        # We put this up here instead of with the rest of checking code
-        # in check_update since we don't wanna spam a ton
-        if isinstance(self.filters, list):
-            warnings.warn('Using a list of filters in MessageHandler is getting '
-                          'deprecated, please use bitwise operators (& and |) '
-                          'instead. More info: https://git.io/vPTbc.')
-
-    def _is_allowed_update(self, update):
-        return any([self.message_updates and update.message,
-                    self.edited_updates and (update.edited_message or update.edited_channel_post),
-                    self.channel_post_updates and update.channel_post])
-
-    def check_update(self, update):
-        """Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        if isinstance(update, Update) and self._is_allowed_update(update):
-
-            if not self.filters:
-                res = True
-
-            else:
-                message = update.effective_message
-                if isinstance(self.filters, list):
-                    res = any(func(message) for func in self.filters)
-                else:
-                    res = self.filters(message)
-
-        else:
-            res = False
-
-        return res
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-
-        """
-        optional_args = self.collect_optional_args(dispatcher, update)
-
-        return self.callback(dispatcher.bot, update, **optional_args)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+# TODO: Remove allow_edited
+"""This module contains the MessageHandler class."""
+import warnings
+
+from telegram import Update
+from .handler import Handler
+
+
+class MessageHandler(Handler):
+    """Handler class to handle telegram messages. They might contain text, media or status updates.
+
+    Attributes:
+        filters (:obj:`Filter`): Only allow updates with these Filters. See
+            :mod:`telegram.ext.filters` for a full list of all available filters.
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+        message_updates (:obj:`bool`): Optional. Should "normal" message updates be handled?
+            Default is ``True``.
+        channel_post_updates (:obj:`bool`): Optional. Should channel posts updates be handled?
+            Default is ``True``.
+        edited_updates (:obj:`bool`): Optional. Should "edited" message updates be handled?
+            Default is ``False``.
+        allow_edited (:obj:`bool`): Optional. If the handler should also accept edited messages.
+            Default is ``False`` - Deprecated. use edited_updates instead.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        filters (:class:`telegram.ext.BaseFilter`, optional): A filter inheriting from
+            :class:`telegram.ext.filters.BaseFilter`. Standard filters can be found in
+            :class:`telegram.ext.filters.Filters`. Filters can be combined using bitwise
+            operators (& for and, | for or, ~ for not).
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+        message_updates (:obj:`bool`, optional): Should "normal" message updates be handled?
+            Default is ``True``.
+        channel_post_updates (:obj:`bool`, optional): Should channel posts updates be handled?
+            Default is ``True``.
+        edited_updates (:obj:`bool`, optional): Should "edited" message updates be handled? Default
+            is ``False``.
+        allow_edited (:obj:`bool`, optional): If the handler should also accept edited messages.
+            Default is ``False`` - Deprecated. use edited_updates instead.
+
+    Raises:
+        ValueError
+
+    """
+
+    def __init__(self,
+                 filters,
+                 callback,
+                 allow_edited=False,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pass_user_data=False,
+                 pass_chat_data=False,
+                 message_updates=True,
+                 channel_post_updates=True,
+                 edited_updates=False):
+        if not message_updates and not channel_post_updates and not edited_updates:
+            raise ValueError(
+                'message_updates, channel_post_updates and edited_updates are all False')
+        if allow_edited:
+            warnings.warn('allow_edited is getting deprecated, please use edited_updates instead')
+            edited_updates = allow_edited
+
+        super(MessageHandler, self).__init__(
+            callback,
+            pass_update_queue=pass_update_queue,
+            pass_job_queue=pass_job_queue,
+            pass_user_data=pass_user_data,
+            pass_chat_data=pass_chat_data)
+        self.filters = filters
+        self.message_updates = message_updates
+        self.channel_post_updates = channel_post_updates
+        self.edited_updates = edited_updates
+
+        # We put this up here instead of with the rest of checking code
+        # in check_update since we don't wanna spam a ton
+        if isinstance(self.filters, list):
+            warnings.warn('Using a list of filters in MessageHandler is getting '
+                          'deprecated, please use bitwise operators (& and |) '
+                          'instead. More info: https://git.io/vPTbc.')
+
+    def _is_allowed_update(self, update):
+        return any([self.message_updates and update.message,
+                    self.edited_updates and (update.edited_message or update.edited_channel_post),
+                    self.channel_post_updates and update.channel_post])
+
+    def check_update(self, update):
+        """Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        if isinstance(update, Update) and self._is_allowed_update(update):
+
+            if not self.filters:
+                res = True
+
+            else:
+                message = update.effective_message
+                if isinstance(self.filters, list):
+                    res = any(func(message) for func in self.filters)
+                else:
+                    res = self.filters(message)
+
+        else:
+            res = False
+
+        return res
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+
+        """
+        optional_args = self.collect_optional_args(dispatcher, update)
+
+        return self.callback(dispatcher.bot, update, **optional_args)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/messagequeue.py` & `python-telegram-bot-9.0.0/telegram/ext/messagequeue.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,312 +1,312 @@
-#!/usr/bin/env python
-#
-# Module author:
-# Tymofii A. Khodniev (thodnev) <thodnev@mail.ru>
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/]
-"""A throughput-limiting message processor for Telegram bots."""
-from telegram.utils import promise
-
-import functools
-import sys
-import time
-import threading
-if sys.version_info.major > 2:
-    import queue as q
-else:
-    import Queue as q
-
-# We need to count < 1s intervals, so the most accurate timer is needed
-# Starting from Python 3.3 we have time.perf_counter which is the clock
-#  with the highest resolution available to the system, so let's use it there.
-# In Python 2.7, there's no perf_counter yet, so fallback on what we have:
-#  on Windows, the best available is time.clock while time.time is on
-#  another platforms (M. Lutz, "Learning Python," 4ed, p.630-634)
-if sys.version_info.major == 3 and sys.version_info.minor >= 3:
-    curtime = time.perf_counter  # pylint: disable=E1101
-else:
-    curtime = time.clock if sys.platform[:3] == 'win' else time.time
-
-
-class DelayQueueError(RuntimeError):
-    """Indicates processing errors."""
-    pass
-
-
-class DelayQueue(threading.Thread):
-    """
-    Processes callbacks from queue with specified throughput limits. Creates a separate thread to
-    process callbacks with delays.
-
-    Attributes:
-        burst_limit (:obj:`int`): Number of maximum callbacks to process per time-window.
-        time_limit (:obj:`int`): Defines width of time-window used when each processing limit is
-            calculated.
-        exc_route (:obj:`callable`): A callable, accepting 1 positional argument; used to route
-            exceptions from processor thread to main thread;
-        name (:obj:`str`): Thread's name.
-
-    Args:
-        queue (:obj:`Queue`, optional): Used to pass callbacks to thread. Creates ``Queue``
-            implicitly if not provided.
-        burst_limit (:obj:`int`, optional): Number of maximum callbacks to process per time-window
-            defined by :attr:`time_limit_ms`. Defaults to 30.
-        time_limit_ms (:obj:`int`, optional): Defines width of time-window used when each
-            processing limit is calculated. Defaults to 1000.
-        exc_route (:obj:`callable`, optional): A callable, accepting 1 positional argument; used to
-            route exceptions from processor thread to main thread; is called on `Exception`
-            subclass exceptions. If not provided, exceptions are routed through dummy handler,
-            which re-raises them.
-        autostart (:obj:`bool`, optional): If True, processor is started immediately after object's
-            creation; if ``False``, should be started manually by `start` method. Defaults to True.
-        name (:obj:`str`, optional): Thread's name. Defaults to ``'DelayQueue-N'``, where N is
-            sequential number of object created.
-
-    """
-
-    _instcnt = 0  # instance counter
-
-    def __init__(self,
-                 queue=None,
-                 burst_limit=30,
-                 time_limit_ms=1000,
-                 exc_route=None,
-                 autostart=True,
-                 name=None):
-        self._queue = queue if queue is not None else q.Queue()
-        self.burst_limit = burst_limit
-        self.time_limit = time_limit_ms / 1000
-        self.exc_route = (exc_route if exc_route is not None else self._default_exception_handler)
-        self.__exit_req = False  # flag to gently exit thread
-        self.__class__._instcnt += 1
-        if name is None:
-            name = '%s-%s' % (self.__class__.__name__, self.__class__._instcnt)
-        super(DelayQueue, self).__init__(name=name)
-        self.daemon = False
-        if autostart:  # immediately start processing
-            super(DelayQueue, self).start()
-
-    def run(self):
-        """
-        Do not use the method except for unthreaded testing purposes, the method normally is
-        automatically called by autostart argument.
-
-        """
-
-        times = []  # used to store each callable processing time
-        while True:
-            item = self._queue.get()
-            if self.__exit_req:
-                return  # shutdown thread
-            # delay routine
-            now = curtime()
-            t_delta = now - self.time_limit  # calculate early to improve perf.
-            if times and t_delta > times[-1]:
-                # if last call was before the limit time-window
-                # used to impr. perf. in long-interval calls case
-                times = [now]
-            else:
-                # collect last in current limit time-window
-                times = [t for t in times if t >= t_delta]
-                times.append(now)
-            if len(times) >= self.burst_limit:  # if throughput limit was hit
-                time.sleep(times[1] - t_delta)
-            # finally process one
-            try:
-                func, args, kwargs = item
-                func(*args, **kwargs)
-            except Exception as exc:  # re-route any exceptions
-                self.exc_route(exc)  # to prevent thread exit
-
-    def stop(self, timeout=None):
-        """Used to gently stop processor and shutdown its thread.
-
-        Args:
-            timeout (:obj:`float`): Indicates maximum time to wait for processor to stop and its
-                thread to exit. If timeout exceeds and processor has not stopped, method silently
-                returns. :attr:`is_alive` could be used afterwards to check the actual status.
-                ``timeout`` set to None, blocks until processor is shut down. Defaults to None.
-
-        """
-
-        self.__exit_req = True  # gently request
-        self._queue.put(None)  # put something to unfreeze if frozen
-        super(DelayQueue, self).join(timeout=timeout)
-
-    @staticmethod
-    def _default_exception_handler(exc):
-        """
-        Dummy exception handler which re-raises exception in thread. Could be possibly overwritten
-        by subclasses.
-
-        """
-
-        raise exc
-
-    def __call__(self, func, *args, **kwargs):
-        """Used to process callbacks in throughput-limiting thread through queue.
-
-        Args:
-            func (:obj:`callable`): The actual function (or any callable) that is processed through
-                queue.
-            *args (:obj:`list`): Variable-length `func` arguments.
-            **kwargs (:obj:`dict`): Arbitrary keyword-arguments to `func`.
-
-        """
-
-        if not self.is_alive() or self.__exit_req:
-            raise DelayQueueError('Could not process callback in stopped thread')
-        self._queue.put((func, args, kwargs))
-
-
-# The most straightforward way to implement this is to use 2 sequenital delay
-# queues, like on classic delay chain schematics in electronics.
-# So, message path is:
-# msg --> group delay if group msg, else no delay --> normal msg delay --> out
-# This way OS threading scheduler cares of timings accuracy.
-# (see time.time, time.clock, time.perf_counter, time.sleep @ docs.python.org)
-class MessageQueue(object):
-    """
-    Implements callback processing with proper delays to avoid hitting Telegram's message limits.
-    Contains two ``DelayQueue``, for group and for all messages, interconnected in delay chain.
-    Callables are processed through *group* ``DelayQueue``, then through *all* ``DelayQueue`` for
-    group-type messages. For non-group messages, only the *all* ``DelayQueue`` is used.
-
-    Args:
-        all_burst_limit (:obj:`int`, optional): Number of maximum *all-type* callbacks to process
-            per time-window defined by :attr:`all_time_limit_ms`. Defaults to 30.
-        all_time_limit_ms (:obj:`int`, optional): Defines width of *all-type* time-window used when
-            each processing limit is calculated. Defaults to 1000 ms.
-        group_burst_limit (:obj:`int`, optional): Number of maximum *group-type* callbacks to
-            process per time-window defined by :attr:`group_time_limit_ms`. Defaults to 20.
-        group_time_limit_ms (:obj:`int`, optional): Defines width of *group-type* time-window used
-            when each processing limit is calculated. Defaults to 60000 ms.
-        exc_route (:obj:`callable`, optional): A callable, accepting one positional argument; used
-            to route exceptions from processor threads to main thread; is called on ``Exception``
-            subclass exceptions. If not provided, exceptions are routed through dummy handler,
-            which re-raises them.
-        autostart (:obj:`bool`, optional): If True, processors are started immediately after
-            object's creation; if ``False``, should be started manually by :attr:`start` method.
-            Defaults to ``True``.
-
-    """
-
-    def __init__(self,
-                 all_burst_limit=30,
-                 all_time_limit_ms=1000,
-                 group_burst_limit=20,
-                 group_time_limit_ms=60000,
-                 exc_route=None,
-                 autostart=True):
-        # create accoring delay queues, use composition
-        self._all_delayq = DelayQueue(
-            burst_limit=all_burst_limit,
-            time_limit_ms=all_time_limit_ms,
-            exc_route=exc_route,
-            autostart=autostart)
-        self._group_delayq = DelayQueue(
-            burst_limit=group_burst_limit,
-            time_limit_ms=group_time_limit_ms,
-            exc_route=exc_route,
-            autostart=autostart)
-
-    def start(self):
-        """Method is used to manually start the ``MessageQueue`` processing."""
-        self._all_delayq.start()
-        self._group_delayq.start()
-
-    def stop(self, timeout=None):
-        self._group_delayq.stop(timeout=timeout)
-        self._all_delayq.stop(timeout=timeout)
-
-    stop.__doc__ = DelayQueue.stop.__doc__ or ''  # reuse docsting if any
-
-    def __call__(self, promise, is_group_msg=False):
-        """
-        Processes callables in troughput-limiting queues to avoid hitting limits (specified with
-        :attr:`burst_limit` and :attr:`time_limit`.
-
-        Args:
-            promise (:obj:`callable`): Mainly the ``telegram.utils.promise.Promise`` (see Notes for
-                other callables), that is processed in delay queues.
-            is_group_msg (:obj:`bool`, optional): Defines whether ``promise`` would be processed in
-                group*+*all* ``DelayQueue``s (if set to ``True``), or only through *all*
-                ``DelayQueue`` (if set to ``False``), resulting in needed delays to avoid
-                hitting specified limits. Defaults to ``True``.
-
-        Notes:
-            Method is designed to accept ``telegram.utils.promise.Promise`` as ``promise``
-            argument, but other callables could be used too. For example, lambdas or simple
-            functions could be used to wrap original func to be called with needed args. In that
-            case, be sure that either wrapper func does not raise outside exceptions or the proper
-            :attr:`exc_route` handler is provided.
-
-        Returns:
-            :obj:`callable`: Used as ``promise`` argument.
-
-        """
-
-        if not is_group_msg:  # ignore middle group delay
-            self._all_delayq(promise)
-        else:  # use middle group delay
-            self._group_delayq(self._all_delayq, promise)
-        return promise
-
-
-def queuedmessage(method):
-    """A decorator to be used with :attr:`telegram.Bot` send* methods.
-
-    Note:
-        As it probably wouldn't be a good idea to make this decorator a property, it has been coded
-        as decorator function, so it implies that first positional argument to wrapped MUST be
-        self.
-
-    The next object attributes are used by decorator:
-
-    Attributes:
-        self._is_messages_queued_default (:obj:`bool`): Value to provide class-defaults to
-            ``queued`` kwarg if not provided during wrapped method call.
-        self._msg_queue (:class:`telegram.ext.messagequeue.MessageQueue`): The actual
-            ``MessageQueue`` used to delay outbound messages according to specified time-limits.
-
-    Wrapped method starts accepting the next kwargs:
-
-    Args:
-        queued (:obj:`bool`, optional): If set to ``True``, the ``MessageQueue`` is used to process
-            output messages. Defaults to `self._is_queued_out`.
-        isgroup (:obj:`bool`, optional): If set to ``True``, the message is meant to be group-type
-            (as there's no obvious way to determine its type in other way at the moment).
-            Group-type messages could have additional processing delay according to limits set
-            in `self._out_queue`. Defaults to ``False``.
-
-    Returns:
-        ``telegram.utils.promise.Promise``: In case call is queued or original method's return
-        value if it's not.
-
-    """
-
-    @functools.wraps(method)
-    def wrapped(self, *args, **kwargs):
-        queued = kwargs.pop('queued', self._is_messages_queued_default)
-        isgroup = kwargs.pop('isgroup', False)
-        if queued:
-            prom = promise.Promise(method, (self, ) + args, kwargs)
-            return self._msg_queue(prom, isgroup)
-        return method(self, *args, **kwargs)
-
-    return wrapped
+#!/usr/bin/env python
+#
+# Module author:
+# Tymofii A. Khodniev (thodnev) <thodnev@mail.ru>
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/]
+"""A throughput-limiting message processor for Telegram bots."""
+from telegram.utils import promise
+
+import functools
+import sys
+import time
+import threading
+if sys.version_info.major > 2:
+    import queue as q
+else:
+    import Queue as q
+
+# We need to count < 1s intervals, so the most accurate timer is needed
+# Starting from Python 3.3 we have time.perf_counter which is the clock
+#  with the highest resolution available to the system, so let's use it there.
+# In Python 2.7, there's no perf_counter yet, so fallback on what we have:
+#  on Windows, the best available is time.clock while time.time is on
+#  another platforms (M. Lutz, "Learning Python," 4ed, p.630-634)
+if sys.version_info.major == 3 and sys.version_info.minor >= 3:
+    curtime = time.perf_counter  # pylint: disable=E1101
+else:
+    curtime = time.clock if sys.platform[:3] == 'win' else time.time
+
+
+class DelayQueueError(RuntimeError):
+    """Indicates processing errors."""
+    pass
+
+
+class DelayQueue(threading.Thread):
+    """
+    Processes callbacks from queue with specified throughput limits. Creates a separate thread to
+    process callbacks with delays.
+
+    Attributes:
+        burst_limit (:obj:`int`): Number of maximum callbacks to process per time-window.
+        time_limit (:obj:`int`): Defines width of time-window used when each processing limit is
+            calculated.
+        exc_route (:obj:`callable`): A callable, accepting 1 positional argument; used to route
+            exceptions from processor thread to main thread;
+        name (:obj:`str`): Thread's name.
+
+    Args:
+        queue (:obj:`Queue`, optional): Used to pass callbacks to thread. Creates ``Queue``
+            implicitly if not provided.
+        burst_limit (:obj:`int`, optional): Number of maximum callbacks to process per time-window
+            defined by :attr:`time_limit_ms`. Defaults to 30.
+        time_limit_ms (:obj:`int`, optional): Defines width of time-window used when each
+            processing limit is calculated. Defaults to 1000.
+        exc_route (:obj:`callable`, optional): A callable, accepting 1 positional argument; used to
+            route exceptions from processor thread to main thread; is called on `Exception`
+            subclass exceptions. If not provided, exceptions are routed through dummy handler,
+            which re-raises them.
+        autostart (:obj:`bool`, optional): If True, processor is started immediately after object's
+            creation; if ``False``, should be started manually by `start` method. Defaults to True.
+        name (:obj:`str`, optional): Thread's name. Defaults to ``'DelayQueue-N'``, where N is
+            sequential number of object created.
+
+    """
+
+    _instcnt = 0  # instance counter
+
+    def __init__(self,
+                 queue=None,
+                 burst_limit=30,
+                 time_limit_ms=1000,
+                 exc_route=None,
+                 autostart=True,
+                 name=None):
+        self._queue = queue if queue is not None else q.Queue()
+        self.burst_limit = burst_limit
+        self.time_limit = time_limit_ms / 1000
+        self.exc_route = (exc_route if exc_route is not None else self._default_exception_handler)
+        self.__exit_req = False  # flag to gently exit thread
+        self.__class__._instcnt += 1
+        if name is None:
+            name = '%s-%s' % (self.__class__.__name__, self.__class__._instcnt)
+        super(DelayQueue, self).__init__(name=name)
+        self.daemon = False
+        if autostart:  # immediately start processing
+            super(DelayQueue, self).start()
+
+    def run(self):
+        """
+        Do not use the method except for unthreaded testing purposes, the method normally is
+        automatically called by autostart argument.
+
+        """
+
+        times = []  # used to store each callable processing time
+        while True:
+            item = self._queue.get()
+            if self.__exit_req:
+                return  # shutdown thread
+            # delay routine
+            now = curtime()
+            t_delta = now - self.time_limit  # calculate early to improve perf.
+            if times and t_delta > times[-1]:
+                # if last call was before the limit time-window
+                # used to impr. perf. in long-interval calls case
+                times = [now]
+            else:
+                # collect last in current limit time-window
+                times = [t for t in times if t >= t_delta]
+                times.append(now)
+            if len(times) >= self.burst_limit:  # if throughput limit was hit
+                time.sleep(times[1] - t_delta)
+            # finally process one
+            try:
+                func, args, kwargs = item
+                func(*args, **kwargs)
+            except Exception as exc:  # re-route any exceptions
+                self.exc_route(exc)  # to prevent thread exit
+
+    def stop(self, timeout=None):
+        """Used to gently stop processor and shutdown its thread.
+
+        Args:
+            timeout (:obj:`float`): Indicates maximum time to wait for processor to stop and its
+                thread to exit. If timeout exceeds and processor has not stopped, method silently
+                returns. :attr:`is_alive` could be used afterwards to check the actual status.
+                ``timeout`` set to None, blocks until processor is shut down. Defaults to None.
+
+        """
+
+        self.__exit_req = True  # gently request
+        self._queue.put(None)  # put something to unfreeze if frozen
+        super(DelayQueue, self).join(timeout=timeout)
+
+    @staticmethod
+    def _default_exception_handler(exc):
+        """
+        Dummy exception handler which re-raises exception in thread. Could be possibly overwritten
+        by subclasses.
+
+        """
+
+        raise exc
+
+    def __call__(self, func, *args, **kwargs):
+        """Used to process callbacks in throughput-limiting thread through queue.
+
+        Args:
+            func (:obj:`callable`): The actual function (or any callable) that is processed through
+                queue.
+            *args (:obj:`list`): Variable-length `func` arguments.
+            **kwargs (:obj:`dict`): Arbitrary keyword-arguments to `func`.
+
+        """
+
+        if not self.is_alive() or self.__exit_req:
+            raise DelayQueueError('Could not process callback in stopped thread')
+        self._queue.put((func, args, kwargs))
+
+
+# The most straightforward way to implement this is to use 2 sequenital delay
+# queues, like on classic delay chain schematics in electronics.
+# So, message path is:
+# msg --> group delay if group msg, else no delay --> normal msg delay --> out
+# This way OS threading scheduler cares of timings accuracy.
+# (see time.time, time.clock, time.perf_counter, time.sleep @ docs.python.org)
+class MessageQueue(object):
+    """
+    Implements callback processing with proper delays to avoid hitting Telegram's message limits.
+    Contains two ``DelayQueue``, for group and for all messages, interconnected in delay chain.
+    Callables are processed through *group* ``DelayQueue``, then through *all* ``DelayQueue`` for
+    group-type messages. For non-group messages, only the *all* ``DelayQueue`` is used.
+
+    Args:
+        all_burst_limit (:obj:`int`, optional): Number of maximum *all-type* callbacks to process
+            per time-window defined by :attr:`all_time_limit_ms`. Defaults to 30.
+        all_time_limit_ms (:obj:`int`, optional): Defines width of *all-type* time-window used when
+            each processing limit is calculated. Defaults to 1000 ms.
+        group_burst_limit (:obj:`int`, optional): Number of maximum *group-type* callbacks to
+            process per time-window defined by :attr:`group_time_limit_ms`. Defaults to 20.
+        group_time_limit_ms (:obj:`int`, optional): Defines width of *group-type* time-window used
+            when each processing limit is calculated. Defaults to 60000 ms.
+        exc_route (:obj:`callable`, optional): A callable, accepting one positional argument; used
+            to route exceptions from processor threads to main thread; is called on ``Exception``
+            subclass exceptions. If not provided, exceptions are routed through dummy handler,
+            which re-raises them.
+        autostart (:obj:`bool`, optional): If True, processors are started immediately after
+            object's creation; if ``False``, should be started manually by :attr:`start` method.
+            Defaults to ``True``.
+
+    """
+
+    def __init__(self,
+                 all_burst_limit=30,
+                 all_time_limit_ms=1000,
+                 group_burst_limit=20,
+                 group_time_limit_ms=60000,
+                 exc_route=None,
+                 autostart=True):
+        # create accoring delay queues, use composition
+        self._all_delayq = DelayQueue(
+            burst_limit=all_burst_limit,
+            time_limit_ms=all_time_limit_ms,
+            exc_route=exc_route,
+            autostart=autostart)
+        self._group_delayq = DelayQueue(
+            burst_limit=group_burst_limit,
+            time_limit_ms=group_time_limit_ms,
+            exc_route=exc_route,
+            autostart=autostart)
+
+    def start(self):
+        """Method is used to manually start the ``MessageQueue`` processing."""
+        self._all_delayq.start()
+        self._group_delayq.start()
+
+    def stop(self, timeout=None):
+        self._group_delayq.stop(timeout=timeout)
+        self._all_delayq.stop(timeout=timeout)
+
+    stop.__doc__ = DelayQueue.stop.__doc__ or ''  # reuse docsting if any
+
+    def __call__(self, promise, is_group_msg=False):
+        """
+        Processes callables in troughput-limiting queues to avoid hitting limits (specified with
+        :attr:`burst_limit` and :attr:`time_limit`.
+
+        Args:
+            promise (:obj:`callable`): Mainly the ``telegram.utils.promise.Promise`` (see Notes for
+                other callables), that is processed in delay queues.
+            is_group_msg (:obj:`bool`, optional): Defines whether ``promise`` would be processed in
+                group*+*all* ``DelayQueue``s (if set to ``True``), or only through *all*
+                ``DelayQueue`` (if set to ``False``), resulting in needed delays to avoid
+                hitting specified limits. Defaults to ``True``.
+
+        Notes:
+            Method is designed to accept ``telegram.utils.promise.Promise`` as ``promise``
+            argument, but other callables could be used too. For example, lambdas or simple
+            functions could be used to wrap original func to be called with needed args. In that
+            case, be sure that either wrapper func does not raise outside exceptions or the proper
+            :attr:`exc_route` handler is provided.
+
+        Returns:
+            :obj:`callable`: Used as ``promise`` argument.
+
+        """
+
+        if not is_group_msg:  # ignore middle group delay
+            self._all_delayq(promise)
+        else:  # use middle group delay
+            self._group_delayq(self._all_delayq, promise)
+        return promise
+
+
+def queuedmessage(method):
+    """A decorator to be used with :attr:`telegram.Bot` send* methods.
+
+    Note:
+        As it probably wouldn't be a good idea to make this decorator a property, it has been coded
+        as decorator function, so it implies that first positional argument to wrapped MUST be
+        self.
+
+    The next object attributes are used by decorator:
+
+    Attributes:
+        self._is_messages_queued_default (:obj:`bool`): Value to provide class-defaults to
+            ``queued`` kwarg if not provided during wrapped method call.
+        self._msg_queue (:class:`telegram.ext.messagequeue.MessageQueue`): The actual
+            ``MessageQueue`` used to delay outbound messages according to specified time-limits.
+
+    Wrapped method starts accepting the next kwargs:
+
+    Args:
+        queued (:obj:`bool`, optional): If set to ``True``, the ``MessageQueue`` is used to process
+            output messages. Defaults to `self._is_queued_out`.
+        isgroup (:obj:`bool`, optional): If set to ``True``, the message is meant to be group-type
+            (as there's no obvious way to determine its type in other way at the moment).
+            Group-type messages could have additional processing delay according to limits set
+            in `self._out_queue`. Defaults to ``False``.
+
+    Returns:
+        ``telegram.utils.promise.Promise``: In case call is queued or original method's return
+        value if it's not.
+
+    """
+
+    @functools.wraps(method)
+    def wrapped(self, *args, **kwargs):
+        queued = kwargs.pop('queued', self._is_messages_queued_default)
+        isgroup = kwargs.pop('isgroup', False)
+        if queued:
+            prom = promise.Promise(method, (self, ) + args, kwargs)
+            return self._msg_queue(prom, isgroup)
+        return method(self, *args, **kwargs)
+
+    return wrapped
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/precheckoutqueryhandler.py` & `python-telegram-bot-9.0.0/telegram/ext/precheckoutqueryhandler.py`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,98 +1,98 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the PreCheckoutQueryHandler class."""
-
-from telegram import Update
-from .handler import Handler
-
-
-class PreCheckoutQueryHandler(Handler):
-    """Handler class to handle Telegram PreCheckout callback queries.
-
-    Attributes:
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-
-    """
-
-    def __init__(self,
-                 callback,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pass_user_data=False,
-                 pass_chat_data=False):
-        super(PreCheckoutQueryHandler, self).__init__(
-            callback,
-            pass_update_queue=pass_update_queue,
-            pass_job_queue=pass_job_queue,
-            pass_user_data=pass_user_data,
-            pass_chat_data=pass_chat_data)
-
-    def check_update(self, update):
-        """Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        return isinstance(update, Update) and update.pre_checkout_query
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-
-        """
-        optional_args = self.collect_optional_args(dispatcher, update)
-        return self.callback(dispatcher.bot, update, **optional_args)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the PreCheckoutQueryHandler class."""
+
+from telegram import Update
+from .handler import Handler
+
+
+class PreCheckoutQueryHandler(Handler):
+    """Handler class to handle Telegram PreCheckout callback queries.
+
+    Attributes:
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+
+    """
+
+    def __init__(self,
+                 callback,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pass_user_data=False,
+                 pass_chat_data=False):
+        super(PreCheckoutQueryHandler, self).__init__(
+            callback,
+            pass_update_queue=pass_update_queue,
+            pass_job_queue=pass_job_queue,
+            pass_user_data=pass_user_data,
+            pass_chat_data=pass_chat_data)
+
+    def check_update(self, update):
+        """Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        return isinstance(update, Update) and update.pre_checkout_query
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+
+        """
+        optional_args = self.collect_optional_args(dispatcher, update)
+        return self.callback(dispatcher.bot, update, **optional_args)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/regexhandler.py` & `python-telegram-bot-9.0.0/telegram/ext/regexhandler.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,173 +1,173 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-# TODO: Remove allow_edited
-"""This module contains the RegexHandler class."""
-
-import re
-import warnings
-
-from future.utils import string_types
-
-from telegram import Update
-from .handler import Handler
-
-
-class RegexHandler(Handler):
-    """Handler class to handle Telegram updates based on a regex.
-
-    It uses a regular expression to check text messages. Read the documentation of the ``re``
-    module for more information. The ``re.match`` function is used to determine if an update should
-    be handled by this handler.
-
-    Attributes:
-        pattern (:obj:`str` | :obj:`Pattern`): The regex pattern.
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_groups (:obj:`bool`): Optional. Determines whether ``groups`` will be passed to the
-            callback function.
-        pass_groupdict (:obj:`bool`): Optional. Determines whether ``groupdict``. will be passed to
-            the callback function.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        pattern (:obj:`str` | :obj:`Pattern`): The regex pattern.
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_groups (:obj:`bool`, optional): If the callback should be passed the result of
-            ``re.match(pattern, data).groups()`` as a keyword argument called ``groups``.
-            Default is ``False``
-        pass_groupdict (:obj:`bool`, optional): If the callback should be passed the result of
-            ``re.match(pattern, data).groupdict()`` as a keyword argument called ``groupdict``.
-            Default is ``False``
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-        message_updates (:obj:`bool`, optional): Should "normal" message updates be handled?
-            Default is ``True``.
-        channel_post_updates (:obj:`bool`, optional): Should channel posts updates be handled?
-            Default is ``True``.
-        edited_updates (:obj:`bool`, optional): Should "edited" message updates be handled? Default
-            is ``False``.
-        allow_edited (:obj:`bool`, optional): If the handler should also accept edited messages.
-            Default is ``False`` - Deprecated. use edited_updates instead.
-
-    Raises:
-        ValueError
-
-    """
-
-    def __init__(self,
-                 pattern,
-                 callback,
-                 pass_groups=False,
-                 pass_groupdict=False,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pass_user_data=False,
-                 pass_chat_data=False,
-                 allow_edited=False,
-                 message_updates=True,
-                 channel_post_updates=False,
-                 edited_updates=False
-                 ):
-        if not message_updates and not channel_post_updates and not edited_updates:
-            raise ValueError(
-                'message_updates, channel_post_updates and edited_updates are all False')
-        if allow_edited:
-            warnings.warn('allow_edited is getting deprecated, please use edited_updates instead')
-            edited_updates = allow_edited
-
-        super(RegexHandler, self).__init__(
-            callback,
-            pass_update_queue=pass_update_queue,
-            pass_job_queue=pass_job_queue,
-            pass_user_data=pass_user_data,
-            pass_chat_data=pass_chat_data)
-
-        if isinstance(pattern, string_types):
-            pattern = re.compile(pattern)
-
-        self.pattern = pattern
-        self.pass_groups = pass_groups
-        self.pass_groupdict = pass_groupdict
-        self.allow_edited = allow_edited
-        self.message_updates = message_updates
-        self.channel_post_updates = channel_post_updates
-        self.edited_updates = edited_updates
-
-    def check_update(self, update):
-        """Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        if not isinstance(update, Update) and not update.effective_message:
-            return False
-        if any([self.message_updates and update.message,
-                self.edited_updates and (update.edited_message or update.edited_channel_post),
-                self.channel_post_updates and update.channel_post]) and \
-                update.effective_message.text:
-            match = re.match(self.pattern, update.effective_message.text)
-            return bool(match)
-        return False
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-
-        """
-
-        optional_args = self.collect_optional_args(dispatcher, update)
-        match = re.match(self.pattern, update.effective_message.text)
-
-        if self.pass_groups:
-            optional_args['groups'] = match.groups()
-        if self.pass_groupdict:
-            optional_args['groupdict'] = match.groupdict()
-
-        return self.callback(dispatcher.bot, update, **optional_args)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+# TODO: Remove allow_edited
+"""This module contains the RegexHandler class."""
+
+import re
+import warnings
+
+from future.utils import string_types
+
+from telegram import Update
+from .handler import Handler
+
+
+class RegexHandler(Handler):
+    """Handler class to handle Telegram updates based on a regex.
+
+    It uses a regular expression to check text messages. Read the documentation of the ``re``
+    module for more information. The ``re.match`` function is used to determine if an update should
+    be handled by this handler.
+
+    Attributes:
+        pattern (:obj:`str` | :obj:`Pattern`): The regex pattern.
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_groups (:obj:`bool`): Optional. Determines whether ``groups`` will be passed to the
+            callback function.
+        pass_groupdict (:obj:`bool`): Optional. Determines whether ``groupdict``. will be passed to
+            the callback function.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        pattern (:obj:`str` | :obj:`Pattern`): The regex pattern.
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_groups (:obj:`bool`, optional): If the callback should be passed the result of
+            ``re.match(pattern, data).groups()`` as a keyword argument called ``groups``.
+            Default is ``False``
+        pass_groupdict (:obj:`bool`, optional): If the callback should be passed the result of
+            ``re.match(pattern, data).groupdict()`` as a keyword argument called ``groupdict``.
+            Default is ``False``
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+        message_updates (:obj:`bool`, optional): Should "normal" message updates be handled?
+            Default is ``True``.
+        channel_post_updates (:obj:`bool`, optional): Should channel posts updates be handled?
+            Default is ``True``.
+        edited_updates (:obj:`bool`, optional): Should "edited" message updates be handled? Default
+            is ``False``.
+        allow_edited (:obj:`bool`, optional): If the handler should also accept edited messages.
+            Default is ``False`` - Deprecated. use edited_updates instead.
+
+    Raises:
+        ValueError
+
+    """
+
+    def __init__(self,
+                 pattern,
+                 callback,
+                 pass_groups=False,
+                 pass_groupdict=False,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pass_user_data=False,
+                 pass_chat_data=False,
+                 allow_edited=False,
+                 message_updates=True,
+                 channel_post_updates=False,
+                 edited_updates=False
+                 ):
+        if not message_updates and not channel_post_updates and not edited_updates:
+            raise ValueError(
+                'message_updates, channel_post_updates and edited_updates are all False')
+        if allow_edited:
+            warnings.warn('allow_edited is getting deprecated, please use edited_updates instead')
+            edited_updates = allow_edited
+
+        super(RegexHandler, self).__init__(
+            callback,
+            pass_update_queue=pass_update_queue,
+            pass_job_queue=pass_job_queue,
+            pass_user_data=pass_user_data,
+            pass_chat_data=pass_chat_data)
+
+        if isinstance(pattern, string_types):
+            pattern = re.compile(pattern)
+
+        self.pattern = pattern
+        self.pass_groups = pass_groups
+        self.pass_groupdict = pass_groupdict
+        self.allow_edited = allow_edited
+        self.message_updates = message_updates
+        self.channel_post_updates = channel_post_updates
+        self.edited_updates = edited_updates
+
+    def check_update(self, update):
+        """Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        if not isinstance(update, Update) and not update.effective_message:
+            return False
+        if any([self.message_updates and update.message,
+                self.edited_updates and (update.edited_message or update.edited_channel_post),
+                self.channel_post_updates and update.channel_post]) and \
+                update.effective_message.text:
+            match = re.match(self.pattern, update.effective_message.text)
+            return bool(match)
+        return False
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+
+        """
+
+        optional_args = self.collect_optional_args(dispatcher, update)
+        match = re.match(self.pattern, update.effective_message.text)
+
+        if self.pass_groups:
+            optional_args['groups'] = match.groups()
+        if self.pass_groupdict:
+            optional_args['groupdict'] = match.groupdict()
+
+        return self.callback(dispatcher.bot, update, **optional_args)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/shippingqueryhandler.py` & `python-telegram-bot-9.0.0/telegram/ext/shippingqueryhandler.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,98 +1,98 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the ShippingQueryHandler class."""
-
-from telegram import Update
-from .handler import Handler
-
-
-class ShippingQueryHandler(Handler):
-    """Handler class to handle Telegram shipping callback queries.
-
-    Attributes:
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
-            the callback function.
-        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
-            the callback function.
-
-    Note:
-        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
-        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
-        either the user or the chat that the update was sent in. For each update from the same user
-        or in the same chat, it will be the same ``dict``.
-
-    Args:
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``user_data`` will be passed to the callback function. Default is ``False``.
-        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``chat_data`` will be passed to the callback function. Default is ``False``.
-
-    """
-
-    def __init__(self,
-                 callback,
-                 pass_update_queue=False,
-                 pass_job_queue=False,
-                 pass_user_data=False,
-                 pass_chat_data=False):
-        super(ShippingQueryHandler, self).__init__(
-            callback,
-            pass_update_queue=pass_update_queue,
-            pass_job_queue=pass_job_queue,
-            pass_user_data=pass_user_data,
-            pass_chat_data=pass_chat_data)
-
-    def check_update(self, update):
-        """Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        return isinstance(update, Update) and update.shipping_query
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the :attr:`callback`.
-
-        Args:
-            update (:class:`telegram.Update`): Incoming telegram update.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
-
-        """
-        optional_args = self.collect_optional_args(dispatcher, update)
-        return self.callback(dispatcher.bot, update, **optional_args)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the ShippingQueryHandler class."""
+
+from telegram import Update
+from .handler import Handler
+
+
+class ShippingQueryHandler(Handler):
+    """Handler class to handle Telegram shipping callback queries.
+
+    Attributes:
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+        pass_user_data (:obj:`bool`): Optional. Determines whether ``user_data`` will be passed to
+            the callback function.
+        pass_chat_data (:obj:`bool`): Optional. Determines whether ``chat_data`` will be passed to
+            the callback function.
+
+    Note:
+        :attr:`pass_user_data` and :attr:`pass_chat_data` determine whether a ``dict`` you
+        can use to keep any data in will be sent to the :attr:`callback` function.. Related to
+        either the user or the chat that the update was sent in. For each update from the same user
+        or in the same chat, it will be the same ``dict``.
+
+    Args:
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+        pass_user_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``user_data`` will be passed to the callback function. Default is ``False``.
+        pass_chat_data (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``chat_data`` will be passed to the callback function. Default is ``False``.
+
+    """
+
+    def __init__(self,
+                 callback,
+                 pass_update_queue=False,
+                 pass_job_queue=False,
+                 pass_user_data=False,
+                 pass_chat_data=False):
+        super(ShippingQueryHandler, self).__init__(
+            callback,
+            pass_update_queue=pass_update_queue,
+            pass_job_queue=pass_job_queue,
+            pass_user_data=pass_user_data,
+            pass_chat_data=pass_chat_data)
+
+    def check_update(self, update):
+        """Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        return isinstance(update, Update) and update.shipping_query
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the :attr:`callback`.
+
+        Args:
+            update (:class:`telegram.Update`): Incoming telegram update.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the Update.
+
+        """
+        optional_args = self.collect_optional_args(dispatcher, update)
+        return self.callback(dispatcher.bot, update, **optional_args)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/stringregexhandler.py` & `python-telegram-bot-9.0.0/telegram/ext/stringregexhandler.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,117 +1,117 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the StringRegexHandler class."""
-
-import re
-
-from future.utils import string_types
-
-from .handler import Handler
-
-
-class StringRegexHandler(Handler):
-    """Handler class to handle string updates based on a regex which checks the update content.
-
-    Read the documentation of the ``re`` module for more information. The ``re.match`` function is
-    used to determine if an update should be handled by this handler.
-
-    Note:
-        This handler is not used to handle Telegram :attr:`telegram.Update`, but strings manually
-        put in the queue. For example to send messages with the bot using command line or API.
-
-    Attributes:
-        pattern (:obj:`str` | :obj:`Pattern`): The regex pattern.
-        callback (:obj:`callable`): The callback function for this handler.
-        pass_groups (:obj:`bool`): Optional. Determines whether ``groups`` will be passed to the
-            callback function.
-        pass_groupdict (:obj:`bool`): Optional. Determines whether ``groupdict``. will be passed to
-            the callback function.
-        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
-            passed to the callback function.
-        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
-            the callback function.
-
-    Args:
-        pattern (:obj:`str` | :obj:`Pattern`): The regex pattern.
-        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
-            It will be called when the :attr:`check_update` has determined that an update should be
-            processed by this handler.
-        pass_groups (:obj:`bool`, optional): If the callback should be passed the result of
-            ``re.match(pattern, data).groups()`` as a keyword argument called ``groups``.
-            Default is ``False``
-        pass_groupdict (:obj:`bool`, optional): If the callback should be passed the result of
-            ``re.match(pattern, data).groupdict()`` as a keyword argument called ``groupdict``.
-            Default is ``False``
-        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
-            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
-            that contains new updates which can be used to insert updates. Default is ``False``.
-        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
-            ``job_queue`` will be passed to the callback function. It will be a
-            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
-            which can be used to schedule new jobs. Default is ``False``.
-
-    """
-
-    def __init__(self,
-                 pattern,
-                 callback,
-                 pass_groups=False,
-                 pass_groupdict=False,
-                 pass_update_queue=False,
-                 pass_job_queue=False):
-        super(StringRegexHandler, self).__init__(
-            callback, pass_update_queue=pass_update_queue, pass_job_queue=pass_job_queue)
-
-        if isinstance(pattern, string_types):
-            pattern = re.compile(pattern)
-
-        self.pattern = pattern
-        self.pass_groups = pass_groups
-        self.pass_groupdict = pass_groupdict
-
-    def check_update(self, update):
-        """Determines whether an update should be passed to this handlers :attr:`callback`.
-
-        Args:
-            update (:obj:`str`): An incomming command.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        return isinstance(update, string_types) and bool(re.match(self.pattern, update))
-
-    def handle_update(self, update, dispatcher):
-        """Send the update to the :attr:`callback`.
-
-        Args:
-            update (:obj:`str`): An incomming command.
-            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the command.
-
-        """
-        optional_args = self.collect_optional_args(dispatcher)
-        match = re.match(self.pattern, update)
-
-        if self.pass_groups:
-            optional_args['groups'] = match.groups()
-        if self.pass_groupdict:
-            optional_args['groupdict'] = match.groupdict()
-
-        return self.callback(dispatcher.bot, update, **optional_args)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the StringRegexHandler class."""
+
+import re
+
+from future.utils import string_types
+
+from .handler import Handler
+
+
+class StringRegexHandler(Handler):
+    """Handler class to handle string updates based on a regex which checks the update content.
+
+    Read the documentation of the ``re`` module for more information. The ``re.match`` function is
+    used to determine if an update should be handled by this handler.
+
+    Note:
+        This handler is not used to handle Telegram :attr:`telegram.Update`, but strings manually
+        put in the queue. For example to send messages with the bot using command line or API.
+
+    Attributes:
+        pattern (:obj:`str` | :obj:`Pattern`): The regex pattern.
+        callback (:obj:`callable`): The callback function for this handler.
+        pass_groups (:obj:`bool`): Optional. Determines whether ``groups`` will be passed to the
+            callback function.
+        pass_groupdict (:obj:`bool`): Optional. Determines whether ``groupdict``. will be passed to
+            the callback function.
+        pass_update_queue (:obj:`bool`): Optional. Determines whether ``update_queue`` will be
+            passed to the callback function.
+        pass_job_queue (:obj:`bool`): Optional. Determines whether ``job_queue`` will be passed to
+            the callback function.
+
+    Args:
+        pattern (:obj:`str` | :obj:`Pattern`): The regex pattern.
+        callback (:obj:`callable`): A function that takes ``bot, update`` as positional arguments.
+            It will be called when the :attr:`check_update` has determined that an update should be
+            processed by this handler.
+        pass_groups (:obj:`bool`, optional): If the callback should be passed the result of
+            ``re.match(pattern, data).groups()`` as a keyword argument called ``groups``.
+            Default is ``False``
+        pass_groupdict (:obj:`bool`, optional): If the callback should be passed the result of
+            ``re.match(pattern, data).groupdict()`` as a keyword argument called ``groupdict``.
+            Default is ``False``
+        pass_update_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``update_queue`` will be passed to the callback function. It will be the ``Queue``
+            instance used by the :class:`telegram.ext.Updater` and :class:`telegram.ext.Dispatcher`
+            that contains new updates which can be used to insert updates. Default is ``False``.
+        pass_job_queue (:obj:`bool`, optional): If set to ``True``, a keyword argument called
+            ``job_queue`` will be passed to the callback function. It will be a
+            :class:`telegram.ext.JobQueue` instance created by the :class:`telegram.ext.Updater`
+            which can be used to schedule new jobs. Default is ``False``.
+
+    """
+
+    def __init__(self,
+                 pattern,
+                 callback,
+                 pass_groups=False,
+                 pass_groupdict=False,
+                 pass_update_queue=False,
+                 pass_job_queue=False):
+        super(StringRegexHandler, self).__init__(
+            callback, pass_update_queue=pass_update_queue, pass_job_queue=pass_job_queue)
+
+        if isinstance(pattern, string_types):
+            pattern = re.compile(pattern)
+
+        self.pattern = pattern
+        self.pass_groups = pass_groups
+        self.pass_groupdict = pass_groupdict
+
+    def check_update(self, update):
+        """Determines whether an update should be passed to this handlers :attr:`callback`.
+
+        Args:
+            update (:obj:`str`): An incomming command.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        return isinstance(update, string_types) and bool(re.match(self.pattern, update))
+
+    def handle_update(self, update, dispatcher):
+        """Send the update to the :attr:`callback`.
+
+        Args:
+            update (:obj:`str`): An incomming command.
+            dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that originated the command.
+
+        """
+        optional_args = self.collect_optional_args(dispatcher)
+        match = re.match(self.pattern, update)
+
+        if self.pass_groups:
+            optional_args['groups'] = match.groups()
+        if self.pass_groupdict:
+            optional_args['groupdict'] = match.groupdict()
+
+        return self.callback(dispatcher.bot, update, **optional_args)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/updater.py` & `python-telegram-bot-9.0.0/telegram/ext/updater.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,472 +1,475 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the class Updater, which tries to make creating Telegram bots intuitive."""
-
-import logging
-import os
-import ssl
-import warnings
-from threading import Thread, Lock, current_thread, Event
-from time import sleep
-import subprocess
-from signal import signal, SIGINT, SIGTERM, SIGABRT
-from queue import Queue
-
-from telegram import Bot, TelegramError
-from telegram.ext import Dispatcher, JobQueue
-from telegram.error import Unauthorized, InvalidToken, RetryAfter
-from telegram.utils.request import Request
-from telegram.utils.webhookhandler import (WebhookServer, WebhookHandler)
-
-logging.getLogger(__name__).addHandler(logging.NullHandler())
-
-
-class Updater(object):
-    """
-    This class, which employs the :class:`telegram.ext.Dispatcher`, provides a frontend to
-    :class:`telegram.Bot` to the programmer, so they can focus on coding the bot. Its purpose is to
-    receive the updates from Telegram and to deliver them to said dispatcher. It also runs in a
-    separate thread, so the user can interact with the bot, for example on the command line. The
-    dispatcher supports handlers for different kinds of data: Updates from Telegram, basic text
-    commands and even arbitrary types. The updater can be started as a polling service or, for
-    production, use a webhook to receive updates. This is achieved using the WebhookServer and
-    WebhookHandler classes.
-
-
-    Attributes:
-        bot (:class:`telegram.Bot`): The bot used with this Updater.
-        user_sig_handler (:obj:`signal`): signals the updater will respond to.
-        update_queue (:obj:`Queue`): Queue for the updates.
-        job_queue (:class:`telegram.ext.JobQueue`): Jobqueue for the updater.
-        dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that handles the updates and
-            dispatches them to the handlers.
-        running (:obj:`bool`): Indicates if the updater is running.
-
-    Args:
-        token (:obj:`str`, optional): The bot's token given by the @BotFather.
-        base_url (:obj:`str`, optional): Base_url for the bot.
-        workers (:obj:`int`, optional): Amount of threads in the thread pool for functions
-            decorated with ``@run_async``.
-        bot (:class:`telegram.Bot`, optional): A pre-initialized bot instance. If a pre-initialized
-            bot is used, it is the user's responsibility to create it using a `Request`
-            instance with a large enough connection pool.
-        user_sig_handler (:obj:`function`, optional): Takes ``signum, frame`` as positional
-            arguments. This will be called when a signal is received, defaults are (SIGINT,
-            SIGTERM, SIGABRT) setable with :attr:`idle`.
-        request_kwargs (:obj:`dict`, optional): Keyword args to control the creation of a
-            `telegram.utils.request.Request` object (ignored if `bot` argument is used). The
-            request_kwargs are very useful for the advanced users who would like to control the
-            default timeouts and/or control the proxy used for http communication.
-
-    Note:
-        You must supply either a :attr:`bot` or a :attr:`token` argument.
-
-    Raises:
-        ValueError: If both :attr:`token` and :attr:`bot` are passed or none of them.
-
-    """
-
-    _request = None
-
-    def __init__(self,
-                 token=None,
-                 base_url=None,
-                 workers=4,
-                 bot=None,
-                 user_sig_handler=None,
-                 request_kwargs=None):
-
-        if (token is None) and (bot is None):
-            raise ValueError('`token` or `bot` must be passed')
-        if (token is not None) and (bot is not None):
-            raise ValueError('`token` and `bot` are mutually exclusive')
-
-        self.logger = logging.getLogger(__name__)
-
-        con_pool_size = workers + 4
-
-        if bot is not None:
-            self.bot = bot
-            if bot.request.con_pool_size < con_pool_size:
-                self.logger.warning(
-                    'Connection pool of Request object is smaller than optimal value (%s)',
-                    con_pool_size)
-        else:
-            # we need a connection pool the size of:
-            # * for each of the workers
-            # * 1 for Dispatcher
-            # * 1 for polling Updater (even if webhook is used, we can spare a connection)
-            # * 1 for JobQueue
-            # * 1 for main thread
-            if request_kwargs is None:
-                request_kwargs = {}
-            if 'con_pool_size' not in request_kwargs:
-                request_kwargs['con_pool_size'] = con_pool_size
-            self._request = Request(**request_kwargs)
-            self.bot = Bot(token, base_url, request=self._request)
-        self.user_sig_handler = user_sig_handler
-        self.update_queue = Queue()
-        self.job_queue = JobQueue(self.bot)
-        self.__exception_event = Event()
-        self.dispatcher = Dispatcher(
-            self.bot,
-            self.update_queue,
-            job_queue=self.job_queue,
-            workers=workers,
-            exception_event=self.__exception_event)
-        self.last_update_id = 0
-        self.running = False
-        self.is_idle = False
-        self.httpd = None
-        self.__lock = Lock()
-        self.__threads = []
-
-    def _init_thread(self, target, name, *args, **kwargs):
-        thr = Thread(target=self._thread_wrapper, name=name, args=(target,) + args, kwargs=kwargs)
-        thr.start()
-        self.__threads.append(thr)
-
-    def _thread_wrapper(self, target, *args, **kwargs):
-        thr_name = current_thread().name
-        self.logger.debug('{0} - started'.format(thr_name))
-        try:
-            target(*args, **kwargs)
-        except Exception:
-            self.__exception_event.set()
-            self.logger.exception('unhandled exception')
-            raise
-        self.logger.debug('{0} - ended'.format(thr_name))
-
-    def start_polling(self,
-                      poll_interval=0.0,
-                      timeout=10,
-                      network_delay=None,
-                      clean=False,
-                      bootstrap_retries=0,
-                      read_latency=2.,
-                      allowed_updates=None):
-        """Starts polling updates from Telegram.
-
-        Args:
-            poll_interval (:obj:`float`, optional): Time to wait between polling updates from
-                Telegram in seconds. Default is 0.0.
-            timeout (:obj:`float`, optional): Passed to :attr:`telegram.Bot.get_updates`.
-            clean (:obj:`bool`, optional): Whether to clean any pending updates on Telegram servers
-                before actually starting to poll. Default is False.
-            bootstrap_retries (:obj:`int`, optional): Whether the bootstrapping phase of the
-                `Updater` will retry on failures on the Telegram server.
-
-                * < 0 - retry indefinitely
-                *   0 - no retries (default)
-                * > 0 - retry up to X times
-
-            allowed_updates (List[:obj:`str`], optional): Passed to
-                :attr:`telegram.Bot.get_updates`.
-            read_latency (:obj:`float` | :obj:`int`, optional): Grace time in seconds for receiving
-                the reply from server. Will be added to the `timeout` value and used as the read
-                timeout from server (Default: 2).
-            network_delay: Deprecated. Will be honoured as :attr:`read_latency` for a while but
-                will be removed in the future.
-
-        Returns:
-            :obj:`Queue`: The update queue that can be filled from the main thread.
-
-        """
-
-        if network_delay is not None:
-            warnings.warn('network_delay is deprecated, use read_latency instead')
-            read_latency = network_delay
-
-        with self.__lock:
-            if not self.running:
-                self.running = True
-
-                # Create & start threads
-                self.job_queue.start()
-                self._init_thread(self.dispatcher.start, "dispatcher")
-                self._init_thread(self._start_polling, "updater", poll_interval, timeout,
-                                  read_latency, bootstrap_retries, clean, allowed_updates)
-
-                # Return the update queue so the main thread can insert updates
-                return self.update_queue
-
-    def start_webhook(self,
-                      listen='127.0.0.1',
-                      port=80,
-                      url_path='',
-                      cert=None,
-                      key=None,
-                      clean=False,
-                      bootstrap_retries=0,
-                      webhook_url=None,
-                      allowed_updates=None):
-        """
-        Starts a small http server to listen for updates via webhook. If cert
-        and key are not provided, the webhook will be started directly on
-        http://listen:port/url_path, so SSL can be handled by another
-        application. Else, the webhook will be started on
-        https://listen:port/url_path
-
-        Args:
-            listen (:obj:`str`, optional): IP-Address to listen on. Default ``127.0.0.1``.
-            port (:obj:`int`, optional): Port the bot should be listening on. Default ``80``.
-            url_path (:obj:`str`, optional): Path inside url.
-            cert (:obj:`str`, optional): Path to the SSL certificate file.
-            key (:obj:`str`, optional): Path to the SSL key file.
-            clean (:obj:`bool`, optional): Whether to clean any pending updates on Telegram servers
-                before actually starting the webhook. Default is ``False``.
-            bootstrap_retries (:obj:`int`, optional): Whether the bootstrapping phase of the
-                `Updater` will retry on failures on the Telegram server.
-
-                * < 0 - retry indefinitely
-                *   0 - no retries (default)
-                * > 0 - retry up to X times
-
-            webhook_url (:obj:`str`, optional): Explicitly specify the webhook url. Useful behind
-                NAT, reverse proxy, etc. Default is derived from `listen`, `port` & `url_path`.
-            allowed_updates (List[:obj:`str`], optional): Passed to
-                :attr:`telegram.Bot.set_webhook`.
-
-        Returns:
-            :obj:`Queue`: The update queue that can be filled from the main thread.
-
-        """
-
-        with self.__lock:
-            if not self.running:
-                self.running = True
-
-                # Create & start threads
-                self.job_queue.start()
-                self._init_thread(self.dispatcher.start, "dispatcher"),
-                self._init_thread(self._start_webhook, "updater", listen, port, url_path, cert,
-                                  key, bootstrap_retries, clean, webhook_url, allowed_updates)
-
-                # Return the update queue so the main thread can insert updates
-                return self.update_queue
-
-    def _start_polling(self, poll_interval, timeout, read_latency, bootstrap_retries, clean,
-                       allowed_updates):  # pragma: no cover
-        # """
-        # Thread target of thread 'updater'. Runs in background, pulls
-        # updates from Telegram and inserts them in the update queue of the
-        # Dispatcher.
-        # """
-
-        cur_interval = poll_interval
-        self.logger.debug('Updater thread started')
-
-        self._bootstrap(bootstrap_retries, clean=clean, webhook_url='', allowed_updates=None)
-
-        while self.running:
-            try:
-                updates = self.bot.get_updates(
-                    self.last_update_id,
-                    timeout=timeout,
-                    read_latency=read_latency,
-                    allowed_updates=allowed_updates)
-            except RetryAfter as e:
-                self.logger.info(str(e))
-                cur_interval = 0.5 + e.retry_after
-            except TelegramError as te:
-                self.logger.error("Error while getting Updates: {0}".format(te))
-
-                # Put the error into the update queue and let the Dispatcher
-                # broadcast it
-                self.update_queue.put(te)
-
-                cur_interval = self._increase_poll_interval(cur_interval)
-            else:
-                if not self.running:
-                    if len(updates) > 0:
-                        self.logger.debug('Updates ignored and will be pulled '
-                                          'again on restart.')
-                    break
-
-                if updates:
-                    for update in updates:
-                        self.update_queue.put(update)
-                    self.last_update_id = updates[-1].update_id + 1
-
-                cur_interval = poll_interval
-
-            sleep(cur_interval)
-
-    @staticmethod
-    def _increase_poll_interval(current_interval):
-        # increase waiting times on subsequent errors up to 30secs
-        if current_interval == 0:
-            current_interval = 1
-        elif current_interval < 30:
-            current_interval += current_interval / 2
-        elif current_interval > 30:
-            current_interval = 30
-        return current_interval
-
-    def _start_webhook(self, listen, port, url_path, cert, key, bootstrap_retries, clean,
-                       webhook_url, allowed_updates):
-        self.logger.debug('Updater thread started')
-        use_ssl = cert is not None and key is not None
-        if not url_path.startswith('/'):
-            url_path = '/{0}'.format(url_path)
-
-        # Create and start server
-        self.httpd = WebhookServer((listen, port), WebhookHandler, self.update_queue, url_path,
-                                   self.bot)
-
-        if use_ssl:
-            self._check_ssl_cert(cert, key)
-
-            # DO NOT CHANGE: Only set webhook if SSL is handled by library
-            if not webhook_url:
-                webhook_url = self._gen_webhook_url(listen, port, url_path)
-
-            self._bootstrap(
-                max_retries=bootstrap_retries,
-                clean=clean,
-                webhook_url=webhook_url,
-                cert=open(cert, 'rb'),
-                allowed_updates=allowed_updates)
-        elif clean:
-            self.logger.warning("cleaning updates is not supported if "
-                                "SSL-termination happens elsewhere; skipping")
-
-        self.httpd.serve_forever(poll_interval=1)
-
-    def _check_ssl_cert(self, cert, key):
-        # Check SSL-Certificate with openssl, if possible
-        try:
-            exit_code = subprocess.call(
-                ["openssl", "x509", "-text", "-noout", "-in", cert],
-                stdout=open(os.devnull, 'wb'),
-                stderr=subprocess.STDOUT)
-        except OSError:
-            exit_code = 0
-        if exit_code is 0:
-            try:
-                self.httpd.socket = ssl.wrap_socket(
-                    self.httpd.socket, certfile=cert, keyfile=key, server_side=True)
-            except ssl.SSLError as error:
-                self.logger.exception('Failed to init SSL socket')
-                raise TelegramError(str(error))
-        else:
-            raise TelegramError('SSL Certificate invalid')
-
-    @staticmethod
-    def _gen_webhook_url(listen, port, url_path):
-        return 'https://{listen}:{port}{path}'.format(listen=listen, port=port, path=url_path)
-
-    def _bootstrap(self, max_retries, clean, webhook_url, allowed_updates, cert=None):
-        retries = 0
-        while 1:
-
-            try:
-                if clean:
-                    # Disable webhook for cleaning
-                    self.bot.delete_webhook()
-                    self._clean_updates()
-                    sleep(1)
-
-                self.bot.set_webhook(
-                    url=webhook_url, certificate=cert, allowed_updates=allowed_updates)
-            except (Unauthorized, InvalidToken):
-                raise
-            except TelegramError:
-                msg = 'error in bootstrap phase; try={0} max_retries={1}'.format(retries,
-                                                                                 max_retries)
-                if max_retries < 0 or retries < max_retries:
-                    self.logger.warning(msg)
-                    retries += 1
-                else:
-                    self.logger.exception(msg)
-                    raise
-            else:
-                break
-            sleep(1)
-
-    def _clean_updates(self):
-        self.logger.debug('Cleaning updates from Telegram server')
-        updates = self.bot.get_updates()
-        while updates:
-            updates = self.bot.get_updates(updates[-1].update_id + 1)
-
-    def stop(self):
-        """Stops the polling/webhook thread, the dispatcher and the job queue."""
-
-        self.job_queue.stop()
-        with self.__lock:
-            if self.running or self.dispatcher.has_running_threads:
-                self.logger.debug('Stopping Updater and Dispatcher...')
-
-                self.running = False
-
-                self._stop_httpd()
-                self._stop_dispatcher()
-                self._join_threads()
-
-                # Stop the Request instance only if it was created by the Updater
-                if self._request:
-                    self._request.stop()
-
-    def _stop_httpd(self):
-        if self.httpd:
-            self.logger.debug('Waiting for current webhook connection to be '
-                              'closed... Send a Telegram message to the bot to exit '
-                              'immediately.')
-            self.httpd.shutdown()
-            self.httpd = None
-
-    def _stop_dispatcher(self):
-        self.logger.debug('Requesting Dispatcher to stop...')
-        self.dispatcher.stop()
-
-    def _join_threads(self):
-        for thr in self.__threads:
-            self.logger.debug('Waiting for {0} thread to end'.format(thr.name))
-            thr.join()
-            self.logger.debug('{0} thread has ended'.format(thr.name))
-        self.__threads = []
-
-    def signal_handler(self, signum, frame):
-        self.is_idle = False
-        if self.running:
-            self.stop()
-            if self.user_sig_handler:
-                self.user_sig_handler(signum, frame)
-        else:
-            self.logger.warning('Exiting immediately!')
-            import os
-            os._exit(1)
-
-    def idle(self, stop_signals=(SIGINT, SIGTERM, SIGABRT)):
-        """Blocks until one of the signals are received and stops the updater.
-
-        Args:
-            stop_signals (:obj:`iterable`): Iterable containing signals from the signal module that
-                should be subscribed to. Updater.stop() will be called on receiving one of those
-                signals. Defaults to (``SIGINT``, ``SIGTERM``, ``SIGABRT``).
-
-        """
-        for sig in stop_signals:
-            signal(sig, self.signal_handler)
-
-        self.is_idle = True
-
-        while self.is_idle:
-            sleep(1)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the class Updater, which tries to make creating Telegram bots intuitive."""
+
+import logging
+import os
+import ssl
+import warnings
+from threading import Thread, Lock, current_thread, Event
+from time import sleep
+import subprocess
+from signal import signal, SIGINT, SIGTERM, SIGABRT
+from queue import Queue
+
+from telegram import Bot, TelegramError
+from telegram.ext import Dispatcher, JobQueue
+from telegram.error import Unauthorized, InvalidToken, RetryAfter
+from telegram.utils.request import Request
+from telegram.utils.webhookhandler import (WebhookServer, WebhookHandler)
+
+logging.getLogger(__name__).addHandler(logging.NullHandler())
+
+
+class Updater(object):
+    """
+    This class, which employs the :class:`telegram.ext.Dispatcher`, provides a frontend to
+    :class:`telegram.Bot` to the programmer, so they can focus on coding the bot. Its purpose is to
+    receive the updates from Telegram and to deliver them to said dispatcher. It also runs in a
+    separate thread, so the user can interact with the bot, for example on the command line. The
+    dispatcher supports handlers for different kinds of data: Updates from Telegram, basic text
+    commands and even arbitrary types. The updater can be started as a polling service or, for
+    production, use a webhook to receive updates. This is achieved using the WebhookServer and
+    WebhookHandler classes.
+
+
+    Attributes:
+        bot (:class:`telegram.Bot`): The bot used with this Updater.
+        user_sig_handler (:obj:`signal`): signals the updater will respond to.
+        update_queue (:obj:`Queue`): Queue for the updates.
+        job_queue (:class:`telegram.ext.JobQueue`): Jobqueue for the updater.
+        dispatcher (:class:`telegram.ext.Dispatcher`): Dispatcher that handles the updates and
+            dispatches them to the handlers.
+        running (:obj:`bool`): Indicates if the updater is running.
+
+    Args:
+        token (:obj:`str`, optional): The bot's token given by the @BotFather.
+        base_url (:obj:`str`, optional): Base_url for the bot.
+        workers (:obj:`int`, optional): Amount of threads in the thread pool for functions
+            decorated with ``@run_async``.
+        bot (:class:`telegram.Bot`, optional): A pre-initialized bot instance. If a pre-initialized
+            bot is used, it is the user's responsibility to create it using a `Request`
+            instance with a large enough connection pool.
+        user_sig_handler (:obj:`function`, optional): Takes ``signum, frame`` as positional
+            arguments. This will be called when a signal is received, defaults are (SIGINT,
+            SIGTERM, SIGABRT) setable with :attr:`idle`.
+        request_kwargs (:obj:`dict`, optional): Keyword args to control the creation of a
+            `telegram.utils.request.Request` object (ignored if `bot` argument is used). The
+            request_kwargs are very useful for the advanced users who would like to control the
+            default timeouts and/or control the proxy used for http communication.
+
+    Note:
+        You must supply either a :attr:`bot` or a :attr:`token` argument.
+
+    Raises:
+        ValueError: If both :attr:`token` and :attr:`bot` are passed or none of them.
+
+    """
+
+    _request = None
+
+    def __init__(self,
+                 token=None,
+                 base_url=None,
+                 workers=4,
+                 bot=None,
+                 user_sig_handler=None,
+                 request_kwargs=None):
+
+        if (token is None) and (bot is None):
+            raise ValueError('`token` or `bot` must be passed')
+        if (token is not None) and (bot is not None):
+            raise ValueError('`token` and `bot` are mutually exclusive')
+
+        self.logger = logging.getLogger(__name__)
+
+        con_pool_size = workers + 4
+
+        if bot is not None:
+            self.bot = bot
+            if bot.request.con_pool_size < con_pool_size:
+                self.logger.warning(
+                    'Connection pool of Request object is smaller than optimal value (%s)',
+                    con_pool_size)
+        else:
+            # we need a connection pool the size of:
+            # * for each of the workers
+            # * 1 for Dispatcher
+            # * 1 for polling Updater (even if webhook is used, we can spare a connection)
+            # * 1 for JobQueue
+            # * 1 for main thread
+            if request_kwargs is None:
+                request_kwargs = {}
+            if 'con_pool_size' not in request_kwargs:
+                request_kwargs['con_pool_size'] = con_pool_size
+            self._request = Request(**request_kwargs)
+            self.bot = Bot(token, base_url, request=self._request)
+        self.user_sig_handler = user_sig_handler
+        self.update_queue = Queue()
+        self.job_queue = JobQueue(self.bot)
+        self.__exception_event = Event()
+        self.dispatcher = Dispatcher(
+            self.bot,
+            self.update_queue,
+            job_queue=self.job_queue,
+            workers=workers,
+            exception_event=self.__exception_event)
+        self.last_update_id = 0
+        self.running = False
+        self.is_idle = False
+        self.httpd = None
+        self.__lock = Lock()
+        self.__threads = []
+
+    def _init_thread(self, target, name, *args, **kwargs):
+        thr = Thread(target=self._thread_wrapper, name=name, args=(target,) + args, kwargs=kwargs)
+        thr.start()
+        self.__threads.append(thr)
+
+    def _thread_wrapper(self, target, *args, **kwargs):
+        thr_name = current_thread().name
+        self.logger.debug('{0} - started'.format(thr_name))
+        try:
+            target(*args, **kwargs)
+        except Exception:
+            self.__exception_event.set()
+            self.logger.exception('unhandled exception')
+            raise
+        self.logger.debug('{0} - ended'.format(thr_name))
+
+    def start_polling(self,
+                      poll_interval=0.0,
+                      timeout=10,
+                      network_delay=None,
+                      clean=False,
+                      bootstrap_retries=0,
+                      read_latency=2.,
+                      allowed_updates=None):
+        """Starts polling updates from Telegram.
+
+        Args:
+            poll_interval (:obj:`float`, optional): Time to wait between polling updates from
+                Telegram in seconds. Default is 0.0.
+            timeout (:obj:`float`, optional): Passed to :attr:`telegram.Bot.get_updates`.
+            clean (:obj:`bool`, optional): Whether to clean any pending updates on Telegram servers
+                before actually starting to poll. Default is False.
+            bootstrap_retries (:obj:`int`, optional): Whether the bootstrapping phase of the
+                `Updater` will retry on failures on the Telegram server.
+
+                * < 0 - retry indefinitely
+                *   0 - no retries (default)
+                * > 0 - retry up to X times
+
+            allowed_updates (List[:obj:`str`], optional): Passed to
+                :attr:`telegram.Bot.get_updates`.
+            read_latency (:obj:`float` | :obj:`int`, optional): Grace time in seconds for receiving
+                the reply from server. Will be added to the `timeout` value and used as the read
+                timeout from server (Default: 2).
+            network_delay: Deprecated. Will be honoured as :attr:`read_latency` for a while but
+                will be removed in the future.
+
+        Returns:
+            :obj:`Queue`: The update queue that can be filled from the main thread.
+
+        """
+
+        if network_delay is not None:
+            warnings.warn('network_delay is deprecated, use read_latency instead')
+            read_latency = network_delay
+
+        with self.__lock:
+            if not self.running:
+                self.running = True
+
+                # Create & start threads
+                self.job_queue.start()
+                dispatcher_ready = Event()
+                self._init_thread(self.dispatcher.start, "dispatcher", ready=dispatcher_ready)
+                self._init_thread(self._start_polling, "updater", poll_interval, timeout,
+                                  read_latency, bootstrap_retries, clean, allowed_updates)
+
+                dispatcher_ready.wait()
+
+                # Return the update queue so the main thread can insert updates
+                return self.update_queue
+
+    def start_webhook(self,
+                      listen='127.0.0.1',
+                      port=80,
+                      url_path='',
+                      cert=None,
+                      key=None,
+                      clean=False,
+                      bootstrap_retries=0,
+                      webhook_url=None,
+                      allowed_updates=None):
+        """
+        Starts a small http server to listen for updates via webhook. If cert
+        and key are not provided, the webhook will be started directly on
+        http://listen:port/url_path, so SSL can be handled by another
+        application. Else, the webhook will be started on
+        https://listen:port/url_path
+
+        Args:
+            listen (:obj:`str`, optional): IP-Address to listen on. Default ``127.0.0.1``.
+            port (:obj:`int`, optional): Port the bot should be listening on. Default ``80``.
+            url_path (:obj:`str`, optional): Path inside url.
+            cert (:obj:`str`, optional): Path to the SSL certificate file.
+            key (:obj:`str`, optional): Path to the SSL key file.
+            clean (:obj:`bool`, optional): Whether to clean any pending updates on Telegram servers
+                before actually starting the webhook. Default is ``False``.
+            bootstrap_retries (:obj:`int`, optional): Whether the bootstrapping phase of the
+                `Updater` will retry on failures on the Telegram server.
+
+                * < 0 - retry indefinitely
+                *   0 - no retries (default)
+                * > 0 - retry up to X times
+
+            webhook_url (:obj:`str`, optional): Explicitly specify the webhook url. Useful behind
+                NAT, reverse proxy, etc. Default is derived from `listen`, `port` & `url_path`.
+            allowed_updates (List[:obj:`str`], optional): Passed to
+                :attr:`telegram.Bot.set_webhook`.
+
+        Returns:
+            :obj:`Queue`: The update queue that can be filled from the main thread.
+
+        """
+
+        with self.__lock:
+            if not self.running:
+                self.running = True
+
+                # Create & start threads
+                self.job_queue.start()
+                self._init_thread(self.dispatcher.start, "dispatcher"),
+                self._init_thread(self._start_webhook, "updater", listen, port, url_path, cert,
+                                  key, bootstrap_retries, clean, webhook_url, allowed_updates)
+
+                # Return the update queue so the main thread can insert updates
+                return self.update_queue
+
+    def _start_polling(self, poll_interval, timeout, read_latency, bootstrap_retries, clean,
+                       allowed_updates):  # pragma: no cover
+        # """
+        # Thread target of thread 'updater'. Runs in background, pulls
+        # updates from Telegram and inserts them in the update queue of the
+        # Dispatcher.
+        # """
+
+        cur_interval = poll_interval
+        self.logger.debug('Updater thread started')
+
+        self._bootstrap(bootstrap_retries, clean=clean, webhook_url='', allowed_updates=None)
+
+        while self.running:
+            try:
+                updates = self.bot.get_updates(
+                    self.last_update_id,
+                    timeout=timeout,
+                    read_latency=read_latency,
+                    allowed_updates=allowed_updates)
+            except RetryAfter as e:
+                self.logger.info(str(e))
+                cur_interval = 0.5 + e.retry_after
+            except TelegramError as te:
+                self.logger.error("Error while getting Updates: {0}".format(te))
+
+                # Put the error into the update queue and let the Dispatcher
+                # broadcast it
+                self.update_queue.put(te)
+
+                cur_interval = self._increase_poll_interval(cur_interval)
+            else:
+                if not self.running:
+                    if len(updates) > 0:
+                        self.logger.debug('Updates ignored and will be pulled '
+                                          'again on restart.')
+                    break
+
+                if updates:
+                    for update in updates:
+                        self.update_queue.put(update)
+                    self.last_update_id = updates[-1].update_id + 1
+
+                cur_interval = poll_interval
+
+            sleep(cur_interval)
+
+    @staticmethod
+    def _increase_poll_interval(current_interval):
+        # increase waiting times on subsequent errors up to 30secs
+        if current_interval == 0:
+            current_interval = 1
+        elif current_interval < 30:
+            current_interval += current_interval / 2
+        elif current_interval > 30:
+            current_interval = 30
+        return current_interval
+
+    def _start_webhook(self, listen, port, url_path, cert, key, bootstrap_retries, clean,
+                       webhook_url, allowed_updates):
+        self.logger.debug('Updater thread started')
+        use_ssl = cert is not None and key is not None
+        if not url_path.startswith('/'):
+            url_path = '/{0}'.format(url_path)
+
+        # Create and start server
+        self.httpd = WebhookServer((listen, port), WebhookHandler, self.update_queue, url_path,
+                                   self.bot)
+
+        if use_ssl:
+            self._check_ssl_cert(cert, key)
+
+            # DO NOT CHANGE: Only set webhook if SSL is handled by library
+            if not webhook_url:
+                webhook_url = self._gen_webhook_url(listen, port, url_path)
+
+            self._bootstrap(
+                max_retries=bootstrap_retries,
+                clean=clean,
+                webhook_url=webhook_url,
+                cert=open(cert, 'rb'),
+                allowed_updates=allowed_updates)
+        elif clean:
+            self.logger.warning("cleaning updates is not supported if "
+                                "SSL-termination happens elsewhere; skipping")
+
+        self.httpd.serve_forever(poll_interval=1)
+
+    def _check_ssl_cert(self, cert, key):
+        # Check SSL-Certificate with openssl, if possible
+        try:
+            exit_code = subprocess.call(
+                ["openssl", "x509", "-text", "-noout", "-in", cert],
+                stdout=open(os.devnull, 'wb'),
+                stderr=subprocess.STDOUT)
+        except OSError:
+            exit_code = 0
+        if exit_code is 0:
+            try:
+                self.httpd.socket = ssl.wrap_socket(
+                    self.httpd.socket, certfile=cert, keyfile=key, server_side=True)
+            except ssl.SSLError as error:
+                self.logger.exception('Failed to init SSL socket')
+                raise TelegramError(str(error))
+        else:
+            raise TelegramError('SSL Certificate invalid')
+
+    @staticmethod
+    def _gen_webhook_url(listen, port, url_path):
+        return 'https://{listen}:{port}{path}'.format(listen=listen, port=port, path=url_path)
+
+    def _bootstrap(self, max_retries, clean, webhook_url, allowed_updates, cert=None):
+        retries = 0
+        while 1:
+
+            try:
+                if clean:
+                    # Disable webhook for cleaning
+                    self.bot.delete_webhook()
+                    self._clean_updates()
+                    sleep(1)
+
+                self.bot.set_webhook(
+                    url=webhook_url, certificate=cert, allowed_updates=allowed_updates)
+            except (Unauthorized, InvalidToken):
+                raise
+            except TelegramError:
+                msg = 'error in bootstrap phase; try={0} max_retries={1}'.format(retries,
+                                                                                 max_retries)
+                if max_retries < 0 or retries < max_retries:
+                    self.logger.warning(msg)
+                    retries += 1
+                else:
+                    self.logger.exception(msg)
+                    raise
+            else:
+                break
+            sleep(1)
+
+    def _clean_updates(self):
+        self.logger.debug('Cleaning updates from Telegram server')
+        updates = self.bot.get_updates()
+        while updates:
+            updates = self.bot.get_updates(updates[-1].update_id + 1)
+
+    def stop(self):
+        """Stops the polling/webhook thread, the dispatcher and the job queue."""
+
+        self.job_queue.stop()
+        with self.__lock:
+            if self.running or self.dispatcher.has_running_threads:
+                self.logger.debug('Stopping Updater and Dispatcher...')
+
+                self.running = False
+
+                self._stop_httpd()
+                self._stop_dispatcher()
+                self._join_threads()
+
+                # Stop the Request instance only if it was created by the Updater
+                if self._request:
+                    self._request.stop()
+
+    def _stop_httpd(self):
+        if self.httpd:
+            self.logger.debug('Waiting for current webhook connection to be '
+                              'closed... Send a Telegram message to the bot to exit '
+                              'immediately.')
+            self.httpd.shutdown()
+            self.httpd = None
+
+    def _stop_dispatcher(self):
+        self.logger.debug('Requesting Dispatcher to stop...')
+        self.dispatcher.stop()
+
+    def _join_threads(self):
+        for thr in self.__threads:
+            self.logger.debug('Waiting for {0} thread to end'.format(thr.name))
+            thr.join()
+            self.logger.debug('{0} thread has ended'.format(thr.name))
+        self.__threads = []
+
+    def signal_handler(self, signum, frame):
+        self.is_idle = False
+        if self.running:
+            self.stop()
+            if self.user_sig_handler:
+                self.user_sig_handler(signum, frame)
+        else:
+            self.logger.warning('Exiting immediately!')
+            import os
+            os._exit(1)
+
+    def idle(self, stop_signals=(SIGINT, SIGTERM, SIGABRT)):
+        """Blocks until one of the signals are received and stops the updater.
+
+        Args:
+            stop_signals (:obj:`iterable`): Iterable containing signals from the signal module that
+                should be subscribed to. Updater.stop() will be called on receiving one of those
+                signals. Defaults to (``SIGINT``, ``SIGTERM``, ``SIGABRT``).
+
+        """
+        for sig in stop_signals:
+            signal(sig, self.signal_handler)
+
+        self.is_idle = True
+
+        while self.is_idle:
+            sleep(1)
```

### Comparing `python-telegram-bot-8.1.1/telegram/ext/__init__.py` & `python-telegram-bot-9.0.0/telegram/ext/__init__.py`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,46 +1,46 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""Extensions over the Telegram Bot API to facilitate bot making"""
-
-from .dispatcher import Dispatcher, DispatcherHandlerStop, run_async
-from .jobqueue import JobQueue, Job
-from .updater import Updater
-from .callbackqueryhandler import CallbackQueryHandler
-from .choseninlineresulthandler import ChosenInlineResultHandler
-from .commandhandler import CommandHandler
-from .handler import Handler
-from .inlinequeryhandler import InlineQueryHandler
-from .messagehandler import MessageHandler
-from .filters import BaseFilter, Filters
-from .regexhandler import RegexHandler
-from .stringcommandhandler import StringCommandHandler
-from .stringregexhandler import StringRegexHandler
-from .typehandler import TypeHandler
-from .conversationhandler import ConversationHandler
-from .precheckoutqueryhandler import PreCheckoutQueryHandler
-from .shippingqueryhandler import ShippingQueryHandler
-from .messagequeue import MessageQueue
-from .messagequeue import DelayQueue
-
-__all__ = ('Dispatcher', 'JobQueue', 'Job', 'Updater', 'CallbackQueryHandler',
-           'ChosenInlineResultHandler', 'CommandHandler', 'Handler', 'InlineQueryHandler',
-           'MessageHandler', 'BaseFilter', 'Filters', 'RegexHandler', 'StringCommandHandler',
-           'StringRegexHandler', 'TypeHandler', 'ConversationHandler',
-           'PreCheckoutQueryHandler', 'ShippingQueryHandler', 'MessageQueue', 'DelayQueue',
-           'DispatcherHandlerStop', 'run_async')
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""Extensions over the Telegram Bot API to facilitate bot making"""
+
+from .dispatcher import Dispatcher, DispatcherHandlerStop, run_async
+from .jobqueue import JobQueue, Job
+from .updater import Updater
+from .callbackqueryhandler import CallbackQueryHandler
+from .choseninlineresulthandler import ChosenInlineResultHandler
+from .commandhandler import CommandHandler
+from .handler import Handler
+from .inlinequeryhandler import InlineQueryHandler
+from .messagehandler import MessageHandler
+from .filters import BaseFilter, Filters
+from .regexhandler import RegexHandler
+from .stringcommandhandler import StringCommandHandler
+from .stringregexhandler import StringRegexHandler
+from .typehandler import TypeHandler
+from .conversationhandler import ConversationHandler
+from .precheckoutqueryhandler import PreCheckoutQueryHandler
+from .shippingqueryhandler import ShippingQueryHandler
+from .messagequeue import MessageQueue
+from .messagequeue import DelayQueue
+
+__all__ = ('Dispatcher', 'JobQueue', 'Job', 'Updater', 'CallbackQueryHandler',
+           'ChosenInlineResultHandler', 'CommandHandler', 'Handler', 'InlineQueryHandler',
+           'MessageHandler', 'BaseFilter', 'Filters', 'RegexHandler', 'StringCommandHandler',
+           'StringRegexHandler', 'TypeHandler', 'ConversationHandler',
+           'PreCheckoutQueryHandler', 'ShippingQueryHandler', 'MessageQueue', 'DelayQueue',
+           'DispatcherHandlerStop', 'run_async')
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/audio.py` & `python-telegram-bot-9.0.0/telegram/files/audio.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,72 +1,72 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Audio."""
-
-from telegram import TelegramObject
-
-
-class Audio(TelegramObject):
-    """This object represents an audio file to be treated as music by the Telegram clients.
-
-    Attributes:
-        file_id (:obj:`str`): Unique identifier for this file.
-        duration (:obj:`int`): Duration of the audio in seconds.
-        performer (:obj:`str`): Optional. Performer of the audio as defined by sender or by audio
-            tags.
-        title (:obj:`str`): Optional. Title of the audio as defined by sender or by audio tags.
-        mime_type (:obj:`str`): Optional. MIME type of the file as defined by sender.
-        file_size (:obj:`int`): Optional. File size.
-
-    Args:
-        file_id (:obj:`str`): Unique identifier for this file.
-        duration (:obj:`int`): Duration of the audio in seconds as defined by sender.
-        performer (:obj:`str`, optional): Performer of the audio as defined by sender or by audio
-            tags.
-        title (:obj:`str`, optional): Title of the audio as defined by sender or by audio tags.
-        mime_type (:obj:`str`, optional): MIME type of the file as defined by sender.
-        file_size (:obj:`int`, optional): File size.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 file_id,
-                 duration,
-                 performer=None,
-                 title=None,
-                 mime_type=None,
-                 file_size=None,
-                 **kwargs):
-        # Required
-        self.file_id = str(file_id)
-        self.duration = int(duration)
-        # Optionals
-        self.performer = performer
-        self.title = title
-        self.mime_type = mime_type
-        self.file_size = file_size
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Audio."""
+
+from telegram import TelegramObject
+
+
+class Audio(TelegramObject):
+    """This object represents an audio file to be treated as music by the Telegram clients.
+
+    Attributes:
+        file_id (:obj:`str`): Unique identifier for this file.
+        duration (:obj:`int`): Duration of the audio in seconds.
+        performer (:obj:`str`): Optional. Performer of the audio as defined by sender or by audio
+            tags.
+        title (:obj:`str`): Optional. Title of the audio as defined by sender or by audio tags.
+        mime_type (:obj:`str`): Optional. MIME type of the file as defined by sender.
+        file_size (:obj:`int`): Optional. File size.
+
+    Args:
+        file_id (:obj:`str`): Unique identifier for this file.
+        duration (:obj:`int`): Duration of the audio in seconds as defined by sender.
+        performer (:obj:`str`, optional): Performer of the audio as defined by sender or by audio
+            tags.
+        title (:obj:`str`, optional): Title of the audio as defined by sender or by audio tags.
+        mime_type (:obj:`str`, optional): MIME type of the file as defined by sender.
+        file_size (:obj:`int`, optional): File size.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 file_id,
+                 duration,
+                 performer=None,
+                 title=None,
+                 mime_type=None,
+                 file_size=None,
+                 **kwargs):
+        # Required
+        self.file_id = str(file_id)
+        self.duration = int(duration)
+        # Optionals
+        self.performer = performer
+        self.title = title
+        self.mime_type = mime_type
+        self.file_size = file_size
+
+        self._id_attrs = (self.file_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/chatphoto.py` & `python-telegram-bot-9.0.0/telegram/files/chatphoto.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ChatPhoto."""
-
-# TODO: add direct download shortcuts.
-
-from telegram import TelegramObject
-
-
-class ChatPhoto(TelegramObject):
-    """This object represents a chat photo.
-
-    Attributes:
-        small_file_id (:obj:`str`): Unique file identifier of small (160x160) chat photo.
-        big_file_id (:obj:`str`): Unique file identifier of big (640x640) chat photo.
-
-    Args:
-        small_file_id (:obj:`str`): Unique file identifier of small (160x160) chat photo. This
-            file_id can be used only for photo download.
-        big_file_id (:obj:`str`): Unique file identifier of big (640x640) chat photo. This file_id
-            can be used only for photo download.
-        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, small_file_id, big_file_id, bot=None, **kwargs):
-        self.small_file_id = small_file_id
-        self.big_file_id = big_file_id
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(bot=bot, **data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ChatPhoto."""
+
+# TODO: add direct download shortcuts.
+
+from telegram import TelegramObject
+
+
+class ChatPhoto(TelegramObject):
+    """This object represents a chat photo.
+
+    Attributes:
+        small_file_id (:obj:`str`): Unique file identifier of small (160x160) chat photo.
+        big_file_id (:obj:`str`): Unique file identifier of big (640x640) chat photo.
+
+    Args:
+        small_file_id (:obj:`str`): Unique file identifier of small (160x160) chat photo. This
+            file_id can be used only for photo download.
+        big_file_id (:obj:`str`): Unique file identifier of big (640x640) chat photo. This file_id
+            can be used only for photo download.
+        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, small_file_id, big_file_id, bot=None, **kwargs):
+        self.small_file_id = small_file_id
+        self.big_file_id = big_file_id
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(bot=bot, **data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/contact.py` & `python-telegram-bot-9.0.0/telegram/files/contact.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Contact."""
-
-from telegram import TelegramObject
-
-
-class Contact(TelegramObject):
-    """This object represents a phone contact.
-
-    Attributes:
-        phone_number (:obj:`str`): Contact's phone number.
-        first_name (:obj:`str`): Contact's first name.
-        last_name (:obj:`str`): Optional. Contact's last name.
-        user_id (:obj:`int`): Optional. Contact's user identifier in Telegram.
-
-    Args:
-        phone_number (:obj:`str`): Contact's phone number.
-        first_name (:obj:`str`): Contact's first name.
-        last_name (:obj:`str`, optional): Contact's last name.
-        user_id (:obj:`int`, optional): Contact's user identifier in Telegram.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, phone_number, first_name, last_name=None, user_id=None, **kwargs):
-        # Required
-        self.phone_number = str(phone_number)
-        self.first_name = first_name
-        # Optionals
-        self.last_name = last_name
-        self.user_id = user_id
-
-        self._id_attrs = (self.phone_number,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Contact."""
+
+from telegram import TelegramObject
+
+
+class Contact(TelegramObject):
+    """This object represents a phone contact.
+
+    Attributes:
+        phone_number (:obj:`str`): Contact's phone number.
+        first_name (:obj:`str`): Contact's first name.
+        last_name (:obj:`str`): Optional. Contact's last name.
+        user_id (:obj:`int`): Optional. Contact's user identifier in Telegram.
+
+    Args:
+        phone_number (:obj:`str`): Contact's phone number.
+        first_name (:obj:`str`): Contact's first name.
+        last_name (:obj:`str`, optional): Contact's last name.
+        user_id (:obj:`int`, optional): Contact's user identifier in Telegram.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, phone_number, first_name, last_name=None, user_id=None, **kwargs):
+        # Required
+        self.phone_number = str(phone_number)
+        self.first_name = first_name
+        # Optionals
+        self.last_name = last_name
+        self.user_id = user_id
+
+        self._id_attrs = (self.phone_number,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/document.py` & `python-telegram-bot-9.0.0/telegram/files/inputmediavideo.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,71 +1,74 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Document."""
-
-from telegram import PhotoSize, TelegramObject
-
-
-class Document(TelegramObject):
-    """This object represents a general file (as opposed to photos, voice messages and audio files).
-
-    Attributes:
-        file_id (:obj:`str`): Unique file identifier.
-        thumb (:class:`telegram.PhotoSize`): Optional. Document thumbnail.
-        file_name (:obj:`str`): Original filename.
-        mime_type (:obj:`str`): Optional. MIME type of the file.
-        file_size (:obj:`int`): Optional. File size.
-
-    Args:
-        file_id (:obj:`str`): Unique file identifier
-        thumb (:class:`telegram.PhotoSize`, optional): Document thumbnail as defined by sender.
-        file_name (:obj:`str`, optional): Original filename as defined by sender.
-        mime_type (:obj:`str`, optional): MIME type of the file as defined by sender.
-        file_size (:obj:`int`, optional): File size.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-    _id_keys = ('file_id',)
-
-    def __init__(self,
-                 file_id,
-                 thumb=None,
-                 file_name=None,
-                 mime_type=None,
-                 file_size=None,
-                 **kwargs):
-        # Required
-        self.file_id = str(file_id)
-        # Optionals
-        self.thumb = thumb
-        self.file_name = file_name
-        self.mime_type = mime_type
-        self.file_size = file_size
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(Document, cls).de_json(data, bot)
-
-        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram InputMediaPhoto."""
+from telegram import InputMedia, Video
+
+
+class InputMediaVideo(InputMedia):
+    """Represents a video to be sent.
+
+    Attributes:
+        type (:obj:`str`): ``video``.
+        media (:obj:`str`): File to send. Pass a file_id to send a file that exists on the Telegram
+            servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet.
+            Lastly you can pass an existing :class:`telegram.Video` object to send.
+        caption (:obj:`str`): Optional. Caption of the video to be sent, 0-200 characters.
+        width (:obj:`int`): Optional. Video width.
+        height (:obj:`int`): Optional. Video height.
+        duration (:obj:`int`): Optional. Video duration.
+
+    Args:
+        media (:obj:`str`): File to send. Pass a file_id to send a file that exists on the Telegram
+            servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet.
+            Lastly you can pass an existing :class:`telegram.Video` object to send.
+        caption (:obj:`str`, optional): Caption of the video to be sent, 0-200 characters.
+        width (:obj:`int`, optional): Video width.
+        height (:obj:`int`, optional): Video height.
+        duration (:obj:`int`, optional): Video duration.
+
+    Note:
+        When using a :class:`telegram.Video` for the :attr:`media` attribute. It will take the
+        width, height and duration from that video, unless otherwise specified with the optional
+        arguments.
+        At the moment using a new file is not yet supported.
+    """
+
+    # TODO: Make InputMediaPhoto, InputMediaVideo and send_media_group work with new files
+
+    def __init__(self, media, caption=None, width=None, height=None, duration=None):
+        self.type = 'video'
+
+        if isinstance(media, Video):
+            self.media = media.file_id
+            self.width = media.width
+            self.height = media.height
+            self.duration = media.duration
+        elif hasattr(media, 'read'):
+            raise ValueError('Sending files is not supported (yet).  Use file_id, url or Video')
+        else:
+            self.media = media
+
+        if caption:
+            self.caption = caption
+        if width:
+            self.width = width
+        if height:
+            self.height = height
+        if duration:
+            self.duration = duration
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/file.py` & `python-telegram-bot-9.0.0/telegram/files/file.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram File."""
-from os.path import basename
-
-from future.backports.urllib import parse as urllib_parse
-
-from telegram import TelegramObject
-
-
-class File(TelegramObject):
-    """
-    This object represents a file ready to be downloaded. The file can be downloaded with
-    :attr:`download`. It is guaranteed that the link will be valid for at least 1 hour. When the
-    link expires, a new one can be requested by calling getFile.
-
-    Note:
-        Maximum file size to download is 20 MB
-
-    Attributes:
-        file_id (:obj:`str`): Unique identifier for this file.
-        file_size (:obj:`str`): Optional. File size.
-        file_path (:obj:`str`): Optional. File path. Use :attr:`download` to get the file.
-
-    Args:
-        file_id (:obj:`str`): Unique identifier for this file.
-        file_size (:obj:`int`, optional): Optional. File size, if known.
-        file_path (:obj:`str`, optional): File path. Use :attr:`download` to get the file.
-        bot (:obj:`telegram.Bot`, optional): Bot to use with shortcut method.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, file_id, bot=None, file_size=None, file_path=None, **kwargs):
-        # Required
-        self.file_id = str(file_id)
-
-        # Optionals
-        self.file_size = file_size
-        self.file_path = file_path
-
-        self.bot = bot
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(bot=bot, **data)
-
-    def download(self, custom_path=None, out=None, timeout=None):
-        """
-        Download this file. By default, the file is saved in the current working directory with its
-        original filename as reported by Telegram. If a :attr:`custom_path` is supplied, it will be
-        saved to that path instead. If :attr:`out` is defined, the file contents will be saved to
-        that object using the ``out.write`` method.
-
-        Note:
-            `custom_path` and `out` are mutually exclusive.
-
-        Args:
-            custom_path (:obj:`str`, optional): Custom path.
-            out (:obj:`object`, optional): A file-like object. Must be opened in binary mode, if
-                applicable.
-            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
-                the read timeout from the server (instead of the one specified during creation of
-                the connection pool).
-
-        Raises:
-            ValueError: If both ``custom_path`` and ``out`` are passed.
-
-        """
-        if custom_path is not None and out is not None:
-            raise ValueError('custom_path and out are mutually exclusive')
-
-        # Convert any UTF-8 char into a url encoded ASCII string.
-        sres = urllib_parse.urlsplit(self.file_path)
-        url = urllib_parse.urlunsplit(urllib_parse.SplitResult(
-            sres.scheme, sres.netloc, urllib_parse.quote(sres.path), sres.query, sres.fragment))
-
-        if out:
-            buf = self.bot.request.retrieve(url)
-            out.write(buf)
-
-        else:
-            if custom_path:
-                filename = custom_path
-            else:
-                filename = basename(self.file_path)
-
-            self.bot.request.download(url, filename, timeout=timeout)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram File."""
+from os.path import basename
+
+from future.backports.urllib import parse as urllib_parse
+
+from telegram import TelegramObject
+
+
+class File(TelegramObject):
+    """
+    This object represents a file ready to be downloaded. The file can be downloaded with
+    :attr:`download`. It is guaranteed that the link will be valid for at least 1 hour. When the
+    link expires, a new one can be requested by calling getFile.
+
+    Note:
+        Maximum file size to download is 20 MB
+
+    Attributes:
+        file_id (:obj:`str`): Unique identifier for this file.
+        file_size (:obj:`str`): Optional. File size.
+        file_path (:obj:`str`): Optional. File path. Use :attr:`download` to get the file.
+
+    Args:
+        file_id (:obj:`str`): Unique identifier for this file.
+        file_size (:obj:`int`, optional): Optional. File size, if known.
+        file_path (:obj:`str`, optional): File path. Use :attr:`download` to get the file.
+        bot (:obj:`telegram.Bot`, optional): Bot to use with shortcut method.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, file_id, bot=None, file_size=None, file_path=None, **kwargs):
+        # Required
+        self.file_id = str(file_id)
+
+        # Optionals
+        self.file_size = file_size
+        self.file_path = file_path
+
+        self.bot = bot
+
+        self._id_attrs = (self.file_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(bot=bot, **data)
+
+    def download(self, custom_path=None, out=None, timeout=None):
+        """
+        Download this file. By default, the file is saved in the current working directory with its
+        original filename as reported by Telegram. If a :attr:`custom_path` is supplied, it will be
+        saved to that path instead. If :attr:`out` is defined, the file contents will be saved to
+        that object using the ``out.write`` method.
+
+        Note:
+            `custom_path` and `out` are mutually exclusive.
+
+        Args:
+            custom_path (:obj:`str`, optional): Custom path.
+            out (:obj:`object`, optional): A file-like object. Must be opened in binary mode, if
+                applicable.
+            timeout (:obj:`int` | :obj:`float`, optional): If this value is specified, use it as
+                the read timeout from the server (instead of the one specified during creation of
+                the connection pool).
+
+        Raises:
+            ValueError: If both ``custom_path`` and ``out`` are passed.
+
+        """
+        if custom_path is not None and out is not None:
+            raise ValueError('custom_path and out are mutually exclusive')
+
+        # Convert any UTF-8 char into a url encoded ASCII string.
+        sres = urllib_parse.urlsplit(self.file_path)
+        url = urllib_parse.urlunsplit(urllib_parse.SplitResult(
+            sres.scheme, sres.netloc, urllib_parse.quote(sres.path), sres.query, sres.fragment))
+
+        if out:
+            buf = self.bot.request.retrieve(url)
+            out.write(buf)
+
+        else:
+            if custom_path:
+                filename = custom_path
+            else:
+                filename = basename(self.file_path)
+
+            self.bot.request.download(url, filename, timeout=timeout)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/inputfile.py` & `python-telegram-bot-9.0.0/telegram/files/inputfile.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,179 +1,179 @@
-#!/usr/bin/env python
-# pylint: disable=W0622,E0611
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram InputFile."""
-
-try:
-    # python 3
-    from email.generator import _make_boundary as choose_boundary
-except ImportError:
-    # python 2
-    from mimetools import choose_boundary
-
-import imghdr
-import mimetypes
-import os
-import sys
-
-from telegram import TelegramError
-
-DEFAULT_MIME_TYPE = 'application/octet-stream'
-USER_AGENT = 'Python Telegram Bot (https://github.com/python-telegram-bot/python-telegram-bot)'
-FILE_TYPES = ('audio', 'document', 'photo', 'sticker', 'video', 'voice', 'certificate',
-              'video_note', 'png_sticker')
-
-
-class InputFile(object):
-    """This object represents a Telegram InputFile.
-
-    Attributes:
-        data (:obj:`dict`): Data containing an inputfile.
-
-    Args:
-        data (:obj:`dict`): Data containing an inputfile.
-
-    Raises:
-        TelegramError
-
-    """
-
-    def __init__(self, data):
-        self.data = data
-        self.boundary = choose_boundary()
-
-        for t in FILE_TYPES:
-            if t in data:
-                self.input_name = t
-                self.input_file = data.pop(t)
-                break
-        else:
-            raise TelegramError('Unknown inputfile type')
-
-        if hasattr(self.input_file, 'read'):
-            self.filename = None
-            self.input_file_content = self.input_file.read()
-            if 'filename' in data:
-                self.filename = self.data.pop('filename')
-            elif hasattr(self.input_file, 'name'):
-                # on py2.7, pylint fails to understand this properly
-                # pylint: disable=E1101
-                self.filename = os.path.basename(self.input_file.name)
-
-            try:
-                self.mimetype = self.is_image(self.input_file_content)
-                if not self.filename or '.' not in self.filename:
-                    self.filename = self.mimetype.replace('/', '.')
-            except TelegramError:
-                if self.filename:
-                    self.mimetype = mimetypes.guess_type(
-                        self.filename)[0] or DEFAULT_MIME_TYPE
-                else:
-                    self.mimetype = DEFAULT_MIME_TYPE
-
-    @property
-    def headers(self):
-        """:obj:`dict`: Headers."""
-
-        return {'User-agent': USER_AGENT, 'Content-type': self.content_type}
-
-    @property
-    def content_type(self):
-        """:obj:`str`: Content type"""
-        return 'multipart/form-data; boundary=%s' % self.boundary
-
-    def to_form(self):
-        """Transform the inputfile to multipart/form data.
-
-        Returns:
-            :obj:`str`
-
-        """
-        form = []
-        form_boundary = '--' + self.boundary
-
-        # Add data fields
-        for name in iter(self.data):
-            value = self.data[name]
-            form.extend([
-                form_boundary, 'Content-Disposition: form-data; name="%s"' % name, '', str(value)
-            ])
-
-        # Add input_file to upload
-        form.extend([
-            form_boundary, 'Content-Disposition: form-data; name="%s"; filename="%s"' %
-            (self.input_name,
-             self.filename), 'Content-Type: %s' % self.mimetype, '', self.input_file_content
-        ])
-
-        form.append('--' + self.boundary + '--')
-        form.append('')
-
-        return self._parse(form)
-
-    @staticmethod
-    def _parse(form):
-        if sys.version_info > (3,):
-            # on Python 3 form needs to be byte encoded
-            encoded_form = []
-            for item in form:
-                try:
-                    encoded_form.append(item.encode())
-                except AttributeError:
-                    encoded_form.append(item)
-
-            return b'\r\n'.join(encoded_form)
-        return '\r\n'.join(form)
-
-    @staticmethod
-    def is_image(stream):
-        """Check if the content file is an image by analyzing its headers.
-
-        Args:
-            stream (:obj:`str`): A str representing the content of a file.
-
-        Returns:
-            :obj:`str`: The str mime-type of an image.
-
-        """
-        image = imghdr.what(None, stream)
-        if image:
-            return 'image/%s' % image
-
-        raise TelegramError('Could not parse file content')
-
-    @staticmethod
-    def is_inputfile(data):
-        """Check if the request is a file request.
-
-        Args:
-            data (Dict[:obj:`str`, :obj:`str`]): A dict of (str, str) key/value pairs.
-
-        Returns:
-            :obj:`bool`
-
-        """
-        if data:
-            file_type = [i for i in iter(data) if i in FILE_TYPES]
-
-            if file_type:
-                file_content = data[file_type[0]]
-
-                return hasattr(file_content, 'read')
-
-        return False
+#!/usr/bin/env python
+# pylint: disable=W0622,E0611
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram InputFile."""
+
+try:
+    # python 3
+    from email.generator import _make_boundary as choose_boundary
+except ImportError:
+    # python 2
+    from mimetools import choose_boundary
+
+import imghdr
+import mimetypes
+import os
+import sys
+
+from telegram import TelegramError
+
+DEFAULT_MIME_TYPE = 'application/octet-stream'
+USER_AGENT = 'Python Telegram Bot (https://github.com/python-telegram-bot/python-telegram-bot)'
+FILE_TYPES = ('audio', 'document', 'photo', 'sticker', 'video', 'voice', 'certificate',
+              'video_note', 'png_sticker')
+
+
+class InputFile(object):
+    """This object represents a Telegram InputFile.
+
+    Attributes:
+        data (:obj:`dict`): Data containing an inputfile.
+
+    Args:
+        data (:obj:`dict`): Data containing an inputfile.
+
+    Raises:
+        TelegramError
+
+    """
+
+    def __init__(self, data):
+        self.data = data
+        self.boundary = choose_boundary()
+
+        for t in FILE_TYPES:
+            if t in data:
+                self.input_name = t
+                self.input_file = data.pop(t)
+                break
+        else:
+            raise TelegramError('Unknown inputfile type')
+
+        if hasattr(self.input_file, 'read'):
+            self.filename = None
+            self.input_file_content = self.input_file.read()
+            if 'filename' in data:
+                self.filename = self.data.pop('filename')
+            elif hasattr(self.input_file, 'name'):
+                # on py2.7, pylint fails to understand this properly
+                # pylint: disable=E1101
+                self.filename = os.path.basename(self.input_file.name)
+
+            try:
+                self.mimetype = self.is_image(self.input_file_content)
+                if not self.filename or '.' not in self.filename:
+                    self.filename = self.mimetype.replace('/', '.')
+            except TelegramError:
+                if self.filename:
+                    self.mimetype = mimetypes.guess_type(
+                        self.filename)[0] or DEFAULT_MIME_TYPE
+                else:
+                    self.mimetype = DEFAULT_MIME_TYPE
+
+    @property
+    def headers(self):
+        """:obj:`dict`: Headers."""
+
+        return {'User-agent': USER_AGENT, 'Content-type': self.content_type}
+
+    @property
+    def content_type(self):
+        """:obj:`str`: Content type"""
+        return 'multipart/form-data; boundary=%s' % self.boundary
+
+    def to_form(self):
+        """Transform the inputfile to multipart/form data.
+
+        Returns:
+            :obj:`str`
+
+        """
+        form = []
+        form_boundary = '--' + self.boundary
+
+        # Add data fields
+        for name in iter(self.data):
+            value = self.data[name]
+            form.extend([
+                form_boundary, 'Content-Disposition: form-data; name="%s"' % name, '', str(value)
+            ])
+
+        # Add input_file to upload
+        form.extend([
+            form_boundary, 'Content-Disposition: form-data; name="%s"; filename="%s"' %
+            (self.input_name,
+             self.filename), 'Content-Type: %s' % self.mimetype, '', self.input_file_content
+        ])
+
+        form.append('--' + self.boundary + '--')
+        form.append('')
+
+        return self._parse(form)
+
+    @staticmethod
+    def _parse(form):
+        if sys.version_info > (3,):
+            # on Python 3 form needs to be byte encoded
+            encoded_form = []
+            for item in form:
+                try:
+                    encoded_form.append(item.encode())
+                except AttributeError:
+                    encoded_form.append(item)
+
+            return b'\r\n'.join(encoded_form)
+        return '\r\n'.join(form)
+
+    @staticmethod
+    def is_image(stream):
+        """Check if the content file is an image by analyzing its headers.
+
+        Args:
+            stream (:obj:`str`): A str representing the content of a file.
+
+        Returns:
+            :obj:`str`: The str mime-type of an image.
+
+        """
+        image = imghdr.what(None, stream)
+        if image:
+            return 'image/%s' % image
+
+        raise TelegramError('Could not parse file content')
+
+    @staticmethod
+    def is_inputfile(data):
+        """Check if the request is a file request.
+
+        Args:
+            data (Dict[:obj:`str`, :obj:`str`]): A dict of (str, str) key/value pairs.
+
+        Returns:
+            :obj:`bool`
+
+        """
+        if data:
+            file_type = [i for i in iter(data) if i in FILE_TYPES]
+
+            if file_type:
+                file_content = data[file_type[0]]
+
+                return hasattr(file_content, 'read')
+
+        return False
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/location.py` & `python-telegram-bot-9.0.0/telegram/files/location.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Location."""
-
-from telegram import TelegramObject
-
-
-class Location(TelegramObject):
-    """This object represents a point on the map.
-
-    Attributes:
-        longitude (:obj:`float`): Longitude as defined by sender.
-        latitude (:obj:`float`): Latitude as defined by sender.
-
-    Args:
-        longitude (:obj:`float`): Longitude as defined by sender.
-        latitude (:obj:`float`): Latitude as defined by sender.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, longitude, latitude, **kwargs):
-        # Required
-        self.longitude = float(longitude)
-        self.latitude = float(latitude)
-
-        self._id_attrs = (self.longitude, self.latitude)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Location."""
+
+from telegram import TelegramObject
+
+
+class Location(TelegramObject):
+    """This object represents a point on the map.
+
+    Attributes:
+        longitude (:obj:`float`): Longitude as defined by sender.
+        latitude (:obj:`float`): Latitude as defined by sender.
+
+    Args:
+        longitude (:obj:`float`): Longitude as defined by sender.
+        latitude (:obj:`float`): Latitude as defined by sender.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, longitude, latitude, **kwargs):
+        # Required
+        self.longitude = float(longitude)
+        self.latitude = float(latitude)
+
+        self._id_attrs = (self.longitude, self.latitude)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/photosize.py` & `python-telegram-bot-9.0.0/telegram/files/photosize.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram PhotoSize."""
-
-from telegram import TelegramObject
-
-
-class PhotoSize(TelegramObject):
-    """This object represents one size of a photo or a file/sticker thumbnail.
-
-    Attributes:
-        file_id (:obj:`str`): Unique identifier for this file.
-        width (:obj:`int`): Photo width.
-        height (:obj:`int`): Photo height.
-        file_size (:obj:`int`): Optional. File size.
-
-    Args:
-        file_id (:obj:`str`): Unique identifier for this file.
-        width (:obj:`int`): Photo width.
-        height (:obj:`int`): Photo height.
-        file_size (:obj:`int`, optional): File size.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, file_id, width, height, file_size=None, **kwargs):
-        # Required
-        self.file_id = str(file_id)
-        self.width = int(width)
-        self.height = int(height)
-        # Optionals
-        self.file_size = file_size
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(**data)
-
-    @classmethod
-    def de_list(cls, data, bot):
-        if not data:
-            return []
-
-        photos = list()
-        for photo in data:
-            photos.append(cls.de_json(photo, bot))
-
-        return photos
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram PhotoSize."""
+
+from telegram import TelegramObject
+
+
+class PhotoSize(TelegramObject):
+    """This object represents one size of a photo or a file/sticker thumbnail.
+
+    Attributes:
+        file_id (:obj:`str`): Unique identifier for this file.
+        width (:obj:`int`): Photo width.
+        height (:obj:`int`): Photo height.
+        file_size (:obj:`int`): Optional. File size.
+
+    Args:
+        file_id (:obj:`str`): Unique identifier for this file.
+        width (:obj:`int`): Photo width.
+        height (:obj:`int`): Photo height.
+        file_size (:obj:`int`, optional): File size.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, file_id, width, height, file_size=None, **kwargs):
+        # Required
+        self.file_id = str(file_id)
+        self.width = int(width)
+        self.height = int(height)
+        # Optionals
+        self.file_size = file_size
+
+        self._id_attrs = (self.file_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(**data)
+
+    @classmethod
+    def de_list(cls, data, bot):
+        if not data:
+            return []
+
+        photos = list()
+        for photo in data:
+            photos.append(cls.de_json(photo, bot))
+
+        return photos
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/sticker.py` & `python-telegram-bot-9.0.0/telegram/files/sticker.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,188 +1,188 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains objects that represents stickers."""
-
-from telegram import PhotoSize, TelegramObject
-
-
-class Sticker(TelegramObject):
-    """This object represents a sticker.
-
-    Attributes:
-        file_id (:obj:`str`): Unique identifier for this file.
-        width (:obj:`int`): Sticker width.
-        height (:obj:`int`): Sticker height.
-        thumb (:class:`telegram.PhotoSize`): Optional. Sticker thumbnail in the .webp or .jpg
-            format.
-        emoji (:obj:`str`): Optional. Emoji associated with the sticker.
-        set_name (:obj:`str`): Optional. Name of the sticker set to which the sticker belongs.
-        mask_position (:class:`telegram.MaskPosition`): Optional. For mask stickers, the position
-            where the mask should be placed.
-        file_size (:obj:`int`): Optional. File size.
-
-    Args:
-        file_id (:obj:`str`): Unique identifier for this file.
-        width (:obj:`int`): Sticker width.
-        height (:obj:`int`): Sticker height.
-        thumb (:class:`telegram.PhotoSize`, optional): Sticker thumbnail in the .webp or .jpg
-            format.
-        emoji (:obj:`str`, optional): Emoji associated with the sticker
-        set_name (:obj:`str`, optional): Name of the sticker set to which the sticker
-            belongs.
-        mask_position (:class:`telegram.MaskPosition`, optional): For mask stickers, the
-            position where the mask should be placed.
-        file_size (:obj:`int`, optional): File size.
-        **kwargs (obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 file_id,
-                 width,
-                 height,
-                 thumb=None,
-                 emoji=None,
-                 file_size=None,
-                 set_name=None,
-                 mask_position=None,
-                 **kwargs):
-        # Required
-        self.file_id = str(file_id)
-        self.width = int(width)
-        self.height = int(height)
-        # Optionals
-        self.thumb = thumb
-        self.emoji = emoji
-        self.file_size = file_size
-        self.set_name = set_name
-        self.mask_position = mask_position
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(Sticker, cls).de_json(data, bot)
-
-        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
-        data['mask_position'] = MaskPosition.de_json(data.get('mask_position'), bot)
-
-        return cls(**data)
-
-    @classmethod
-    def de_list(cls, data, bot):
-        if not data:
-            return list()
-
-        return [cls.de_json(d, bot) for d in data]
-
-
-class StickerSet(TelegramObject):
-    """This object represents a sticker set.
-
-    Attributes:
-        name (:obj:`str`): Sticker set name.
-        title (:obj:`str`): Sticker set title.
-        contains_masks (:obj:`bool`): True, if the sticker set contains masks.
-        stickers (List[:class:`telegram.Sticker`]): List of all set stickers.
-
-    Args:
-        name (:obj:`str`): Sticker set name.
-        title (:obj:`str`): Sticker set title.
-        contains_masks (:obj:`bool`): True, if the sticker set contains masks.
-        stickers (List[:class:`telegram.Sticker`]): List of all set stickers.
-
-    """
-
-    def __init__(self, name, title, contains_masks, stickers, bot=None, **kwargs):
-        self.name = name
-        self.title = title
-        self.contains_masks = contains_masks
-        self.stickers = stickers
-
-        self._id_attrs = (self.name,)
-
-    @staticmethod
-    def de_json(data, bot):
-        if not data:
-            return None
-
-        data = super(StickerSet, StickerSet).de_json(data, bot)
-
-        data['stickers'] = Sticker.de_list(data.get('stickers'), bot)
-
-        return StickerSet(bot=bot, **data)
-
-    def to_dict(self):
-        data = super(StickerSet, self).to_dict()
-
-        data['stickers'] = [s.to_dict() for s in data.get('stickers')]
-
-        return data
-
-
-class MaskPosition(TelegramObject):
-    """This object describes the position on faces where a mask should be placed by default.
-
-    Attributes:
-        point (:obj:`str`): The part of the face relative to which the mask should be placed.
-        x_shift (:obj:`float`): Shift by X-axis measured in widths of the mask scaled to the face
-            size, from left to right.
-        y_shift (:obj:`float`): Shift by Y-axis measured in heights of the mask scaled to the face
-            size, from top to bottom.
-        scale (:obj:`float`): Mask scaling coefficient. For example, 2.0 means double size.
-
-    Notes:
-        :attr:`type` should be one of the following: `forehead`, `eyes`, `mouth` or `chin`. You can
-        use the classconstants for those.
-
-    Args:
-        point (:obj:`str`): The part of the face relative to which the mask should be placed.
-        x_shift (:obj:`float`): Shift by X-axis measured in widths of the mask scaled to the face
-            size, from left to right. For example, choosing -1.0 will place mask just to the left
-            of the default mask position.
-        y_shift (:obj:`float`): Shift by Y-axis measured in heights of the mask scaled to the face
-            size, from top to bottom. For example, 1.0 will place the mask just below the default
-            mask position.
-        scale (:obj:`float`): Mask scaling coefficient. For example, 2.0 means double size.
-
-    """
-    FOREHEAD = 'forehead'
-    """:obj:`str`: 'forehead'"""
-    EYES = 'eyes'
-    """:obj:`str`: 'eyes'"""
-    MOUTH = 'mouth'
-    """:obj:`str`: 'mouth'"""
-    CHIN = 'chin'
-    """:obj:`str`: 'chin'"""
-
-    def __init__(self, point, x_shift, y_shift, scale, **kwargs):
-        self.point = point
-        self.x_shift = x_shift
-        self.y_shift = y_shift
-        self.scale = scale
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if data is None:
-            return None
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains objects that represents stickers."""
+
+from telegram import PhotoSize, TelegramObject
+
+
+class Sticker(TelegramObject):
+    """This object represents a sticker.
+
+    Attributes:
+        file_id (:obj:`str`): Unique identifier for this file.
+        width (:obj:`int`): Sticker width.
+        height (:obj:`int`): Sticker height.
+        thumb (:class:`telegram.PhotoSize`): Optional. Sticker thumbnail in the .webp or .jpg
+            format.
+        emoji (:obj:`str`): Optional. Emoji associated with the sticker.
+        set_name (:obj:`str`): Optional. Name of the sticker set to which the sticker belongs.
+        mask_position (:class:`telegram.MaskPosition`): Optional. For mask stickers, the position
+            where the mask should be placed.
+        file_size (:obj:`int`): Optional. File size.
+
+    Args:
+        file_id (:obj:`str`): Unique identifier for this file.
+        width (:obj:`int`): Sticker width.
+        height (:obj:`int`): Sticker height.
+        thumb (:class:`telegram.PhotoSize`, optional): Sticker thumbnail in the .webp or .jpg
+            format.
+        emoji (:obj:`str`, optional): Emoji associated with the sticker
+        set_name (:obj:`str`, optional): Name of the sticker set to which the sticker
+            belongs.
+        mask_position (:class:`telegram.MaskPosition`, optional): For mask stickers, the
+            position where the mask should be placed.
+        file_size (:obj:`int`, optional): File size.
+        **kwargs (obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 file_id,
+                 width,
+                 height,
+                 thumb=None,
+                 emoji=None,
+                 file_size=None,
+                 set_name=None,
+                 mask_position=None,
+                 **kwargs):
+        # Required
+        self.file_id = str(file_id)
+        self.width = int(width)
+        self.height = int(height)
+        # Optionals
+        self.thumb = thumb
+        self.emoji = emoji
+        self.file_size = file_size
+        self.set_name = set_name
+        self.mask_position = mask_position
+
+        self._id_attrs = (self.file_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(Sticker, cls).de_json(data, bot)
+
+        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
+        data['mask_position'] = MaskPosition.de_json(data.get('mask_position'), bot)
+
+        return cls(**data)
+
+    @classmethod
+    def de_list(cls, data, bot):
+        if not data:
+            return list()
+
+        return [cls.de_json(d, bot) for d in data]
+
+
+class StickerSet(TelegramObject):
+    """This object represents a sticker set.
+
+    Attributes:
+        name (:obj:`str`): Sticker set name.
+        title (:obj:`str`): Sticker set title.
+        contains_masks (:obj:`bool`): True, if the sticker set contains masks.
+        stickers (List[:class:`telegram.Sticker`]): List of all set stickers.
+
+    Args:
+        name (:obj:`str`): Sticker set name.
+        title (:obj:`str`): Sticker set title.
+        contains_masks (:obj:`bool`): True, if the sticker set contains masks.
+        stickers (List[:class:`telegram.Sticker`]): List of all set stickers.
+
+    """
+
+    def __init__(self, name, title, contains_masks, stickers, bot=None, **kwargs):
+        self.name = name
+        self.title = title
+        self.contains_masks = contains_masks
+        self.stickers = stickers
+
+        self._id_attrs = (self.name,)
+
+    @staticmethod
+    def de_json(data, bot):
+        if not data:
+            return None
+
+        data = super(StickerSet, StickerSet).de_json(data, bot)
+
+        data['stickers'] = Sticker.de_list(data.get('stickers'), bot)
+
+        return StickerSet(bot=bot, **data)
+
+    def to_dict(self):
+        data = super(StickerSet, self).to_dict()
+
+        data['stickers'] = [s.to_dict() for s in data.get('stickers')]
+
+        return data
+
+
+class MaskPosition(TelegramObject):
+    """This object describes the position on faces where a mask should be placed by default.
+
+    Attributes:
+        point (:obj:`str`): The part of the face relative to which the mask should be placed.
+        x_shift (:obj:`float`): Shift by X-axis measured in widths of the mask scaled to the face
+            size, from left to right.
+        y_shift (:obj:`float`): Shift by Y-axis measured in heights of the mask scaled to the face
+            size, from top to bottom.
+        scale (:obj:`float`): Mask scaling coefficient. For example, 2.0 means double size.
+
+    Notes:
+        :attr:`type` should be one of the following: `forehead`, `eyes`, `mouth` or `chin`. You can
+        use the classconstants for those.
+
+    Args:
+        point (:obj:`str`): The part of the face relative to which the mask should be placed.
+        x_shift (:obj:`float`): Shift by X-axis measured in widths of the mask scaled to the face
+            size, from left to right. For example, choosing -1.0 will place mask just to the left
+            of the default mask position.
+        y_shift (:obj:`float`): Shift by Y-axis measured in heights of the mask scaled to the face
+            size, from top to bottom. For example, 1.0 will place the mask just below the default
+            mask position.
+        scale (:obj:`float`): Mask scaling coefficient. For example, 2.0 means double size.
+
+    """
+    FOREHEAD = 'forehead'
+    """:obj:`str`: 'forehead'"""
+    EYES = 'eyes'
+    """:obj:`str`: 'eyes'"""
+    MOUTH = 'mouth'
+    """:obj:`str`: 'mouth'"""
+    CHIN = 'chin'
+    """:obj:`str`: 'chin'"""
+
+    def __init__(self, point, x_shift, y_shift, scale, **kwargs):
+        self.point = point
+        self.x_shift = x_shift
+        self.y_shift = y_shift
+        self.scale = scale
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if data is None:
+            return None
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/venue.py` & `python-telegram-bot-9.0.0/telegram/files/venue.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,61 +1,61 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Venue."""
-
-from telegram import TelegramObject, Location
-
-
-class Venue(TelegramObject):
-    """This object represents a venue.
-
-    Attributes:
-        location (:class:`telegram.Location`): Venue location.
-        title (:obj:`str`): Name of the venue.
-        address (:obj:`str`): Address of the venue.
-        foursquare_id (:obj:`str`): Optional. Foursquare identifier of the venue.
-
-    Args:
-        location (:class:`telegram.Location`): Venue location.
-        title (:obj:`str`): Name of the venue.
-        address (:obj:`str`): Address of the venue.
-        foursquare_id (:obj:`str`, optional): Foursquare identifier of the venue.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, location, title, address, foursquare_id=None, **kwargs):
-        # Required
-        self.location = location
-        self.title = title
-        self.address = address
-        # Optionals
-        self.foursquare_id = foursquare_id
-
-        self._id_attrs = (self.location, self.title)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        data = super(Venue, cls).de_json(data, bot)
-
-        if not data:
-            return None
-
-        data['location'] = Location.de_json(data.get('location'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Venue."""
+
+from telegram import TelegramObject, Location
+
+
+class Venue(TelegramObject):
+    """This object represents a venue.
+
+    Attributes:
+        location (:class:`telegram.Location`): Venue location.
+        title (:obj:`str`): Name of the venue.
+        address (:obj:`str`): Address of the venue.
+        foursquare_id (:obj:`str`): Optional. Foursquare identifier of the venue.
+
+    Args:
+        location (:class:`telegram.Location`): Venue location.
+        title (:obj:`str`): Name of the venue.
+        address (:obj:`str`): Address of the venue.
+        foursquare_id (:obj:`str`, optional): Foursquare identifier of the venue.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, location, title, address, foursquare_id=None, **kwargs):
+        # Required
+        self.location = location
+        self.title = title
+        self.address = address
+        # Optionals
+        self.foursquare_id = foursquare_id
+
+        self._id_attrs = (self.location, self.title)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        data = super(Venue, cls).de_json(data, bot)
+
+        if not data:
+            return None
+
+        data['location'] = Location.de_json(data.get('location'), bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/video.py` & `python-telegram-bot-9.0.0/telegram/files/video.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,78 +1,78 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Video."""
-
-from telegram import PhotoSize, TelegramObject
-
-
-class Video(TelegramObject):
-    """This object represents a video file.
-
-    Attributes:
-        file_id (:obj:`str`): Unique identifier for this file.
-        width (:obj:`int`): Video width as defined by sender.
-        height (:obj:`int`): Video height as defined by sender.
-        duration (:obj:`int`): Duration of the video in seconds as defined by sender.
-        thumb (:class:`telegram.PhotoSize`): Optional. Video thumbnail.
-        mime_type (:obj:`str`): Optional. Mime type of a file as defined by sender.
-        file_size (:obj:`int`): Optional. File size.
-
-    Args:
-        file_id (:obj:`str`): Unique identifier for this file.
-        width (:obj:`int`): Video width as defined by sender.
-        height (:obj:`int`): Video height as defined by sender.
-        duration (:obj:`int`): Duration of the video in seconds as defined by sender.
-        thumb (:class:`telegram.PhotoSize`, optional): Video thumbnail.
-        mime_type (:obj:`str`, optional): Mime type of a file as defined by sender.
-        file_size (:obj:`int`, optional): File size.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 file_id,
-                 width,
-                 height,
-                 duration,
-                 thumb=None,
-                 mime_type=None,
-                 file_size=None,
-                 **kwargs):
-        # Required
-        self.file_id = str(file_id)
-        self.width = int(width)
-        self.height = int(height)
-        self.duration = int(duration)
-        # Optionals
-        self.thumb = thumb
-        self.mime_type = mime_type
-        self.file_size = file_size
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(Video, cls).de_json(data, bot)
-
-        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Video."""
+
+from telegram import PhotoSize, TelegramObject
+
+
+class Video(TelegramObject):
+    """This object represents a video file.
+
+    Attributes:
+        file_id (:obj:`str`): Unique identifier for this file.
+        width (:obj:`int`): Video width as defined by sender.
+        height (:obj:`int`): Video height as defined by sender.
+        duration (:obj:`int`): Duration of the video in seconds as defined by sender.
+        thumb (:class:`telegram.PhotoSize`): Optional. Video thumbnail.
+        mime_type (:obj:`str`): Optional. Mime type of a file as defined by sender.
+        file_size (:obj:`int`): Optional. File size.
+
+    Args:
+        file_id (:obj:`str`): Unique identifier for this file.
+        width (:obj:`int`): Video width as defined by sender.
+        height (:obj:`int`): Video height as defined by sender.
+        duration (:obj:`int`): Duration of the video in seconds as defined by sender.
+        thumb (:class:`telegram.PhotoSize`, optional): Video thumbnail.
+        mime_type (:obj:`str`, optional): Mime type of a file as defined by sender.
+        file_size (:obj:`int`, optional): File size.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 file_id,
+                 width,
+                 height,
+                 duration,
+                 thumb=None,
+                 mime_type=None,
+                 file_size=None,
+                 **kwargs):
+        # Required
+        self.file_id = str(file_id)
+        self.width = int(width)
+        self.height = int(height)
+        self.duration = int(duration)
+        # Optionals
+        self.thumb = thumb
+        self.mime_type = mime_type
+        self.file_size = file_size
+
+        self._id_attrs = (self.file_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(Video, cls).de_json(data, bot)
+
+        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/videonote.py` & `python-telegram-bot-9.0.0/telegram/files/videonote.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,64 +1,64 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram VideoNote."""
-
-from telegram import PhotoSize, TelegramObject
-
-
-class VideoNote(TelegramObject):
-    """This object represents a video message (available in Telegram apps as of v.4.0).
-
-    Attributes:
-        file_id (:obj:`str`): Unique identifier for this file.
-        length (:obj:`int`): Video width and height as defined by sender.
-        duration (:obj:`int`): Duration of the video in seconds as defined by sender.
-        thumb (:class:`telegram.PhotoSize`): Optional. Video thumbnail.
-        file_size (:obj:`int`): Optional. File size.
-
-    Args:
-        file_id (:obj:`str`): Unique identifier for this file.
-        length (:obj:`int`): Video width and height as defined by sender.
-        duration (:obj:`int`): Duration of the video in seconds as defined by sender.
-        thumb (:class:`telegram.PhotoSize`, optional): Video thumbnail.
-        file_size (:obj:`int`, optional): File size.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, file_id, length, duration, thumb=None, file_size=None, **kwargs):
-        # Required
-        self.file_id = str(file_id)
-        self.length = int(length)
-        self.duration = int(duration)
-        # Optionals
-        self.thumb = thumb
-        self.file_size = file_size
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(VideoNote, cls).de_json(data, bot)
-
-        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram VideoNote."""
+
+from telegram import PhotoSize, TelegramObject
+
+
+class VideoNote(TelegramObject):
+    """This object represents a video message (available in Telegram apps as of v.4.0).
+
+    Attributes:
+        file_id (:obj:`str`): Unique identifier for this file.
+        length (:obj:`int`): Video width and height as defined by sender.
+        duration (:obj:`int`): Duration of the video in seconds as defined by sender.
+        thumb (:class:`telegram.PhotoSize`): Optional. Video thumbnail.
+        file_size (:obj:`int`): Optional. File size.
+
+    Args:
+        file_id (:obj:`str`): Unique identifier for this file.
+        length (:obj:`int`): Video width and height as defined by sender.
+        duration (:obj:`int`): Duration of the video in seconds as defined by sender.
+        thumb (:class:`telegram.PhotoSize`, optional): Video thumbnail.
+        file_size (:obj:`int`, optional): File size.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, file_id, length, duration, thumb=None, file_size=None, **kwargs):
+        # Required
+        self.file_id = str(file_id)
+        self.length = int(length)
+        self.duration = int(duration)
+        # Optionals
+        self.thumb = thumb
+        self.file_size = file_size
+
+        self._id_attrs = (self.file_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(VideoNote, cls).de_json(data, bot)
+
+        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/files/voice.py` & `python-telegram-bot-9.0.0/telegram/files/voice.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Voice."""
-
-from telegram import TelegramObject
-
-
-class Voice(TelegramObject):
-    """This object represents a voice note.
-
-    Attributes:
-        file_id (:obj:`str`): Unique identifier for this file.
-        duration (:obj:`int`): Duration of the audio in seconds as defined by sender.
-        mime_type (:obj:`str`): Optional. MIME type of the file as defined by sender.
-        file_size (:obj:`int`): Optional. File size.
-
-    Args:
-        file_id (:obj:`str`): Unique identifier for this file.
-        duration (:obj:`int`, optional): Duration of the audio in seconds as defined by sender.
-        mime_type (:obj:`str`, optional): MIME type of the file as defined by sender.
-        file_size (:obj:`int`, optional): File size.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, file_id, duration, mime_type=None, file_size=None, **kwargs):
-        # Required
-        self.file_id = str(file_id)
-        self.duration = int(duration)
-        # Optionals
-        self.mime_type = mime_type
-        self.file_size = file_size
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(Voice, cls).de_json(data, bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Voice."""
+
+from telegram import TelegramObject
+
+
+class Voice(TelegramObject):
+    """This object represents a voice note.
+
+    Attributes:
+        file_id (:obj:`str`): Unique identifier for this file.
+        duration (:obj:`int`): Duration of the audio in seconds as defined by sender.
+        mime_type (:obj:`str`): Optional. MIME type of the file as defined by sender.
+        file_size (:obj:`int`): Optional. File size.
+
+    Args:
+        file_id (:obj:`str`): Unique identifier for this file.
+        duration (:obj:`int`, optional): Duration of the audio in seconds as defined by sender.
+        mime_type (:obj:`str`, optional): MIME type of the file as defined by sender.
+        file_size (:obj:`int`, optional): File size.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, file_id, duration, mime_type=None, file_size=None, **kwargs):
+        # Required
+        self.file_id = str(file_id)
+        self.duration = int(duration)
+        # Optionals
+        self.mime_type = mime_type
+        self.file_size = file_size
+
+        self._id_attrs = (self.file_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(Voice, cls).de_json(data, bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/forcereply.py` & `python-telegram-bot-9.0.0/telegram/forcereply.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ForceReply."""
-
-from telegram import ReplyMarkup
-
-
-class ForceReply(ReplyMarkup):
-    """
-    Upon receiving a message with this object, Telegram clients will display a reply interface to
-    the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be
-    extremely useful if you want to create user-friendly step-by-step interfaces without having
-    to sacrifice privacy mode.
-
-    Attributes:
-        force_reply (:obj:`True`): Shows reply interface to the user.
-        selective (:obj:`bool`): Optional. Force reply from specific users only.
-
-    Args:
-        selective (:obj:`bool`, optional): Use this parameter if you want to force reply from
-            specific users only. Targets:
-
-            1) users that are @mentioned in the text of the Message object
-            2) if the bot's message is a reply (has reply_to_message_id), sender of the
-               original message.
-
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, force_reply=True, selective=False, **kwargs):
-        # Required
-        self.force_reply = bool(force_reply)
-        # Optionals
-        self.selective = bool(selective)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ForceReply."""
+
+from telegram import ReplyMarkup
+
+
+class ForceReply(ReplyMarkup):
+    """
+    Upon receiving a message with this object, Telegram clients will display a reply interface to
+    the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be
+    extremely useful if you want to create user-friendly step-by-step interfaces without having
+    to sacrifice privacy mode.
+
+    Attributes:
+        force_reply (:obj:`True`): Shows reply interface to the user.
+        selective (:obj:`bool`): Optional. Force reply from specific users only.
+
+    Args:
+        selective (:obj:`bool`, optional): Use this parameter if you want to force reply from
+            specific users only. Targets:
+
+            1) users that are @mentioned in the text of the Message object
+            2) if the bot's message is a reply (has reply_to_message_id), sender of the
+               original message.
+
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, force_reply=True, selective=False, **kwargs):
+        # Required
+        self.force_reply = bool(force_reply)
+        # Optionals
+        self.selective = bool(selective)
```

### Comparing `python-telegram-bot-8.1.1/telegram/games/animation.py` & `python-telegram-bot-9.0.0/telegram/games/animation.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Animation."""
-from telegram import PhotoSize
-from telegram import TelegramObject
-
-
-class Animation(TelegramObject):
-    """This object represents an animation file to be displayed in the message containing a game.
-
-    Attributes:
-        file_id (:obj:`str`): Unique file identifier.
-        thumb (:class:`telegram.PhotoSize`): Optional. Animation thumbnail as defined
-            by sender.
-        file_name (:obj:`str`): Optional. Original animation filename as defined by sender.
-        mime_type (:obj:`str`): Optional. MIME type of the file as defined by sender.
-        file_size (:obj:`int`): Optional. File size.
-
-    Args:
-        file_id (:obj:`str`): Unique file identifier.
-        thumb (:class:`telegram.PhotoSize`, optional): Animation thumbnail as defined by sender.
-        file_name (:obj:`str`, optional): Original animation filename as defined by sender.
-        mime_type (:obj:`str`, optional): MIME type of the file as defined by sender.
-        file_size (:obj:`int`, optional): File size.
-
-    """
-
-    def __init__(self,
-                 file_id,
-                 thumb=None,
-                 file_name=None,
-                 mime_type=None,
-                 file_size=None,
-                 **kwargs):
-        self.file_id = file_id
-        self.thumb = thumb
-        self.file_name = file_name
-        self.mime_type = mime_type
-        self.file_size = file_size
-
-        self._id_attrs = (self.file_id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(Animation, cls).de_json(data, bot)
-
-        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Animation."""
+from telegram import PhotoSize
+from telegram import TelegramObject
+
+
+class Animation(TelegramObject):
+    """This object represents an animation file to be displayed in the message containing a game.
+
+    Attributes:
+        file_id (:obj:`str`): Unique file identifier.
+        thumb (:class:`telegram.PhotoSize`): Optional. Animation thumbnail as defined
+            by sender.
+        file_name (:obj:`str`): Optional. Original animation filename as defined by sender.
+        mime_type (:obj:`str`): Optional. MIME type of the file as defined by sender.
+        file_size (:obj:`int`): Optional. File size.
+
+    Args:
+        file_id (:obj:`str`): Unique file identifier.
+        thumb (:class:`telegram.PhotoSize`, optional): Animation thumbnail as defined by sender.
+        file_name (:obj:`str`, optional): Original animation filename as defined by sender.
+        mime_type (:obj:`str`, optional): MIME type of the file as defined by sender.
+        file_size (:obj:`int`, optional): File size.
+
+    """
+
+    def __init__(self,
+                 file_id,
+                 thumb=None,
+                 file_name=None,
+                 mime_type=None,
+                 file_size=None,
+                 **kwargs):
+        self.file_id = file_id
+        self.thumb = thumb
+        self.file_name = file_name
+        self.mime_type = mime_type
+        self.file_size = file_size
+
+        self._id_attrs = (self.file_id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(Animation, cls).de_json(data, bot)
+
+        data['thumb'] = PhotoSize.de_json(data.get('thumb'), bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/games/callbackgame.py` & `python-telegram-bot-9.0.0/telegram/games/callbackgame.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram CallbackGame."""
-
-from telegram import TelegramObject
-
-
-class CallbackGame(TelegramObject):
-    """A placeholder, currently holds no information. Use BotFather to set up your game."""
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram CallbackGame."""
+
+from telegram import TelegramObject
+
+
+class CallbackGame(TelegramObject):
+    """A placeholder, currently holds no information. Use BotFather to set up your game."""
```

### Comparing `python-telegram-bot-8.1.1/telegram/games/game.py` & `python-telegram-bot-9.0.0/telegram/games/game.py`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,149 +1,149 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Game."""
-
-import sys
-
-from telegram import MessageEntity, TelegramObject, Animation, PhotoSize
-
-
-class Game(TelegramObject):
-    """
-    This object represents a game. Use BotFather to create and edit games, their short names will
-    act as unique identifiers.
-
-    Attributes:
-        title (:obj:`str`): Title of the game.
-        description (:obj:`str`): Description of the game.
-        photo (List[:class:`telegram.PhotoSize`]): Photo that will be displayed in the game message
-            in chats.
-        text (:obj:`str`): Optional. Brief description of the game or high scores included in the
-            game message. Can be automatically edited to include current high scores for the game
-            when the bot calls set_game_score, or manually edited using edit_message_text.
-        text_entities (List[:class:`telegram.MessageEntity`]): Optional. Special entities that
-            appear in text, such as usernames, URLs, bot commands, etc.
-        animation (:class:`telegram.Animation`): Optional. Animation that will be displayed in the
-            game message in chats. Upload via BotFather.
-
-    Args:
-        title (:obj:`str`): Title of the game.
-        description (:obj:`str`): Description of the game.
-        photo (List[:class:`telegram.PhotoSize`]): Photo that will be displayed in the game message
-            in chats.
-        text (:obj:`str`, optional): Brief description of the game or high scores included in the
-            game message. Can be automatically edited to include current high scores for the game
-            when the bot calls set_game_score, or manually edited using edit_message_text.
-            0-4096 characters. Also found as ``telegram.constants.MAX_MESSAGE_LENGTH``.
-        text_entities (List[:class:`telegram.MessageEntity`], optional): Special entities that
-            appear in text, such as usernames, URLs, bot commands, etc.
-        animation (:class:`telegram.Animation`, optional): Animation that will be displayed in the
-            game message in chats. Upload via BotFather.
-
-    """
-
-    def __init__(self,
-                 title,
-                 description,
-                 photo,
-                 text=None,
-                 text_entities=None,
-                 animation=None,
-                 **kwargs):
-        self.title = title
-        self.description = description
-        self.photo = photo
-        self.text = text
-        self.text_entities = text_entities or list()
-        self.animation = animation
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(Game, cls).de_json(data, bot)
-
-        data['photo'] = PhotoSize.de_list(data.get('photo'), bot)
-        data['text_entities'] = MessageEntity.de_list(data.get('text_entities'), bot)
-        data['animation'] = Animation.de_json(data.get('animation'), bot)
-
-        return cls(**data)
-
-    def to_dict(self):
-        data = super(Game, self).to_dict()
-
-        data['photo'] = [p.to_dict() for p in self.photo]
-        if self.text_entities:
-            data['text_entities'] = [x.to_dict() for x in self.text_entities]
-
-        return data
-
-    def parse_text_entity(self, entity):
-        """Returns the text from a given :class:`telegram.MessageEntity`.
-
-        Note:
-            This method is present because Telegram calculates the offset and length in
-            UTF-16 codepoint pairs, which some versions of Python don't handle automatically.
-            (That is, you can't just slice ``Message.text`` with the offset and length.)
-
-        Args:
-            entity (:class:`telegram.MessageEntity`): The entity to extract the text from. It must
-                be an entity that belongs to this message.
-
-        Returns:
-            :obj:`str`: The text of the given entity.
-
-        """
-        # Is it a narrow build, if so we don't need to convert
-        if sys.maxunicode == 0xffff:
-            return self.text[entity.offset:entity.offset + entity.length]
-        else:
-            entity_text = self.text.encode('utf-16-le')
-            entity_text = entity_text[entity.offset * 2:(entity.offset + entity.length) * 2]
-
-        return entity_text.decode('utf-16-le')
-
-    def parse_text_entities(self, types=None):
-        """
-        Returns a :obj:`dict` that maps :class:`telegram.MessageEntity` to :obj:`str`.
-        It contains entities from this message filtered by their ``type`` attribute as the key, and
-        the text that each entity belongs to as the value of the :obj:`dict`.
-
-        Note:
-            This method should always be used instead of the :attr:`text_entities` attribute, since
-            it calculates the correct substring from the message text based on UTF-16 codepoints.
-            See :attr:`parse_text_entity` for more info.
-
-        Args:
-            types (List[:obj:`str`], optional): List of ``MessageEntity`` types as strings. If the
-                    ``type`` attribute of an entity is contained in this list, it will be returned.
-                    Defaults to :attr:`telegram.MessageEntity.ALL_TYPES`.
-
-        Returns:
-            Dict[:class:`telegram.MessageEntity`, :obj:`str`]: A dictionary of entities mapped to
-            the text that belongs to them, calculated based on UTF-16 codepoints.
-
-        """
-        if types is None:
-            types = MessageEntity.ALL_TYPES
-
-        return {
-            entity: self.parse_text_entity(entity)
-            for entity in self.text_entities if entity.type in types
-        }
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Game."""
+
+import sys
+
+from telegram import MessageEntity, TelegramObject, Animation, PhotoSize
+
+
+class Game(TelegramObject):
+    """
+    This object represents a game. Use BotFather to create and edit games, their short names will
+    act as unique identifiers.
+
+    Attributes:
+        title (:obj:`str`): Title of the game.
+        description (:obj:`str`): Description of the game.
+        photo (List[:class:`telegram.PhotoSize`]): Photo that will be displayed in the game message
+            in chats.
+        text (:obj:`str`): Optional. Brief description of the game or high scores included in the
+            game message. Can be automatically edited to include current high scores for the game
+            when the bot calls set_game_score, or manually edited using edit_message_text.
+        text_entities (List[:class:`telegram.MessageEntity`]): Optional. Special entities that
+            appear in text, such as usernames, URLs, bot commands, etc.
+        animation (:class:`telegram.Animation`): Optional. Animation that will be displayed in the
+            game message in chats. Upload via BotFather.
+
+    Args:
+        title (:obj:`str`): Title of the game.
+        description (:obj:`str`): Description of the game.
+        photo (List[:class:`telegram.PhotoSize`]): Photo that will be displayed in the game message
+            in chats.
+        text (:obj:`str`, optional): Brief description of the game or high scores included in the
+            game message. Can be automatically edited to include current high scores for the game
+            when the bot calls set_game_score, or manually edited using edit_message_text.
+            0-4096 characters. Also found as ``telegram.constants.MAX_MESSAGE_LENGTH``.
+        text_entities (List[:class:`telegram.MessageEntity`], optional): Special entities that
+            appear in text, such as usernames, URLs, bot commands, etc.
+        animation (:class:`telegram.Animation`, optional): Animation that will be displayed in the
+            game message in chats. Upload via BotFather.
+
+    """
+
+    def __init__(self,
+                 title,
+                 description,
+                 photo,
+                 text=None,
+                 text_entities=None,
+                 animation=None,
+                 **kwargs):
+        self.title = title
+        self.description = description
+        self.photo = photo
+        self.text = text
+        self.text_entities = text_entities or list()
+        self.animation = animation
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(Game, cls).de_json(data, bot)
+
+        data['photo'] = PhotoSize.de_list(data.get('photo'), bot)
+        data['text_entities'] = MessageEntity.de_list(data.get('text_entities'), bot)
+        data['animation'] = Animation.de_json(data.get('animation'), bot)
+
+        return cls(**data)
+
+    def to_dict(self):
+        data = super(Game, self).to_dict()
+
+        data['photo'] = [p.to_dict() for p in self.photo]
+        if self.text_entities:
+            data['text_entities'] = [x.to_dict() for x in self.text_entities]
+
+        return data
+
+    def parse_text_entity(self, entity):
+        """Returns the text from a given :class:`telegram.MessageEntity`.
+
+        Note:
+            This method is present because Telegram calculates the offset and length in
+            UTF-16 codepoint pairs, which some versions of Python don't handle automatically.
+            (That is, you can't just slice ``Message.text`` with the offset and length.)
+
+        Args:
+            entity (:class:`telegram.MessageEntity`): The entity to extract the text from. It must
+                be an entity that belongs to this message.
+
+        Returns:
+            :obj:`str`: The text of the given entity.
+
+        """
+        # Is it a narrow build, if so we don't need to convert
+        if sys.maxunicode == 0xffff:
+            return self.text[entity.offset:entity.offset + entity.length]
+        else:
+            entity_text = self.text.encode('utf-16-le')
+            entity_text = entity_text[entity.offset * 2:(entity.offset + entity.length) * 2]
+
+        return entity_text.decode('utf-16-le')
+
+    def parse_text_entities(self, types=None):
+        """
+        Returns a :obj:`dict` that maps :class:`telegram.MessageEntity` to :obj:`str`.
+        It contains entities from this message filtered by their ``type`` attribute as the key, and
+        the text that each entity belongs to as the value of the :obj:`dict`.
+
+        Note:
+            This method should always be used instead of the :attr:`text_entities` attribute, since
+            it calculates the correct substring from the message text based on UTF-16 codepoints.
+            See :attr:`parse_text_entity` for more info.
+
+        Args:
+            types (List[:obj:`str`], optional): List of ``MessageEntity`` types as strings. If the
+                    ``type`` attribute of an entity is contained in this list, it will be returned.
+                    Defaults to :attr:`telegram.MessageEntity.ALL_TYPES`.
+
+        Returns:
+            Dict[:class:`telegram.MessageEntity`, :obj:`str`]: A dictionary of entities mapped to
+            the text that belongs to them, calculated based on UTF-16 codepoints.
+
+        """
+        if types is None:
+            types = MessageEntity.ALL_TYPES
+
+        return {
+            entity: self.parse_text_entity(entity)
+            for entity in self.text_entities if entity.type in types
+        }
```

### Comparing `python-telegram-bot-8.1.1/telegram/games/gamehighscore.py` & `python-telegram-bot-9.0.0/telegram/games/gamehighscore.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram GameHighScore."""
-
-from telegram import TelegramObject, User
-
-
-class GameHighScore(TelegramObject):
-    """This object represents one row of the high scores table for a game.
-
-    Attributes:
-        position (:obj:`int`): Position in high score table for the game.
-        user (:class:`telegram.User`): User.
-        score (:obj:`int`): Score.
-
-    Args:
-        position (:obj:`int`): Position in high score table for the game.
-        user (:class:`telegram.User`): User.
-        score (:obj:`int`): Score.
-
-    """
-
-    def __init__(self, position, user, score):
-        self.position = position
-        self.user = user
-        self.score = score
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(GameHighScore, cls).de_json(data, bot)
-
-        data['user'] = User.de_json(data.get('user'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram GameHighScore."""
+
+from telegram import TelegramObject, User
+
+
+class GameHighScore(TelegramObject):
+    """This object represents one row of the high scores table for a game.
+
+    Attributes:
+        position (:obj:`int`): Position in high score table for the game.
+        user (:class:`telegram.User`): User.
+        score (:obj:`int`): Score.
+
+    Args:
+        position (:obj:`int`): Position in high score table for the game.
+        user (:class:`telegram.User`): User.
+        score (:obj:`int`): Score.
+
+    """
+
+    def __init__(self, position, user, score):
+        self.position = position
+        self.user = user
+        self.score = score
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(GameHighScore, cls).de_json(data, bot)
+
+        data['user'] = User.de_json(data.get('user'), bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinekeyboardmarkup.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinekeyboardmarkup.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram InlineKeyboardMarkup."""
-
-from telegram import ReplyMarkup
-
-
-class InlineKeyboardMarkup(ReplyMarkup):
-    """
-    This object represents an inline keyboard that appears right next to the message it belongs to.
-
-    Attributes:
-        inline_keyboard (List[List[:class:`telegram.InlineKeyboardButton`]]): Array of button rows,
-            each represented by an Array of InlineKeyboardButton objects.
-
-    Args:
-        inline_keyboard (List[List[:class:`telegram.InlineKeyboardButton`]]): Array of button rows,
-            each represented by an Array of InlineKeyboardButton objects.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, inline_keyboard, **kwargs):
-        # Required
-        self.inline_keyboard = inline_keyboard
-
-    def to_dict(self):
-        data = super(InlineKeyboardMarkup, self).to_dict()
-
-        data['inline_keyboard'] = []
-        for inline_keyboard in self.inline_keyboard:
-            data['inline_keyboard'].append([x.to_dict() for x in inline_keyboard])
-
-        return data
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram InlineKeyboardMarkup."""
+
+from telegram import ReplyMarkup
+
+
+class InlineKeyboardMarkup(ReplyMarkup):
+    """
+    This object represents an inline keyboard that appears right next to the message it belongs to.
+
+    Attributes:
+        inline_keyboard (List[List[:class:`telegram.InlineKeyboardButton`]]): Array of button rows,
+            each represented by an Array of InlineKeyboardButton objects.
+
+    Args:
+        inline_keyboard (List[List[:class:`telegram.InlineKeyboardButton`]]): Array of button rows,
+            each represented by an Array of InlineKeyboardButton objects.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, inline_keyboard, **kwargs):
+        # Required
+        self.inline_keyboard = inline_keyboard
+
+    def to_dict(self):
+        data = super(InlineKeyboardMarkup, self).to_dict()
+
+        data['inline_keyboard'] = []
+        for inline_keyboard in self.inline_keyboard:
+            data['inline_keyboard'].append([x.to_dict() for x in inline_keyboard])
+
+        return data
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequery.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequery.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,111 +1,111 @@
-#!/usr/bin/env python
-# pylint: disable=R0902,R0912,R0913
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram InlineQuery."""
-
-from telegram import TelegramObject, User, Location
-
-
-class InlineQuery(TelegramObject):
-    """
-    This object represents an incoming inline query. When the user sends an empty query, your bot
-    could return some default or trending results.
-
-    Note:
-        * In Python `from` is a reserved word, use `from_user` instead.
-
-    Attributes:
-        id (:obj:`str`): Unique identifier for this query.
-        from_user (:class:`telegram.User`): Sender.
-        location (:class:`telegram.Location`): Optional. Sender location, only for bots that
-            request user location.
-        query (:obj:`str`): Text of the query (up to 512 characters).
-        offset (:obj:`str`): Offset of the results to be returned, can be controlled by the bot.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this query.
-        from_user (:class:`telegram.User`): Sender.
-        location (:class:`telegram.Location`, optional): Sender location, only for bots that
-            request user location.
-        query (:obj:`str`): Text of the query (up to 512 characters).
-        offset (:obj:`str`): Offset of the results to be returned, can be controlled by the bot.
-        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, id, from_user, query, offset, location=None, bot=None, **kwargs):
-        # Required
-        self.id = id
-        self.from_user = from_user
-        self.query = query
-        self.offset = offset
-
-        # Optional
-        self.location = location
-
-        self.bot = bot
-        self._id_attrs = (self.id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        data = super(InlineQuery, cls).de_json(data, bot)
-
-        if not data:
-            return None
-
-        data['from_user'] = User.de_json(data.get('from'), bot)
-        data['location'] = Location.de_json(data.get('location'), bot)
-
-        return cls(bot=bot, **data)
-
-    def to_dict(self):
-        data = super(InlineQuery, self).to_dict()
-
-        # Required
-        data['from'] = data.pop('from_user', None)
-
-        return data
-
-    def answer(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.answer_inline_query(update.inline_query.id, *args, **kwargs)
-
-        Args:
-            results (List[:class:`telegram.InlineQueryResult`]): A list of results for the inline
-                query.
-            cache_time (:obj:`int`, optional): The maximum amount of time in seconds that the
-                result of the inline query may be cached on the server. Defaults to 300.
-            is_personal (:obj:`bool`, optional): Pass True, if results may be cached on the server
-                side only for the user that sent the query. By default, results may be returned to
-                any user who sends the same query.
-            next_offset (:obj:`str`, optional): Pass the offset that a client should send in the
-                next query with the same text to receive more results. Pass an empty string if
-                there are no more results or if you don't support pagination. Offset length can't
-                exceed 64 bytes.
-            switch_pm_text (:obj:`str`, optional): If passed, clients will display a button with
-                specified text that switches the user to a private chat with the bot and sends the
-                bot a start message with the parameter switch_pm_parameter.
-            switch_pm_parameter (:obj:`str`, optional): Deep-linking parameter for the /start
-                message sent to the bot when user presses the switch button. 1-64 characters,
-                only A-Z, a-z, 0-9, _ and - are allowed.
-
-        """
-        return self.bot.answer_inline_query(self.id, *args, **kwargs)
+#!/usr/bin/env python
+# pylint: disable=R0902,R0912,R0913
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram InlineQuery."""
+
+from telegram import TelegramObject, User, Location
+
+
+class InlineQuery(TelegramObject):
+    """
+    This object represents an incoming inline query. When the user sends an empty query, your bot
+    could return some default or trending results.
+
+    Note:
+        * In Python `from` is a reserved word, use `from_user` instead.
+
+    Attributes:
+        id (:obj:`str`): Unique identifier for this query.
+        from_user (:class:`telegram.User`): Sender.
+        location (:class:`telegram.Location`): Optional. Sender location, only for bots that
+            request user location.
+        query (:obj:`str`): Text of the query (up to 512 characters).
+        offset (:obj:`str`): Offset of the results to be returned, can be controlled by the bot.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this query.
+        from_user (:class:`telegram.User`): Sender.
+        location (:class:`telegram.Location`, optional): Sender location, only for bots that
+            request user location.
+        query (:obj:`str`): Text of the query (up to 512 characters).
+        offset (:obj:`str`): Offset of the results to be returned, can be controlled by the bot.
+        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, id, from_user, query, offset, location=None, bot=None, **kwargs):
+        # Required
+        self.id = id
+        self.from_user = from_user
+        self.query = query
+        self.offset = offset
+
+        # Optional
+        self.location = location
+
+        self.bot = bot
+        self._id_attrs = (self.id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        data = super(InlineQuery, cls).de_json(data, bot)
+
+        if not data:
+            return None
+
+        data['from_user'] = User.de_json(data.get('from'), bot)
+        data['location'] = Location.de_json(data.get('location'), bot)
+
+        return cls(bot=bot, **data)
+
+    def to_dict(self):
+        data = super(InlineQuery, self).to_dict()
+
+        # Required
+        data['from'] = data.pop('from_user', None)
+
+        return data
+
+    def answer(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.answer_inline_query(update.inline_query.id, *args, **kwargs)
+
+        Args:
+            results (List[:class:`telegram.InlineQueryResult`]): A list of results for the inline
+                query.
+            cache_time (:obj:`int`, optional): The maximum amount of time in seconds that the
+                result of the inline query may be cached on the server. Defaults to 300.
+            is_personal (:obj:`bool`, optional): Pass True, if results may be cached on the server
+                side only for the user that sent the query. By default, results may be returned to
+                any user who sends the same query.
+            next_offset (:obj:`str`, optional): Pass the offset that a client should send in the
+                next query with the same text to receive more results. Pass an empty string if
+                there are no more results or if you don't support pagination. Offset length can't
+                exceed 64 bytes.
+            switch_pm_text (:obj:`str`, optional): If passed, clients will display a button with
+                specified text that switches the user to a private chat with the bot and sends the
+                bot a start message with the parameter switch_pm_parameter.
+            switch_pm_parameter (:obj:`str`, optional): Deep-linking parameter for the /start
+                message sent to the bot when user presses the switch button. 1-64 characters,
+                only A-Z, a-z, 0-9, _ and - are allowed.
+
+        """
+        return self.bot.answer_inline_query(self.id, *args, **kwargs)
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresult.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresult.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResult."""
-
-from telegram import TelegramObject
-
-
-class InlineQueryResult(TelegramObject):
-    """Baseclass for the InlineQueryResult* classes.
-
-    Attributes:
-        type (:obj:`str`): Type of the result.
-        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
-
-    Args:
-        type (:obj:`str`): Type of the result.
-        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, type, id, **kwargs):
-        # Required
-        self.type = str(type)
-        self.id = str(id)
-
-        self._id_attrs = (self.id,)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResult."""
+
+from telegram import TelegramObject
+
+
+class InlineQueryResult(TelegramObject):
+    """Baseclass for the InlineQueryResult* classes.
+
+    Attributes:
+        type (:obj:`str`): Type of the result.
+        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
+
+    Args:
+        type (:obj:`str`): Type of the result.
+        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, type, id, **kwargs):
+        # Required
+        self.type = str(type)
+        self.id = str(id)
+
+        self._id_attrs = (self.id,)
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultarticle.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultarticle.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,93 +1,93 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultArticle."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultArticle(InlineQueryResult):
-    """This object represents a Telegram InlineQueryResultArticle.
-
-    Attributes:
-        type (:obj:`str`): 'article'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
-        title (:obj:`str`): Title of the result.
-        input_message_content (:class:`telegram.InputMessageContent`): Content of the message to
-            be sent.
-        reply_markup (:class:`telegram.ReplyMarkup`): Optional. Inline keyboard attached to
-            the message.
-        url (:obj:`str`): Optional. URL of the result.
-        hide_url (:obj:`bool`): Optional. Pass True, if you don't want the URL to be shown in the
-            message.
-        description (:obj:`str`): Optional. Short description of the result.
-        thumb_url (:obj:`str`): Optional. Url of the thumbnail for the result.
-        thumb_width (:obj:`int`): Optional. Thumbnail width.
-        thumb_height (:obj:`int`): Optional. Thumbnail height.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
-        title (:obj:`str`): Title of the result.
-        input_message_content (:class:`telegram.InputMessageContent`): Content of the message to
-            be sent.
-        reply_markup (:class:`telegram.ReplyMarkup`, optional): Inline keyboard attached to
-            the message
-        url (:obj:`str`, optional): URL of the result.
-        hide_url (:obj:`bool`, optional): Pass True, if you don't want the URL to be shown in the
-            message.
-        description (:obj:`str`, optional): Short description of the result.
-        thumb_url (:obj:`str`, optional): Url of the thumbnail for the result.
-        thumb_width (:obj:`int`, optional): Thumbnail width.
-        thumb_height (:obj:`int`, optional): Thumbnail height.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 title,
-                 input_message_content,
-                 reply_markup=None,
-                 url=None,
-                 hide_url=None,
-                 description=None,
-                 thumb_url=None,
-                 thumb_width=None,
-                 thumb_height=None,
-                 **kwargs):
-
-        # Required
-        super(InlineQueryResultArticle, self).__init__('article', id)
-        self.title = title
-        self.input_message_content = input_message_content
-
-        # Optional
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if url:
-            self.url = url
-        if hide_url:
-            self.hide_url = hide_url
-        if description:
-            self.description = description
-        if thumb_url:
-            self.thumb_url = thumb_url
-        if thumb_width:
-            self.thumb_width = thumb_width
-        if thumb_height:
-            self.thumb_height = thumb_height
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultArticle."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultArticle(InlineQueryResult):
+    """This object represents a Telegram InlineQueryResultArticle.
+
+    Attributes:
+        type (:obj:`str`): 'article'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
+        title (:obj:`str`): Title of the result.
+        input_message_content (:class:`telegram.InputMessageContent`): Content of the message to
+            be sent.
+        reply_markup (:class:`telegram.ReplyMarkup`): Optional. Inline keyboard attached to
+            the message.
+        url (:obj:`str`): Optional. URL of the result.
+        hide_url (:obj:`bool`): Optional. Pass True, if you don't want the URL to be shown in the
+            message.
+        description (:obj:`str`): Optional. Short description of the result.
+        thumb_url (:obj:`str`): Optional. Url of the thumbnail for the result.
+        thumb_width (:obj:`int`): Optional. Thumbnail width.
+        thumb_height (:obj:`int`): Optional. Thumbnail height.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
+        title (:obj:`str`): Title of the result.
+        input_message_content (:class:`telegram.InputMessageContent`): Content of the message to
+            be sent.
+        reply_markup (:class:`telegram.ReplyMarkup`, optional): Inline keyboard attached to
+            the message
+        url (:obj:`str`, optional): URL of the result.
+        hide_url (:obj:`bool`, optional): Pass True, if you don't want the URL to be shown in the
+            message.
+        description (:obj:`str`, optional): Short description of the result.
+        thumb_url (:obj:`str`, optional): Url of the thumbnail for the result.
+        thumb_width (:obj:`int`, optional): Thumbnail width.
+        thumb_height (:obj:`int`, optional): Thumbnail height.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 title,
+                 input_message_content,
+                 reply_markup=None,
+                 url=None,
+                 hide_url=None,
+                 description=None,
+                 thumb_url=None,
+                 thumb_width=None,
+                 thumb_height=None,
+                 **kwargs):
+
+        # Required
+        super(InlineQueryResultArticle, self).__init__('article', id)
+        self.title = title
+        self.input_message_content = input_message_content
+
+        # Optional
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if url:
+            self.url = url
+        if hide_url:
+            self.hide_url = hide_url
+        if description:
+            self.description = description
+        if thumb_url:
+            self.thumb_url = thumb_url
+        if thumb_width:
+            self.thumb_width = thumb_width
+        if thumb_height:
+            self.thumb_height = thumb_height
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultaudio.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultvoice.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,84 +1,80 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultAudio."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultAudio(InlineQueryResult):
-    """
-    Represents a link to an mp3 audio file. By default, this audio file will be sent by the user.
-    Alternatively, you can use :attr:`input_message_content` to send a message with the specified
-    content instead of the audio.
-
-    Attributes:
-        type (:obj:`str`): 'audio'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        audio_url (:obj:`str`): A valid URL for the audio file.
-        title (:obj:`str`): Title.
-        performer (:obj:`str`): Optional. Caption, 0-200 characters.
-        audio_duration (:obj:`str`): Optional. Performer.
-        caption (:obj:`str`): Optional. Audio duration in seconds.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the audio.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        audio_url (:obj:`str`): A valid URL for the audio file.
-        title (:obj:`str`): Title.
-        performer (:obj:`str`, optional): Caption, 0-200 characters.
-        audio_duration (:obj:`str`, optional): Performer.
-        caption (:obj:`str`, optional): Audio duration in seconds.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the audio.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 audio_url,
-                 title,
-                 performer=None,
-                 audio_duration=None,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-
-        # Required
-        super(InlineQueryResultAudio, self).__init__('audio', id)
-        self.audio_url = audio_url
-        self.title = title
-
-        # Optionals
-        if performer:
-            self.performer = performer
-        if audio_duration:
-            self.audio_duration = audio_duration
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultVoice."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultVoice(InlineQueryResult):
+    """
+    Represents a link to a voice recording in an .ogg container encoded with OPUS. By default,
+    this voice recording will be sent by the user. Alternatively, you can use
+    :attr:`input_message_content` to send a message with the specified content instead of the
+    the voice message.
+
+    Attributes:
+        type (:obj:`str`): 'voice'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        voice_url (:obj:`str`): A valid URL for the voice recording.
+        title (:obj:`str`): Voice message title.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters.
+        voice_duration (:obj:`int`): Optional. Recording duration in seconds.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the voice.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        voice_url (:obj:`str`): A valid URL for the voice recording.
+        title (:obj:`str`): Voice message title.
+        caption (:obj:`str`, optional): Caption, 0-200 characters.
+        voice_duration (:obj:`int`, optional): Recording duration in seconds.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the voice.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 voice_url,
+                 title,
+                 voice_duration=None,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+
+        # Required
+        super(InlineQueryResultVoice, self).__init__('voice', id)
+        self.voice_url = voice_url
+        self.title = title
+
+        # Optional
+        if voice_duration:
+            self.voice_duration = voice_duration
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedaudio.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedgif.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,69 +1,75 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultCachedAudio."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultCachedAudio(InlineQueryResult):
-    """
-    Represents a link to an mp3 audio file stored on the Telegram servers. By default, this audio
-    file will be sent by the user. Alternatively, you can use :attr:`input_message_content` to
-    send amessage with the specified content instead of the audio.
-
-    Attributes:
-        type (:obj:`str`): 'audio'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        audio_file_id (:obj:`str`): A valid file identifier for the audio file.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the audio.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        audio_file_id (:obj:`str`): A valid file identifier for the audio file.
-        caption (:obj:`str`, optional): Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the audio.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 audio_file_id,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultCachedAudio, self).__init__('audio', id)
-        self.audio_file_id = audio_file_id
-
-        # Optionals
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultCachedGif."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultCachedGif(InlineQueryResult):
+    """
+    Represents a link to an animated GIF file stored on the Telegram servers. By default, this
+    animated GIF file will be sent by the user with an optional caption. Alternatively, you can
+    use :attr:`input_message_content` to send a message with specified content instead of
+    the animation.
+
+    Attributes:
+        type (:obj:`str`): 'gif'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        gif_file_id (:obj:`str`): A valid file identifier for the GIF file.
+        title (:obj:`str`): Optional. Title for the result.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the gif.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        gif_file_id (:obj:`str`): A valid file identifier for the GIF file.
+        title (:obj:`str`, optional): Title for the result.caption (:obj:`str`, optional):
+        caption (:obj:`str`, optional): Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the gif.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 gif_file_id,
+                 title=None,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultCachedGif, self).__init__('gif', id)
+        self.gif_file_id = gif_file_id
+
+        # Optionals
+        if title:
+            self.title = title
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcacheddocument.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedvideo.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,78 +1,79 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultCachedDocument."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultCachedDocument(InlineQueryResult):
-    """
-    Represents a link to a file stored on the Telegram servers. By default, this file will be sent
-    by the user with an optional caption. Alternatively, you can use :attr:`input_message_content`
-    to send a message with the specified content instead of the file.
-
-    Attributes:
-        type (:obj:`str`): 'document'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        title (:obj:`str`): Title for the result.
-        document_file_id (:obj:`str`): A valid file identifier for the file.
-        description (:obj:`str`): Optional. Short description of the result.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the file.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        title (:obj:`str`): Title for the result.
-        document_file_id (:obj:`str`): A valid file identifier for the file.
-        description (:obj:`str`, optional): Short description of the result.
-        caption (:obj:`str`, optional): Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the file.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 title,
-                 document_file_id,
-                 description=None,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultCachedDocument, self).__init__('document', id)
-        self.title = title
-        self.document_file_id = document_file_id
-
-        # Optionals
-        if description:
-            self.description = description
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultCachedVideo."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultCachedVideo(InlineQueryResult):
+    """
+    Represents a link to a video file stored on the Telegram servers. By default, this video file
+    will be sent by the user with an optional caption. Alternatively, you can use
+    :attr:`input_message_content` to send a message with the specified content instead
+    of the video.
+
+    Attributes:
+        type (:obj:`str`): 'video'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        video_file_id (:obj:`str`): A valid file identifier for the video file.
+        title (:obj:`str`): Title for the result.
+        description (:obj:`str`): Optional. Short description of the result.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the video.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        video_file_id (:obj:`str`): A valid file identifier for the video file.
+        title (:obj:`str`): Title for the result.
+        description (:obj:`str`, optional): Short description of the result.
+        caption (:obj:`str`, optional): Caption, 0-200 characters.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the video.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 video_file_id,
+                 title,
+                 description=None,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultCachedVideo, self).__init__('video', id)
+        self.video_file_id = video_file_id
+        self.title = title
+
+        # Optionals
+        if description:
+            self.description = description
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedgif.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedmpeg4gif.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,75 +1,75 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultCachedGif."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultCachedGif(InlineQueryResult):
-    """
-    Represents a link to an animated GIF file stored on the Telegram servers. By default, this
-    animated GIF file will be sent by the user with an optional caption. Alternatively, you can
-    use :attr:`input_message_content` to send a message with specified content instead of
-    the animation.
-
-    Attributes:
-        type (:obj:`str`): 'gif'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        gif_file_id (:obj:`str`): A valid file identifier for the GIF file.
-        title (:obj:`str`): Optional. Title for the result.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the gif.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        gif_file_id (:obj:`str`): A valid file identifier for the GIF file.
-        title (:obj:`str`, optional): Title for the result.caption (:obj:`str`, optional):
-        caption (:obj:`str`, optional): Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the gif.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 gif_file_id,
-                 title=None,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultCachedGif, self).__init__('gif', id)
-        self.gif_file_id = gif_file_id
-
-        # Optionals
-        if title:
-            self.title = title
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultMpeg4Gif."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultCachedMpeg4Gif(InlineQueryResult):
+    """
+    Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the
+    Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an
+    optional caption. Alternatively, you can use :attr:`input_message_content` to send a message
+    with the specified content instead of the animation.
+
+    Attributes:
+        type (:obj:`str`): 'mpeg4_gif'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        mpeg4_file_id (:obj:`str`): A valid file identifier for the MP4 file.
+        title (:obj:`str`): Optional. Title for the result.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the MPEG-4 file.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        mpeg4_file_id (:obj:`str`): A valid file identifier for the MP4 file.
+        title (:obj:`str`, optional): Title for the result.
+        caption (:obj:`str`, optional): Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the MPEG-4 file.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 mpeg4_file_id,
+                 title=None,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultCachedMpeg4Gif, self).__init__('mpeg4_gif', id)
+        self.mpeg4_file_id = mpeg4_file_id
+
+        # Optionals
+        if title:
+            self.title = title
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedmpeg4gif.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedphoto.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,75 +1,80 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultMpeg4Gif."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultCachedMpeg4Gif(InlineQueryResult):
-    """
-    Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the
-    Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an
-    optional caption. Alternatively, you can use :attr:`input_message_content` to send a message
-    with the specified content instead of the animation.
-
-    Attributes:
-        type (:obj:`str`): 'mpeg4_gif'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        mpeg4_file_id (:obj:`str`): A valid file identifier for the MP4 file.
-        title (:obj:`str`): Optional. Title for the result.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the MPEG-4 file.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        mpeg4_file_id (:obj:`str`): A valid file identifier for the MP4 file.
-        title (:obj:`str`, optional): Title for the result.
-        caption (:obj:`str`, optional): Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the MPEG-4 file.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 mpeg4_file_id,
-                 title=None,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultCachedMpeg4Gif, self).__init__('mpeg4_gif', id)
-        self.mpeg4_file_id = mpeg4_file_id
-
-        # Optionals
-        if title:
-            self.title = title
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultPhoto"""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultCachedPhoto(InlineQueryResult):
+    """
+    Represents a link to a photo stored on the Telegram servers. By default, this photo will be
+    sent by the user with an optional caption. Alternatively, you can use
+    :attr:`input_message_content` to send a message with the specified content instead
+    of the photo.
+
+    Attributes:
+        type (:obj:`str`): 'photo'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        photo_file_id (:obj:`str`): A valid file identifier of the photo.
+        title (:obj:`str`): Optional. Title for the result.
+        description (:obj:`str`): Optional. Short description of the result.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the photo.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        photo_file_id (:obj:`str`): A valid file identifier of the photo.
+        title (:obj:`str`, optional): Title for the result.
+        description (:obj:`str`, optional): Short description of the result.
+        caption (:obj:`str`, optional): Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the photo.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 photo_file_id,
+                 title=None,
+                 description=None,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultCachedPhoto, self).__init__('photo', id)
+        self.photo_file_id = photo_file_id
+
+        # Optionals
+        if title:
+            self.title = title
+        if description:
+            self.description = description
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedphoto.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcacheddocument.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,80 +1,78 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultPhoto"""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultCachedPhoto(InlineQueryResult):
-    """
-    Represents a link to a photo stored on the Telegram servers. By default, this photo will be
-    sent by the user with an optional caption. Alternatively, you can use
-    :attr:`input_message_content` to send a message with the specified content instead
-    of the photo.
-
-    Attributes:
-        type (:obj:`str`): 'photo'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        photo_file_id (:obj:`str`): A valid file identifier of the photo.
-        title (:obj:`str`): Optional. Title for the result.
-        description (:obj:`str`): Optional. Short description of the result.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the photo.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        photo_file_id (:obj:`str`): A valid file identifier of the photo.
-        title (:obj:`str`, optional): Title for the result.
-        description (:obj:`str`, optional): Short description of the result.
-        caption (:obj:`str`, optional): Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the photo.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 photo_file_id,
-                 title=None,
-                 description=None,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultCachedPhoto, self).__init__('photo', id)
-        self.photo_file_id = photo_file_id
-
-        # Optionals
-        if title:
-            self.title = title
-        if description:
-            self.description = description
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultCachedDocument."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultCachedDocument(InlineQueryResult):
+    """
+    Represents a link to a file stored on the Telegram servers. By default, this file will be sent
+    by the user with an optional caption. Alternatively, you can use :attr:`input_message_content`
+    to send a message with the specified content instead of the file.
+
+    Attributes:
+        type (:obj:`str`): 'document'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        title (:obj:`str`): Title for the result.
+        document_file_id (:obj:`str`): A valid file identifier for the file.
+        description (:obj:`str`): Optional. Short description of the result.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the file.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        title (:obj:`str`): Title for the result.
+        document_file_id (:obj:`str`): A valid file identifier for the file.
+        description (:obj:`str`, optional): Short description of the result.
+        caption (:obj:`str`, optional): Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the file.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 title,
+                 document_file_id,
+                 description=None,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultCachedDocument, self).__init__('document', id)
+        self.title = title
+        self.document_file_id = document_file_id
+
+        # Optionals
+        if description:
+            self.description = description
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedsticker.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedsticker.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,64 +1,64 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultCachedSticker."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultCachedSticker(InlineQueryResult):
-    """
-    Represents a link to a sticker stored on the Telegram servers. By default, this sticker will
-    be sent by the user. Alternatively, you can use :attr:`input_message_content` to send a
-    message with the specified content instead of the sticker.
-
-    Attributes:
-        type (:obj:`str`): 'sticker`.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        sticker_file_id (:obj:`str`): A valid file identifier of the sticker.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the sticker.
-
-    Args:
-        id (:obj:`str`):
-        sticker_file_id (:obj:`str`):
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the sticker.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 sticker_file_id,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultCachedSticker, self).__init__('sticker', id)
-        self.sticker_file_id = sticker_file_id
-
-        # Optionals
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultCachedSticker."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultCachedSticker(InlineQueryResult):
+    """
+    Represents a link to a sticker stored on the Telegram servers. By default, this sticker will
+    be sent by the user. Alternatively, you can use :attr:`input_message_content` to send a
+    message with the specified content instead of the sticker.
+
+    Attributes:
+        type (:obj:`str`): 'sticker`.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        sticker_file_id (:obj:`str`): A valid file identifier of the sticker.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the sticker.
+
+    Args:
+        id (:obj:`str`):
+        sticker_file_id (:obj:`str`):
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the sticker.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 sticker_file_id,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultCachedSticker, self).__init__('sticker', id)
+        self.sticker_file_id = sticker_file_id
+
+        # Optionals
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcachedvoice.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedaudio.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,73 +1,69 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultCachedVoice."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultCachedVoice(InlineQueryResult):
-    """
-    Represents a link to a voice message stored on the Telegram servers. By default, this voice
-    message will be sent by the user. Alternatively, you can use :attr:`input_message_content` to
-    send a message with the specified content instead of the voice message.
-
-    Attributes:
-        type (:obj:`str`): 'voice'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        voice_file_id (:obj:`str`): A valid file identifier for the voice message.
-        title (:obj:`str`): Voice message title.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the voice.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        voice_file_id (:obj:`str`): A valid file identifier for the voice message.
-        title (:obj:`str`): Voice message title.
-        caption (:obj:`str`, optional): Caption, 0-200 characters.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the voice.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 voice_file_id,
-                 title,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultCachedVoice, self).__init__('voice', id)
-        self.voice_file_id = voice_file_id
-        self.title = title
-
-        # Optionals
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultCachedAudio."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultCachedAudio(InlineQueryResult):
+    """
+    Represents a link to an mp3 audio file stored on the Telegram servers. By default, this audio
+    file will be sent by the user. Alternatively, you can use :attr:`input_message_content` to
+    send amessage with the specified content instead of the audio.
+
+    Attributes:
+        type (:obj:`str`): 'audio'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        audio_file_id (:obj:`str`): A valid file identifier for the audio file.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the audio.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        audio_file_id (:obj:`str`): A valid file identifier for the audio file.
+        caption (:obj:`str`, optional): Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the audio.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 audio_file_id,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultCachedAudio, self).__init__('audio', id)
+        self.audio_file_id = audio_file_id
+
+        # Optionals
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultcontact.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultvenue.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,88 +1,97 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultContact."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultContact(InlineQueryResult):
-    """
-    Represents a contact with a phone number. By default, this contact will be sent by the user.
-    Alternatively, you can use :attr:`input_message_content` to send a message with the specified
-    content instead of the contact.
-
-    Attributes:
-        type (:obj:`str`): 'contact'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        phone_number (:obj:`str`): Contact's phone number.
-        first_name (:obj:`str`): Contact's first name.
-        last_name (:obj:`str`): Optional. Contact's last name.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the contact.
-        thumb_url (:obj:`str`): Optional. Url of the thumbnail for the result.
-        thumb_width (:obj:`int`): Optional. Thumbnail width.
-        thumb_height (:obj:`int`): Optional. Thumbnail height.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        phone_number (:obj:`str`): Contact's phone number.
-        first_name (:obj:`str`): Contact's first name.
-        last_name (:obj:`str`, optional): Contact's last name.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the contact.
-        thumb_url (:obj:`str`, optional): Url of the thumbnail for the result.
-        thumb_width (:obj:`int`, optional): Thumbnail width.
-        thumb_height (:obj:`int`, optional): Thumbnail height.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 phone_number,
-                 first_name,
-                 last_name=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 thumb_url=None,
-                 thumb_width=None,
-                 thumb_height=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultContact, self).__init__('contact', id)
-        self.phone_number = phone_number
-        self.first_name = first_name
-
-        # Optionals
-        if last_name:
-            self.last_name = last_name
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
-        if thumb_url:
-            self.thumb_url = thumb_url
-        if thumb_width:
-            self.thumb_width = thumb_width
-        if thumb_height:
-            self.thumb_height = thumb_height
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultVenue."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultVenue(InlineQueryResult):
+    """
+    Represents a venue. By default, the venue will be sent by the user. Alternatively, you can
+    use :attr:`input_message_content` to send a message with the specified content instead of the
+    venue.
+
+    Attributes:
+        type (:obj:`str`): 'venue'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
+        latitude (:obj:`float`): Latitude of the venue location in degrees.
+        longitude (:obj:`float`): Longitude of the venue location in degrees.
+        title (:obj:`str`): Title of the venue.
+        address (:obj:`str`): Address of the venue.
+        foursquare_id (:obj:`str`): Optional. Foursquare identifier of the venue if known.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the venue.
+        thumb_url (:obj:`str`): Optional. Url of the thumbnail for the result.
+        thumb_width (:obj:`int`): Optional. Thumbnail width.
+        thumb_height (:obj:`int`): Optional. Thumbnail height.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 Bytes.
+        latitude (:obj:`float`): Latitude of the venue location in degrees.
+        longitude (:obj:`float`): Longitude of the venue location in degrees.
+        title (:obj:`str`): Title of the venue.
+        address (:obj:`str`): Address of the venue.
+        foursquare_id (:obj:`str`, optional): Foursquare identifier of the venue if known.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the location.
+        thumb_url (:obj:`str`, optional): Url of the thumbnail for the result.
+        thumb_width (:obj:`int`, optional): Thumbnail width.
+        thumb_height (:obj:`int`, optional): Thumbnail height.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 latitude,
+                 longitude,
+                 title,
+                 address,
+                 foursquare_id=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 thumb_url=None,
+                 thumb_width=None,
+                 thumb_height=None,
+                 **kwargs):
+
+        # Required
+        super(InlineQueryResultVenue, self).__init__('venue', id)
+        self.latitude = latitude
+        self.longitude = longitude
+        self.title = title
+        self.address = address
+
+        # Optional
+        if foursquare_id:
+            self.foursquare_id = foursquare_id
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
+        if thumb_url:
+            self.thumb_url = thumb_url
+        if thumb_width:
+            self.thumb_width = thumb_width
+        if thumb_height:
+            self.thumb_height = thumb_height
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultdocument.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultvideo.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,100 +1,103 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultDocument"""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultDocument(InlineQueryResult):
-    """
-    Represents a link to a file. By default, this file will be sent by the user with an optional
-    caption. Alternatively, you can use :attr:`input_message_content` to send a message with the
-    specified content instead of the file. Currently, only .PDF and .ZIP files can be sent
-    using this method.
-
-    Attributes:
-        type (:obj:`str`): 'document'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        title (:obj:`str`): Title for the result.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters
-        document_url (:obj:`str`): A valid URL for the file.
-        mime_type (:obj:`str`): Mime type of the content of the file, either "application/pdf"
-            or "application/zip".
-        description (:obj:`str`): Optional. Short description of the result.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the file.
-        thumb_url (:obj:`str`): Optional. URL of the thumbnail (jpeg only) for the file.
-        thumb_width (:obj:`int`): Optional. Thumbnail width.
-        thumb_height (:obj:`int`): Optional. Thumbnail height.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        title (:obj:`str`): Title for the result.
-        caption (:obj:`str`, optional): Caption, 0-200 characters
-        document_url (:obj:`str`): A valid URL for the file.
-        mime_type (:obj:`str`): Mime type of the content of the file, either "application/pdf"
-            or "application/zip".
-        description (:obj:`str`, optional): Short description of the result.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the file.
-        thumb_url (:obj:`str`, optional): URL of the thumbnail (jpeg only) for the file.
-        thumb_width (:obj:`int`, optional): Thumbnail width.
-        thumb_height (:obj:`int`, optional): Thumbnail height.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 document_url,
-                 title,
-                 mime_type,
-                 caption=None,
-                 description=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 thumb_url=None,
-                 thumb_width=None,
-                 thumb_height=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultDocument, self).__init__('document', id)
-        self.document_url = document_url
-        self.title = title
-        self.mime_type = mime_type
-
-        # Optionals
-        if caption:
-            self.caption = caption
-        if description:
-            self.description = description
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
-        if thumb_url:
-            self.thumb_url = thumb_url
-        if thumb_width:
-            self.thumb_width = thumb_width
-        if thumb_height:
-            self.thumb_height = thumb_height
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultVideo."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultVideo(InlineQueryResult):
+    """
+    Represents a link to a page containing an embedded video player or a video file. By default,
+    this video file will be sent by the user with an optional caption. Alternatively, you can use
+    :attr:`input_message_content` to send a message with the specified content instead of
+    the video.
+
+    Attributes:
+        type (:obj:`str`): 'video'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        video_url (:obj:`str`): A valid URL for the embedded video player or video file.
+        mime_type (:obj:`str`): Mime type of the content of video url, "text/html" or "video/mp4".
+        thumb_url (:obj:`str`): URL of the thumbnail (jpeg only) for the video.
+        title (:obj:`str`): Title for the result.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters
+        video_width (:obj:`int`): Optional. Video width.
+        video_height (:obj:`int`): Optional. Video height.
+        video_duration (:obj:`int`): Optional. Video duration in seconds.
+        description (:obj:`str`): Optional. Short description of the result.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the video.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        video_url (:obj:`str`): A valid URL for the embedded video player or video file.
+        mime_type (:obj:`str`): Mime type of the content of video url, "text/html" or "video/mp4".
+        thumb_url (:obj:`str`): URL of the thumbnail (jpeg only) for the video.
+        title (:obj:`str`): Title for the result.
+        caption (:obj:`str`, optional): Caption, 0-200 characters.
+        video_width (:obj:`int`, optional): Video width.
+        video_height (:obj:`int`, optional): Video height.
+        video_duration (:obj:`int`, optional): Video duration in seconds.
+        description (:obj:`str`, optional): Short description of the result.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the video.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 video_url,
+                 mime_type,
+                 thumb_url,
+                 title,
+                 caption=None,
+                 video_width=None,
+                 video_height=None,
+                 video_duration=None,
+                 description=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+
+        # Required
+        super(InlineQueryResultVideo, self).__init__('video', id)
+        self.video_url = video_url
+        self.mime_type = mime_type
+        self.thumb_url = thumb_url
+        self.title = title
+
+        # Optional
+        if caption:
+            self.caption = caption
+        if video_width:
+            self.video_width = video_width
+        if video_height:
+            self.video_height = video_height
+        if video_duration:
+            self.video_duration = video_duration
+        if description:
+            self.description = description
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultgame.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultgame.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultGame."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultGame(InlineQueryResult):
-    """Represents a Game.
-
-    Attributes:
-        type (:obj:`str`): 'game'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        game_short_name (:obj:`str`): Short name of the game.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        game_short_name (:obj:`str`): Short name of the game.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, id, game_short_name, reply_markup=None, **kwargs):
-        # Required
-        super(InlineQueryResultGame, self).__init__('game', id)
-        self.id = id
-        self.game_short_name = game_short_name
-
-        if reply_markup:
-            self.reply_markup = reply_markup
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultGame."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultGame(InlineQueryResult):
+    """Represents a Game.
+
+    Attributes:
+        type (:obj:`str`): 'game'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        game_short_name (:obj:`str`): Short name of the game.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        game_short_name (:obj:`str`): Short name of the game.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, id, game_short_name, reply_markup=None, **kwargs):
+        # Required
+        super(InlineQueryResultGame, self).__init__('game', id)
+        self.id = id
+        self.game_short_name = game_short_name
+
+        if reply_markup:
+            self.reply_markup = reply_markup
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultgif.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultgif.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,94 +1,94 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultGif."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultGif(InlineQueryResult):
-    """
-    Represents a link to an animated GIF file. By default, this animated GIF file will be sent by
-    the user with optional caption. Alternatively, you can use :attr:`input_message_content` to
-    send a message with the specified content instead of the animation.
-
-    Attributes:
-        type (:obj:`str`): 'gif'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        gif_url (:obj:`str`): A valid URL for the GIF file. File size must not exceed 1MB.
-        gif_width (:obj:`int`): Optional. Width of the GIF.
-        gif_height (:obj:`int`): Optional. Height of the GIF.
-        gif_duration (:obj:`int`): Optional. Duration of the GIF.
-        thumb_url (:obj:`str`): URL of the static thumbnail for the result (jpeg or gif).
-        title (:obj:`str`): Optional. Title for the result.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the gif.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        gif_url (:obj:`str`): A valid URL for the GIF file. File size must not exceed 1MB.
-        gif_width (:obj:`int`, optional): Width of the GIF.
-        gif_height (:obj:`int`, optional): Height of the GIF.
-        gif_duration (:obj:`int`, optional): Duration of the GIF
-        thumb_url (:obj:`str`): URL of the static thumbnail for the result (jpeg or gif).
-        title (:obj:`str`, optional): Title for the result.caption (:obj:`str`, optional):
-        caption (:obj:`str`, optional): Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the gif.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 gif_url,
-                 thumb_url,
-                 gif_width=None,
-                 gif_height=None,
-                 title=None,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 gif_duration=None,
-                 **kwargs):
-
-        # Required
-        super(InlineQueryResultGif, self).__init__('gif', id)
-        self.gif_url = gif_url
-        self.thumb_url = thumb_url
-
-        # Optionals
-        if gif_width:
-            self.gif_width = gif_width
-        if gif_height:
-            self.gif_height = gif_height
-        if gif_duration:
-            self.gif_duration = gif_duration
-        if title:
-            self.title = title
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultGif."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultGif(InlineQueryResult):
+    """
+    Represents a link to an animated GIF file. By default, this animated GIF file will be sent by
+    the user with optional caption. Alternatively, you can use :attr:`input_message_content` to
+    send a message with the specified content instead of the animation.
+
+    Attributes:
+        type (:obj:`str`): 'gif'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        gif_url (:obj:`str`): A valid URL for the GIF file. File size must not exceed 1MB.
+        gif_width (:obj:`int`): Optional. Width of the GIF.
+        gif_height (:obj:`int`): Optional. Height of the GIF.
+        gif_duration (:obj:`int`): Optional. Duration of the GIF.
+        thumb_url (:obj:`str`): URL of the static thumbnail for the result (jpeg or gif).
+        title (:obj:`str`): Optional. Title for the result.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the gif.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        gif_url (:obj:`str`): A valid URL for the GIF file. File size must not exceed 1MB.
+        gif_width (:obj:`int`, optional): Width of the GIF.
+        gif_height (:obj:`int`, optional): Height of the GIF.
+        gif_duration (:obj:`int`, optional): Duration of the GIF
+        thumb_url (:obj:`str`): URL of the static thumbnail for the result (jpeg or gif).
+        title (:obj:`str`, optional): Title for the result.caption (:obj:`str`, optional):
+        caption (:obj:`str`, optional): Caption, 0-200 characters
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the gif.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 gif_url,
+                 thumb_url,
+                 gif_width=None,
+                 gif_height=None,
+                 title=None,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 gif_duration=None,
+                 **kwargs):
+
+        # Required
+        super(InlineQueryResultGif, self).__init__('gif', id)
+        self.gif_url = gif_url
+        self.thumb_url = thumb_url
+
+        # Optionals
+        if gif_width:
+            self.gif_width = gif_width
+        if gif_height:
+            self.gif_height = gif_height
+        if gif_duration:
+            self.gif_duration = gif_duration
+        if title:
+            self.title = title
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultlocation.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcontact.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,94 +1,88 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultLocation."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultLocation(InlineQueryResult):
-    """
-    Represents a location on a map. By default, the location will be sent by the user.
-    Alternatively, you can use :attr:`input_message_content` to send a message with the specified
-    content instead of the location.
-
-    Attributes:
-        type (:obj:`str`): 'location'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        latitude (:obj:`float`): Location latitude in degrees.
-        longitude (:obj:`float`): Location longitude in degrees.
-        title (:obj:`str`): Location title.
-        live_period (:obj:`int`): Optional. Period in seconds for which the location can be
-            updated, should be between 60 and 86400.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the location.
-        thumb_url (:obj:`str`): Optional. Url of the thumbnail for the result.
-        thumb_width (:obj:`int`): Optional. Thumbnail width.
-        thumb_height (:obj:`int`): Optional. Thumbnail height.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        latitude (:obj:`float`): Location latitude in degrees.
-        longitude (:obj:`float`): Location longitude in degrees.
-        title (:obj:`str`): Location title.
-        live_period (:obj:`int`, optional): Period in seconds for which the location can be
-            updated, should be between 60 and 86400.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the location.
-        thumb_url (:obj:`str`, optional): Url of the thumbnail for the result.
-        thumb_width (:obj:`int`, optional): Thumbnail width.
-        thumb_height (:obj:`int`, optional): Thumbnail height.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 latitude,
-                 longitude,
-                 title,
-                 live_period=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 thumb_url=None,
-                 thumb_width=None,
-                 thumb_height=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultLocation, self).__init__('location', id)
-        self.latitude = latitude
-        self.longitude = longitude
-        self.title = title
-
-        # Optionals
-        if live_period:
-            self.live_period = live_period
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
-        if thumb_url:
-            self.thumb_url = thumb_url
-        if thumb_width:
-            self.thumb_width = thumb_width
-        if thumb_height:
-            self.thumb_height = thumb_height
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultContact."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultContact(InlineQueryResult):
+    """
+    Represents a contact with a phone number. By default, this contact will be sent by the user.
+    Alternatively, you can use :attr:`input_message_content` to send a message with the specified
+    content instead of the contact.
+
+    Attributes:
+        type (:obj:`str`): 'contact'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        phone_number (:obj:`str`): Contact's phone number.
+        first_name (:obj:`str`): Contact's first name.
+        last_name (:obj:`str`): Optional. Contact's last name.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the contact.
+        thumb_url (:obj:`str`): Optional. Url of the thumbnail for the result.
+        thumb_width (:obj:`int`): Optional. Thumbnail width.
+        thumb_height (:obj:`int`): Optional. Thumbnail height.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        phone_number (:obj:`str`): Contact's phone number.
+        first_name (:obj:`str`): Contact's first name.
+        last_name (:obj:`str`, optional): Contact's last name.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the contact.
+        thumb_url (:obj:`str`, optional): Url of the thumbnail for the result.
+        thumb_width (:obj:`int`, optional): Thumbnail width.
+        thumb_height (:obj:`int`, optional): Thumbnail height.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 phone_number,
+                 first_name,
+                 last_name=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 thumb_url=None,
+                 thumb_width=None,
+                 thumb_height=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultContact, self).__init__('contact', id)
+        self.phone_number = phone_number
+        self.first_name = first_name
+
+        # Optionals
+        if last_name:
+            self.last_name = last_name
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
+        if thumb_url:
+            self.thumb_url = thumb_url
+        if thumb_width:
+            self.thumb_width = thumb_width
+        if thumb_height:
+            self.thumb_height = thumb_height
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultphoto.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultdocument.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,95 +1,100 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultPhoto."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultPhoto(InlineQueryResult):
-    """
-    Represents a link to a photo. By default, this photo will be sent by the user with optional
-    caption. Alternatively, you can use :attr:`input_message_content` to send a message with the
-    specified content instead of the photo.
-
-    Attributes:
-        type (:obj:`str`): 'photo'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        photo_url (:obj:`str`): A valid URL of the photo. Photo must be in jpeg format. Photo size
-            must not exceed 5MB.
-        thumb_url (:obj:`str`): URL of the thumbnail for the photo.
-        photo_width (:obj:`int`): Optional. Width of the photo.
-        photo_height (:obj:`int`): Optional. Height of the photo.
-        title (:obj:`str`): Optional. Title for the result.
-        description (:obj:`str`): Optional. Short description of the result.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the photo.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        photo_url (:obj:`str`): A valid URL of the photo. Photo must be in jpeg format. Photo size
-            must not exceed 5MB.
-        thumb_url (:obj:`str`): URL of the thumbnail for the photo.
-        photo_width (:obj:`int`, optional): Width of the photo.
-        photo_height (:obj:`int`, optional): Height of the photo.
-        title (:obj:`str`, optional): Title for the result.
-        description (:obj:`str`, optional): Short description of the result.
-        caption (:obj:`str`, optional): Caption, 0-200 characters
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the photo.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 photo_url,
-                 thumb_url,
-                 photo_width=None,
-                 photo_height=None,
-                 title=None,
-                 description=None,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-        # Required
-        super(InlineQueryResultPhoto, self).__init__('photo', id)
-        self.photo_url = photo_url
-        self.thumb_url = thumb_url
-
-        # Optionals
-        if photo_width:
-            self.photo_width = int(photo_width)
-        if photo_height:
-            self.photo_height = int(photo_height)
-        if title:
-            self.title = title
-        if description:
-            self.description = description
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultDocument"""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultDocument(InlineQueryResult):
+    """
+    Represents a link to a file. By default, this file will be sent by the user with an optional
+    caption. Alternatively, you can use :attr:`input_message_content` to send a message with the
+    specified content instead of the file. Currently, only .PDF and .ZIP files can be sent
+    using this method.
+
+    Attributes:
+        type (:obj:`str`): 'document'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        title (:obj:`str`): Title for the result.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters
+        document_url (:obj:`str`): A valid URL for the file.
+        mime_type (:obj:`str`): Mime type of the content of the file, either "application/pdf"
+            or "application/zip".
+        description (:obj:`str`): Optional. Short description of the result.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the file.
+        thumb_url (:obj:`str`): Optional. URL of the thumbnail (jpeg only) for the file.
+        thumb_width (:obj:`int`): Optional. Thumbnail width.
+        thumb_height (:obj:`int`): Optional. Thumbnail height.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        title (:obj:`str`): Title for the result.
+        caption (:obj:`str`, optional): Caption, 0-200 characters
+        document_url (:obj:`str`): A valid URL for the file.
+        mime_type (:obj:`str`): Mime type of the content of the file, either "application/pdf"
+            or "application/zip".
+        description (:obj:`str`, optional): Short description of the result.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the file.
+        thumb_url (:obj:`str`, optional): URL of the thumbnail (jpeg only) for the file.
+        thumb_width (:obj:`int`, optional): Thumbnail width.
+        thumb_height (:obj:`int`, optional): Thumbnail height.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 document_url,
+                 title,
+                 mime_type,
+                 caption=None,
+                 description=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 thumb_url=None,
+                 thumb_width=None,
+                 thumb_height=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultDocument, self).__init__('document', id)
+        self.document_url = document_url
+        self.title = title
+        self.mime_type = mime_type
+
+        # Optionals
+        if caption:
+            self.caption = caption
+        if description:
+            self.description = description
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
+        if thumb_url:
+            self.thumb_url = thumb_url
+        if thumb_width:
+            self.thumb_width = thumb_width
+        if thumb_height:
+            self.thumb_height = thumb_height
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inlinequeryresultvoice.py` & `python-telegram-bot-9.0.0/telegram/inline/inlinequeryresultcachedvoice.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,80 +1,73 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InlineQueryResultVoice."""
-
-from telegram import InlineQueryResult
-
-
-class InlineQueryResultVoice(InlineQueryResult):
-    """
-    Represents a link to a voice recording in an .ogg container encoded with OPUS. By default,
-    this voice recording will be sent by the user. Alternatively, you can use
-    :attr:`input_message_content` to send a message with the specified content instead of the
-    the voice message.
-
-    Attributes:
-        type (:obj:`str`): 'voice'.
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        voice_url (:obj:`str`): A valid URL for the voice recording.
-        title (:obj:`str`): Voice message title.
-        caption (:obj:`str`): Optional. Caption, 0-200 characters.
-        voice_duration (:obj:`int`): Optional. Recording duration in seconds.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
-            message to be sent instead of the voice.
-
-    Args:
-        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
-        voice_url (:obj:`str`): A valid URL for the voice recording.
-        title (:obj:`str`): Voice message title.
-        caption (:obj:`str`, optional): Caption, 0-200 characters.
-        voice_duration (:obj:`int`, optional): Recording duration in seconds.
-        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
-            to the message.
-        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
-            message to be sent instead of the voice.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 voice_url,
-                 title,
-                 voice_duration=None,
-                 caption=None,
-                 reply_markup=None,
-                 input_message_content=None,
-                 **kwargs):
-
-        # Required
-        super(InlineQueryResultVoice, self).__init__('voice', id)
-        self.voice_url = voice_url
-        self.title = title
-
-        # Optional
-        if voice_duration:
-            self.voice_duration = voice_duration
-        if caption:
-            self.caption = caption
-        if reply_markup:
-            self.reply_markup = reply_markup
-        if input_message_content:
-            self.input_message_content = input_message_content
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InlineQueryResultCachedVoice."""
+
+from telegram import InlineQueryResult
+
+
+class InlineQueryResultCachedVoice(InlineQueryResult):
+    """
+    Represents a link to a voice message stored on the Telegram servers. By default, this voice
+    message will be sent by the user. Alternatively, you can use :attr:`input_message_content` to
+    send a message with the specified content instead of the voice message.
+
+    Attributes:
+        type (:obj:`str`): 'voice'.
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        voice_file_id (:obj:`str`): A valid file identifier for the voice message.
+        title (:obj:`str`): Voice message title.
+        caption (:obj:`str`): Optional. Caption, 0-200 characters.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`): Optional. Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`): Optional. Content of the
+            message to be sent instead of the voice.
+
+    Args:
+        id (:obj:`str`): Unique identifier for this result, 1-64 bytes.
+        voice_file_id (:obj:`str`): A valid file identifier for the voice message.
+        title (:obj:`str`): Voice message title.
+        caption (:obj:`str`, optional): Caption, 0-200 characters.
+        reply_markup (:class:`telegram.InlineKeyboardMarkup`, optional): Inline keyboard attached
+            to the message.
+        input_message_content (:class:`telegram.InputMessageContent`, optional): Content of the
+            message to be sent instead of the voice.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 voice_file_id,
+                 title,
+                 caption=None,
+                 reply_markup=None,
+                 input_message_content=None,
+                 **kwargs):
+        # Required
+        super(InlineQueryResultCachedVoice, self).__init__('voice', id)
+        self.voice_file_id = voice_file_id
+        self.title = title
+
+        # Optionals
+        if caption:
+            self.caption = caption
+        if reply_markup:
+            self.reply_markup = reply_markup
+        if input_message_content:
+            self.input_message_content = input_message_content
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inputcontactmessagecontent.py` & `python-telegram-bot-9.0.0/telegram/inline/inputcontactmessagecontent.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InputContactMessageContent."""
-
-from telegram import InputMessageContent
-
-
-class InputContactMessageContent(InputMessageContent):
-    """Represents the content of a contact message to be sent as the result of an inline query.
-
-    Attributes:
-        phone_number (:obj:`str`): Contact's phone number.
-        first_name (:obj:`str`): Contact's first name.
-        last_name (:obj:`str`): Optional. Contact's last name.
-
-    Args:
-        phone_number (:obj:`str`): Contact's phone number.
-        first_name (:obj:`str`): Contact's first name.
-        last_name (:obj:`str`, optional): Contact's last name.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, phone_number, first_name, last_name=None, **kwargs):
-        # Required
-        self.phone_number = phone_number
-        self.first_name = first_name
-        # Optionals
-        self.last_name = last_name
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InputContactMessageContent."""
+
+from telegram import InputMessageContent
+
+
+class InputContactMessageContent(InputMessageContent):
+    """Represents the content of a contact message to be sent as the result of an inline query.
+
+    Attributes:
+        phone_number (:obj:`str`): Contact's phone number.
+        first_name (:obj:`str`): Contact's first name.
+        last_name (:obj:`str`): Optional. Contact's last name.
+
+    Args:
+        phone_number (:obj:`str`): Contact's phone number.
+        first_name (:obj:`str`): Contact's first name.
+        last_name (:obj:`str`, optional): Contact's last name.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, phone_number, first_name, last_name=None, **kwargs):
+        # Required
+        self.phone_number = phone_number
+        self.first_name = first_name
+        # Optionals
+        self.last_name = last_name
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inputlocationmessagecontent.py` & `python-telegram-bot-9.0.0/telegram/inline/inputvenuemessagecontent.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,45 +1,51 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InputLocationMessageContent."""
-
-from telegram import InputMessageContent
-
-
-class InputLocationMessageContent(InputMessageContent):
-    """
-    Represents the content of a location message to be sent as the result of an inline query.
-
-    Attributes:
-        latitude (:obj:`float`): Latitude of the location in degrees.
-        longitude (:obj:`float`): Longitude of the location in degrees.
-
-    Args:
-        latitude (:obj:`float`): Latitude of the location in degrees.
-        longitude (:obj:`float`): Longitude of the location in degrees.
-        live_period	(:obj:`int`, optional): Period in seconds for which the location can be
-            updated, should be between 60 and 86400.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, latitude, longitude, live_period=None, **kwargs):
-        # Required
-        self.latitude = latitude
-        self.longitude = longitude
-        self.live_period = live_period
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InputVenueMessageContent."""
+
+from telegram import InputMessageContent
+
+
+class InputVenueMessageContent(InputMessageContent):
+    """Represents the content of a venue message to be sent as the result of an inline query.
+
+    Attributes:
+        latitude (:obj:`float`): Latitude of the location in degrees.
+        longitude (:obj:`float`): Longitude of the location in degrees.
+        title (:obj:`str`): Name of the venue.
+        address (:obj:`str`): Address of the venue.
+        foursquare_id (:obj:`str`): Optional. Foursquare identifier of the venue, if known.
+
+    Args:
+        latitude (:obj:`float`): Latitude of the location in degrees.
+        longitude (:obj:`float`): Longitude of the location in degrees.
+        title (:obj:`str`): Name of the venue.
+        address (:obj:`str`): Address of the venue.
+        foursquare_id (:obj:`str`, optional): Foursquare identifier of the venue, if known.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, latitude, longitude, title, address, foursquare_id=None, **kwargs):
+        # Required
+        self.latitude = latitude
+        self.longitude = longitude
+        self.title = title
+        self.address = address
+        # Optionals
+        self.foursquare_id = foursquare_id
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inputmessagecontent.py` & `python-telegram-bot-9.0.0/telegram/inline/inputmessagecontent.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InputMessageContent."""
-
-from telegram import TelegramObject
-
-
-class InputMessageContent(TelegramObject):
-    """Base class for Telegram InputMessageContent Objects.
-
-    See: :class:`telegram.InputContactMessageContent`,
-    :class:`telegram.InputLocationMessageContent`, :class:`telegram.InputTextMessageContent` and
-    :class:`telegram.InputVenueMessageContent` for more details.
-
-    """
-    pass
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InputMessageContent."""
+
+from telegram import TelegramObject
+
+
+class InputMessageContent(TelegramObject):
+    """Base class for Telegram InputMessageContent Objects.
+
+    See: :class:`telegram.InputContactMessageContent`,
+    :class:`telegram.InputLocationMessageContent`, :class:`telegram.InputTextMessageContent` and
+    :class:`telegram.InputVenueMessageContent` for more details.
+
+    """
+    pass
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inputtextmessagecontent.py` & `python-telegram-bot-9.0.0/telegram/inline/inputtextmessagecontent.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InputTextMessageContent."""
-
-from telegram import InputMessageContent
-
-
-class InputTextMessageContent(InputMessageContent):
-    """
-    Represents the content of a text message to be sent as the result of an inline query.
-
-    Attributes:
-        message_text (:obj:`str`): Text of the message to be sent, 1-4096 characters.
-        parse_mode (:obj:`str`): Optional. Send Markdown or HTML, if you want Telegram apps to show
-            bold, italic, fixed-width text or inline URLs in your bot's message.
-        disable_web_page_preview (:obj:`bool`): Optional. Disables link previews for links in the
-            sent message.
-
-    Args:
-        message_text (:obj:`str`): Text of the message to be sent, 1-4096 characters.  Also found
-            as :attr:`telegram.constants.MAX_MESSAGE_LENGTH`.
-        parse_mode (:obj:`str`, optional): Send Markdown or HTML, if you want Telegram apps to show
-            bold, italic, fixed-width text or inline URLs in your bot's message.
-        disable_web_page_preview (:obj:`bool`, optional): Disables link previews for links in the
-            sent message.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, message_text, parse_mode=None, disable_web_page_preview=None, **kwargs):
-        # Required
-        self.message_text = message_text
-        # Optionals
-        self.parse_mode = parse_mode
-        self.disable_web_page_preview = disable_web_page_preview
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains the classes that represent Telegram InputTextMessageContent."""
+
+from telegram import InputMessageContent
+
+
+class InputTextMessageContent(InputMessageContent):
+    """
+    Represents the content of a text message to be sent as the result of an inline query.
+
+    Attributes:
+        message_text (:obj:`str`): Text of the message to be sent, 1-4096 characters.
+        parse_mode (:obj:`str`): Optional. Send Markdown or HTML, if you want Telegram apps to show
+            bold, italic, fixed-width text or inline URLs in your bot's message.
+        disable_web_page_preview (:obj:`bool`): Optional. Disables link previews for links in the
+            sent message.
+
+    Args:
+        message_text (:obj:`str`): Text of the message to be sent, 1-4096 characters.  Also found
+            as :attr:`telegram.constants.MAX_MESSAGE_LENGTH`.
+        parse_mode (:obj:`str`, optional): Send Markdown or HTML, if you want Telegram apps to show
+            bold, italic, fixed-width text or inline URLs in your bot's message.
+        disable_web_page_preview (:obj:`bool`, optional): Disables link previews for links in the
+            sent message.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, message_text, parse_mode=None, disable_web_page_preview=None, **kwargs):
+        # Required
+        self.message_text = message_text
+        # Optionals
+        self.parse_mode = parse_mode
+        self.disable_web_page_preview = disable_web_page_preview
```

### Comparing `python-telegram-bot-8.1.1/telegram/inline/inputvenuemessagecontent.py` & `python-telegram-bot-9.0.0/telegram/userprofilephotos.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,51 +1,61 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains the classes that represent Telegram InputVenueMessageContent."""
-
-from telegram import InputMessageContent
-
-
-class InputVenueMessageContent(InputMessageContent):
-    """Represents the content of a venue message to be sent as the result of an inline query.
-
-    Attributes:
-        latitude (:obj:`float`): Latitude of the location in degrees.
-        longitude (:obj:`float`): Longitude of the location in degrees.
-        title (:obj:`str`): Name of the venue.
-        address (:obj:`str`): Address of the venue.
-        foursquare_id (:obj:`str`): Optional. Foursquare identifier of the venue, if known.
-
-    Args:
-        latitude (:obj:`float`): Latitude of the location in degrees.
-        longitude (:obj:`float`): Longitude of the location in degrees.
-        title (:obj:`str`): Name of the venue.
-        address (:obj:`str`): Address of the venue.
-        foursquare_id (:obj:`str`, optional): Foursquare identifier of the venue, if known.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, latitude, longitude, title, address, foursquare_id=None, **kwargs):
-        # Required
-        self.latitude = latitude
-        self.longitude = longitude
-        self.title = title
-        self.address = address
-        # Optionals
-        self.foursquare_id = foursquare_id
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram UserProfilePhotos."""
+
+from telegram import PhotoSize, TelegramObject
+
+
+class UserProfilePhotos(TelegramObject):
+    """This object represent a user's profile pictures.
+
+    Attributes:
+        total_count (:obj:`int`): Total number of profile pictures.
+        photos (List[List[:class:`telegram.PhotoSize`]]): Requested profile pictures.
+
+    Args:
+        total_count (:obj:`int`): Total number of profile pictures the target user has.
+        photos (List[List[:class:`telegram.PhotoSize`]]): Requested profile pictures (in up to 4
+            sizes each).
+
+    """
+
+    def __init__(self, total_count, photos, **kwargs):
+        # Required
+        self.total_count = int(total_count)
+        self.photos = photos
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(UserProfilePhotos, cls).de_json(data, bot)
+
+        data['photos'] = [PhotoSize.de_list(photo, bot) for photo in data['photos']]
+
+        return cls(**data)
+
+    def to_dict(self):
+        data = super(UserProfilePhotos, self).to_dict()
+
+        data['photos'] = []
+        for photo in self.photos:
+            data['photos'].append([x.to_dict() for x in photo])
+
+        return data
```

### Comparing `python-telegram-bot-8.1.1/telegram/keyboardbutton.py` & `python-telegram-bot-9.0.0/telegram/keyboardbutton.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram KeyboardButton."""
-
-from telegram import TelegramObject
-
-
-class KeyboardButton(TelegramObject):
-    """
-    This object represents one button of the reply keyboard. For simple text buttons String can be
-    used instead of this object to specify text of the button.
-
-    Note:
-        Optional fields are mutually exclusive.
-
-    Attributes:
-        text (:obj:`str`): Text of the button.
-        request_contact (:obj:`bool`): Optional. If the user's phone number will be sent.
-        request_location (:obj:`bool`): Optional. If the user's current location will be sent.
-
-    Args:
-        text (:obj:`str`): Text of the button. If none of the optional fields are used, it will be
-            sent to the bot as a message when the button is pressed.
-        request_contact (:obj:`bool`, optional): If True, the user's phone number will be sent as
-            a contact when the button is pressed. Available in private chats only.
-        request_location (:obj:`bool`, optional): If True, the user's current location will be sent
-            when the button is pressed. Available in private chats only.
-
-    Note:
-        :attr:`request_contact` and :attr:`request_location` options will only work in Telegram
-        versions released after 9 April, 2016. Older clients will ignore them.
-
-    """
-
-    def __init__(self, text, request_contact=None, request_location=None, **kwargs):
-        # Required
-        self.text = text
-        # Optionals
-        self.request_contact = request_contact
-        self.request_location = request_location
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram KeyboardButton."""
+
+from telegram import TelegramObject
+
+
+class KeyboardButton(TelegramObject):
+    """
+    This object represents one button of the reply keyboard. For simple text buttons String can be
+    used instead of this object to specify text of the button.
+
+    Note:
+        Optional fields are mutually exclusive.
+
+    Attributes:
+        text (:obj:`str`): Text of the button.
+        request_contact (:obj:`bool`): Optional. If the user's phone number will be sent.
+        request_location (:obj:`bool`): Optional. If the user's current location will be sent.
+
+    Args:
+        text (:obj:`str`): Text of the button. If none of the optional fields are used, it will be
+            sent to the bot as a message when the button is pressed.
+        request_contact (:obj:`bool`, optional): If True, the user's phone number will be sent as
+            a contact when the button is pressed. Available in private chats only.
+        request_location (:obj:`bool`, optional): If True, the user's current location will be sent
+            when the button is pressed. Available in private chats only.
+
+    Note:
+        :attr:`request_contact` and :attr:`request_location` options will only work in Telegram
+        versions released after 9 April, 2016. Older clients will ignore them.
+
+    """
+
+    def __init__(self, text, request_contact=None, request_location=None, **kwargs):
+        # Required
+        self.text = text
+        # Optionals
+        self.request_contact = request_contact
+        self.request_location = request_location
```

### Comparing `python-telegram-bot-8.1.1/telegram/message.py` & `python-telegram-bot-9.0.0/telegram/message.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,934 +1,940 @@
-#!/usr/bin/env python
-# pylint: disable=R0902,R0912,R0913
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Message."""
-import sys
-
-from telegram import (Audio, Contact, Document, Chat, Location, PhotoSize, Sticker, TelegramObject,
-                      User, Video, Voice, Venue, MessageEntity, Game, Invoice, SuccessfulPayment,
-                      VideoNote)
-from telegram.utils.deprecate import warn_deprecate_obj
-from telegram.utils.helpers import escape_html, escape_markdown, to_timestamp, from_timestamp
-
-_UNDEFINED = object()
-
-
-class Message(TelegramObject):
-    """This object represents a message.
-
-    Note:
-        * In Python `from` is a reserved word, use `from_user` instead.
-
-    Attributes:
-        message_id (:obj:`int`): Unique message identifier inside this chat.
-        from_user (:class:`telegram.User`): Optional. Sender.
-        date (:class:`datetime.datetime`): Date the message was sent.
-        chat (:class:`telegram.Chat`): Conversation the message belongs to.
-        forward_from (:class:`telegram.User`): Optional. Sender of the original message.
-        forward_from_chat (:class:`telegram.Chat`): Optional. Information about the original
-            channel.
-        forward_from_message_id (:obj:`int`): Optional. Identifier of the original message in the
-            channel.
-        forward_date (:class:`datetime.datetime`): Optional. Date the original message was sent.
-        reply_to_message (:class:`telegram.Message`): Optional. The original message.
-        edit_date (:class:`datetime.datetime`): Optional. Date the message was last edited.
-        text (:obj:`str`): Optional. The actual UTF-8 text of the message.
-        entities (List[:class:`telegram.MessageEntity`]): Optional. Special entities like
-            usernames, URLs, bot commands, etc. that appear in the text. See
-            :attr:`Message.parse_entity` and :attr:`parse_entities` methods for how to use
-            properly.
-        caption_entities (List[:class:`telegram.MessageEntity`]): Optional. Special entities like
-            usernames, URLs, bot commands, etc. that appear in the caption. See
-            :attr:`Message.parse_caption_entity` and :attr:`parse_caption_entities` methods for how
-            to use properly.
-        audio (:class:`telegram.Audio`): Optional. Information about the file.
-        document (:class:`telegram.Document`): Optional. Information about the file.
-        game (:class:`telegram.Game`): Optional. Information about the game.
-        photo (List[:class:`telegram.PhotoSize`]): Optional. Available sizes of the photo.
-        sticker (:class:`telegram.Sticker`): Optional. Information about the sticker.
-        video (:class:`telegram.Video`): Optional. Information about the video.
-        voice (:class:`telegram.Voice`): Optional. Information about the file.
-        video_note (:class:`telegram.VideoNote`): Optional. Information about the video message.
-        new_chat_members (List[:class:`telegram.User`]): Optional. Information about new members to
-            the chat. (the bot itself may be one of these members).
-        caption (:obj:`str`): Optional. Caption for the document, photo or video, 0-200 characters.
-        contact (:class:`telegram.Contact`): Optional. Information about the contact.
-        location (:class:`telegram.Location`): Optional. Information about the location.
-        venue (:class:`telegram.Venue`): Optional. Information about the venue.
-        left_chat_member (:class:`telegram.User`): Optional. Information about the user that left
-            the group. (this member may be the bot itself).
-        new_chat_title (:obj:`str`): Optional. A chat title was changed to this value.
-        new_chat_photo (List[:class:`telegram.PhotoSize`]): Optional. A chat photo was changed to
-            this value.
-        delete_chat_photo (:obj:`bool`): Optional. The chat photo was deleted.
-        group_chat_created (:obj:`bool`): Optional. The group has been created.
-        supergroup_chat_created (:obj:`bool`): Optional. The supergroup has been created.
-        channel_chat_created (:obj:`bool`): Optional. The channel has been created.
-        migrate_to_chat_id (:obj:`int`): Optional. The group has been migrated to a supergroup with
-            the specified identifier.
-        migrate_from_chat_id (:obj:`int`): Optional. The supergroup has been migrated from a group
-            with the specified identifier.
-        pinned_message (:class:`telegram.message`): Optional. Specified message was pinned.
-        invoice (:class:`telegram.Invoice`): Optional. Information about the invoice.
-        successful_payment (:class:`telegram.SuccessfulPayment`): Optional. Information about the
-            payment.
-        forward_signature (:obj:`str`): Optional. Signature of the post author for messages
-            forwarded from channels.
-        author_signature (:obj:`str`): Optional. Signature of the post author for messages
-            in channels.
-        bot (:class:`telegram.Bot`): Optional. The Bot to use for instance methods.
-
-    Deprecated: 6.0
-        new_chat_member (:class:`telegram.User`): Replaced with :attr:`new_chat_members`
-
-    Args:
-        message_id (:obj:`int`): Unique message identifier inside this chat.
-        from_user (:class:`telegram.User`, optional): Sender, can be empty for messages sent
-            to channels.
-        date (:class:`datetime.datetime`): Date the message was sent in Unix time. Converted to
-            :class:`datetime.datetime`.
-        chat (:class:`telegram.Chat`): Conversation the message belongs to.
-        forward_from (:class:`telegram.User`, optional): For forwarded messages, sender of
-            the original message.
-        forward_from_chat (:class:`telegram.Chat`, optional): For messages forwarded from a
-            channel, information about the original channel.
-        forward_from_message_id (:obj:`int`, optional): For forwarded channel posts, identifier of
-            the original message in the channel.
-        forward_date (:class:`datetime.datetime`, optional): For forwarded messages, date the
-            original message was sent in Unix time. Converted to :class:`datetime.datetime`.
-        reply_to_message (:class:`telegram.Message`, optional): For replies, the original message.
-            Note that the Message object in this field will not contain further
-            ``reply_to_message`` fields even if it itself is a reply.
-        edit_date (:class:`datetime.datetime`, optional): Date the message was last edited in Unix
-            time. Converted to :class:`datetime.datetime`.
-        text (str, optional): For text messages, the actual UTF-8 text of the message, 0-4096
-            characters. Also found as :attr:`telegram.constants.MAX_MESSAGE_LENGTH`.
-        entities (List[:class:`telegram.MessageEntity`], optional): For text messages, special
-            entities like usernames, URLs, bot commands, etc. that appear in the text. See
-            attr:`parse_entity` and attr:`parse_entities` methods for how to use properly.
-        caption_entities (List[:class:`telegram.MessageEntity`]): Optional. For Messages with a
-            Caption. Special entities like usernames, URLs, bot commands, etc. that appear in the
-            caption. See :attr:`Message.parse_caption_entity` and :attr:`parse_caption_entities`
-            methods for how to use properly.
-        audio (:class:`telegram.Audio`, optional): Message is an audio file, information
-            about the file.
-        document (:class:`telegram.Document`, optional): Message is a general file, information
-            about the file.
-        game (:class:`telegram.Game`, optional): Message is a game, information about the game.
-        photo (List[:class:`telegram.PhotoSize`], optional): Message is a photo, available
-            sizes of the photo.
-        sticker (:class:`telegram.Sticker`, optional): Message is a sticker, information
-            about the sticker.
-        video (:class:`telegram.Video`, optional): Message is a video, information about the video.
-        voice (:class:`telegram.Voice`, optional): Message is a voice message, information about
-            the file.
-        video_note (:class:`telegram.VideoNote`, optional): Message is a video note, information
-            about the video message.
-        new_chat_members (List[:class:`telegram.User`], optional): New members that were added to
-            the group or supergroup and information about them (the bot itself may be one of these
-            members).
-        caption (:obj:`str`, optional): Caption for the document, photo or video, 0-200 characters.
-        contact (:class:`telegram.Contact`, optional): Message is a shared contact, information
-            about the contact.
-        location (:class:`telegram.Location`, optional): Message is a shared location, information
-            about the location.
-        venue (:class:`telegram.Venue`, optional): Message is a venue, information about the venue.
-        left_chat_member (:class:`telegram.User`, optional): A member was removed from the group,
-            information about them (this member may be the bot itself).
-        new_chat_title (:obj:`str`, optional): A chat title was changed to this value.
-        new_chat_photo (List[:class:`telegram.PhotoSize`], optional): A chat photo was change to
-            this value.
-        delete_chat_photo (:obj:`bool`, optional): Service message: The chat photo was deleted.
-        group_chat_created (:obj:`bool`, optional): Service message: The group has been created.
-        supergroup_chat_created (:obj:`bool`, optional): Service message: The supergroup has been
-            created. This field can't be received in a message coming through updates, because bot
-            can't be a member of a supergroup when it is created. It can only be found in
-            :attr:`reply_to_message` if someone replies to a very first message in a directly
-            created supergroup.
-        channel_chat_created (:obj:`bool`, optional): Service message: The channel has been
-            created. This field can't be received in a message coming through updates, because bot
-            can't be a member of a channel when it is created. It can only be found in
-            attr:`reply_to_message` if someone replies to a very first message in a channel.
-        migrate_to_chat_id (:obj:`int`, optional): The group has been migrated to a supergroup with
-            the specified identifier. This number may be greater than 32 bits and some programming
-            languages may have difficulty/silent defects in interpreting it. But it is smaller than
-            52 bits, so a signed 64 bit integer or double-precision float type are safe for storing
-            this identifier.
-        migrate_from_chat_id (:obj:`int`, optional): The supergroup has been migrated from a group
-            with the specified identifier. This number may be greater than 32 bits and some
-            programming languages may have difficulty/silent defects in interpreting it. But it is
-            smaller than 52 bits, so a signed 64 bit integer or double-precision float type are
-            safe for storing this identifier.
-        pinned_message (:class:`telegram.message`, optional): Specified message was pinned. Note
-            that the Message object in this field will not contain further attr:`reply_to_message`
-            fields even if it is itself a reply.
-        invoice (:class:`telegram.Invoice`, optional): Message is an invoice for a payment,
-            information about the invoice.
-        successful_payment (:class:`telegram.SuccessfulPayment`, optional): Message is a service
-            message about a successful payment, information about the payment.
-        forward_signature (:obj:`str`, optional): Signature of the post author for messages
-            forwarded from channels.
-        author_signature (:obj:`str`, optional): Signature of the post author for messages
-            in channels.
-    """
-
-    _effective_attachment = _UNDEFINED
-
-    def __init__(self,
-                 message_id,
-                 from_user,
-                 date,
-                 chat,
-                 forward_from=None,
-                 forward_from_chat=None,
-                 forward_from_message_id=None,
-                 forward_date=None,
-                 reply_to_message=None,
-                 edit_date=None,
-                 text=None,
-                 entities=None,
-                 caption_entities=None,
-                 audio=None,
-                 document=None,
-                 game=None,
-                 photo=None,
-                 sticker=None,
-                 video=None,
-                 voice=None,
-                 video_note=None,
-                 new_chat_members=None,
-                 caption=None,
-                 contact=None,
-                 location=None,
-                 venue=None,
-                 new_chat_member=None,
-                 left_chat_member=None,
-                 new_chat_title=None,
-                 new_chat_photo=None,
-                 delete_chat_photo=False,
-                 group_chat_created=False,
-                 supergroup_chat_created=False,
-                 channel_chat_created=False,
-                 migrate_to_chat_id=None,
-                 migrate_from_chat_id=None,
-                 pinned_message=None,
-                 invoice=None,
-                 successful_payment=None,
-                 forward_signature=None,
-                 author_signature=None,
-                 bot=None,
-                 **kwargs):
-        # Required
-        self.message_id = int(message_id)
-        self.from_user = from_user
-        self.date = date
-        self.chat = chat
-        # Optionals
-        self.forward_from = forward_from
-        self.forward_from_chat = forward_from_chat
-        self.forward_date = forward_date
-        self.reply_to_message = reply_to_message
-        self.edit_date = edit_date
-        self.text = text
-        self.entities = entities or list()
-        self.caption_entities = caption_entities or list()
-        self.audio = audio
-        self.game = game
-        self.document = document
-        self.photo = photo or list()
-        self.sticker = sticker
-        self.video = video
-        self.voice = voice
-        self.video_note = video_note
-        self.caption = caption
-        self.contact = contact
-        self.location = location
-        self.venue = venue
-        self._new_chat_member = new_chat_member
-        self.new_chat_members = new_chat_members or list()
-        self.left_chat_member = left_chat_member
-        self.new_chat_title = new_chat_title
-        self.new_chat_photo = new_chat_photo or list()
-        self.delete_chat_photo = bool(delete_chat_photo)
-        self.group_chat_created = bool(group_chat_created)
-        self.supergroup_chat_created = bool(supergroup_chat_created)
-        self.migrate_to_chat_id = migrate_to_chat_id
-        self.migrate_from_chat_id = migrate_from_chat_id
-        self.channel_chat_created = bool(channel_chat_created)
-        self.pinned_message = pinned_message
-        self.forward_from_message_id = forward_from_message_id
-        self.invoice = invoice
-        self.successful_payment = successful_payment
-        self.forward_signature = forward_signature
-        self.author_signature = author_signature
-
-        self.bot = bot
-
-        self._id_attrs = (self.message_id,)
-
-    @property
-    def chat_id(self):
-        """:obj:`int`: Shortcut for :attr:`telegram.Chat.id` for :attr:`chat`."""
-        return self.chat.id
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(Message, cls).de_json(data, bot)
-
-        data['from_user'] = User.de_json(data.get('from'), bot)
-        data['date'] = from_timestamp(data['date'])
-        data['chat'] = Chat.de_json(data.get('chat'), bot)
-        data['entities'] = MessageEntity.de_list(data.get('entities'), bot)
-        data['caption_entities'] = MessageEntity.de_list(data.get('caption_entities'), bot)
-        data['forward_from'] = User.de_json(data.get('forward_from'), bot)
-        data['forward_from_chat'] = Chat.de_json(data.get('forward_from_chat'), bot)
-        data['forward_date'] = from_timestamp(data.get('forward_date'))
-        data['reply_to_message'] = Message.de_json(data.get('reply_to_message'), bot)
-        data['edit_date'] = from_timestamp(data.get('edit_date'))
-        data['audio'] = Audio.de_json(data.get('audio'), bot)
-        data['document'] = Document.de_json(data.get('document'), bot)
-        data['game'] = Game.de_json(data.get('game'), bot)
-        data['photo'] = PhotoSize.de_list(data.get('photo'), bot)
-        data['sticker'] = Sticker.de_json(data.get('sticker'), bot)
-        data['video'] = Video.de_json(data.get('video'), bot)
-        data['voice'] = Voice.de_json(data.get('voice'), bot)
-        data['video_note'] = VideoNote.de_json(data.get('video_note'), bot)
-        data['contact'] = Contact.de_json(data.get('contact'), bot)
-        data['location'] = Location.de_json(data.get('location'), bot)
-        data['venue'] = Venue.de_json(data.get('venue'), bot)
-        data['new_chat_member'] = User.de_json(data.get('new_chat_member'), bot)
-        data['new_chat_members'] = User.de_list(data.get('new_chat_members'), bot)
-        data['left_chat_member'] = User.de_json(data.get('left_chat_member'), bot)
-        data['new_chat_photo'] = PhotoSize.de_list(data.get('new_chat_photo'), bot)
-        data['pinned_message'] = Message.de_json(data.get('pinned_message'), bot)
-        data['invoice'] = Invoice.de_json(data.get('invoice'), bot)
-        data['successful_payment'] = SuccessfulPayment.de_json(data.get('successful_payment'), bot)
-
-        return cls(bot=bot, **data)
-
-    @property
-    def effective_attachment(self):
-        """
-        :class:`telegram.Audio`
-            or :class:`telegram.Contact`
-            or :class:`telegram.Document`
-            or :class:`telegram.Game`
-            or :class:`telegram.Invoice`
-            or :class:`telegram.Location`
-            or List[:class:`telegram.PhotoSize`]
-            or :class:`telegram.Sticker`
-            or :class:`telegram.SuccessfulPayment`
-            or :class:`telegram.Venue`
-            or :class:`telegram.Video`
-            or :class:`telegram.VideoNote`
-            or :class:`telegram.Voice`: The attachment that this message was sent with. May be
-            ``None`` if no attachment was sent.
-
-        """
-        if self._effective_attachment is not _UNDEFINED:
-            return self._effective_attachment
-
-        for i in (self.audio, self.game, self.document, self.photo, self.sticker,
-                  self.video, self.voice, self.video_note, self.contact, self.location,
-                  self.venue, self.invoice, self.successful_payment):
-            if i:
-                self._effective_attachment = i
-                break
-        else:
-            self._effective_attachment = None
-
-        return self._effective_attachment
-
-    def __getitem__(self, item):
-        if item in self.__dict__.keys():
-            return self.__dict__[item]
-        elif item == 'chat_id':
-            return self.chat.id
-
-    def to_dict(self):
-        data = super(Message, self).to_dict()
-
-        # Required
-        data['from'] = data.pop('from_user', None)
-        data['date'] = to_timestamp(self.date)
-        # Optionals
-        if self.forward_date:
-            data['forward_date'] = to_timestamp(self.forward_date)
-        if self.edit_date:
-            data['edit_date'] = to_timestamp(self.edit_date)
-        if self.photo:
-            data['photo'] = [p.to_dict() for p in self.photo]
-        if self.entities:
-            data['entities'] = [e.to_dict() for e in self.entities]
-        if self.caption_entities:
-            data['caption_entities'] = [e.to_dict() for e in self.caption_entities]
-        if self.new_chat_photo:
-            data['new_chat_photo'] = [p.to_dict() for p in self.new_chat_photo]
-        data['new_chat_member'] = data.pop('_new_chat_member', None)
-        if self.new_chat_members:
-            data['new_chat_members'] = [u.to_dict() for u in self.new_chat_members]
-
-        return data
-
-    def _quote(self, kwargs):
-        """Modify kwargs for replying with or without quoting."""
-        if 'reply_to_message_id' in kwargs:
-            if 'quote' in kwargs:
-                del kwargs['quote']
-
-        elif 'quote' in kwargs:
-            if kwargs['quote']:
-                kwargs['reply_to_message_id'] = self.message_id
-
-            del kwargs['quote']
-
-        else:
-            if self.chat.type != Chat.PRIVATE:
-                kwargs['reply_to_message_id'] = self.message_id
-
-    def reply_text(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_message(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the message is sent as an actual
-                reply to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this
-                parameter will be ignored. Default: ``True`` in group chats and ``False`` in
-                private chats.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_message(self.chat_id, *args, **kwargs)
-
-    def reply_photo(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_photo(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_photo(self.chat_id, *args, **kwargs)
-
-    def reply_audio(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_audio(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_audio(self.chat_id, *args, **kwargs)
-
-    def reply_document(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_document(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_document(self.chat_id, *args, **kwargs)
-
-    def reply_sticker(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_sticker(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_sticker(self.chat_id, *args, **kwargs)
-
-    def reply_video(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_video(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_video(self.chat_id, *args, **kwargs)
-
-    def reply_video_note(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_video_note(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_video_note(self.chat_id, *args, **kwargs)
-
-    def reply_voice(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_voice(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_voice(self.chat_id, *args, **kwargs)
-
-    def reply_location(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_location(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_location(self.chat_id, *args, **kwargs)
-
-    def reply_venue(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_venue(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_venue(self.chat_id, *args, **kwargs)
-
-    def reply_contact(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.send_contact(update.message.chat_id, *args, **kwargs)
-
-        Keyword Args:
-            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
-                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
-                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message posted.
-
-        """
-        self._quote(kwargs)
-        return self.bot.send_contact(self.chat_id, *args, **kwargs)
-
-    def forward(self, chat_id, disable_notification=False):
-        """Shortcut for::
-
-            bot.forward_message(chat_id=chat_id,
-                                from_chat_id=update.message.chat_id,
-                                disable_notification=disable_notification,
-                                message_id=update.message.message_id)
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the message forwarded.
-
-        """
-        return self.bot.forward_message(
-            chat_id=chat_id,
-            from_chat_id=self.chat_id,
-            disable_notification=disable_notification,
-            message_id=self.message_id)
-
-    def edit_text(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.edit_message_text(chat_id=message.chat_id,
-                                  message_id=message.message_id,
-                                  *args,
-                                  **kwargs)
-
-        Note:
-            You can only edit messages that the bot sent itself,
-            therefore this method can only be used on the
-            return value of the ``bot.send_*`` family of methods..
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the edited message.
-
-        """
-        return self.bot.edit_message_text(
-            chat_id=self.chat_id, message_id=self.message_id, *args, **kwargs)
-
-    def edit_caption(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.edit_message_caption(chat_id=message.chat_id,
-                                     message_id=message.message_id,
-                                     *args,
-                                     **kwargs)
-
-        Note:
-            You can only edit messages that the bot sent itself,
-            therefore this method can only be used on the
-            return value of the ``bot.send_*`` family of methods.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the edited message.
-
-        """
-        return self.bot.edit_message_caption(
-            chat_id=self.chat_id, message_id=self.message_id, *args, **kwargs)
-
-    def edit_reply_markup(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.edit_message_reply_markup(chat_id=message.chat_id,
-                                          message_id=message.message_id,
-                                          *args,
-                                          **kwargs)
-
-        Note:
-            You can only edit messages that the bot sent itself,
-            therefore this method can only be used on the
-            return value of the ``bot.send_*`` family of methods.
-
-        Returns:
-            :class:`telegram.Message`: On success, instance representing the edited message.
-        """
-        return self.bot.edit_message_reply_markup(
-            chat_id=self.chat_id, message_id=self.message_id, *args, **kwargs)
-
-    def delete(self, *args, **kwargs):
-        """Shortcut for::
-
-             bot.delete_message(chat_id=message.chat_id,
-                                message_id=message.message_id,
-                                *args,
-                                **kwargs)
-
-        Returns:
-            :obj:`bool`: On success, ``True`` is returned.
-
-        """
-        return self.bot.delete_message(
-            chat_id=self.chat_id, message_id=self.message_id, *args, **kwargs)
-
-    def parse_entity(self, entity):
-        """Returns the text from a given :class:`telegram.MessageEntity`.
-
-        Note:
-            This method is present because Telegram calculates the offset and length in
-            UTF-16 codepoint pairs, which some versions of Python don't handle automatically.
-            (That is, you can't just slice ``Message.text`` with the offset and length.)
-
-        Args:
-            entity (:class:`telegram.MessageEntity`): The entity to extract the text from. It must
-            be an entity that belongs to this message.
-
-        Returns:
-            :obj:`str`: The text of the given entity
-
-        """
-        # Is it a narrow build, if so we don't need to convert
-        if sys.maxunicode == 0xffff:
-            return self.text[entity.offset:entity.offset + entity.length]
-        else:
-            entity_text = self.text.encode('utf-16-le')
-            entity_text = entity_text[entity.offset * 2:(entity.offset + entity.length) * 2]
-
-        return entity_text.decode('utf-16-le')
-
-    def parse_caption_entity(self, entity):
-        """Returns the text from a given :class:`telegram.MessageEntity`.
-
-        Note:
-            This method is present because Telegram calculates the offset and length in
-            UTF-16 codepoint pairs, which some versions of Python don't handle automatically.
-            (That is, you can't just slice ``Message.caption`` with the offset and length.)
-
-        Args:
-            entity (:class:`telegram.MessageEntity`): The entity to extract the text from. It must
-            be an entity that belongs to this message.
-
-        Returns:
-            :obj:`str`: The text of the given entity
-
-        """
-        # Is it a narrow build, if so we don't need to convert
-        if sys.maxunicode == 0xffff:
-            return self.caption[entity.offset:entity.offset + entity.length]
-        else:
-            entity_text = self.caption.encode('utf-16-le')
-            entity_text = entity_text[entity.offset * 2:(entity.offset + entity.length) * 2]
-
-        return entity_text.decode('utf-16-le')
-
-    def parse_entities(self, types=None):
-        """
-        Returns a :obj:`dict` that maps :class:`telegram.MessageEntity` to :obj:`str`.
-        It contains entities from this message filtered by their
-        :attr:`telegram.MessageEntity.type` attribute as the key, and the text that each entity
-        belongs to as the value of the :obj:`dict`.
-
-        Note:
-            This method should always be used instead of the :attr:`entities` attribute, since it
-            calculates the correct substring from the message text based on UTF-16 codepoints.
-            See :attr:`parse_entity` for more info.
-
-        Args:
-            types (List[:obj:`str`], optional): List of :class:`telegram.MessageEntity` types as
-                strings. If the ``type`` attribute of an entity is contained in this list, it will
-                be returned. Defaults to a list of all types. All types can be found as constants
-                in :class:`telegram.MessageEntity`.
-
-        Returns:
-            Dict[:class:`telegram.MessageEntity`, :obj:`str`]: A dictionary of entities mapped to
-            the text that belongs to them, calculated based on UTF-16 codepoints.
-
-        """
-        if types is None:
-            types = MessageEntity.ALL_TYPES
-
-        return {
-            entity: self.parse_entity(entity)
-            for entity in self.entities if entity.type in types
-        }
-
-    def parse_caption_entities(self, types=None):
-        """
-        Returns a :obj:`dict` that maps :class:`telegram.MessageEntity` to :obj:`str`.
-        It contains entities from this message's caption filtered by their
-        :attr:`telegram.MessageEntity.type` attribute as the key, and the text that each entity
-        belongs to as the value of the :obj:`dict`.
-
-        Note:
-            This method should always be used instead of the :attr:`caption_entities` attribute,
-            since it calculates the correct substring from the message text based on UTF-16
-            codepoints. See :attr:`parse_entity` for more info.
-
-        Args:
-            types (List[:obj:`str`], optional): List of :class:`telegram.MessageEntity` types as
-                strings. If the ``type`` attribute of an entity is contained in this list, it will
-                be returned. Defaults to a list of all types. All types can be found as constants
-                in :class:`telegram.MessageEntity`.
-
-        Returns:
-            Dict[:class:`telegram.MessageEntity`, :obj:`str`]: A dictionary of entities mapped to
-            the text that belongs to them, calculated based on UTF-16 codepoints.
-
-        """
-        if types is None:
-            types = MessageEntity.ALL_TYPES
-
-        return {
-            entity: self.parse_caption_entity(entity)
-            for entity in self.caption_entities if entity.type in types
-        }
-
-    def _text_html(self, urled=False):
-        entities = self.parse_entities()
-        message_text = self.text
-        if not sys.maxunicode == 0xffff:
-            message_text = message_text.encode('utf-16-le')
-
-        html_text = ''
-        last_offset = 0
-
-        for entity, text in sorted(entities.items(), key=(lambda item: item[0].offset)):
-            text = escape_html(text)
-
-            if entity.type == MessageEntity.TEXT_LINK:
-                insert = '<a href="{}">{}</a>'.format(entity.url, text)
-            elif (entity.type == MessageEntity.URL) and urled:
-                insert = '<a href="{0}">{0}</a>'.format(text)
-            elif entity.type == MessageEntity.BOLD:
-                insert = '<b>' + text + '</b>'
-            elif entity.type == MessageEntity.ITALIC:
-                insert = '<i>' + text + '</i>'
-            elif entity.type == MessageEntity.CODE:
-                insert = '<code>' + text + '</code>'
-            elif entity.type == MessageEntity.PRE:
-                insert = '<pre>' + text + '</pre>'
-            else:
-                insert = text
-
-            if sys.maxunicode == 0xffff:
-                html_text += escape_html(message_text[last_offset:entity.offset]) + insert
-            else:
-                html_text += escape_html(message_text[last_offset * 2:entity.offset * 2]
-                                         .decode('utf-16-le')) + insert
-
-            last_offset = entity.offset + entity.length
-
-        if sys.maxunicode == 0xffff:
-            html_text += escape_html(message_text[last_offset:])
-        else:
-            html_text += escape_html(message_text[last_offset * 2:].decode('utf-16-le'))
-        return html_text
-
-    @property
-    def text_html(self):
-        """Creates an HTML-formatted string from the markup entities found in the message.
-
-        Use this if you want to retrieve the message text with the entities formatted as HTML in
-        the same way the original message was formatted.
-
-        Returns:
-            :obj:`str`: Message text with entities formatted as HTML.
-
-        """
-        return self._text_html(urled=False)
-
-    @property
-    def text_html_urled(self):
-        """Creates an HTML-formatted string from the markup entities found in the message.
-
-        Use this if you want to retrieve the message text with the entities formatted as HTML.
-        This also formats :attr:`telegram.MessageEntity.URL` as a hyperlink.
-
-        Returns:
-            :obj:`str`: Message text with entities formatted as HTML.
-
-        """
-        return self._text_html(urled=True)
-
-    def _text_markdown(self, urled=False):
-        entities = self.parse_entities()
-        message_text = self.text
-        if not sys.maxunicode == 0xffff:
-            message_text = message_text.encode('utf-16-le')
-
-        markdown_text = ''
-        last_offset = 0
-
-        for entity, text in sorted(entities.items(), key=(lambda item: item[0].offset)):
-            text = escape_markdown(text)
-
-            if entity.type == MessageEntity.TEXT_LINK:
-                insert = '[{}]({})'.format(text, entity.url)
-            elif (entity.type == MessageEntity.URL) and urled:
-                insert = '[{0}]({0})'.format(text)
-            elif entity.type == MessageEntity.BOLD:
-                insert = '*' + text + '*'
-            elif entity.type == MessageEntity.ITALIC:
-                insert = '_' + text + '_'
-            elif entity.type == MessageEntity.CODE:
-                insert = '`' + text + '`'
-            elif entity.type == MessageEntity.PRE:
-                insert = '```' + text + '```'
-            else:
-                insert = text
-            if sys.maxunicode == 0xffff:
-                markdown_text += escape_markdown(message_text[last_offset:entity.offset]) + insert
-            else:
-                markdown_text += escape_markdown(message_text[last_offset * 2:entity.offset * 2]
-                                                 .decode('utf-16-le')) + insert
-
-            last_offset = entity.offset + entity.length
-
-        if sys.maxunicode == 0xffff:
-            markdown_text += escape_markdown(message_text[last_offset:])
-        else:
-            markdown_text += escape_markdown(message_text[last_offset * 2:].decode('utf-16-le'))
-        return markdown_text
-
-    @property
-    def text_markdown(self):
-        """Creates an Markdown-formatted string from the markup entities found in the message.
-
-        Use this if you want to retrieve the message text with the entities formatted as Markdown
-        in the same way the original message was formatted.
-
-        Returns:
-            :obj:`str`: Message text with entities formatted as Markdown.
-
-        """
-        return self._text_markdown(urled=False)
-
-    @property
-    def text_markdown_urled(self):
-        """Creates an Markdown-formatted string from the markup entities found in the message.
-
-        Use this if you want to retrieve the message text with the entities formatted as Markdown.
-        This also formats :attr:`telegram.MessageEntity.URL` as a hyperlink.
-
-        Returns:
-            :obj:`str`: Message text with entities formatted as Markdown.
-
-        """
-        return self._text_markdown(urled=True)
-
-    @property
-    def new_chat_member(self):
-        """Deprecated"""
-        warn_deprecate_obj('new_chat_member', 'new_chat_members')
-        return self._new_chat_member
+#!/usr/bin/env python
+# pylint: disable=R0902,R0912,R0913
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Message."""
+import sys
+
+from telegram import (Audio, Contact, Document, Chat, Location, PhotoSize, Sticker, TelegramObject,
+                      User, Video, Voice, Venue, MessageEntity, Game, Invoice, SuccessfulPayment,
+                      VideoNote)
+from telegram.utils.deprecate import warn_deprecate_obj
+from telegram.utils.helpers import escape_html, escape_markdown, to_timestamp, from_timestamp
+
+_UNDEFINED = object()
+
+
+class Message(TelegramObject):
+    """This object represents a message.
+
+    Note:
+        * In Python `from` is a reserved word, use `from_user` instead.
+
+    Attributes:
+        message_id (:obj:`int`): Unique message identifier inside this chat.
+        from_user (:class:`telegram.User`): Optional. Sender.
+        date (:class:`datetime.datetime`): Date the message was sent.
+        chat (:class:`telegram.Chat`): Conversation the message belongs to.
+        forward_from (:class:`telegram.User`): Optional. Sender of the original message.
+        forward_from_chat (:class:`telegram.Chat`): Optional. Information about the original
+            channel.
+        forward_from_message_id (:obj:`int`): Optional. Identifier of the original message in the
+            channel.
+        forward_date (:class:`datetime.datetime`): Optional. Date the original message was sent.
+        reply_to_message (:class:`telegram.Message`): Optional. The original message.
+        edit_date (:class:`datetime.datetime`): Optional. Date the message was last edited.
+        media_group_id (:obj:`str`): Optional. The unique identifier of a media message group this
+            message belongs to.
+        text (:obj:`str`): Optional. The actual UTF-8 text of the message.
+        entities (List[:class:`telegram.MessageEntity`]): Optional. Special entities like
+            usernames, URLs, bot commands, etc. that appear in the text. See
+            :attr:`Message.parse_entity` and :attr:`parse_entities` methods for how to use
+            properly.
+        caption_entities (List[:class:`telegram.MessageEntity`]): Optional. Special entities like
+            usernames, URLs, bot commands, etc. that appear in the caption. See
+            :attr:`Message.parse_caption_entity` and :attr:`parse_caption_entities` methods for how
+            to use properly.
+        audio (:class:`telegram.Audio`): Optional. Information about the file.
+        document (:class:`telegram.Document`): Optional. Information about the file.
+        game (:class:`telegram.Game`): Optional. Information about the game.
+        photo (List[:class:`telegram.PhotoSize`]): Optional. Available sizes of the photo.
+        sticker (:class:`telegram.Sticker`): Optional. Information about the sticker.
+        video (:class:`telegram.Video`): Optional. Information about the video.
+        voice (:class:`telegram.Voice`): Optional. Information about the file.
+        video_note (:class:`telegram.VideoNote`): Optional. Information about the video message.
+        new_chat_members (List[:class:`telegram.User`]): Optional. Information about new members to
+            the chat. (the bot itself may be one of these members).
+        caption (:obj:`str`): Optional. Caption for the document, photo or video, 0-200 characters.
+        contact (:class:`telegram.Contact`): Optional. Information about the contact.
+        location (:class:`telegram.Location`): Optional. Information about the location.
+        venue (:class:`telegram.Venue`): Optional. Information about the venue.
+        left_chat_member (:class:`telegram.User`): Optional. Information about the user that left
+            the group. (this member may be the bot itself).
+        new_chat_title (:obj:`str`): Optional. A chat title was changed to this value.
+        new_chat_photo (List[:class:`telegram.PhotoSize`]): Optional. A chat photo was changed to
+            this value.
+        delete_chat_photo (:obj:`bool`): Optional. The chat photo was deleted.
+        group_chat_created (:obj:`bool`): Optional. The group has been created.
+        supergroup_chat_created (:obj:`bool`): Optional. The supergroup has been created.
+        channel_chat_created (:obj:`bool`): Optional. The channel has been created.
+        migrate_to_chat_id (:obj:`int`): Optional. The group has been migrated to a supergroup with
+            the specified identifier.
+        migrate_from_chat_id (:obj:`int`): Optional. The supergroup has been migrated from a group
+            with the specified identifier.
+        pinned_message (:class:`telegram.message`): Optional. Specified message was pinned.
+        invoice (:class:`telegram.Invoice`): Optional. Information about the invoice.
+        successful_payment (:class:`telegram.SuccessfulPayment`): Optional. Information about the
+            payment.
+        forward_signature (:obj:`str`): Optional. Signature of the post author for messages
+            forwarded from channels.
+        author_signature (:obj:`str`): Optional. Signature of the post author for messages
+            in channels.
+        bot (:class:`telegram.Bot`): Optional. The Bot to use for instance methods.
+
+    Deprecated: 6.0
+        new_chat_member (:class:`telegram.User`): Replaced with :attr:`new_chat_members`
+
+    Args:
+        message_id (:obj:`int`): Unique message identifier inside this chat.
+        from_user (:class:`telegram.User`, optional): Sender, can be empty for messages sent
+            to channels.
+        date (:class:`datetime.datetime`): Date the message was sent in Unix time. Converted to
+            :class:`datetime.datetime`.
+        chat (:class:`telegram.Chat`): Conversation the message belongs to.
+        forward_from (:class:`telegram.User`, optional): For forwarded messages, sender of
+            the original message.
+        forward_from_chat (:class:`telegram.Chat`, optional): For messages forwarded from a
+            channel, information about the original channel.
+        forward_from_message_id (:obj:`int`, optional): For forwarded channel posts, identifier of
+            the original message in the channel.
+        forward_date (:class:`datetime.datetime`, optional): For forwarded messages, date the
+            original message was sent in Unix time. Converted to :class:`datetime.datetime`.
+        reply_to_message (:class:`telegram.Message`, optional): For replies, the original message.
+            Note that the Message object in this field will not contain further
+            ``reply_to_message`` fields even if it itself is a reply.
+        edit_date (:class:`datetime.datetime`, optional): Date the message was last edited in Unix
+            time. Converted to :class:`datetime.datetime`.
+        media_group_id (:obj:`str`, optional): The unique identifier of a media message group this
+            message belongs to.
+        text (str, optional): For text messages, the actual UTF-8 text of the message, 0-4096
+            characters. Also found as :attr:`telegram.constants.MAX_MESSAGE_LENGTH`.
+        entities (List[:class:`telegram.MessageEntity`], optional): For text messages, special
+            entities like usernames, URLs, bot commands, etc. that appear in the text. See
+            attr:`parse_entity` and attr:`parse_entities` methods for how to use properly.
+        caption_entities (List[:class:`telegram.MessageEntity`]): Optional. For Messages with a
+            Caption. Special entities like usernames, URLs, bot commands, etc. that appear in the
+            caption. See :attr:`Message.parse_caption_entity` and :attr:`parse_caption_entities`
+            methods for how to use properly.
+        audio (:class:`telegram.Audio`, optional): Message is an audio file, information
+            about the file.
+        document (:class:`telegram.Document`, optional): Message is a general file, information
+            about the file.
+        game (:class:`telegram.Game`, optional): Message is a game, information about the game.
+        photo (List[:class:`telegram.PhotoSize`], optional): Message is a photo, available
+            sizes of the photo.
+        sticker (:class:`telegram.Sticker`, optional): Message is a sticker, information
+            about the sticker.
+        video (:class:`telegram.Video`, optional): Message is a video, information about the video.
+        voice (:class:`telegram.Voice`, optional): Message is a voice message, information about
+            the file.
+        video_note (:class:`telegram.VideoNote`, optional): Message is a video note, information
+            about the video message.
+        new_chat_members (List[:class:`telegram.User`], optional): New members that were added to
+            the group or supergroup and information about them (the bot itself may be one of these
+            members).
+        caption (:obj:`str`, optional): Caption for the document, photo or video, 0-200 characters.
+        contact (:class:`telegram.Contact`, optional): Message is a shared contact, information
+            about the contact.
+        location (:class:`telegram.Location`, optional): Message is a shared location, information
+            about the location.
+        venue (:class:`telegram.Venue`, optional): Message is a venue, information about the venue.
+        left_chat_member (:class:`telegram.User`, optional): A member was removed from the group,
+            information about them (this member may be the bot itself).
+        new_chat_title (:obj:`str`, optional): A chat title was changed to this value.
+        new_chat_photo (List[:class:`telegram.PhotoSize`], optional): A chat photo was change to
+            this value.
+        delete_chat_photo (:obj:`bool`, optional): Service message: The chat photo was deleted.
+        group_chat_created (:obj:`bool`, optional): Service message: The group has been created.
+        supergroup_chat_created (:obj:`bool`, optional): Service message: The supergroup has been
+            created. This field can't be received in a message coming through updates, because bot
+            can't be a member of a supergroup when it is created. It can only be found in
+            :attr:`reply_to_message` if someone replies to a very first message in a directly
+            created supergroup.
+        channel_chat_created (:obj:`bool`, optional): Service message: The channel has been
+            created. This field can't be received in a message coming through updates, because bot
+            can't be a member of a channel when it is created. It can only be found in
+            attr:`reply_to_message` if someone replies to a very first message in a channel.
+        migrate_to_chat_id (:obj:`int`, optional): The group has been migrated to a supergroup with
+            the specified identifier. This number may be greater than 32 bits and some programming
+            languages may have difficulty/silent defects in interpreting it. But it is smaller than
+            52 bits, so a signed 64 bit integer or double-precision float type are safe for storing
+            this identifier.
+        migrate_from_chat_id (:obj:`int`, optional): The supergroup has been migrated from a group
+            with the specified identifier. This number may be greater than 32 bits and some
+            programming languages may have difficulty/silent defects in interpreting it. But it is
+            smaller than 52 bits, so a signed 64 bit integer or double-precision float type are
+            safe for storing this identifier.
+        pinned_message (:class:`telegram.message`, optional): Specified message was pinned. Note
+            that the Message object in this field will not contain further attr:`reply_to_message`
+            fields even if it is itself a reply.
+        invoice (:class:`telegram.Invoice`, optional): Message is an invoice for a payment,
+            information about the invoice.
+        successful_payment (:class:`telegram.SuccessfulPayment`, optional): Message is a service
+            message about a successful payment, information about the payment.
+        forward_signature (:obj:`str`, optional): Signature of the post author for messages
+            forwarded from channels.
+        author_signature (:obj:`str`, optional): Signature of the post author for messages
+            in channels.
+    """
+
+    _effective_attachment = _UNDEFINED
+
+    def __init__(self,
+                 message_id,
+                 from_user,
+                 date,
+                 chat,
+                 forward_from=None,
+                 forward_from_chat=None,
+                 forward_from_message_id=None,
+                 forward_date=None,
+                 reply_to_message=None,
+                 edit_date=None,
+                 text=None,
+                 entities=None,
+                 caption_entities=None,
+                 audio=None,
+                 document=None,
+                 game=None,
+                 photo=None,
+                 sticker=None,
+                 video=None,
+                 voice=None,
+                 video_note=None,
+                 new_chat_members=None,
+                 caption=None,
+                 contact=None,
+                 location=None,
+                 venue=None,
+                 new_chat_member=None,
+                 left_chat_member=None,
+                 new_chat_title=None,
+                 new_chat_photo=None,
+                 delete_chat_photo=False,
+                 group_chat_created=False,
+                 supergroup_chat_created=False,
+                 channel_chat_created=False,
+                 migrate_to_chat_id=None,
+                 migrate_from_chat_id=None,
+                 pinned_message=None,
+                 invoice=None,
+                 successful_payment=None,
+                 forward_signature=None,
+                 author_signature=None,
+                 media_group_id=None,
+                 bot=None,
+                 **kwargs):
+        # Required
+        self.message_id = int(message_id)
+        self.from_user = from_user
+        self.date = date
+        self.chat = chat
+        # Optionals
+        self.forward_from = forward_from
+        self.forward_from_chat = forward_from_chat
+        self.forward_date = forward_date
+        self.reply_to_message = reply_to_message
+        self.edit_date = edit_date
+        self.text = text
+        self.entities = entities or list()
+        self.caption_entities = caption_entities or list()
+        self.audio = audio
+        self.game = game
+        self.document = document
+        self.photo = photo or list()
+        self.sticker = sticker
+        self.video = video
+        self.voice = voice
+        self.video_note = video_note
+        self.caption = caption
+        self.contact = contact
+        self.location = location
+        self.venue = venue
+        self._new_chat_member = new_chat_member
+        self.new_chat_members = new_chat_members or list()
+        self.left_chat_member = left_chat_member
+        self.new_chat_title = new_chat_title
+        self.new_chat_photo = new_chat_photo or list()
+        self.delete_chat_photo = bool(delete_chat_photo)
+        self.group_chat_created = bool(group_chat_created)
+        self.supergroup_chat_created = bool(supergroup_chat_created)
+        self.migrate_to_chat_id = migrate_to_chat_id
+        self.migrate_from_chat_id = migrate_from_chat_id
+        self.channel_chat_created = bool(channel_chat_created)
+        self.pinned_message = pinned_message
+        self.forward_from_message_id = forward_from_message_id
+        self.invoice = invoice
+        self.successful_payment = successful_payment
+        self.forward_signature = forward_signature
+        self.author_signature = author_signature
+        self.media_group_id = media_group_id
+
+        self.bot = bot
+
+        self._id_attrs = (self.message_id,)
+
+    @property
+    def chat_id(self):
+        """:obj:`int`: Shortcut for :attr:`telegram.Chat.id` for :attr:`chat`."""
+        return self.chat.id
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(Message, cls).de_json(data, bot)
+
+        data['from_user'] = User.de_json(data.get('from'), bot)
+        data['date'] = from_timestamp(data['date'])
+        data['chat'] = Chat.de_json(data.get('chat'), bot)
+        data['entities'] = MessageEntity.de_list(data.get('entities'), bot)
+        data['caption_entities'] = MessageEntity.de_list(data.get('caption_entities'), bot)
+        data['forward_from'] = User.de_json(data.get('forward_from'), bot)
+        data['forward_from_chat'] = Chat.de_json(data.get('forward_from_chat'), bot)
+        data['forward_date'] = from_timestamp(data.get('forward_date'))
+        data['reply_to_message'] = Message.de_json(data.get('reply_to_message'), bot)
+        data['edit_date'] = from_timestamp(data.get('edit_date'))
+        data['audio'] = Audio.de_json(data.get('audio'), bot)
+        data['document'] = Document.de_json(data.get('document'), bot)
+        data['game'] = Game.de_json(data.get('game'), bot)
+        data['photo'] = PhotoSize.de_list(data.get('photo'), bot)
+        data['sticker'] = Sticker.de_json(data.get('sticker'), bot)
+        data['video'] = Video.de_json(data.get('video'), bot)
+        data['voice'] = Voice.de_json(data.get('voice'), bot)
+        data['video_note'] = VideoNote.de_json(data.get('video_note'), bot)
+        data['contact'] = Contact.de_json(data.get('contact'), bot)
+        data['location'] = Location.de_json(data.get('location'), bot)
+        data['venue'] = Venue.de_json(data.get('venue'), bot)
+        data['new_chat_member'] = User.de_json(data.get('new_chat_member'), bot)
+        data['new_chat_members'] = User.de_list(data.get('new_chat_members'), bot)
+        data['left_chat_member'] = User.de_json(data.get('left_chat_member'), bot)
+        data['new_chat_photo'] = PhotoSize.de_list(data.get('new_chat_photo'), bot)
+        data['pinned_message'] = Message.de_json(data.get('pinned_message'), bot)
+        data['invoice'] = Invoice.de_json(data.get('invoice'), bot)
+        data['successful_payment'] = SuccessfulPayment.de_json(data.get('successful_payment'), bot)
+
+        return cls(bot=bot, **data)
+
+    @property
+    def effective_attachment(self):
+        """
+        :class:`telegram.Audio`
+            or :class:`telegram.Contact`
+            or :class:`telegram.Document`
+            or :class:`telegram.Game`
+            or :class:`telegram.Invoice`
+            or :class:`telegram.Location`
+            or List[:class:`telegram.PhotoSize`]
+            or :class:`telegram.Sticker`
+            or :class:`telegram.SuccessfulPayment`
+            or :class:`telegram.Venue`
+            or :class:`telegram.Video`
+            or :class:`telegram.VideoNote`
+            or :class:`telegram.Voice`: The attachment that this message was sent with. May be
+            ``None`` if no attachment was sent.
+
+        """
+        if self._effective_attachment is not _UNDEFINED:
+            return self._effective_attachment
+
+        for i in (self.audio, self.game, self.document, self.photo, self.sticker,
+                  self.video, self.voice, self.video_note, self.contact, self.location,
+                  self.venue, self.invoice, self.successful_payment):
+            if i:
+                self._effective_attachment = i
+                break
+        else:
+            self._effective_attachment = None
+
+        return self._effective_attachment
+
+    def __getitem__(self, item):
+        if item in self.__dict__.keys():
+            return self.__dict__[item]
+        elif item == 'chat_id':
+            return self.chat.id
+
+    def to_dict(self):
+        data = super(Message, self).to_dict()
+
+        # Required
+        data['from'] = data.pop('from_user', None)
+        data['date'] = to_timestamp(self.date)
+        # Optionals
+        if self.forward_date:
+            data['forward_date'] = to_timestamp(self.forward_date)
+        if self.edit_date:
+            data['edit_date'] = to_timestamp(self.edit_date)
+        if self.photo:
+            data['photo'] = [p.to_dict() for p in self.photo]
+        if self.entities:
+            data['entities'] = [e.to_dict() for e in self.entities]
+        if self.caption_entities:
+            data['caption_entities'] = [e.to_dict() for e in self.caption_entities]
+        if self.new_chat_photo:
+            data['new_chat_photo'] = [p.to_dict() for p in self.new_chat_photo]
+        data['new_chat_member'] = data.pop('_new_chat_member', None)
+        if self.new_chat_members:
+            data['new_chat_members'] = [u.to_dict() for u in self.new_chat_members]
+
+        return data
+
+    def _quote(self, kwargs):
+        """Modify kwargs for replying with or without quoting."""
+        if 'reply_to_message_id' in kwargs:
+            if 'quote' in kwargs:
+                del kwargs['quote']
+
+        elif 'quote' in kwargs:
+            if kwargs['quote']:
+                kwargs['reply_to_message_id'] = self.message_id
+
+            del kwargs['quote']
+
+        else:
+            if self.chat.type != Chat.PRIVATE:
+                kwargs['reply_to_message_id'] = self.message_id
+
+    def reply_text(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_message(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the message is sent as an actual
+                reply to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this
+                parameter will be ignored. Default: ``True`` in group chats and ``False`` in
+                private chats.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_message(self.chat_id, *args, **kwargs)
+
+    def reply_photo(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_photo(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_photo(self.chat_id, *args, **kwargs)
+
+    def reply_audio(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_audio(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_audio(self.chat_id, *args, **kwargs)
+
+    def reply_document(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_document(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_document(self.chat_id, *args, **kwargs)
+
+    def reply_sticker(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_sticker(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_sticker(self.chat_id, *args, **kwargs)
+
+    def reply_video(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_video(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_video(self.chat_id, *args, **kwargs)
+
+    def reply_video_note(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_video_note(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_video_note(self.chat_id, *args, **kwargs)
+
+    def reply_voice(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_voice(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_voice(self.chat_id, *args, **kwargs)
+
+    def reply_location(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_location(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_location(self.chat_id, *args, **kwargs)
+
+    def reply_venue(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_venue(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_venue(self.chat_id, *args, **kwargs)
+
+    def reply_contact(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.send_contact(update.message.chat_id, *args, **kwargs)
+
+        Keyword Args:
+            quote (:obj:`bool`, optional): If set to ``True``, the photo is sent as an actual reply
+                to this message. If ``reply_to_message_id`` is passed in ``kwargs``, this parameter
+                will be ignored. Default: ``True`` in group chats and ``False`` in private chats.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message posted.
+
+        """
+        self._quote(kwargs)
+        return self.bot.send_contact(self.chat_id, *args, **kwargs)
+
+    def forward(self, chat_id, disable_notification=False):
+        """Shortcut for::
+
+            bot.forward_message(chat_id=chat_id,
+                                from_chat_id=update.message.chat_id,
+                                disable_notification=disable_notification,
+                                message_id=update.message.message_id)
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the message forwarded.
+
+        """
+        return self.bot.forward_message(
+            chat_id=chat_id,
+            from_chat_id=self.chat_id,
+            disable_notification=disable_notification,
+            message_id=self.message_id)
+
+    def edit_text(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.edit_message_text(chat_id=message.chat_id,
+                                  message_id=message.message_id,
+                                  *args,
+                                  **kwargs)
+
+        Note:
+            You can only edit messages that the bot sent itself,
+            therefore this method can only be used on the
+            return value of the ``bot.send_*`` family of methods..
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the edited message.
+
+        """
+        return self.bot.edit_message_text(
+            chat_id=self.chat_id, message_id=self.message_id, *args, **kwargs)
+
+    def edit_caption(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.edit_message_caption(chat_id=message.chat_id,
+                                     message_id=message.message_id,
+                                     *args,
+                                     **kwargs)
+
+        Note:
+            You can only edit messages that the bot sent itself,
+            therefore this method can only be used on the
+            return value of the ``bot.send_*`` family of methods.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the edited message.
+
+        """
+        return self.bot.edit_message_caption(
+            chat_id=self.chat_id, message_id=self.message_id, *args, **kwargs)
+
+    def edit_reply_markup(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.edit_message_reply_markup(chat_id=message.chat_id,
+                                          message_id=message.message_id,
+                                          *args,
+                                          **kwargs)
+
+        Note:
+            You can only edit messages that the bot sent itself,
+            therefore this method can only be used on the
+            return value of the ``bot.send_*`` family of methods.
+
+        Returns:
+            :class:`telegram.Message`: On success, instance representing the edited message.
+        """
+        return self.bot.edit_message_reply_markup(
+            chat_id=self.chat_id, message_id=self.message_id, *args, **kwargs)
+
+    def delete(self, *args, **kwargs):
+        """Shortcut for::
+
+             bot.delete_message(chat_id=message.chat_id,
+                                message_id=message.message_id,
+                                *args,
+                                **kwargs)
+
+        Returns:
+            :obj:`bool`: On success, ``True`` is returned.
+
+        """
+        return self.bot.delete_message(
+            chat_id=self.chat_id, message_id=self.message_id, *args, **kwargs)
+
+    def parse_entity(self, entity):
+        """Returns the text from a given :class:`telegram.MessageEntity`.
+
+        Note:
+            This method is present because Telegram calculates the offset and length in
+            UTF-16 codepoint pairs, which some versions of Python don't handle automatically.
+            (That is, you can't just slice ``Message.text`` with the offset and length.)
+
+        Args:
+            entity (:class:`telegram.MessageEntity`): The entity to extract the text from. It must
+            be an entity that belongs to this message.
+
+        Returns:
+            :obj:`str`: The text of the given entity
+
+        """
+        # Is it a narrow build, if so we don't need to convert
+        if sys.maxunicode == 0xffff:
+            return self.text[entity.offset:entity.offset + entity.length]
+        else:
+            entity_text = self.text.encode('utf-16-le')
+            entity_text = entity_text[entity.offset * 2:(entity.offset + entity.length) * 2]
+
+        return entity_text.decode('utf-16-le')
+
+    def parse_caption_entity(self, entity):
+        """Returns the text from a given :class:`telegram.MessageEntity`.
+
+        Note:
+            This method is present because Telegram calculates the offset and length in
+            UTF-16 codepoint pairs, which some versions of Python don't handle automatically.
+            (That is, you can't just slice ``Message.caption`` with the offset and length.)
+
+        Args:
+            entity (:class:`telegram.MessageEntity`): The entity to extract the text from. It must
+            be an entity that belongs to this message.
+
+        Returns:
+            :obj:`str`: The text of the given entity
+
+        """
+        # Is it a narrow build, if so we don't need to convert
+        if sys.maxunicode == 0xffff:
+            return self.caption[entity.offset:entity.offset + entity.length]
+        else:
+            entity_text = self.caption.encode('utf-16-le')
+            entity_text = entity_text[entity.offset * 2:(entity.offset + entity.length) * 2]
+
+        return entity_text.decode('utf-16-le')
+
+    def parse_entities(self, types=None):
+        """
+        Returns a :obj:`dict` that maps :class:`telegram.MessageEntity` to :obj:`str`.
+        It contains entities from this message filtered by their
+        :attr:`telegram.MessageEntity.type` attribute as the key, and the text that each entity
+        belongs to as the value of the :obj:`dict`.
+
+        Note:
+            This method should always be used instead of the :attr:`entities` attribute, since it
+            calculates the correct substring from the message text based on UTF-16 codepoints.
+            See :attr:`parse_entity` for more info.
+
+        Args:
+            types (List[:obj:`str`], optional): List of :class:`telegram.MessageEntity` types as
+                strings. If the ``type`` attribute of an entity is contained in this list, it will
+                be returned. Defaults to a list of all types. All types can be found as constants
+                in :class:`telegram.MessageEntity`.
+
+        Returns:
+            Dict[:class:`telegram.MessageEntity`, :obj:`str`]: A dictionary of entities mapped to
+            the text that belongs to them, calculated based on UTF-16 codepoints.
+
+        """
+        if types is None:
+            types = MessageEntity.ALL_TYPES
+
+        return {
+            entity: self.parse_entity(entity)
+            for entity in self.entities if entity.type in types
+        }
+
+    def parse_caption_entities(self, types=None):
+        """
+        Returns a :obj:`dict` that maps :class:`telegram.MessageEntity` to :obj:`str`.
+        It contains entities from this message's caption filtered by their
+        :attr:`telegram.MessageEntity.type` attribute as the key, and the text that each entity
+        belongs to as the value of the :obj:`dict`.
+
+        Note:
+            This method should always be used instead of the :attr:`caption_entities` attribute,
+            since it calculates the correct substring from the message text based on UTF-16
+            codepoints. See :attr:`parse_entity` for more info.
+
+        Args:
+            types (List[:obj:`str`], optional): List of :class:`telegram.MessageEntity` types as
+                strings. If the ``type`` attribute of an entity is contained in this list, it will
+                be returned. Defaults to a list of all types. All types can be found as constants
+                in :class:`telegram.MessageEntity`.
+
+        Returns:
+            Dict[:class:`telegram.MessageEntity`, :obj:`str`]: A dictionary of entities mapped to
+            the text that belongs to them, calculated based on UTF-16 codepoints.
+
+        """
+        if types is None:
+            types = MessageEntity.ALL_TYPES
+
+        return {
+            entity: self.parse_caption_entity(entity)
+            for entity in self.caption_entities if entity.type in types
+        }
+
+    def _text_html(self, urled=False):
+        entities = self.parse_entities()
+        message_text = self.text
+        if not sys.maxunicode == 0xffff:
+            message_text = message_text.encode('utf-16-le')
+
+        html_text = ''
+        last_offset = 0
+
+        for entity, text in sorted(entities.items(), key=(lambda item: item[0].offset)):
+            text = escape_html(text)
+
+            if entity.type == MessageEntity.TEXT_LINK:
+                insert = '<a href="{}">{}</a>'.format(entity.url, text)
+            elif (entity.type == MessageEntity.URL) and urled:
+                insert = '<a href="{0}">{0}</a>'.format(text)
+            elif entity.type == MessageEntity.BOLD:
+                insert = '<b>' + text + '</b>'
+            elif entity.type == MessageEntity.ITALIC:
+                insert = '<i>' + text + '</i>'
+            elif entity.type == MessageEntity.CODE:
+                insert = '<code>' + text + '</code>'
+            elif entity.type == MessageEntity.PRE:
+                insert = '<pre>' + text + '</pre>'
+            else:
+                insert = text
+
+            if sys.maxunicode == 0xffff:
+                html_text += escape_html(message_text[last_offset:entity.offset]) + insert
+            else:
+                html_text += escape_html(message_text[last_offset * 2:entity.offset * 2]
+                                         .decode('utf-16-le')) + insert
+
+            last_offset = entity.offset + entity.length
+
+        if sys.maxunicode == 0xffff:
+            html_text += escape_html(message_text[last_offset:])
+        else:
+            html_text += escape_html(message_text[last_offset * 2:].decode('utf-16-le'))
+        return html_text
+
+    @property
+    def text_html(self):
+        """Creates an HTML-formatted string from the markup entities found in the message.
+
+        Use this if you want to retrieve the message text with the entities formatted as HTML in
+        the same way the original message was formatted.
+
+        Returns:
+            :obj:`str`: Message text with entities formatted as HTML.
+
+        """
+        return self._text_html(urled=False)
+
+    @property
+    def text_html_urled(self):
+        """Creates an HTML-formatted string from the markup entities found in the message.
+
+        Use this if you want to retrieve the message text with the entities formatted as HTML.
+        This also formats :attr:`telegram.MessageEntity.URL` as a hyperlink.
+
+        Returns:
+            :obj:`str`: Message text with entities formatted as HTML.
+
+        """
+        return self._text_html(urled=True)
+
+    def _text_markdown(self, urled=False):
+        entities = self.parse_entities()
+        message_text = self.text
+        if not sys.maxunicode == 0xffff:
+            message_text = message_text.encode('utf-16-le')
+
+        markdown_text = ''
+        last_offset = 0
+
+        for entity, text in sorted(entities.items(), key=(lambda item: item[0].offset)):
+            text = escape_markdown(text)
+
+            if entity.type == MessageEntity.TEXT_LINK:
+                insert = '[{}]({})'.format(text, entity.url)
+            elif (entity.type == MessageEntity.URL) and urled:
+                insert = '[{0}]({0})'.format(text)
+            elif entity.type == MessageEntity.BOLD:
+                insert = '*' + text + '*'
+            elif entity.type == MessageEntity.ITALIC:
+                insert = '_' + text + '_'
+            elif entity.type == MessageEntity.CODE:
+                insert = '`' + text + '`'
+            elif entity.type == MessageEntity.PRE:
+                insert = '```' + text + '```'
+            else:
+                insert = text
+            if sys.maxunicode == 0xffff:
+                markdown_text += escape_markdown(message_text[last_offset:entity.offset]) + insert
+            else:
+                markdown_text += escape_markdown(message_text[last_offset * 2:entity.offset * 2]
+                                                 .decode('utf-16-le')) + insert
+
+            last_offset = entity.offset + entity.length
+
+        if sys.maxunicode == 0xffff:
+            markdown_text += escape_markdown(message_text[last_offset:])
+        else:
+            markdown_text += escape_markdown(message_text[last_offset * 2:].decode('utf-16-le'))
+        return markdown_text
+
+    @property
+    def text_markdown(self):
+        """Creates an Markdown-formatted string from the markup entities found in the message.
+
+        Use this if you want to retrieve the message text with the entities formatted as Markdown
+        in the same way the original message was formatted.
+
+        Returns:
+            :obj:`str`: Message text with entities formatted as Markdown.
+
+        """
+        return self._text_markdown(urled=False)
+
+    @property
+    def text_markdown_urled(self):
+        """Creates an Markdown-formatted string from the markup entities found in the message.
+
+        Use this if you want to retrieve the message text with the entities formatted as Markdown.
+        This also formats :attr:`telegram.MessageEntity.URL` as a hyperlink.
+
+        Returns:
+            :obj:`str`: Message text with entities formatted as Markdown.
+
+        """
+        return self._text_markdown(urled=True)
+
+    @property
+    def new_chat_member(self):
+        """Deprecated"""
+        warn_deprecate_obj('new_chat_member', 'new_chat_members')
+        return self._new_chat_member
```

### Comparing `python-telegram-bot-8.1.1/telegram/parsemode.py` & `python-telegram-bot-9.0.0/telegram/parsemode.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,29 +1,29 @@
-#!/usr/bin/env python
-# pylint: disable=R0903
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Message Parse Modes."""
-
-
-class ParseMode(object):
-    """This object represents a Telegram Message Parse Modes."""
-
-    MARKDOWN = 'Markdown'
-    """:obj:`str`: 'Markdown'"""
-    HTML = 'HTML'
-    """:obj:`str`: 'HTML'"""
+#!/usr/bin/env python
+# pylint: disable=R0903
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Message Parse Modes."""
+
+
+class ParseMode(object):
+    """This object represents a Telegram Message Parse Modes."""
+
+    MARKDOWN = 'Markdown'
+    """:obj:`str`: 'Markdown'"""
+    HTML = 'HTML'
+    """:obj:`str`: 'HTML'"""
```

### Comparing `python-telegram-bot-8.1.1/telegram/payment/invoice.py` & `python-telegram-bot-9.0.0/telegram/payment/invoice.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,58 +1,58 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Invoice."""
-
-from telegram import TelegramObject
-
-
-class Invoice(TelegramObject):
-    """This object contains basic information about an invoice.
-
-    Attributes:
-        title (:obj:`str`): Product name.
-        description (:obj:`str`): Product description.
-        start_parameter (:obj:`str`): Unique bot deep-linking parameter.
-        currency (:obj:`str`): Three-letter ISO 4217 currency code.
-        total_amount (:obj:`int`): Total price in the smallest units of the currency.
-
-    Args:
-        title (:obj:`str`): Product name.
-        description (:obj:`str`): Product description.
-        start_parameter (:obj:`str`): Unique bot deep-linking parameter that can be used to
-            generate this invoice.
-        currency (:obj:`str`): Three-letter ISO 4217 currency code.
-        total_amount (:obj:`int`): Total price in the smallest units of the currency (integer, not
-            float/double). For example, for a price of US$ 1.45 pass amount = 145.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, title, description, start_parameter, currency, total_amount, **kwargs):
-        self.title = title
-        self.description = description
-        self.start_parameter = start_parameter
-        self.currency = currency
-        self.total_amount = total_amount
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Invoice."""
+
+from telegram import TelegramObject
+
+
+class Invoice(TelegramObject):
+    """This object contains basic information about an invoice.
+
+    Attributes:
+        title (:obj:`str`): Product name.
+        description (:obj:`str`): Product description.
+        start_parameter (:obj:`str`): Unique bot deep-linking parameter.
+        currency (:obj:`str`): Three-letter ISO 4217 currency code.
+        total_amount (:obj:`int`): Total price in the smallest units of the currency.
+
+    Args:
+        title (:obj:`str`): Product name.
+        description (:obj:`str`): Product description.
+        start_parameter (:obj:`str`): Unique bot deep-linking parameter that can be used to
+            generate this invoice.
+        currency (:obj:`str`): Three-letter ISO 4217 currency code.
+        total_amount (:obj:`int`): Total price in the smallest units of the currency (integer, not
+            float/double). For example, for a price of US$ 1.45 pass amount = 145.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, title, description, start_parameter, currency, total_amount, **kwargs):
+        self.title = title
+        self.description = description
+        self.start_parameter = start_parameter
+        self.currency = currency
+        self.total_amount = total_amount
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/payment/labeledprice.py` & `python-telegram-bot-9.0.0/telegram/payment/labeledprice.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,43 +1,43 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram LabeledPrice."""
-
-from telegram import TelegramObject
-
-
-class LabeledPrice(TelegramObject):
-    """This object represents a portion of the price for goods or services.
-
-    Attributes:
-        label (:obj:`str`): Portion label.
-        amount (:obj:`int`): Price of the product in the smallest units of the currency.
-
-    Args:
-        label (:obj:`str`): Portion label
-        amount (:obj:`int`): Price of the product in the smallest units of the currency (integer,
-            not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp
-            parameter in currencies.json, it shows the number of digits past the decimal point for
-            each currency (2 for the majority of currencies).
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, label, amount, **kwargs):
-        self.label = label
-        self.amount = amount
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram LabeledPrice."""
+
+from telegram import TelegramObject
+
+
+class LabeledPrice(TelegramObject):
+    """This object represents a portion of the price for goods or services.
+
+    Attributes:
+        label (:obj:`str`): Portion label.
+        amount (:obj:`int`): Price of the product in the smallest units of the currency.
+
+    Args:
+        label (:obj:`str`): Portion label
+        amount (:obj:`int`): Price of the product in the smallest units of the currency (integer,
+            not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp
+            parameter in currencies.json, it shows the number of digits past the decimal point for
+            each currency (2 for the majority of currencies).
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, label, amount, **kwargs):
+        self.label = label
+        self.amount = amount
```

### Comparing `python-telegram-bot-8.1.1/telegram/payment/orderinfo.py` & `python-telegram-bot-9.0.0/telegram/payment/orderinfo.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram OrderInfo."""
-
-from telegram import TelegramObject, ShippingAddress
-
-
-class OrderInfo(TelegramObject):
-    """This object represents information about an order.
-
-    Attributes:
-        name (:obj:`str`): Optional. User name.
-        phone_number (:obj:`str`): Optional. User's phone number.
-        email (:obj:`str`): Optional. User email.
-        shipping_address (:class:`telegram.ShippingAddress`): Optional. User shipping address.
-
-    Args:
-        name (:obj:`str`, optional): User name.
-        phone_number (:obj:`str`, optional): User's phone number.
-        email (:obj:`str`, optional): User email.
-        shipping_address (:class:`telegram.ShippingAddress`, optional): User shipping address.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, name=None, phone_number=None, email=None, shipping_address=None, **kwargs):
-        self.name = name
-        self.phone_number = phone_number
-        self.email = email
-        self.shipping_address = shipping_address
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return cls()
-
-        data = super(OrderInfo, cls).de_json(data, bot)
-
-        data['shipping_address'] = ShippingAddress.de_json(data.get('shipping_address'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram OrderInfo."""
+
+from telegram import TelegramObject, ShippingAddress
+
+
+class OrderInfo(TelegramObject):
+    """This object represents information about an order.
+
+    Attributes:
+        name (:obj:`str`): Optional. User name.
+        phone_number (:obj:`str`): Optional. User's phone number.
+        email (:obj:`str`): Optional. User email.
+        shipping_address (:class:`telegram.ShippingAddress`): Optional. User shipping address.
+
+    Args:
+        name (:obj:`str`, optional): User name.
+        phone_number (:obj:`str`, optional): User's phone number.
+        email (:obj:`str`, optional): User email.
+        shipping_address (:class:`telegram.ShippingAddress`, optional): User shipping address.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, name=None, phone_number=None, email=None, shipping_address=None, **kwargs):
+        self.name = name
+        self.phone_number = phone_number
+        self.email = email
+        self.shipping_address = shipping_address
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return cls()
+
+        data = super(OrderInfo, cls).de_json(data, bot)
+
+        data['shipping_address'] = ShippingAddress.de_json(data.get('shipping_address'), bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/payment/precheckoutquery.py` & `python-telegram-bot-9.0.0/telegram/payment/precheckoutquery.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,115 +1,115 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram PreCheckoutQuery."""
-
-from telegram import TelegramObject, User, OrderInfo
-
-
-class PreCheckoutQuery(TelegramObject):
-    """This object contains information about an incoming pre-checkout query.
-
-    Note:
-        * In Python `from` is a reserved word, use `from_user` instead.
-
-    Attributes:
-        id (:obj:`str`): Unique query identifier.
-        from_user (:class:`telegram.User`): User who sent the query.
-        currency (:obj:`str`): Three-letter ISO 4217 currency code.
-        total_amount (:obj:`int`): Total price in the smallest units of the currency.
-        invoice_payload (:obj:`str`): Bot specified invoice payload.
-        shipping_option_id (:obj:`str`): Optional. Identifier of the shipping option chosen by the
-            user.
-        order_info (:class:`telegram.OrderInfo`): Optional. Order info provided by the user.
-        bot (:class:`telegram.Bot`): Optional. The Bot to use for instance methods.
-
-    Args:
-        id (:obj:`str`): Unique query identifier.
-        from_user (:class:`telegram.User`): User who sent the query.
-        currency (:obj:`str`): Three-letter ISO 4217 currency code
-        total_amount (:obj:`int`): Total price in the smallest units of the currency (integer, not
-            float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp
-            parameter in currencies.json, it shows the number of digits past the decimal point for
-            each currency (2 for the majority of currencies).
-        invoice_payload (:obj:`str`): Bot specified invoice payload.
-        shipping_option_id (:obj:`str`, optional): Identifier of the shipping option chosen by the
-            user.
-        order_info (:class:`telegram.OrderInfo`, optional): Order info provided by the user.
-        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 id,
-                 from_user,
-                 currency,
-                 total_amount,
-                 invoice_payload,
-                 shipping_option_id=None,
-                 order_info=None,
-                 bot=None,
-                 **kwargs):
-        self.id = id
-        self.from_user = from_user
-        self.currency = currency
-        self.total_amount = total_amount
-        self.invoice_payload = invoice_payload
-        self.shipping_option_id = shipping_option_id
-        self.order_info = order_info
-
-        self.bot = bot
-
-        self._id_attrs = (self.id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(PreCheckoutQuery, cls).de_json(data, bot)
-
-        data['from_user'] = User.de_json(data.pop('from'), bot)
-        data['order_info'] = OrderInfo.de_json(data.get('order_info'), bot)
-
-        return cls(**data)
-
-    def to_dict(self):
-        data = super(PreCheckoutQuery, self).to_dict()
-
-        data['from'] = data.pop('from_user', None)
-
-        return data
-
-    def answer(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.answer_pre_checkout_query(update.pre_checkout_query.id, *args, **kwargs)
-
-        Args:
-            ok (:obj:`bool`): Specify True if everything is alright (goods are available, etc.) and
-                the bot is ready to proceed with the order. Use False if there are any problems.
-            error_message (:obj:`str`, optional): Required if ok is False. Error message in human
-                readable form that explains the reason for failure to proceed with the checkout
-                (e.g. "Sorry, somebody just bought the last of our amazing black T-shirts while you
-                were busy filling out your payment details. Please choose a different color or
-                garment!"). Telegram will display this message to the user.
-            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-        """
-        return self.bot.answer_pre_checkout_query(self.id, *args, **kwargs)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram PreCheckoutQuery."""
+
+from telegram import TelegramObject, User, OrderInfo
+
+
+class PreCheckoutQuery(TelegramObject):
+    """This object contains information about an incoming pre-checkout query.
+
+    Note:
+        * In Python `from` is a reserved word, use `from_user` instead.
+
+    Attributes:
+        id (:obj:`str`): Unique query identifier.
+        from_user (:class:`telegram.User`): User who sent the query.
+        currency (:obj:`str`): Three-letter ISO 4217 currency code.
+        total_amount (:obj:`int`): Total price in the smallest units of the currency.
+        invoice_payload (:obj:`str`): Bot specified invoice payload.
+        shipping_option_id (:obj:`str`): Optional. Identifier of the shipping option chosen by the
+            user.
+        order_info (:class:`telegram.OrderInfo`): Optional. Order info provided by the user.
+        bot (:class:`telegram.Bot`): Optional. The Bot to use for instance methods.
+
+    Args:
+        id (:obj:`str`): Unique query identifier.
+        from_user (:class:`telegram.User`): User who sent the query.
+        currency (:obj:`str`): Three-letter ISO 4217 currency code
+        total_amount (:obj:`int`): Total price in the smallest units of the currency (integer, not
+            float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp
+            parameter in currencies.json, it shows the number of digits past the decimal point for
+            each currency (2 for the majority of currencies).
+        invoice_payload (:obj:`str`): Bot specified invoice payload.
+        shipping_option_id (:obj:`str`, optional): Identifier of the shipping option chosen by the
+            user.
+        order_info (:class:`telegram.OrderInfo`, optional): Order info provided by the user.
+        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 id,
+                 from_user,
+                 currency,
+                 total_amount,
+                 invoice_payload,
+                 shipping_option_id=None,
+                 order_info=None,
+                 bot=None,
+                 **kwargs):
+        self.id = id
+        self.from_user = from_user
+        self.currency = currency
+        self.total_amount = total_amount
+        self.invoice_payload = invoice_payload
+        self.shipping_option_id = shipping_option_id
+        self.order_info = order_info
+
+        self.bot = bot
+
+        self._id_attrs = (self.id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(PreCheckoutQuery, cls).de_json(data, bot)
+
+        data['from_user'] = User.de_json(data.pop('from'), bot)
+        data['order_info'] = OrderInfo.de_json(data.get('order_info'), bot)
+
+        return cls(**data)
+
+    def to_dict(self):
+        data = super(PreCheckoutQuery, self).to_dict()
+
+        data['from'] = data.pop('from_user', None)
+
+        return data
+
+    def answer(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.answer_pre_checkout_query(update.pre_checkout_query.id, *args, **kwargs)
+
+        Args:
+            ok (:obj:`bool`): Specify True if everything is alright (goods are available, etc.) and
+                the bot is ready to proceed with the order. Use False if there are any problems.
+            error_message (:obj:`str`, optional): Required if ok is False. Error message in human
+                readable form that explains the reason for failure to proceed with the checkout
+                (e.g. "Sorry, somebody just bought the last of our amazing black T-shirts while you
+                were busy filling out your payment details. Please choose a different color or
+                garment!"). Telegram will display this message to the user.
+            **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+        """
+        return self.bot.answer_pre_checkout_query(self.id, *args, **kwargs)
```

### Comparing `python-telegram-bot-8.1.1/telegram/payment/shippingaddress.py` & `python-telegram-bot-9.0.0/telegram/payment/shippingaddress.py`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ShippingAddress."""
-
-from telegram import TelegramObject
-
-
-class ShippingAddress(TelegramObject):
-    """This object represents a Telegram ShippingAddress.
-
-    Attributes:
-        country_code (:obj:`str`): ISO 3166-1 alpha-2 country code.
-        state (:obj:`str`): State, if applicable.
-        city (:obj:`str`): City.
-        street_line1 (:obj:`str`): First line for the address.
-        street_line2 (:obj:`str`): Second line for the address.
-        post_code (:obj:`str`): Address post code.
-
-    Args:
-        country_code (:obj:`str`): ISO 3166-1 alpha-2 country code.
-        state (:obj:`str`): State, if applicable.
-        city (:obj:`str`): City.
-        street_line1 (:obj:`str`): First line for the address.
-        street_line2 (:obj:`str`): Second line for the address.
-        post_code (:obj:`str`): Address post code.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, country_code, state, city, street_line1, street_line2, post_code, **kwargs):
-        self.country_code = country_code
-        self.state = state
-        self.city = city
-        self.street_line1 = street_line1
-        self.street_line2 = street_line2
-        self.post_code = post_code
-
-        self._id_attrs = (self.country_code, self.state, self.city, self.street_line1,
-                          self.street_line2, self.post_code)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ShippingAddress."""
+
+from telegram import TelegramObject
+
+
+class ShippingAddress(TelegramObject):
+    """This object represents a Telegram ShippingAddress.
+
+    Attributes:
+        country_code (:obj:`str`): ISO 3166-1 alpha-2 country code.
+        state (:obj:`str`): State, if applicable.
+        city (:obj:`str`): City.
+        street_line1 (:obj:`str`): First line for the address.
+        street_line2 (:obj:`str`): Second line for the address.
+        post_code (:obj:`str`): Address post code.
+
+    Args:
+        country_code (:obj:`str`): ISO 3166-1 alpha-2 country code.
+        state (:obj:`str`): State, if applicable.
+        city (:obj:`str`): City.
+        street_line1 (:obj:`str`): First line for the address.
+        street_line2 (:obj:`str`): Second line for the address.
+        post_code (:obj:`str`): Address post code.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, country_code, state, city, street_line1, street_line2, post_code, **kwargs):
+        self.country_code = country_code
+        self.state = state
+        self.city = city
+        self.street_line1 = street_line1
+        self.street_line2 = street_line2
+        self.post_code = post_code
+
+        self._id_attrs = (self.country_code, self.state, self.city, self.street_line1,
+                          self.street_line2, self.post_code)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/payment/shippingoption.py` & `python-telegram-bot-9.0.0/telegram/payment/shippingoption.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ShippingOption."""
-
-from telegram import TelegramObject
-
-
-class ShippingOption(TelegramObject):
-    """This object represents one shipping option.
-
-    Attributes:
-        id (:obj:`str`): Shipping option identifier.
-        title (:obj:`str`): Option title.
-        prices (List[:class:`telegram.LabeledPrice`]): List of price portions.
-
-    Args:
-        id (:obj:`str`): Shipping option identifier.
-        title (:obj:`str`): Option title.
-        prices (List[:class:`telegram.LabeledPrice`]): List of price portions.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, id, title, prices, **kwargs):
-        self.id = id
-        self.title = title
-        self.prices = prices
-
-        self._id_attrs = (self.id,)
-
-    def to_dict(self):
-        data = super(ShippingOption, self).to_dict()
-
-        data['prices'] = [p.to_dict() for p in self.prices]
-
-        return data
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ShippingOption."""
+
+from telegram import TelegramObject
+
+
+class ShippingOption(TelegramObject):
+    """This object represents one shipping option.
+
+    Attributes:
+        id (:obj:`str`): Shipping option identifier.
+        title (:obj:`str`): Option title.
+        prices (List[:class:`telegram.LabeledPrice`]): List of price portions.
+
+    Args:
+        id (:obj:`str`): Shipping option identifier.
+        title (:obj:`str`): Option title.
+        prices (List[:class:`telegram.LabeledPrice`]): List of price portions.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, id, title, prices, **kwargs):
+        self.id = id
+        self.title = title
+        self.prices = prices
+
+        self._id_attrs = (self.id,)
+
+    def to_dict(self):
+        data = super(ShippingOption, self).to_dict()
+
+        data['prices'] = [p.to_dict() for p in self.prices]
+
+        return data
```

### Comparing `python-telegram-bot-8.1.1/telegram/payment/shippingquery.py` & `python-telegram-bot-9.0.0/telegram/payment/shippingquery.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,93 +1,93 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ShippingQuery."""
-
-from telegram import TelegramObject, User, ShippingAddress
-
-
-class ShippingQuery(TelegramObject):
-    """This object contains information about an incoming shipping query.
-
-    Note:
-        * In Python `from` is a reserved word, use `from_user` instead.
-
-    Attributes:
-        id (:obj:`str`): Unique query identifier.
-        from_user (:class:`telegram.User`): User who sent the query.
-        invoice_payload (:obj:`str`): Bot specified invoice payload.
-        shipping_address (:class:`telegram.ShippingAddress`): User specified shipping address.
-        bot (:class:`telegram.Bot`): Optional. The Bot to use for instance methods.
-
-    Args:
-        id (:obj:`str`): Unique query identifier.
-        from_user (:class:`telegram.User`): User who sent the query.
-        invoice_payload (:obj:`str`): Bot specified invoice payload.
-        shipping_address (:class:`telegram.ShippingAddress`): User specified shipping address.
-        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, id, from_user, invoice_payload, shipping_address, bot=None, **kwargs):
-        self.id = id
-        self.from_user = from_user
-        self.invoice_payload = invoice_payload
-        self.shipping_address = shipping_address
-
-        self.bot = bot
-
-        self._id_attrs = (self.id,)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(ShippingQuery, cls).de_json(data, bot)
-
-        data['from_user'] = User.de_json(data.pop('from'), bot)
-        data['shipping_address'] = ShippingAddress.de_json(data.get('shipping_address'), bot)
-
-        return cls(**data)
-
-    def to_dict(self):
-        data = super(ShippingQuery, self).to_dict()
-
-        data['from'] = data.pop('from_user', None)
-
-        return data
-
-    def answer(self, *args, **kwargs):
-        """Shortcut for::
-
-            bot.answer_shipping_query(update.shipping_query.id, *args, **kwargs)
-
-        Args:
-            ok (:obj:`bool`): Specify True if delivery to the specified address is possible and
-                False if there are any problems (for example, if delivery to the specified address
-                is not possible).
-            shipping_options (List[:class:`telegram.ShippingOption`], optional): Required if ok is
-                True. A JSON-serialized array of available shipping options.
-            error_message (:obj:`str`, optional): Required if ok is False. Error message in human
-                readable form that explains why it is impossible to complete the order (e.g.
-                "Sorry, delivery to your desired address is unavailable'). Telegram will display
-                this message to the user.
-
-        """
-        return self.bot.answer_shipping_query(self.id, *args, **kwargs)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ShippingQuery."""
+
+from telegram import TelegramObject, User, ShippingAddress
+
+
+class ShippingQuery(TelegramObject):
+    """This object contains information about an incoming shipping query.
+
+    Note:
+        * In Python `from` is a reserved word, use `from_user` instead.
+
+    Attributes:
+        id (:obj:`str`): Unique query identifier.
+        from_user (:class:`telegram.User`): User who sent the query.
+        invoice_payload (:obj:`str`): Bot specified invoice payload.
+        shipping_address (:class:`telegram.ShippingAddress`): User specified shipping address.
+        bot (:class:`telegram.Bot`): Optional. The Bot to use for instance methods.
+
+    Args:
+        id (:obj:`str`): Unique query identifier.
+        from_user (:class:`telegram.User`): User who sent the query.
+        invoice_payload (:obj:`str`): Bot specified invoice payload.
+        shipping_address (:class:`telegram.ShippingAddress`): User specified shipping address.
+        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, id, from_user, invoice_payload, shipping_address, bot=None, **kwargs):
+        self.id = id
+        self.from_user = from_user
+        self.invoice_payload = invoice_payload
+        self.shipping_address = shipping_address
+
+        self.bot = bot
+
+        self._id_attrs = (self.id,)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(ShippingQuery, cls).de_json(data, bot)
+
+        data['from_user'] = User.de_json(data.pop('from'), bot)
+        data['shipping_address'] = ShippingAddress.de_json(data.get('shipping_address'), bot)
+
+        return cls(**data)
+
+    def to_dict(self):
+        data = super(ShippingQuery, self).to_dict()
+
+        data['from'] = data.pop('from_user', None)
+
+        return data
+
+    def answer(self, *args, **kwargs):
+        """Shortcut for::
+
+            bot.answer_shipping_query(update.shipping_query.id, *args, **kwargs)
+
+        Args:
+            ok (:obj:`bool`): Specify True if delivery to the specified address is possible and
+                False if there are any problems (for example, if delivery to the specified address
+                is not possible).
+            shipping_options (List[:class:`telegram.ShippingOption`], optional): Required if ok is
+                True. A JSON-serialized array of available shipping options.
+            error_message (:obj:`str`, optional): Required if ok is False. Error message in human
+                readable form that explains why it is impossible to complete the order (e.g.
+                "Sorry, delivery to your desired address is unavailable'). Telegram will display
+                this message to the user.
+
+        """
+        return self.bot.answer_shipping_query(self.id, *args, **kwargs)
```

### Comparing `python-telegram-bot-8.1.1/telegram/payment/successfulpayment.py` & `python-telegram-bot-9.0.0/telegram/payment/successfulpayment.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,80 +1,80 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram SuccessfulPayment."""
-
-from telegram import TelegramObject, OrderInfo
-
-
-class SuccessfulPayment(TelegramObject):
-    """This object contains basic information about a successful payment.
-
-    Attributes:
-        currency (:obj:`str`): Three-letter ISO 4217 currency code.
-        total_amount (:obj:`int`): Total price in the smallest units of the currency.
-        invoice_payload (:obj:`str`): Bot specified invoice payload.
-        shipping_option_id (:obj:`str`): Optional. Identifier of the shipping option chosen by the
-            user.
-        order_info (:class:`telegram.OrderInfo`): Optional. Order info provided by the user.
-        telegram_payment_charge_id (:obj:`str`): Telegram payment identifier.
-        provider_payment_charge_id (:obj:`str`): Provider payment identifier.
-
-    Args:
-        currency (:obj:`str`): Three-letter ISO 4217 currency code.
-        total_amount (:obj:`int`): Total price in the smallest units of the currency (integer, not
-            float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp
-            parameter in currencies.json, it shows the number of digits past the decimal point for
-            each currency (2 for the majority of currencies).
-        invoice_payload (:obj:`str`): Bot specified invoice payload.
-        shipping_option_id (:obj:`str`, optional): Identifier of the shipping option chosen by the
-            user.
-        order_info (:class:`telegram.OrderInfo`, optional): Order info provided by the user
-        telegram_payment_charge_id (:obj:`str`): Telegram payment identifier.
-        provider_payment_charge_id (:obj:`str`): Provider payment identifier.
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 currency,
-                 total_amount,
-                 invoice_payload,
-                 telegram_payment_charge_id,
-                 provider_payment_charge_id,
-                 shipping_option_id=None,
-                 order_info=None,
-                 **kwargs):
-        self.currency = currency
-        self.total_amount = total_amount
-        self.invoice_payload = invoice_payload
-        self.shipping_option_id = shipping_option_id
-        self.order_info = order_info
-        self.telegram_payment_charge_id = telegram_payment_charge_id
-        self.provider_payment_charge_id = provider_payment_charge_id
-
-        self._id_attrs = (self.telegram_payment_charge_id, self.provider_payment_charge_id)
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(SuccessfulPayment, cls).de_json(data, bot)
-        data['order_info'] = OrderInfo.de_json(data.get('order_info'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram SuccessfulPayment."""
+
+from telegram import TelegramObject, OrderInfo
+
+
+class SuccessfulPayment(TelegramObject):
+    """This object contains basic information about a successful payment.
+
+    Attributes:
+        currency (:obj:`str`): Three-letter ISO 4217 currency code.
+        total_amount (:obj:`int`): Total price in the smallest units of the currency.
+        invoice_payload (:obj:`str`): Bot specified invoice payload.
+        shipping_option_id (:obj:`str`): Optional. Identifier of the shipping option chosen by the
+            user.
+        order_info (:class:`telegram.OrderInfo`): Optional. Order info provided by the user.
+        telegram_payment_charge_id (:obj:`str`): Telegram payment identifier.
+        provider_payment_charge_id (:obj:`str`): Provider payment identifier.
+
+    Args:
+        currency (:obj:`str`): Three-letter ISO 4217 currency code.
+        total_amount (:obj:`int`): Total price in the smallest units of the currency (integer, not
+            float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp
+            parameter in currencies.json, it shows the number of digits past the decimal point for
+            each currency (2 for the majority of currencies).
+        invoice_payload (:obj:`str`): Bot specified invoice payload.
+        shipping_option_id (:obj:`str`, optional): Identifier of the shipping option chosen by the
+            user.
+        order_info (:class:`telegram.OrderInfo`, optional): Order info provided by the user
+        telegram_payment_charge_id (:obj:`str`): Telegram payment identifier.
+        provider_payment_charge_id (:obj:`str`): Provider payment identifier.
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 currency,
+                 total_amount,
+                 invoice_payload,
+                 telegram_payment_charge_id,
+                 provider_payment_charge_id,
+                 shipping_option_id=None,
+                 order_info=None,
+                 **kwargs):
+        self.currency = currency
+        self.total_amount = total_amount
+        self.invoice_payload = invoice_payload
+        self.shipping_option_id = shipping_option_id
+        self.order_info = order_info
+        self.telegram_payment_charge_id = telegram_payment_charge_id
+        self.provider_payment_charge_id = provider_payment_charge_id
+
+        self._id_attrs = (self.telegram_payment_charge_id, self.provider_payment_charge_id)
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(SuccessfulPayment, cls).de_json(data, bot)
+        data['order_info'] = OrderInfo.de_json(data.get('order_info'), bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/replykeyboardmarkup.py` & `python-telegram-bot-9.0.0/telegram/replykeyboardmarkup.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,87 +1,87 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ReplyKeyboardMarkup."""
-
-from telegram import ReplyMarkup
-
-
-class ReplyKeyboardMarkup(ReplyMarkup):
-    """This object represents a custom keyboard with reply options.
-
-    Attributes:
-        keyboard (List[List[:class:`telegram.KeyboardButton` | :obj:`str`]]): Array of button rows.
-        resize_keyboard (:obj:`bool`): Optional. Requests clients to resize the keyboard.
-        one_time_keyboard (:obj:`bool`): Optional. Requests clients to hide the keyboard as soon as
-            it's been used.
-        selective (:obj:`bool`): Optional. Show the keyboard to specific users only.
-
-    Example:
-        A user requests to change the bot's language, bot replies to the request with a keyboard
-        to select the new language. Other users in the group don't see the keyboard.
-
-    Args:
-        keyboard (List[List[:obj:`str` | :class:`telegram.KeyboardButton`]]): Array of button rows,
-                each represented by an Array of :class:`telegram.KeyboardButton` objects.
-        resize_keyboard (:obj:`bool`, optional): Requests clients to resize the keyboard vertically
-            for optimal fit (e.g., make the keyboard smaller if there are just two rows of
-            buttons). Defaults to false, in which case the custom keyboard is always of the same
-            height as the app's standard keyboard. Defaults to ``False``
-        one_time_keyboard (:obj:`bool`, optional): Requests clients to hide the keyboard as soon as
-            it's been used. The keyboard will still be available, but clients will automatically
-            display the usual letter-keyboard in the chat - the user can press a special button in
-            the input field to see the custom keyboard again. Defaults to ``False``.
-        selective (:obj:`bool`, optional): Use this parameter if you want to show the keyboard to
-            specific users only. Targets:
-
-            1) users that are @mentioned in the text of the Message object
-            2) if the bot's message is a reply (has reply_to_message_id), sender of the original
-               message.
-
-            Defaults to ``False``.
-
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 keyboard,
-                 resize_keyboard=False,
-                 one_time_keyboard=False,
-                 selective=False,
-                 **kwargs):
-        # Required
-        self.keyboard = keyboard
-        # Optionals
-        self.resize_keyboard = bool(resize_keyboard)
-        self.one_time_keyboard = bool(one_time_keyboard)
-        self.selective = bool(selective)
-
-    def to_dict(self):
-        data = super(ReplyKeyboardMarkup, self).to_dict()
-
-        data['keyboard'] = []
-        for row in self.keyboard:
-            r = []
-            for button in row:
-                if hasattr(button, 'to_dict'):
-                    r.append(button.to_dict())  # telegram.KeyboardButton
-                else:
-                    r.append(button)  # str
-            data['keyboard'].append(r)
-        return data
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ReplyKeyboardMarkup."""
+
+from telegram import ReplyMarkup
+
+
+class ReplyKeyboardMarkup(ReplyMarkup):
+    """This object represents a custom keyboard with reply options.
+
+    Attributes:
+        keyboard (List[List[:class:`telegram.KeyboardButton` | :obj:`str`]]): Array of button rows.
+        resize_keyboard (:obj:`bool`): Optional. Requests clients to resize the keyboard.
+        one_time_keyboard (:obj:`bool`): Optional. Requests clients to hide the keyboard as soon as
+            it's been used.
+        selective (:obj:`bool`): Optional. Show the keyboard to specific users only.
+
+    Example:
+        A user requests to change the bot's language, bot replies to the request with a keyboard
+        to select the new language. Other users in the group don't see the keyboard.
+
+    Args:
+        keyboard (List[List[:obj:`str` | :class:`telegram.KeyboardButton`]]): Array of button rows,
+                each represented by an Array of :class:`telegram.KeyboardButton` objects.
+        resize_keyboard (:obj:`bool`, optional): Requests clients to resize the keyboard vertically
+            for optimal fit (e.g., make the keyboard smaller if there are just two rows of
+            buttons). Defaults to false, in which case the custom keyboard is always of the same
+            height as the app's standard keyboard. Defaults to ``False``
+        one_time_keyboard (:obj:`bool`, optional): Requests clients to hide the keyboard as soon as
+            it's been used. The keyboard will still be available, but clients will automatically
+            display the usual letter-keyboard in the chat - the user can press a special button in
+            the input field to see the custom keyboard again. Defaults to ``False``.
+        selective (:obj:`bool`, optional): Use this parameter if you want to show the keyboard to
+            specific users only. Targets:
+
+            1) users that are @mentioned in the text of the Message object
+            2) if the bot's message is a reply (has reply_to_message_id), sender of the original
+               message.
+
+            Defaults to ``False``.
+
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 keyboard,
+                 resize_keyboard=False,
+                 one_time_keyboard=False,
+                 selective=False,
+                 **kwargs):
+        # Required
+        self.keyboard = keyboard
+        # Optionals
+        self.resize_keyboard = bool(resize_keyboard)
+        self.one_time_keyboard = bool(one_time_keyboard)
+        self.selective = bool(selective)
+
+    def to_dict(self):
+        data = super(ReplyKeyboardMarkup, self).to_dict()
+
+        data['keyboard'] = []
+        for row in self.keyboard:
+            r = []
+            for button in row:
+                if hasattr(button, 'to_dict'):
+                    r.append(button.to_dict())  # telegram.KeyboardButton
+                else:
+                    r.append(button)  # str
+            data['keyboard'].append(r)
+        return data
```

### Comparing `python-telegram-bot-8.1.1/telegram/replykeyboardremove.py` & `python-telegram-bot-9.0.0/telegram/replykeyboardremove.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram ReplyKeyboardRemove."""
-from telegram import ReplyMarkup
-
-
-class ReplyKeyboardRemove(ReplyMarkup):
-    """
-    Upon receiving a message with this object, Telegram clients will remove the current custom
-    keyboard and display the default letter-keyboard. By default, custom keyboards are displayed
-    until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are
-    hidden immediately after the user presses a button (see :class:`telegram.ReplyKeyboardMarkup`).
-
-    Attributes:
-        remove_keyboard (:obj:`True`): Requests clients to remove the custom keyboard.
-        selective (:obj:`bool`): Optional. Use this parameter if you want to remove the keyboard
-            for specific users only.
-
-    Example:
-        A user votes in a poll, bot returns confirmation message in reply to the vote and removes
-        the keyboard for that user, while still showing the keyboard with poll options to users who
-        haven't voted yet.
-
-    Args:
-        selective (:obj:`bool`, optional): Use this parameter if you want to remove the keyboard
-            for specific users only. Targets:
-
-            1) users that are @mentioned in the text of the Message object
-            2) if the bot's message is a reply (has reply_to_message_id), sender of the original
-               message.
-
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self, selective=False, **kwargs):
-        # Required
-        self.remove_keyboard = True
-        # Optionals
-        self.selective = bool(selective)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram ReplyKeyboardRemove."""
+from telegram import ReplyMarkup
+
+
+class ReplyKeyboardRemove(ReplyMarkup):
+    """
+    Upon receiving a message with this object, Telegram clients will remove the current custom
+    keyboard and display the default letter-keyboard. By default, custom keyboards are displayed
+    until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are
+    hidden immediately after the user presses a button (see :class:`telegram.ReplyKeyboardMarkup`).
+
+    Attributes:
+        remove_keyboard (:obj:`True`): Requests clients to remove the custom keyboard.
+        selective (:obj:`bool`): Optional. Use this parameter if you want to remove the keyboard
+            for specific users only.
+
+    Example:
+        A user votes in a poll, bot returns confirmation message in reply to the vote and removes
+        the keyboard for that user, while still showing the keyboard with poll options to users who
+        haven't voted yet.
+
+    Args:
+        selective (:obj:`bool`, optional): Use this parameter if you want to remove the keyboard
+            for specific users only. Targets:
+
+            1) users that are @mentioned in the text of the Message object
+            2) if the bot's message is a reply (has reply_to_message_id), sender of the original
+               message.
+
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self, selective=False, **kwargs):
+        # Required
+        self.remove_keyboard = True
+        # Optionals
+        self.selective = bool(selective)
```

### Comparing `python-telegram-bot-8.1.1/telegram/replymarkup.py` & `python-telegram-bot-9.0.0/telegram/replymarkup.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""Base class for Telegram ReplyMarkup Objects."""
-
-from telegram import TelegramObject
-
-
-class ReplyMarkup(TelegramObject):
-    """Base class for Telegram ReplyMarkup Objects.
-
-    See :class:`telegram.ReplyKeyboardMarkup` and :class:`telegram.InlineKeyboardMarkup` for
-    detailed use.
-
-    """
-    pass
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""Base class for Telegram ReplyMarkup Objects."""
+
+from telegram import TelegramObject
+
+
+class ReplyMarkup(TelegramObject):
+    """Base class for Telegram ReplyMarkup Objects.
+
+    See :class:`telegram.ReplyKeyboardMarkup` and :class:`telegram.InlineKeyboardMarkup` for
+    detailed use.
+
+    """
+    pass
```

### Comparing `python-telegram-bot-8.1.1/telegram/update.py` & `python-telegram-bot-9.0.0/telegram/update.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,219 +1,219 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram Update."""
-
-from telegram import (Message, TelegramObject, InlineQuery, ChosenInlineResult,
-                      CallbackQuery, ShippingQuery, PreCheckoutQuery)
-
-
-class Update(TelegramObject):
-    """This object represents an incoming update.
-
-    Note:
-        At most one of the optional parameters can be present in any given update.
-
-    Attributes:
-        update_id (:obj:`int`): The update's unique identifier.
-        message (:class:`telegram.Message`): Optional. New incoming message.
-        edited_message (:class:`telegram.Message`): Optional. New version of a message.
-        channel_post (:class:`telegram.Message`): Optional. New incoming channel post.
-        edited_channel_post (:class:`telegram.Message`): Optional. New version of a channel post.
-        inline_query (:class:`telegram.InlineQuery`): Optional. New incoming inline query.
-        chosen_inline_result (:class:`telegram.ChosenInlineResult`): Optional. The result of an
-            inline query that was chosen by a user.
-        callback_query (:class:`telegram.CallbackQuery`): Optional. New incoming callback query.
-        shipping_query (:class:`telegram.ShippingQuery`): Optional. New incoming shipping query.
-        pre_checkout_query (:class:`telegram.PreCheckoutQuery`): Optional. New incoming
-            pre-checkout query.
-
-    Args:
-        update_id (:obj:`int`): The update's unique identifier. Update identifiers start from a
-            certain positive number and increase sequentially. This ID becomes especially handy if
-            you're using Webhooks, since it allows you to ignore repeated updates or to restore the
-            correct update sequence, should they get out of order.
-        message (:class:`telegram.Message`, optional): New incoming message of any kind - text,
-            photo, sticker, etc.
-        edited_message (:class:`telegram.Message`, optional): New version of a message that is
-            known to the bot and was edited.
-        channel_post (:class:`telegram.Message`, optional): New incoming channel post of any kind
-            - text, photo, sticker, etc.
-        edited_channel_post (:class:`telegram.Message`, optional): New version of a channel post
-            that is known to the bot and was edited.
-        inline_query (:class:`telegram.InlineQuery`, optional): New incoming inline query.
-        chosen_inline_result (:class:`telegram.ChosenInlineResult`, optional): The result of an
-            inline query that was chosen by a user and sent to their chat partner.
-        callback_query (:class:`telegram.CallbackQuery`, optional): New incoming callback query.
-        shipping_query (:class:`telegram.ShippingQuery`, optional): New incoming shipping query.
-            Only for invoices with flexible price.
-        pre_checkout_query (:class:`telegram.PreCheckoutQuery`, optional): New incoming
-            pre-checkout query. Contains full information about checkout
-        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
-
-    """
-
-    def __init__(self,
-                 update_id,
-                 message=None,
-                 edited_message=None,
-                 channel_post=None,
-                 edited_channel_post=None,
-                 inline_query=None,
-                 chosen_inline_result=None,
-                 callback_query=None,
-                 shipping_query=None,
-                 pre_checkout_query=None,
-                 **kwargs):
-        # Required
-        self.update_id = int(update_id)
-        # Optionals
-        self.message = message
-        self.edited_message = edited_message
-        self.inline_query = inline_query
-        self.chosen_inline_result = chosen_inline_result
-        self.callback_query = callback_query
-        self.shipping_query = shipping_query
-        self.pre_checkout_query = pre_checkout_query
-        self.channel_post = channel_post
-        self.edited_channel_post = edited_channel_post
-
-        self._effective_user = None
-        self._effective_chat = None
-        self._effective_message = None
-
-        self._id_attrs = (self.update_id,)
-
-    @property
-    def effective_user(self):
-        """
-        :class:`telegram.User`: The user that sent this update, no matter what kind of update this
-            is. Will be ``None`` for :attr:`channel_post`.
-
-        """
-        if self._effective_user:
-            return self._effective_user
-
-        user = None
-
-        if self.message:
-            user = self.message.from_user
-
-        elif self.edited_message:
-            user = self.edited_message.from_user
-
-        elif self.inline_query:
-            user = self.inline_query.from_user
-
-        elif self.chosen_inline_result:
-            user = self.chosen_inline_result.from_user
-
-        elif self.callback_query:
-            user = self.callback_query.from_user
-
-        elif self.shipping_query:
-            user = self.shipping_query.from_user
-
-        elif self.pre_checkout_query:
-            user = self.pre_checkout_query.from_user
-
-        self._effective_user = user
-        return user
-
-    @property
-    def effective_chat(self):
-        """
-        :class:`telegram.Chat`: The chat that this update was sent in, no matter what kind of
-            update this is. Will be ``None`` for :attr:`inline_query`,
-            :attr:`chosen_inline_result`, :attr:`callback_query` from inline messages,
-            :attr:`shipping_query` and :attr:`pre_checkout_query`.
-
-        """
-        if self._effective_chat:
-            return self._effective_chat
-
-        chat = None
-
-        if self.message:
-            chat = self.message.chat
-
-        elif self.edited_message:
-            chat = self.edited_message.chat
-
-        elif self.callback_query and self.callback_query.message:
-            chat = self.callback_query.message.chat
-
-        elif self.channel_post:
-            chat = self.channel_post.chat
-
-        elif self.edited_channel_post:
-            chat = self.edited_channel_post.chat
-
-        self._effective_chat = chat
-        return chat
-
-    @property
-    def effective_message(self):
-        """
-        :class:`telegram.Message`: The message included in this update, no matter what kind of
-            update this is. Will be ``None`` for :attr:`inline_query`,
-            :attr:`chosen_inline_result`, :attr:`callback_query` from inline messages,
-            :attr:`shipping_query` and :attr:`pre_checkout_query`.
-
-        """
-        if self._effective_message:
-            return self._effective_message
-
-        message = None
-
-        if self.message:
-            message = self.message
-
-        elif self.edited_message:
-            message = self.edited_message
-
-        elif self.callback_query:
-            message = self.callback_query.message
-
-        elif self.channel_post:
-            message = self.channel_post
-
-        elif self.edited_channel_post:
-            message = self.edited_channel_post
-
-        self._effective_message = message
-        return message
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(Update, cls).de_json(data, bot)
-
-        data['message'] = Message.de_json(data.get('message'), bot)
-        data['edited_message'] = Message.de_json(data.get('edited_message'), bot)
-        data['inline_query'] = InlineQuery.de_json(data.get('inline_query'), bot)
-        data['chosen_inline_result'] = ChosenInlineResult.de_json(
-            data.get('chosen_inline_result'), bot)
-        data['callback_query'] = CallbackQuery.de_json(data.get('callback_query'), bot)
-        data['shipping_query'] = ShippingQuery.de_json(data.get('shipping_query'), bot)
-        data['pre_checkout_query'] = PreCheckoutQuery.de_json(data.get('pre_checkout_query'), bot)
-        data['channel_post'] = Message.de_json(data.get('channel_post'), bot)
-        data['edited_channel_post'] = Message.de_json(data.get('edited_channel_post'), bot)
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram Update."""
+
+from telegram import (Message, TelegramObject, InlineQuery, ChosenInlineResult,
+                      CallbackQuery, ShippingQuery, PreCheckoutQuery)
+
+
+class Update(TelegramObject):
+    """This object represents an incoming update.
+
+    Note:
+        At most one of the optional parameters can be present in any given update.
+
+    Attributes:
+        update_id (:obj:`int`): The update's unique identifier.
+        message (:class:`telegram.Message`): Optional. New incoming message.
+        edited_message (:class:`telegram.Message`): Optional. New version of a message.
+        channel_post (:class:`telegram.Message`): Optional. New incoming channel post.
+        edited_channel_post (:class:`telegram.Message`): Optional. New version of a channel post.
+        inline_query (:class:`telegram.InlineQuery`): Optional. New incoming inline query.
+        chosen_inline_result (:class:`telegram.ChosenInlineResult`): Optional. The result of an
+            inline query that was chosen by a user.
+        callback_query (:class:`telegram.CallbackQuery`): Optional. New incoming callback query.
+        shipping_query (:class:`telegram.ShippingQuery`): Optional. New incoming shipping query.
+        pre_checkout_query (:class:`telegram.PreCheckoutQuery`): Optional. New incoming
+            pre-checkout query.
+
+    Args:
+        update_id (:obj:`int`): The update's unique identifier. Update identifiers start from a
+            certain positive number and increase sequentially. This ID becomes especially handy if
+            you're using Webhooks, since it allows you to ignore repeated updates or to restore the
+            correct update sequence, should they get out of order.
+        message (:class:`telegram.Message`, optional): New incoming message of any kind - text,
+            photo, sticker, etc.
+        edited_message (:class:`telegram.Message`, optional): New version of a message that is
+            known to the bot and was edited.
+        channel_post (:class:`telegram.Message`, optional): New incoming channel post of any kind
+            - text, photo, sticker, etc.
+        edited_channel_post (:class:`telegram.Message`, optional): New version of a channel post
+            that is known to the bot and was edited.
+        inline_query (:class:`telegram.InlineQuery`, optional): New incoming inline query.
+        chosen_inline_result (:class:`telegram.ChosenInlineResult`, optional): The result of an
+            inline query that was chosen by a user and sent to their chat partner.
+        callback_query (:class:`telegram.CallbackQuery`, optional): New incoming callback query.
+        shipping_query (:class:`telegram.ShippingQuery`, optional): New incoming shipping query.
+            Only for invoices with flexible price.
+        pre_checkout_query (:class:`telegram.PreCheckoutQuery`, optional): New incoming
+            pre-checkout query. Contains full information about checkout
+        **kwargs (:obj:`dict`): Arbitrary keyword arguments.
+
+    """
+
+    def __init__(self,
+                 update_id,
+                 message=None,
+                 edited_message=None,
+                 channel_post=None,
+                 edited_channel_post=None,
+                 inline_query=None,
+                 chosen_inline_result=None,
+                 callback_query=None,
+                 shipping_query=None,
+                 pre_checkout_query=None,
+                 **kwargs):
+        # Required
+        self.update_id = int(update_id)
+        # Optionals
+        self.message = message
+        self.edited_message = edited_message
+        self.inline_query = inline_query
+        self.chosen_inline_result = chosen_inline_result
+        self.callback_query = callback_query
+        self.shipping_query = shipping_query
+        self.pre_checkout_query = pre_checkout_query
+        self.channel_post = channel_post
+        self.edited_channel_post = edited_channel_post
+
+        self._effective_user = None
+        self._effective_chat = None
+        self._effective_message = None
+
+        self._id_attrs = (self.update_id,)
+
+    @property
+    def effective_user(self):
+        """
+        :class:`telegram.User`: The user that sent this update, no matter what kind of update this
+            is. Will be ``None`` for :attr:`channel_post`.
+
+        """
+        if self._effective_user:
+            return self._effective_user
+
+        user = None
+
+        if self.message:
+            user = self.message.from_user
+
+        elif self.edited_message:
+            user = self.edited_message.from_user
+
+        elif self.inline_query:
+            user = self.inline_query.from_user
+
+        elif self.chosen_inline_result:
+            user = self.chosen_inline_result.from_user
+
+        elif self.callback_query:
+            user = self.callback_query.from_user
+
+        elif self.shipping_query:
+            user = self.shipping_query.from_user
+
+        elif self.pre_checkout_query:
+            user = self.pre_checkout_query.from_user
+
+        self._effective_user = user
+        return user
+
+    @property
+    def effective_chat(self):
+        """
+        :class:`telegram.Chat`: The chat that this update was sent in, no matter what kind of
+            update this is. Will be ``None`` for :attr:`inline_query`,
+            :attr:`chosen_inline_result`, :attr:`callback_query` from inline messages,
+            :attr:`shipping_query` and :attr:`pre_checkout_query`.
+
+        """
+        if self._effective_chat:
+            return self._effective_chat
+
+        chat = None
+
+        if self.message:
+            chat = self.message.chat
+
+        elif self.edited_message:
+            chat = self.edited_message.chat
+
+        elif self.callback_query and self.callback_query.message:
+            chat = self.callback_query.message.chat
+
+        elif self.channel_post:
+            chat = self.channel_post.chat
+
+        elif self.edited_channel_post:
+            chat = self.edited_channel_post.chat
+
+        self._effective_chat = chat
+        return chat
+
+    @property
+    def effective_message(self):
+        """
+        :class:`telegram.Message`: The message included in this update, no matter what kind of
+            update this is. Will be ``None`` for :attr:`inline_query`,
+            :attr:`chosen_inline_result`, :attr:`callback_query` from inline messages,
+            :attr:`shipping_query` and :attr:`pre_checkout_query`.
+
+        """
+        if self._effective_message:
+            return self._effective_message
+
+        message = None
+
+        if self.message:
+            message = self.message
+
+        elif self.edited_message:
+            message = self.edited_message
+
+        elif self.callback_query:
+            message = self.callback_query.message
+
+        elif self.channel_post:
+            message = self.channel_post
+
+        elif self.edited_channel_post:
+            message = self.edited_channel_post
+
+        self._effective_message = message
+        return message
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(Update, cls).de_json(data, bot)
+
+        data['message'] = Message.de_json(data.get('message'), bot)
+        data['edited_message'] = Message.de_json(data.get('edited_message'), bot)
+        data['inline_query'] = InlineQuery.de_json(data.get('inline_query'), bot)
+        data['chosen_inline_result'] = ChosenInlineResult.de_json(
+            data.get('chosen_inline_result'), bot)
+        data['callback_query'] = CallbackQuery.de_json(data.get('callback_query'), bot)
+        data['shipping_query'] = ShippingQuery.de_json(data.get('shipping_query'), bot)
+        data['pre_checkout_query'] = PreCheckoutQuery.de_json(data.get('pre_checkout_query'), bot)
+        data['channel_post'] = Message.de_json(data.get('channel_post'), bot)
+        data['edited_channel_post'] = Message.de_json(data.get('edited_channel_post'), bot)
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/user.py` & `python-telegram-bot-9.0.0/telegram/user.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,140 +1,140 @@
-#!/usr/bin/env python
-# pylint: disable=C0103,W0622
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram User."""
-
-from telegram import TelegramObject
-from telegram.utils.helpers import mention_markdown as util_mention_markdown
-from telegram.utils.helpers import mention_html as util_mention_html
-
-
-class User(TelegramObject):
-    """This object represents a Telegram user or bot.
-
-    Attributes:
-        id (:obj:`int`): Unique identifier for this user or bot.
-        is_bot (:obj:`bool`): True, if this user is a bot
-        first_name (:obj:`str`): User's or bot's first name.
-        last_name (:obj:`str`): Optional. User's or bot's last name.
-        username (:obj:`str`): Optional. User's or bot's username.
-        language_code (:obj:`str`): Optional. IETF language tag of the user's language.
-        bot (:class:`telegram.Bot`): Optional. The Bot to use for instance methods.
-
-    Args:
-        id (:obj:`int`): Unique identifier for this user or bot.
-        is_bot (:obj:`bool`): True, if this user is a bot
-        first_name (:obj:`str`): User's or bot's first name.
-        last_name (:obj:`str`, optional): User's or bot's last name.
-        username (:obj:`str`, optional): User's or bot's username.
-        language_code (:obj:`str`, optional): IETF language tag of the user's language.
-        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
-
-    """
-
-    def __init__(self,
-                 id,
-                 first_name,
-                 is_bot,
-                 last_name=None,
-                 username=None,
-                 language_code=None,
-                 bot=None,
-                 **kwargs):
-        # Required
-        self.id = int(id)
-        self.first_name = first_name
-        self.is_bot = is_bot
-        # Optionals
-        self.last_name = last_name
-        self.username = username
-        self.language_code = language_code
-
-        self.bot = bot
-
-        self._id_attrs = (self.id,)
-
-    @property
-    def name(self):
-        """
-        :obj:`str`: The users :attr:`username` if available, if not it returns the first name and
-            if present :attr:`first_name` and :attr:`last_name`.
-
-        """
-
-        if self.username:
-            return '@%s' % self.username
-        if self.last_name:
-            return '%s %s' % (self.first_name, self.last_name)
-        return self.first_name
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        data = super(User, cls).de_json(data, bot)
-
-        return cls(bot=bot, **data)
-
-    def get_profile_photos(self, *args, **kwargs):
-        """
-        Shortcut for::
-
-                bot.get_user_profile_photos(update.message.from_user.id, *args, **kwargs)
-
-        """
-
-        return self.bot.get_user_profile_photos(self.id, *args, **kwargs)
-
-    @classmethod
-    def de_list(cls, data, bot):
-        if not data:
-            return []
-
-        users = list()
-        for user in data:
-            users.append(cls.de_json(user, bot))
-
-        return users
-
-    def mention_markdown(self, name=None):
-        """
-        Args:
-            name (:obj:`str`): If provided, will overwrite the user's name.
-
-        Returns:
-            :obj:`str`: The inline mention for the user as markdown.
-        """
-        if not name:
-            return util_mention_markdown(self.id, self.name)
-        else:
-            return util_mention_markdown(self.id, name)
-
-    def mention_html(self, name=None):
-        """
-        Args:
-            name (:obj:`str`): If provided, will overwrite the user's name.
-
-        Returns:
-            :obj:`str`: The inline mention for the user as HTML.
-        """
-        if not name:
-            return util_mention_html(self.id, self.name)
-        else:
-            return util_mention_html(self.id, name)
+#!/usr/bin/env python
+# pylint: disable=C0103,W0622
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram User."""
+
+from telegram import TelegramObject
+from telegram.utils.helpers import mention_markdown as util_mention_markdown
+from telegram.utils.helpers import mention_html as util_mention_html
+
+
+class User(TelegramObject):
+    """This object represents a Telegram user or bot.
+
+    Attributes:
+        id (:obj:`int`): Unique identifier for this user or bot.
+        is_bot (:obj:`bool`): True, if this user is a bot
+        first_name (:obj:`str`): User's or bot's first name.
+        last_name (:obj:`str`): Optional. User's or bot's last name.
+        username (:obj:`str`): Optional. User's or bot's username.
+        language_code (:obj:`str`): Optional. IETF language tag of the user's language.
+        bot (:class:`telegram.Bot`): Optional. The Bot to use for instance methods.
+
+    Args:
+        id (:obj:`int`): Unique identifier for this user or bot.
+        is_bot (:obj:`bool`): True, if this user is a bot
+        first_name (:obj:`str`): User's or bot's first name.
+        last_name (:obj:`str`, optional): User's or bot's last name.
+        username (:obj:`str`, optional): User's or bot's username.
+        language_code (:obj:`str`, optional): IETF language tag of the user's language.
+        bot (:class:`telegram.Bot`, optional): The Bot to use for instance methods.
+
+    """
+
+    def __init__(self,
+                 id,
+                 first_name,
+                 is_bot,
+                 last_name=None,
+                 username=None,
+                 language_code=None,
+                 bot=None,
+                 **kwargs):
+        # Required
+        self.id = int(id)
+        self.first_name = first_name
+        self.is_bot = is_bot
+        # Optionals
+        self.last_name = last_name
+        self.username = username
+        self.language_code = language_code
+
+        self.bot = bot
+
+        self._id_attrs = (self.id,)
+
+    @property
+    def name(self):
+        """
+        :obj:`str`: The users :attr:`username` if available, if not it returns the first name and
+            if present :attr:`first_name` and :attr:`last_name`.
+
+        """
+
+        if self.username:
+            return '@%s' % self.username
+        if self.last_name:
+            return '%s %s' % (self.first_name, self.last_name)
+        return self.first_name
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        data = super(User, cls).de_json(data, bot)
+
+        return cls(bot=bot, **data)
+
+    def get_profile_photos(self, *args, **kwargs):
+        """
+        Shortcut for::
+
+                bot.get_user_profile_photos(update.message.from_user.id, *args, **kwargs)
+
+        """
+
+        return self.bot.get_user_profile_photos(self.id, *args, **kwargs)
+
+    @classmethod
+    def de_list(cls, data, bot):
+        if not data:
+            return []
+
+        users = list()
+        for user in data:
+            users.append(cls.de_json(user, bot))
+
+        return users
+
+    def mention_markdown(self, name=None):
+        """
+        Args:
+            name (:obj:`str`): If provided, will overwrite the user's name.
+
+        Returns:
+            :obj:`str`: The inline mention for the user as markdown.
+        """
+        if not name:
+            return util_mention_markdown(self.id, self.name)
+        else:
+            return util_mention_markdown(self.id, name)
+
+    def mention_html(self, name=None):
+        """
+        Args:
+            name (:obj:`str`): If provided, will overwrite the user's name.
+
+        Returns:
+            :obj:`str`: The inline mention for the user as HTML.
+        """
+        if not name:
+            return util_mention_html(self.id, self.name)
+        else:
+            return util_mention_html(self.id, name)
```

### Comparing `python-telegram-bot-8.1.1/telegram/utils/deprecate.py` & `python-telegram-bot-9.0.0/telegram/utils/deprecate.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module facilitates the deprecation of functions."""
-
-import warnings
-
-
-# We use our own DeprecationWarning since they are muted by default and "UserWarning" makes it
-# seem like it's the user that issued the warning
-# We name it something else so that you don't get confused when you attempt to suppress it
-class TelegramDeprecationWarning(Warning):
-    pass
-
-
-def warn_deprecate_obj(old, new, stacklevel=3):
-    warnings.warn(
-        '{0} is being deprecated, please use {1} from now on.'.format(old, new),
-        category=TelegramDeprecationWarning,
-        stacklevel=stacklevel)
-
-
-def deprecate(func, old, new):
-    """Warn users invoking old to switch to the new function."""
-
-    def f(*args, **kwargs):
-        warn_deprecate_obj(old, new)
-        return func(*args, **kwargs)
-
-    return f
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module facilitates the deprecation of functions."""
+
+import warnings
+
+
+# We use our own DeprecationWarning since they are muted by default and "UserWarning" makes it
+# seem like it's the user that issued the warning
+# We name it something else so that you don't get confused when you attempt to suppress it
+class TelegramDeprecationWarning(Warning):
+    pass
+
+
+def warn_deprecate_obj(old, new, stacklevel=3):
+    warnings.warn(
+        '{0} is being deprecated, please use {1} from now on.'.format(old, new),
+        category=TelegramDeprecationWarning,
+        stacklevel=stacklevel)
+
+
+def deprecate(func, old, new):
+    """Warn users invoking old to switch to the new function."""
+
+    def f(*args, **kwargs):
+        warn_deprecate_obj(old, new)
+        return func(*args, **kwargs)
+
+    return f
```

### Comparing `python-telegram-bot-8.1.1/telegram/utils/helpers.py` & `python-telegram-bot-9.0.0/telegram/utils/helpers.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,102 +1,102 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains helper functions."""
-
-import re
-from datetime import datetime
-
-try:
-    from html import escape as escape_html  # noqa: F401
-except ImportError:
-    from cgi import escape as escape_html  # noqa: F401
-
-# Not using future.backports.datetime here as datetime value might be an input from the user,
-# making every isinstace() call more delicate. So we just use our own compat layer.
-if hasattr(datetime, 'timestamp'):
-    # Python 3.3+
-    def _timestamp(dt_obj):
-        return dt_obj.timestamp()
-else:
-    # Python < 3.3 (incl 2.7)
-    from time import mktime
-
-    def _timestamp(dt_obj):
-        return mktime(dt_obj.timetuple())
-
-
-def escape_markdown(text):
-    """Helper function to escape telegram markup symbols."""
-    escape_chars = '\*_`\['
-    return re.sub(r'([%s])' % escape_chars, r'\\\1', text)
-
-
-def to_timestamp(dt_obj):
-    """
-    Args:
-        dt_obj (:class:`datetime.datetime`):
-
-    Returns:
-        int:
-
-    """
-    if not dt_obj:
-        return None
-
-    return int(_timestamp(dt_obj))
-
-
-def from_timestamp(unixtime):
-    """
-    Args:
-        unixtime (int):
-
-    Returns:
-        datetime.datetime:
-
-    """
-    if not unixtime:
-        return None
-
-    return datetime.fromtimestamp(unixtime)
-
-
-def mention_html(user_id, name):
-    """
-    Args:
-        user_id (:obj:`int`) The user's id which you want to mention.
-        name (:obj:`str`) The name the mention is showing.
-
-    Returns:
-        :obj:`str`: The inline mention for the user as html.
-    """
-    if isinstance(user_id, int):
-        return '<a href="tg://user?id={}">{}</a>'.format(user_id, escape_html(name))
-
-
-def mention_markdown(user_id, name):
-    """
-    Args:
-        user_id (:obj:`int`) The user's id which you want to mention.
-        name (:obj:`str`) The name the mention is showing.
-
-    Returns:
-        :obj:`str`: The inline mention for the user as markdown.
-    """
-    if isinstance(user_id, int):
-        return '[{}](tg://user?id={})'.format(escape_markdown(name), user_id)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains helper functions."""
+
+import re
+from datetime import datetime
+
+try:
+    from html import escape as escape_html  # noqa: F401
+except ImportError:
+    from cgi import escape as escape_html  # noqa: F401
+
+# Not using future.backports.datetime here as datetime value might be an input from the user,
+# making every isinstace() call more delicate. So we just use our own compat layer.
+if hasattr(datetime, 'timestamp'):
+    # Python 3.3+
+    def _timestamp(dt_obj):
+        return dt_obj.timestamp()
+else:
+    # Python < 3.3 (incl 2.7)
+    from time import mktime
+
+    def _timestamp(dt_obj):
+        return mktime(dt_obj.timetuple())
+
+
+def escape_markdown(text):
+    """Helper function to escape telegram markup symbols."""
+    escape_chars = '\*_`\['
+    return re.sub(r'([%s])' % escape_chars, r'\\\1', text)
+
+
+def to_timestamp(dt_obj):
+    """
+    Args:
+        dt_obj (:class:`datetime.datetime`):
+
+    Returns:
+        int:
+
+    """
+    if not dt_obj:
+        return None
+
+    return int(_timestamp(dt_obj))
+
+
+def from_timestamp(unixtime):
+    """
+    Args:
+        unixtime (int):
+
+    Returns:
+        datetime.datetime:
+
+    """
+    if not unixtime:
+        return None
+
+    return datetime.fromtimestamp(unixtime)
+
+
+def mention_html(user_id, name):
+    """
+    Args:
+        user_id (:obj:`int`) The user's id which you want to mention.
+        name (:obj:`str`) The name the mention is showing.
+
+    Returns:
+        :obj:`str`: The inline mention for the user as html.
+    """
+    if isinstance(user_id, int):
+        return '<a href="tg://user?id={}">{}</a>'.format(user_id, escape_html(name))
+
+
+def mention_markdown(user_id, name):
+    """
+    Args:
+        user_id (:obj:`int`) The user's id which you want to mention.
+        name (:obj:`str`) The name the mention is showing.
+
+    Returns:
+        :obj:`str`: The inline mention for the user as markdown.
+    """
+    if isinstance(user_id, int):
+        return '[{}](tg://user?id={})'.format(escape_markdown(name), user_id)
```

### Comparing `python-telegram-bot-8.1.1/telegram/utils/request.py` & `python-telegram-bot-9.0.0/telegram/utils/request.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,306 +1,306 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains methods to make POST and GET requests."""
-import os
-import socket
-import sys
-import logging
-import warnings
-
-try:
-    import ujson as json
-except ImportError:
-    import json
-
-import certifi
-
-try:
-    import telegram.vendor.ptb_urllib3.urllib3 as urllib3
-    import telegram.vendor.ptb_urllib3.urllib3.contrib.appengine as appengine
-    from telegram.vendor.ptb_urllib3.urllib3.connection import HTTPConnection
-    from telegram.vendor.ptb_urllib3.urllib3.util.timeout import Timeout
-except ImportError:  # pragma: no cover
-    warnings.warn("python-telegram-bot wasn't properly installed. Please refer to README.rst on "
-                  "how to properly install.")
-    raise
-
-from telegram import (InputFile, TelegramError)
-from telegram.error import (Unauthorized, NetworkError, TimedOut, BadRequest, ChatMigrated,
-                            RetryAfter, InvalidToken)
-
-logging.getLogger('urllib3').setLevel(logging.WARNING)
-
-
-class Request(object):
-    """
-    Helper class for python-telegram-bot which provides methods to perform POST & GET towards
-    telegram servers.
-
-    Args:
-        con_pool_size (int): Number of connections to keep in the connection pool.
-        proxy_url (str): The URL to the proxy server. For example: `http://127.0.0.1:3128`.
-        urllib3_proxy_kwargs (dict): Arbitrary arguments passed as-is to `urllib3.ProxyManager`.
-            This value will be ignored if proxy_url is not set.
-        connect_timeout (int|float): The maximum amount of time (in seconds) to wait for a
-            connection attempt to a server to succeed. None will set an infinite timeout for
-            connection attempts. (default: 5.)
-        read_timeout (int|float): The maximum amount of time (in seconds) to wait between
-            consecutive read operations for a response from the server. None will set an infinite
-            timeout. This value is usually overridden by the various ``telegram.Bot`` methods.
-            (default: 5.)
-
-    """
-
-    def __init__(self,
-                 con_pool_size=1,
-                 proxy_url=None,
-                 urllib3_proxy_kwargs=None,
-                 connect_timeout=5.,
-                 read_timeout=5.):
-        if urllib3_proxy_kwargs is None:
-            urllib3_proxy_kwargs = dict()
-
-        self._connect_timeout = connect_timeout
-
-        sockopts = HTTPConnection.default_socket_options + [
-            (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]
-
-        # TODO: Support other platforms like mac and windows.
-        if 'linux' in sys.platform:
-            sockopts.append((socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 120))
-            sockopts.append((socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 30))
-            sockopts.append((socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 8))
-
-        self._con_pool_size = con_pool_size
-
-        kwargs = dict(
-            maxsize=con_pool_size,
-            cert_reqs='CERT_REQUIRED',
-            ca_certs=certifi.where(),
-            socket_options=sockopts,
-            timeout=urllib3.Timeout(
-                connect=self._connect_timeout, read=read_timeout, total=None))
-
-        # Set a proxy according to the following order:
-        # * proxy defined in proxy_url (+ urllib3_proxy_kwargs)
-        # * proxy set in `HTTPS_PROXY` env. var.
-        # * proxy set in `https_proxy` env. var.
-        # * None (if no proxy is configured)
-
-        if not proxy_url:
-            proxy_url = os.environ.get('HTTPS_PROXY') or os.environ.get('https_proxy')
-
-        if not proxy_url:
-            if appengine.is_appengine_sandbox():
-                # Use URLFetch service if running in App Engine
-                mgr = appengine.AppEngineManager()
-            else:
-                mgr = urllib3.PoolManager(**kwargs)
-        else:
-            kwargs.update(urllib3_proxy_kwargs)
-            if proxy_url.startswith('socks'):
-                try:
-                    from telegram.vendor.ptb_urllib3.urllib3.contrib.socks import SOCKSProxyManager
-                except ImportError:
-                    raise RuntimeError('PySocks is missing')
-                mgr = SOCKSProxyManager(proxy_url, **kwargs)
-            else:
-                mgr = urllib3.proxy_from_url(proxy_url, **kwargs)
-                if mgr.proxy.auth:
-                    # TODO: what about other auth types?
-                    auth_hdrs = urllib3.make_headers(proxy_basic_auth=mgr.proxy.auth)
-                    mgr.proxy_headers.update(auth_hdrs)
-
-        self._con_pool = mgr
-
-    @property
-    def con_pool_size(self):
-        """The size of the connection pool used."""
-        return self._con_pool_size
-
-    def stop(self):
-        self._con_pool.clear()
-
-    @staticmethod
-    def _parse(json_data):
-        """Try and parse the JSON returned from Telegram.
-
-        Returns:
-            dict: A JSON parsed as Python dict with results - on error this dict will be empty.
-
-        """
-        decoded_s = json_data.decode('utf-8')
-        try:
-            data = json.loads(decoded_s)
-        except ValueError:
-            raise TelegramError('Invalid server response')
-
-        if not data.get('ok'):  # pragma: no cover
-            description = data.get('description')
-            parameters = data.get('parameters')
-            if parameters:
-                migrate_to_chat_id = parameters.get('migrate_to_chat_id')
-                if migrate_to_chat_id:
-                    raise ChatMigrated(migrate_to_chat_id)
-                retry_after = parameters.get('retry_after')
-                if retry_after:
-                    raise RetryAfter(retry_after)
-            if description:
-                return description
-
-        return data['result']
-
-    def _request_wrapper(self, *args, **kwargs):
-        """Wraps urllib3 request for handling known exceptions.
-
-        Args:
-            args: unnamed arguments, passed to urllib3 request.
-            kwargs: keyword arguments, passed tp urllib3 request.
-
-        Returns:
-            str: A non-parsed JSON text.
-
-        Raises:
-            TelegramError
-
-        """
-        # Make sure to hint Telegram servers that we reuse connections by sending
-        # "Connection: keep-alive" in the HTTP headers.
-        if 'headers' not in kwargs:
-            kwargs['headers'] = {}
-        kwargs['headers']['connection'] = 'keep-alive'
-
-        try:
-            resp = self._con_pool.request(*args, **kwargs)
-        except urllib3.exceptions.TimeoutError:
-            raise TimedOut()
-        except urllib3.exceptions.HTTPError as error:
-            # HTTPError must come last as its the base urllib3 exception class
-            # TODO: do something smart here; for now just raise NetworkError
-            raise NetworkError('urllib3 HTTPError {0}'.format(error))
-
-        if 200 <= resp.status <= 299:
-            # 200-299 range are HTTP success statuses
-            return resp.data
-
-        try:
-            message = self._parse(resp.data)
-        except ValueError:
-            message = 'Unknown HTTPError'
-
-        if resp.status in (401, 403):
-            raise Unauthorized(message)
-        elif resp.status == 400:
-            raise BadRequest(message)
-        elif resp.status == 404:
-            raise InvalidToken()
-        elif resp.status == 413:
-            raise NetworkError('File too large. Check telegram api limits '
-                               'https://core.telegram.org/bots/api#senddocument')
-
-        elif resp.status == 502:
-            raise NetworkError('Bad Gateway')
-        else:
-            raise NetworkError('{0} ({1})'.format(message, resp.status))
-
-    def get(self, url, timeout=None):
-        """Request an URL.
-
-        Args:
-            url (:obj:`str`): The web location we want to retrieve.
-            timeout (:obj:`int` | :obj:`float`): If this value is specified, use it as the read
-                timeout from the server (instead of the one specified during creation of the
-                connection pool).
-
-        Returns:
-          A JSON object.
-
-        """
-        urlopen_kwargs = {}
-
-        if timeout is not None:
-            urlopen_kwargs['timeout'] = Timeout(read=timeout, connect=self._connect_timeout)
-
-        result = self._request_wrapper('GET', url, **urlopen_kwargs)
-        return self._parse(result)
-
-    def post(self, url, data, timeout=None):
-        """Request an URL.
-        Args:
-            url (:obj:`str`): The web location we want to retrieve.
-            data (dict[str, str|int]): A dict of key/value pairs. Note: On py2.7 value is unicode.
-            timeout (:obj:`int` | :obj:`float`): If this value is specified, use it as the read
-                timeout from the server (instead of the one specified during creation of the
-                connection pool).
-
-        Returns:
-          A JSON object.
-
-        """
-        urlopen_kwargs = {}
-
-        if timeout is not None:
-            urlopen_kwargs['timeout'] = Timeout(read=timeout, connect=self._connect_timeout)
-
-        if InputFile.is_inputfile(data):
-            data = InputFile(data)
-            result = self._request_wrapper(
-                'POST', url, body=data.to_form(), headers=data.headers, **urlopen_kwargs)
-        else:
-            data = json.dumps(data)
-            result = self._request_wrapper(
-                'POST',
-                url,
-                body=data.encode(),
-                headers={'Content-Type': 'application/json'},
-                **urlopen_kwargs)
-
-        return self._parse(result)
-
-    def retrieve(self, url, timeout=None):
-        """Retrieve the contents of a file by its URL.
-
-        Args:
-            url (:obj:`str`): The web location we want to retrieve.
-            timeout (:obj:`int` | :obj:`float`): If this value is specified, use it as the read
-                timeout from the server (instead of the one specified during creation of the
-                connection pool).
-
-        """
-        urlopen_kwargs = {}
-        if timeout is not None:
-            urlopen_kwargs['timeout'] = Timeout(read=timeout, connect=self._connect_timeout)
-
-        return self._request_wrapper('GET', url, **urlopen_kwargs)
-
-    def download(self, url, filename, timeout=None):
-        """Download a file by its URL.
-        Args:
-            url (str): The web location we want to retrieve.
-            timeout (:obj:`int` | :obj:`float`): If this value is specified, use it as the read
-                timeout from the server (instead of the one specified during creation of the
-                connection pool).
-
-          filename:
-            The filename within the path to download the file.
-
-        """
-        buf = self.retrieve(url, timeout=timeout)
-        with open(filename, 'wb') as fobj:
-            fobj.write(buf)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains methods to make POST and GET requests."""
+import os
+import socket
+import sys
+import logging
+import warnings
+
+try:
+    import ujson as json
+except ImportError:
+    import json
+
+import certifi
+
+try:
+    import telegram.vendor.ptb_urllib3.urllib3 as urllib3
+    import telegram.vendor.ptb_urllib3.urllib3.contrib.appengine as appengine
+    from telegram.vendor.ptb_urllib3.urllib3.connection import HTTPConnection
+    from telegram.vendor.ptb_urllib3.urllib3.util.timeout import Timeout
+except ImportError:  # pragma: no cover
+    warnings.warn("python-telegram-bot wasn't properly installed. Please refer to README.rst on "
+                  "how to properly install.")
+    raise
+
+from telegram import (InputFile, TelegramError)
+from telegram.error import (Unauthorized, NetworkError, TimedOut, BadRequest, ChatMigrated,
+                            RetryAfter, InvalidToken)
+
+logging.getLogger('urllib3').setLevel(logging.WARNING)
+
+
+class Request(object):
+    """
+    Helper class for python-telegram-bot which provides methods to perform POST & GET towards
+    telegram servers.
+
+    Args:
+        con_pool_size (int): Number of connections to keep in the connection pool.
+        proxy_url (str): The URL to the proxy server. For example: `http://127.0.0.1:3128`.
+        urllib3_proxy_kwargs (dict): Arbitrary arguments passed as-is to `urllib3.ProxyManager`.
+            This value will be ignored if proxy_url is not set.
+        connect_timeout (int|float): The maximum amount of time (in seconds) to wait for a
+            connection attempt to a server to succeed. None will set an infinite timeout for
+            connection attempts. (default: 5.)
+        read_timeout (int|float): The maximum amount of time (in seconds) to wait between
+            consecutive read operations for a response from the server. None will set an infinite
+            timeout. This value is usually overridden by the various ``telegram.Bot`` methods.
+            (default: 5.)
+
+    """
+
+    def __init__(self,
+                 con_pool_size=1,
+                 proxy_url=None,
+                 urllib3_proxy_kwargs=None,
+                 connect_timeout=5.,
+                 read_timeout=5.):
+        if urllib3_proxy_kwargs is None:
+            urllib3_proxy_kwargs = dict()
+
+        self._connect_timeout = connect_timeout
+
+        sockopts = HTTPConnection.default_socket_options + [
+            (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]
+
+        # TODO: Support other platforms like mac and windows.
+        if 'linux' in sys.platform:
+            sockopts.append((socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 120))
+            sockopts.append((socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 30))
+            sockopts.append((socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 8))
+
+        self._con_pool_size = con_pool_size
+
+        kwargs = dict(
+            maxsize=con_pool_size,
+            cert_reqs='CERT_REQUIRED',
+            ca_certs=certifi.where(),
+            socket_options=sockopts,
+            timeout=urllib3.Timeout(
+                connect=self._connect_timeout, read=read_timeout, total=None))
+
+        # Set a proxy according to the following order:
+        # * proxy defined in proxy_url (+ urllib3_proxy_kwargs)
+        # * proxy set in `HTTPS_PROXY` env. var.
+        # * proxy set in `https_proxy` env. var.
+        # * None (if no proxy is configured)
+
+        if not proxy_url:
+            proxy_url = os.environ.get('HTTPS_PROXY') or os.environ.get('https_proxy')
+
+        if not proxy_url:
+            if appengine.is_appengine_sandbox():
+                # Use URLFetch service if running in App Engine
+                mgr = appengine.AppEngineManager()
+            else:
+                mgr = urllib3.PoolManager(**kwargs)
+        else:
+            kwargs.update(urllib3_proxy_kwargs)
+            if proxy_url.startswith('socks'):
+                try:
+                    from telegram.vendor.ptb_urllib3.urllib3.contrib.socks import SOCKSProxyManager
+                except ImportError:
+                    raise RuntimeError('PySocks is missing')
+                mgr = SOCKSProxyManager(proxy_url, **kwargs)
+            else:
+                mgr = urllib3.proxy_from_url(proxy_url, **kwargs)
+                if mgr.proxy.auth:
+                    # TODO: what about other auth types?
+                    auth_hdrs = urllib3.make_headers(proxy_basic_auth=mgr.proxy.auth)
+                    mgr.proxy_headers.update(auth_hdrs)
+
+        self._con_pool = mgr
+
+    @property
+    def con_pool_size(self):
+        """The size of the connection pool used."""
+        return self._con_pool_size
+
+    def stop(self):
+        self._con_pool.clear()
+
+    @staticmethod
+    def _parse(json_data):
+        """Try and parse the JSON returned from Telegram.
+
+        Returns:
+            dict: A JSON parsed as Python dict with results - on error this dict will be empty.
+
+        """
+        decoded_s = json_data.decode('utf-8')
+        try:
+            data = json.loads(decoded_s)
+        except ValueError:
+            raise TelegramError('Invalid server response')
+
+        if not data.get('ok'):  # pragma: no cover
+            description = data.get('description')
+            parameters = data.get('parameters')
+            if parameters:
+                migrate_to_chat_id = parameters.get('migrate_to_chat_id')
+                if migrate_to_chat_id:
+                    raise ChatMigrated(migrate_to_chat_id)
+                retry_after = parameters.get('retry_after')
+                if retry_after:
+                    raise RetryAfter(retry_after)
+            if description:
+                return description
+
+        return data['result']
+
+    def _request_wrapper(self, *args, **kwargs):
+        """Wraps urllib3 request for handling known exceptions.
+
+        Args:
+            args: unnamed arguments, passed to urllib3 request.
+            kwargs: keyword arguments, passed tp urllib3 request.
+
+        Returns:
+            str: A non-parsed JSON text.
+
+        Raises:
+            TelegramError
+
+        """
+        # Make sure to hint Telegram servers that we reuse connections by sending
+        # "Connection: keep-alive" in the HTTP headers.
+        if 'headers' not in kwargs:
+            kwargs['headers'] = {}
+        kwargs['headers']['connection'] = 'keep-alive'
+
+        try:
+            resp = self._con_pool.request(*args, **kwargs)
+        except urllib3.exceptions.TimeoutError:
+            raise TimedOut()
+        except urllib3.exceptions.HTTPError as error:
+            # HTTPError must come last as its the base urllib3 exception class
+            # TODO: do something smart here; for now just raise NetworkError
+            raise NetworkError('urllib3 HTTPError {0}'.format(error))
+
+        if 200 <= resp.status <= 299:
+            # 200-299 range are HTTP success statuses
+            return resp.data
+
+        try:
+            message = self._parse(resp.data)
+        except ValueError:
+            message = 'Unknown HTTPError'
+
+        if resp.status in (401, 403):
+            raise Unauthorized(message)
+        elif resp.status == 400:
+            raise BadRequest(message)
+        elif resp.status == 404:
+            raise InvalidToken()
+        elif resp.status == 413:
+            raise NetworkError('File too large. Check telegram api limits '
+                               'https://core.telegram.org/bots/api#senddocument')
+
+        elif resp.status == 502:
+            raise NetworkError('Bad Gateway')
+        else:
+            raise NetworkError('{0} ({1})'.format(message, resp.status))
+
+    def get(self, url, timeout=None):
+        """Request an URL.
+
+        Args:
+            url (:obj:`str`): The web location we want to retrieve.
+            timeout (:obj:`int` | :obj:`float`): If this value is specified, use it as the read
+                timeout from the server (instead of the one specified during creation of the
+                connection pool).
+
+        Returns:
+          A JSON object.
+
+        """
+        urlopen_kwargs = {}
+
+        if timeout is not None:
+            urlopen_kwargs['timeout'] = Timeout(read=timeout, connect=self._connect_timeout)
+
+        result = self._request_wrapper('GET', url, **urlopen_kwargs)
+        return self._parse(result)
+
+    def post(self, url, data, timeout=None):
+        """Request an URL.
+        Args:
+            url (:obj:`str`): The web location we want to retrieve.
+            data (dict[str, str|int]): A dict of key/value pairs. Note: On py2.7 value is unicode.
+            timeout (:obj:`int` | :obj:`float`): If this value is specified, use it as the read
+                timeout from the server (instead of the one specified during creation of the
+                connection pool).
+
+        Returns:
+          A JSON object.
+
+        """
+        urlopen_kwargs = {}
+
+        if timeout is not None:
+            urlopen_kwargs['timeout'] = Timeout(read=timeout, connect=self._connect_timeout)
+
+        if InputFile.is_inputfile(data):
+            data = InputFile(data)
+            result = self._request_wrapper(
+                'POST', url, body=data.to_form(), headers=data.headers, **urlopen_kwargs)
+        else:
+            data = json.dumps(data)
+            result = self._request_wrapper(
+                'POST',
+                url,
+                body=data.encode(),
+                headers={'Content-Type': 'application/json'},
+                **urlopen_kwargs)
+
+        return self._parse(result)
+
+    def retrieve(self, url, timeout=None):
+        """Retrieve the contents of a file by its URL.
+
+        Args:
+            url (:obj:`str`): The web location we want to retrieve.
+            timeout (:obj:`int` | :obj:`float`): If this value is specified, use it as the read
+                timeout from the server (instead of the one specified during creation of the
+                connection pool).
+
+        """
+        urlopen_kwargs = {}
+        if timeout is not None:
+            urlopen_kwargs['timeout'] = Timeout(read=timeout, connect=self._connect_timeout)
+
+        return self._request_wrapper('GET', url, **urlopen_kwargs)
+
+    def download(self, url, filename, timeout=None):
+        """Download a file by its URL.
+        Args:
+            url (str): The web location we want to retrieve.
+            timeout (:obj:`int` | :obj:`float`): If this value is specified, use it as the read
+                timeout from the server (instead of the one specified during creation of the
+                connection pool).
+
+          filename:
+            The filename within the path to download the file.
+
+        """
+        buf = self.retrieve(url, timeout=timeout)
+        with open(filename, 'wb') as fobj:
+            fobj.write(buf)
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/connection.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/connection.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,369 +1,369 @@
-from __future__ import absolute_import
-import datetime
-import logging
-import os
-import sys
-import socket
-from socket import error as SocketError, timeout as SocketTimeout
-import warnings
-from .packages import six
-from .packages.six.moves.http_client import HTTPConnection as _HTTPConnection
-from .packages.six.moves.http_client import HTTPException  # noqa: F401
-
-try:  # Compiled with SSL?
-    import ssl
-    BaseSSLError = ssl.SSLError
-except (ImportError, AttributeError):  # Platform-specific: No SSL.
-    ssl = None
-
-    class BaseSSLError(BaseException):
-        pass
-
-
-try:  # Python 3:
-    # Not a no-op, we're adding this to the namespace so it can be imported.
-    ConnectionError = ConnectionError
-except NameError:  # Python 2:
-    class ConnectionError(Exception):
-        pass
-
-
-from .exceptions import (
-    NewConnectionError,
-    ConnectTimeoutError,
-    SubjectAltNameWarning,
-    SystemTimeWarning,
-)
-from .packages.ssl_match_hostname import match_hostname, CertificateError
-
-from .util.ssl_ import (
-    resolve_cert_reqs,
-    resolve_ssl_version,
-    assert_fingerprint,
-    create_urllib3_context,
-    ssl_wrap_socket
-)
-
-
-from .util import connection
-
-from ._collections import HTTPHeaderDict
-
-log = logging.getLogger(__name__)
-
-port_by_scheme = {
-    'http': 80,
-    'https': 443,
-}
-
-# When updating RECENT_DATE, move it to
-# within two years of the current date, and no
-# earlier than 6 months ago.
-RECENT_DATE = datetime.date(2016, 1, 1)
-
-
-class DummyConnection(object):
-    """Used to detect a failed ConnectionCls import."""
-    pass
-
-
-class HTTPConnection(_HTTPConnection, object):
-    """
-    Based on httplib.HTTPConnection but provides an extra constructor
-    backwards-compatibility layer between older and newer Pythons.
-
-    Additional keyword parameters are used to configure attributes of the connection.
-    Accepted parameters include:
-
-      - ``strict``: See the documentation on :class:`urllib3.connectionpool.HTTPConnectionPool`
-      - ``source_address``: Set the source address for the current connection.
-
-        .. note:: This is ignored for Python 2.6. It is only applied for 2.7 and 3.x
-
-      - ``socket_options``: Set specific options on the underlying socket. If not specified, then
-        defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling
-        Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.
-
-        For example, if you wish to enable TCP Keep Alive in addition to the defaults,
-        you might pass::
-
-            HTTPConnection.default_socket_options + [
-                (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),
-            ]
-
-        Or you may want to disable the defaults by passing an empty list (e.g., ``[]``).
-    """
-
-    default_port = port_by_scheme['http']
-
-    #: Disable Nagle's algorithm by default.
-    #: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``
-    default_socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]
-
-    #: Whether this connection verifies the host's certificate.
-    is_verified = False
-
-    def __init__(self, *args, **kw):
-        if six.PY3:  # Python 3
-            kw.pop('strict', None)
-
-        # Pre-set source_address in case we have an older Python like 2.6.
-        self.source_address = kw.get('source_address')
-
-        if sys.version_info < (2, 7):  # Python 2.6
-            # _HTTPConnection on Python 2.6 will balk at this keyword arg, but
-            # not newer versions. We can still use it when creating a
-            # connection though, so we pop it *after* we have saved it as
-            # self.source_address.
-            kw.pop('source_address', None)
-
-        #: The socket options provided by the user. If no options are
-        #: provided, we use the default options.
-        self.socket_options = kw.pop('socket_options', self.default_socket_options)
-
-        # Superclass also sets self.source_address in Python 2.7+.
-        _HTTPConnection.__init__(self, *args, **kw)
-
-    def _new_conn(self):
-        """ Establish a socket connection and set nodelay settings on it.
-
-        :return: New socket connection.
-        """
-        extra_kw = {}
-        if self.source_address:
-            extra_kw['source_address'] = self.source_address
-
-        if self.socket_options:
-            extra_kw['socket_options'] = self.socket_options
-
-        try:
-            conn = connection.create_connection(
-                (self.host, self.port), self.timeout, **extra_kw)
-
-        except SocketTimeout as e:
-            raise ConnectTimeoutError(
-                self, "Connection to %s timed out. (connect timeout=%s)" %
-                (self.host, self.timeout))
-
-        except SocketError as e:
-            raise NewConnectionError(
-                self, "Failed to establish a new connection: %s" % e)
-
-        return conn
-
-    def _prepare_conn(self, conn):
-        self.sock = conn
-        # the _tunnel_host attribute was added in python 2.6.3 (via
-        # http://hg.python.org/cpython/rev/0f57b30a152f) so pythons 2.6(0-2) do
-        # not have them.
-        if getattr(self, '_tunnel_host', None):
-            # TODO: Fix tunnel so it doesn't depend on self.sock state.
-            self._tunnel()
-            # Mark this connection as not reusable
-            self.auto_open = 0
-
-    def connect(self):
-        conn = self._new_conn()
-        self._prepare_conn(conn)
-
-    def request_chunked(self, method, url, body=None, headers=None):
-        """
-        Alternative to the common request method, which sends the
-        body with chunked encoding and not as one block
-        """
-        headers = HTTPHeaderDict(headers if headers is not None else {})
-        skip_accept_encoding = 'accept-encoding' in headers
-        skip_host = 'host' in headers
-        self.putrequest(
-            method,
-            url,
-            skip_accept_encoding=skip_accept_encoding,
-            skip_host=skip_host
-        )
-        for header, value in headers.items():
-            self.putheader(header, value)
-        if 'transfer-encoding' not in headers:
-            self.putheader('Transfer-Encoding', 'chunked')
-        self.endheaders()
-
-        if body is not None:
-            stringish_types = six.string_types + (six.binary_type,)
-            if isinstance(body, stringish_types):
-                body = (body,)
-            for chunk in body:
-                if not chunk:
-                    continue
-                if not isinstance(chunk, six.binary_type):
-                    chunk = chunk.encode('utf8')
-                len_str = hex(len(chunk))[2:]
-                self.send(len_str.encode('utf-8'))
-                self.send(b'\r\n')
-                self.send(chunk)
-                self.send(b'\r\n')
-
-        # After the if clause, to always have a closed body
-        self.send(b'0\r\n\r\n')
-
-
-class HTTPSConnection(HTTPConnection):
-    default_port = port_by_scheme['https']
-
-    ssl_version = None
-
-    def __init__(self, host, port=None, key_file=None, cert_file=None,
-                 strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
-                 ssl_context=None, **kw):
-
-        HTTPConnection.__init__(self, host, port, strict=strict,
-                                timeout=timeout, **kw)
-
-        self.key_file = key_file
-        self.cert_file = cert_file
-        self.ssl_context = ssl_context
-
-        # Required property for Google AppEngine 1.9.0 which otherwise causes
-        # HTTPS requests to go out as HTTP. (See Issue #356)
-        self._protocol = 'https'
-
-    def connect(self):
-        conn = self._new_conn()
-        self._prepare_conn(conn)
-
-        if self.ssl_context is None:
-            self.ssl_context = create_urllib3_context(
-                ssl_version=resolve_ssl_version(None),
-                cert_reqs=resolve_cert_reqs(None),
-            )
-
-        self.sock = ssl_wrap_socket(
-            sock=conn,
-            keyfile=self.key_file,
-            certfile=self.cert_file,
-            ssl_context=self.ssl_context,
-        )
-
-
-class VerifiedHTTPSConnection(HTTPSConnection):
-    """
-    Based on httplib.HTTPSConnection but wraps the socket with
-    SSL certification.
-    """
-    cert_reqs = None
-    ca_certs = None
-    ca_cert_dir = None
-    ssl_version = None
-    assert_fingerprint = None
-
-    def set_cert(self, key_file=None, cert_file=None,
-                 cert_reqs=None, ca_certs=None,
-                 assert_hostname=None, assert_fingerprint=None,
-                 ca_cert_dir=None):
-        """
-        This method should only be called once, before the connection is used.
-        """
-        # If cert_reqs is not provided, we can try to guess. If the user gave
-        # us a cert database, we assume they want to use it: otherwise, if
-        # they gave us an SSL Context object we should use whatever is set for
-        # it.
-        if cert_reqs is None:
-            if ca_certs or ca_cert_dir:
-                cert_reqs = 'CERT_REQUIRED'
-            elif self.ssl_context is not None:
-                cert_reqs = self.ssl_context.verify_mode
-
-        self.key_file = key_file
-        self.cert_file = cert_file
-        self.cert_reqs = cert_reqs
-        self.assert_hostname = assert_hostname
-        self.assert_fingerprint = assert_fingerprint
-        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)
-        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)
-
-    def connect(self):
-        # Add certificate verification
-        conn = self._new_conn()
-
-        hostname = self.host
-        if getattr(self, '_tunnel_host', None):
-            # _tunnel_host was added in Python 2.6.3
-            # (See: http://hg.python.org/cpython/rev/0f57b30a152f)
-
-            self.sock = conn
-            # Calls self._set_hostport(), so self.host is
-            # self._tunnel_host below.
-            self._tunnel()
-            # Mark this connection as not reusable
-            self.auto_open = 0
-
-            # Override the host with the one we're requesting data from.
-            hostname = self._tunnel_host
-
-        is_time_off = datetime.date.today() < RECENT_DATE
-        if is_time_off:
-            warnings.warn((
-                'System time is way off (before {0}). This will probably '
-                'lead to SSL verification errors').format(RECENT_DATE),
-                SystemTimeWarning
-            )
-
-        # Wrap socket using verification with the root certs in
-        # trusted_root_certs
-        if self.ssl_context is None:
-            self.ssl_context = create_urllib3_context(
-                ssl_version=resolve_ssl_version(self.ssl_version),
-                cert_reqs=resolve_cert_reqs(self.cert_reqs),
-            )
-
-        context = self.ssl_context
-        context.verify_mode = resolve_cert_reqs(self.cert_reqs)
-        self.sock = ssl_wrap_socket(
-            sock=conn,
-            keyfile=self.key_file,
-            certfile=self.cert_file,
-            ca_certs=self.ca_certs,
-            ca_cert_dir=self.ca_cert_dir,
-            server_hostname=hostname,
-            ssl_context=context)
-
-        if self.assert_fingerprint:
-            assert_fingerprint(self.sock.getpeercert(binary_form=True),
-                               self.assert_fingerprint)
-        elif context.verify_mode != ssl.CERT_NONE \
-                and self.assert_hostname is not False:
-            cert = self.sock.getpeercert()
-            if not cert.get('subjectAltName', ()):
-                warnings.warn((
-                    'Certificate for {0} has no `subjectAltName`, falling back to check for a '
-                    '`commonName` for now. This feature is being removed by major browsers and '
-                    'deprecated by RFC 2818. (See https://github.com/shazow/urllib3/issues/497 '
-                    'for details.)'.format(hostname)),
-                    SubjectAltNameWarning
-                )
-            _match_hostname(cert, self.assert_hostname or hostname)
-
-        self.is_verified = (
-            context.verify_mode == ssl.CERT_REQUIRED or
-            self.assert_fingerprint is not None
-        )
-
-
-def _match_hostname(cert, asserted_hostname):
-    try:
-        match_hostname(cert, asserted_hostname)
-    except CertificateError as e:
-        log.error(
-            'Certificate did not match expected hostname: %s. '
-            'Certificate: %s', asserted_hostname, cert
-        )
-        # Add cert to exception and reraise so client code can inspect
-        # the cert when catching the exception, if they want to
-        e._peer_cert = cert
-        raise
-
-
-if ssl:
-    # Make a copy for testing.
-    UnverifiedHTTPSConnection = HTTPSConnection
-    HTTPSConnection = VerifiedHTTPSConnection
-else:
-    HTTPSConnection = DummyConnection
+from __future__ import absolute_import
+import datetime
+import logging
+import os
+import sys
+import socket
+from socket import error as SocketError, timeout as SocketTimeout
+import warnings
+from .packages import six
+from .packages.six.moves.http_client import HTTPConnection as _HTTPConnection
+from .packages.six.moves.http_client import HTTPException  # noqa: F401
+
+try:  # Compiled with SSL?
+    import ssl
+    BaseSSLError = ssl.SSLError
+except (ImportError, AttributeError):  # Platform-specific: No SSL.
+    ssl = None
+
+    class BaseSSLError(BaseException):
+        pass
+
+
+try:  # Python 3:
+    # Not a no-op, we're adding this to the namespace so it can be imported.
+    ConnectionError = ConnectionError
+except NameError:  # Python 2:
+    class ConnectionError(Exception):
+        pass
+
+
+from .exceptions import (
+    NewConnectionError,
+    ConnectTimeoutError,
+    SubjectAltNameWarning,
+    SystemTimeWarning,
+)
+from .packages.ssl_match_hostname import match_hostname, CertificateError
+
+from .util.ssl_ import (
+    resolve_cert_reqs,
+    resolve_ssl_version,
+    assert_fingerprint,
+    create_urllib3_context,
+    ssl_wrap_socket
+)
+
+
+from .util import connection
+
+from ._collections import HTTPHeaderDict
+
+log = logging.getLogger(__name__)
+
+port_by_scheme = {
+    'http': 80,
+    'https': 443,
+}
+
+# When updating RECENT_DATE, move it to
+# within two years of the current date, and no
+# earlier than 6 months ago.
+RECENT_DATE = datetime.date(2016, 1, 1)
+
+
+class DummyConnection(object):
+    """Used to detect a failed ConnectionCls import."""
+    pass
+
+
+class HTTPConnection(_HTTPConnection, object):
+    """
+    Based on httplib.HTTPConnection but provides an extra constructor
+    backwards-compatibility layer between older and newer Pythons.
+
+    Additional keyword parameters are used to configure attributes of the connection.
+    Accepted parameters include:
+
+      - ``strict``: See the documentation on :class:`urllib3.connectionpool.HTTPConnectionPool`
+      - ``source_address``: Set the source address for the current connection.
+
+        .. note:: This is ignored for Python 2.6. It is only applied for 2.7 and 3.x
+
+      - ``socket_options``: Set specific options on the underlying socket. If not specified, then
+        defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling
+        Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.
+
+        For example, if you wish to enable TCP Keep Alive in addition to the defaults,
+        you might pass::
+
+            HTTPConnection.default_socket_options + [
+                (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),
+            ]
+
+        Or you may want to disable the defaults by passing an empty list (e.g., ``[]``).
+    """
+
+    default_port = port_by_scheme['http']
+
+    #: Disable Nagle's algorithm by default.
+    #: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``
+    default_socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]
+
+    #: Whether this connection verifies the host's certificate.
+    is_verified = False
+
+    def __init__(self, *args, **kw):
+        if six.PY3:  # Python 3
+            kw.pop('strict', None)
+
+        # Pre-set source_address in case we have an older Python like 2.6.
+        self.source_address = kw.get('source_address')
+
+        if sys.version_info < (2, 7):  # Python 2.6
+            # _HTTPConnection on Python 2.6 will balk at this keyword arg, but
+            # not newer versions. We can still use it when creating a
+            # connection though, so we pop it *after* we have saved it as
+            # self.source_address.
+            kw.pop('source_address', None)
+
+        #: The socket options provided by the user. If no options are
+        #: provided, we use the default options.
+        self.socket_options = kw.pop('socket_options', self.default_socket_options)
+
+        # Superclass also sets self.source_address in Python 2.7+.
+        _HTTPConnection.__init__(self, *args, **kw)
+
+    def _new_conn(self):
+        """ Establish a socket connection and set nodelay settings on it.
+
+        :return: New socket connection.
+        """
+        extra_kw = {}
+        if self.source_address:
+            extra_kw['source_address'] = self.source_address
+
+        if self.socket_options:
+            extra_kw['socket_options'] = self.socket_options
+
+        try:
+            conn = connection.create_connection(
+                (self.host, self.port), self.timeout, **extra_kw)
+
+        except SocketTimeout as e:
+            raise ConnectTimeoutError(
+                self, "Connection to %s timed out. (connect timeout=%s)" %
+                (self.host, self.timeout))
+
+        except SocketError as e:
+            raise NewConnectionError(
+                self, "Failed to establish a new connection: %s" % e)
+
+        return conn
+
+    def _prepare_conn(self, conn):
+        self.sock = conn
+        # the _tunnel_host attribute was added in python 2.6.3 (via
+        # http://hg.python.org/cpython/rev/0f57b30a152f) so pythons 2.6(0-2) do
+        # not have them.
+        if getattr(self, '_tunnel_host', None):
+            # TODO: Fix tunnel so it doesn't depend on self.sock state.
+            self._tunnel()
+            # Mark this connection as not reusable
+            self.auto_open = 0
+
+    def connect(self):
+        conn = self._new_conn()
+        self._prepare_conn(conn)
+
+    def request_chunked(self, method, url, body=None, headers=None):
+        """
+        Alternative to the common request method, which sends the
+        body with chunked encoding and not as one block
+        """
+        headers = HTTPHeaderDict(headers if headers is not None else {})
+        skip_accept_encoding = 'accept-encoding' in headers
+        skip_host = 'host' in headers
+        self.putrequest(
+            method,
+            url,
+            skip_accept_encoding=skip_accept_encoding,
+            skip_host=skip_host
+        )
+        for header, value in headers.items():
+            self.putheader(header, value)
+        if 'transfer-encoding' not in headers:
+            self.putheader('Transfer-Encoding', 'chunked')
+        self.endheaders()
+
+        if body is not None:
+            stringish_types = six.string_types + (six.binary_type,)
+            if isinstance(body, stringish_types):
+                body = (body,)
+            for chunk in body:
+                if not chunk:
+                    continue
+                if not isinstance(chunk, six.binary_type):
+                    chunk = chunk.encode('utf8')
+                len_str = hex(len(chunk))[2:]
+                self.send(len_str.encode('utf-8'))
+                self.send(b'\r\n')
+                self.send(chunk)
+                self.send(b'\r\n')
+
+        # After the if clause, to always have a closed body
+        self.send(b'0\r\n\r\n')
+
+
+class HTTPSConnection(HTTPConnection):
+    default_port = port_by_scheme['https']
+
+    ssl_version = None
+
+    def __init__(self, host, port=None, key_file=None, cert_file=None,
+                 strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
+                 ssl_context=None, **kw):
+
+        HTTPConnection.__init__(self, host, port, strict=strict,
+                                timeout=timeout, **kw)
+
+        self.key_file = key_file
+        self.cert_file = cert_file
+        self.ssl_context = ssl_context
+
+        # Required property for Google AppEngine 1.9.0 which otherwise causes
+        # HTTPS requests to go out as HTTP. (See Issue #356)
+        self._protocol = 'https'
+
+    def connect(self):
+        conn = self._new_conn()
+        self._prepare_conn(conn)
+
+        if self.ssl_context is None:
+            self.ssl_context = create_urllib3_context(
+                ssl_version=resolve_ssl_version(None),
+                cert_reqs=resolve_cert_reqs(None),
+            )
+
+        self.sock = ssl_wrap_socket(
+            sock=conn,
+            keyfile=self.key_file,
+            certfile=self.cert_file,
+            ssl_context=self.ssl_context,
+        )
+
+
+class VerifiedHTTPSConnection(HTTPSConnection):
+    """
+    Based on httplib.HTTPSConnection but wraps the socket with
+    SSL certification.
+    """
+    cert_reqs = None
+    ca_certs = None
+    ca_cert_dir = None
+    ssl_version = None
+    assert_fingerprint = None
+
+    def set_cert(self, key_file=None, cert_file=None,
+                 cert_reqs=None, ca_certs=None,
+                 assert_hostname=None, assert_fingerprint=None,
+                 ca_cert_dir=None):
+        """
+        This method should only be called once, before the connection is used.
+        """
+        # If cert_reqs is not provided, we can try to guess. If the user gave
+        # us a cert database, we assume they want to use it: otherwise, if
+        # they gave us an SSL Context object we should use whatever is set for
+        # it.
+        if cert_reqs is None:
+            if ca_certs or ca_cert_dir:
+                cert_reqs = 'CERT_REQUIRED'
+            elif self.ssl_context is not None:
+                cert_reqs = self.ssl_context.verify_mode
+
+        self.key_file = key_file
+        self.cert_file = cert_file
+        self.cert_reqs = cert_reqs
+        self.assert_hostname = assert_hostname
+        self.assert_fingerprint = assert_fingerprint
+        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)
+        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)
+
+    def connect(self):
+        # Add certificate verification
+        conn = self._new_conn()
+
+        hostname = self.host
+        if getattr(self, '_tunnel_host', None):
+            # _tunnel_host was added in Python 2.6.3
+            # (See: http://hg.python.org/cpython/rev/0f57b30a152f)
+
+            self.sock = conn
+            # Calls self._set_hostport(), so self.host is
+            # self._tunnel_host below.
+            self._tunnel()
+            # Mark this connection as not reusable
+            self.auto_open = 0
+
+            # Override the host with the one we're requesting data from.
+            hostname = self._tunnel_host
+
+        is_time_off = datetime.date.today() < RECENT_DATE
+        if is_time_off:
+            warnings.warn((
+                'System time is way off (before {0}). This will probably '
+                'lead to SSL verification errors').format(RECENT_DATE),
+                SystemTimeWarning
+            )
+
+        # Wrap socket using verification with the root certs in
+        # trusted_root_certs
+        if self.ssl_context is None:
+            self.ssl_context = create_urllib3_context(
+                ssl_version=resolve_ssl_version(self.ssl_version),
+                cert_reqs=resolve_cert_reqs(self.cert_reqs),
+            )
+
+        context = self.ssl_context
+        context.verify_mode = resolve_cert_reqs(self.cert_reqs)
+        self.sock = ssl_wrap_socket(
+            sock=conn,
+            keyfile=self.key_file,
+            certfile=self.cert_file,
+            ca_certs=self.ca_certs,
+            ca_cert_dir=self.ca_cert_dir,
+            server_hostname=hostname,
+            ssl_context=context)
+
+        if self.assert_fingerprint:
+            assert_fingerprint(self.sock.getpeercert(binary_form=True),
+                               self.assert_fingerprint)
+        elif context.verify_mode != ssl.CERT_NONE \
+                and self.assert_hostname is not False:
+            cert = self.sock.getpeercert()
+            if not cert.get('subjectAltName', ()):
+                warnings.warn((
+                    'Certificate for {0} has no `subjectAltName`, falling back to check for a '
+                    '`commonName` for now. This feature is being removed by major browsers and '
+                    'deprecated by RFC 2818. (See https://github.com/shazow/urllib3/issues/497 '
+                    'for details.)'.format(hostname)),
+                    SubjectAltNameWarning
+                )
+            _match_hostname(cert, self.assert_hostname or hostname)
+
+        self.is_verified = (
+            context.verify_mode == ssl.CERT_REQUIRED or
+            self.assert_fingerprint is not None
+        )
+
+
+def _match_hostname(cert, asserted_hostname):
+    try:
+        match_hostname(cert, asserted_hostname)
+    except CertificateError as e:
+        log.error(
+            'Certificate did not match expected hostname: %s. '
+            'Certificate: %s', asserted_hostname, cert
+        )
+        # Add cert to exception and reraise so client code can inspect
+        # the cert when catching the exception, if they want to
+        e._peer_cert = cert
+        raise
+
+
+if ssl:
+    # Make a copy for testing.
+    UnverifiedHTTPSConnection = HTTPSConnection
+    HTTPSConnection = VerifiedHTTPSConnection
+else:
+    HTTPSConnection = DummyConnection
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/connectionpool.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/connectionpool.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,912 +1,912 @@
-from __future__ import absolute_import
-import errno
-import logging
-import sys
-import warnings
-
-from socket import error as SocketError, timeout as SocketTimeout
-import socket
-
-
-from .exceptions import (
-    ClosedPoolError,
-    ProtocolError,
-    EmptyPoolError,
-    HeaderParsingError,
-    HostChangedError,
-    LocationValueError,
-    MaxRetryError,
-    ProxyError,
-    ReadTimeoutError,
-    SSLError,
-    TimeoutError,
-    InsecureRequestWarning,
-    NewConnectionError,
-    ConnectTimeoutError,
-)
-from .packages.ssl_match_hostname import CertificateError
-from .packages import six
-from .packages.six.moves import queue
-from .connection import (
-    port_by_scheme,
-    DummyConnection,
-    HTTPConnection, HTTPSConnection, VerifiedHTTPSConnection,
-    HTTPException, BaseSSLError,
-)
-from .request import RequestMethods
-from .response import HTTPResponse
-
-from .util.connection import is_connection_dropped
-from .util.request import set_file_position
-from .util.response import assert_header_parsing
-from .util.retry import Retry
-from .util.timeout import Timeout
-from .util.url import get_host, Url
-
-
-if six.PY2:
-    # Queue is imported for side effects on MS Windows
-    import Queue as _unused_module_Queue  # noqa: F401
-
-xrange = six.moves.xrange
-
-log = logging.getLogger(__name__)
-
-_Default = object()
-
-
-# Pool objects
-class ConnectionPool(object):
-    """
-    Base class for all connection pools, such as
-    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.
-    """
-
-    scheme = None
-    QueueCls = queue.LifoQueue
-
-    def __init__(self, host, port=None):
-        if not host:
-            raise LocationValueError("No host specified.")
-
-        self.host = _ipv6_host(host).lower()
-        self.port = port
-
-    def __str__(self):
-        return '%s(host=%r, port=%r)' % (type(self).__name__,
-                                         self.host, self.port)
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.close()
-        # Return False to re-raise any potential exceptions
-        return False
-
-    def close(self):
-        """
-        Close all pooled connections and disable the pool.
-        """
-        pass
-
-
-# This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252
-_blocking_errnos = set([errno.EAGAIN, errno.EWOULDBLOCK])
-
-
-class HTTPConnectionPool(ConnectionPool, RequestMethods):
-    """
-    Thread-safe connection pool for one host.
-
-    :param host:
-        Host used for this HTTP Connection (e.g. "localhost"), passed into
-        :class:`httplib.HTTPConnection`.
-
-    :param port:
-        Port used for this HTTP Connection (None is equivalent to 80), passed
-        into :class:`httplib.HTTPConnection`.
-
-    :param strict:
-        Causes BadStatusLine to be raised if the status line can't be parsed
-        as a valid HTTP/1.0 or 1.1 status line, passed into
-        :class:`httplib.HTTPConnection`.
-
-        .. note::
-           Only works in Python 2. This parameter is ignored in Python 3.
-
-    :param timeout:
-        Socket timeout in seconds for each individual connection. This can
-        be a float or integer, which sets the timeout for the HTTP request,
-        or an instance of :class:`urllib3.util.Timeout` which gives you more
-        fine-grained control over request timeouts. After the constructor has
-        been parsed, this is always a `urllib3.util.Timeout` object.
-
-    :param maxsize:
-        Number of connections to save that can be reused. More than 1 is useful
-        in multithreaded situations. If ``block`` is set to False, more
-        connections will be created but they will not be saved once they've
-        been used.
-
-    :param block:
-        If set to True, no more than ``maxsize`` connections will be used at
-        a time. When no free connections are available, the call will block
-        until a connection has been released. This is a useful side effect for
-        particular multithreaded situations where one does not want to use more
-        than maxsize connections per host to prevent flooding.
-
-    :param headers:
-        Headers to include with all requests, unless other headers are given
-        explicitly.
-
-    :param retries:
-        Retry configuration to use by default with requests in this pool.
-
-    :param _proxy:
-        Parsed proxy URL, should not be used directly, instead, see
-        :class:`urllib3.connectionpool.ProxyManager`"
-
-    :param _proxy_headers:
-        A dictionary with proxy headers, should not be used directly,
-        instead, see :class:`urllib3.connectionpool.ProxyManager`"
-
-    :param \\**conn_kw:
-        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,
-        :class:`urllib3.connection.HTTPSConnection` instances.
-    """
-
-    scheme = 'http'
-    ConnectionCls = HTTPConnection
-    ResponseCls = HTTPResponse
-
-    def __init__(self, host, port=None, strict=False,
-                 timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False,
-                 headers=None, retries=None,
-                 _proxy=None, _proxy_headers=None,
-                 **conn_kw):
-        ConnectionPool.__init__(self, host, port)
-        RequestMethods.__init__(self, headers)
-
-        self.strict = strict
-
-        if not isinstance(timeout, Timeout):
-            timeout = Timeout.from_float(timeout)
-
-        if retries is None:
-            retries = Retry.DEFAULT
-
-        self.timeout = timeout
-        self.retries = retries
-
-        self.pool = self.QueueCls(maxsize)
-        self.block = block
-
-        self.proxy = _proxy
-        self.proxy_headers = _proxy_headers or {}
-
-        # Fill the queue up so that doing get() on it will block properly
-        for _ in xrange(maxsize):
-            self.pool.put(None)
-
-        # These are mostly for testing and debugging purposes.
-        self.num_connections = 0
-        self.num_requests = 0
-        self.conn_kw = conn_kw
-
-        if self.proxy:
-            # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.
-            # We cannot know if the user has added default socket options, so we cannot replace the
-            # list.
-            self.conn_kw.setdefault('socket_options', [])
-
-    def _new_conn(self):
-        """
-        Return a fresh :class:`HTTPConnection`.
-        """
-        self.num_connections += 1
-        log.debug("Starting new HTTP connection (%d): %s",
-                  self.num_connections, self.host)
-
-        conn = self.ConnectionCls(host=self.host, port=self.port,
-                                  timeout=self.timeout.connect_timeout,
-                                  strict=self.strict, **self.conn_kw)
-        return conn
-
-    def _get_conn(self, timeout=None):
-        """
-        Get a connection. Will return a pooled connection if one is available.
-
-        If no connections are available and :prop:`.block` is ``False``, then a
-        fresh connection is returned.
-
-        :param timeout:
-            Seconds to wait before giving up and raising
-            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and
-            :prop:`.block` is ``True``.
-        """
-        conn = None
-        try:
-            conn = self.pool.get(block=self.block, timeout=timeout)
-
-        except AttributeError:  # self.pool is None
-            raise ClosedPoolError(self, "Pool is closed.")
-
-        except queue.Empty:
-            if self.block:
-                raise EmptyPoolError(self,
-                                     "Pool reached maximum size and no more "
-                                     "connections are allowed.")
-            pass  # Oh well, we'll create a new connection then
-
-        # If this is a persistent connection, check if it got disconnected
-        if conn and is_connection_dropped(conn):
-            log.debug("Resetting dropped connection: %s", self.host)
-            conn.close()
-            if getattr(conn, 'auto_open', 1) == 0:
-                # This is a proxied connection that has been mutated by
-                # httplib._tunnel() and cannot be reused (since it would
-                # attempt to bypass the proxy)
-                conn = None
-
-        return conn or self._new_conn()
-
-    def _put_conn(self, conn):
-        """
-        Put a connection back into the pool.
-
-        :param conn:
-            Connection object for the current host and port as returned by
-            :meth:`._new_conn` or :meth:`._get_conn`.
-
-        If the pool is already full, the connection is closed and discarded
-        because we exceeded maxsize. If connections are discarded frequently,
-        then maxsize should be increased.
-
-        If the pool is closed, then the connection will be closed and discarded.
-        """
-        try:
-            self.pool.put(conn, block=False)
-            return  # Everything is dandy, done.
-        except AttributeError:
-            # self.pool is None.
-            pass
-        except queue.Full:
-            # This should never happen if self.block == True
-            log.warning(
-                "Connection pool is full, discarding connection: %s",
-                self.host)
-
-        # Connection never got put back into the pool, close it.
-        if conn:
-            conn.close()
-
-    def _validate_conn(self, conn):
-        """
-        Called right before a request is made, after the socket is created.
-        """
-        # Force connect early to allow us to set read timeout in time
-        if not getattr(conn, 'sock', None):  # AppEngine might not have  `.sock`
-            conn.connect()
-
-    def _prepare_proxy(self, conn):
-        # Nothing to do for HTTP connections.
-        pass
-
-    def _get_timeout(self, timeout):
-        """ Helper that always returns a :class:`urllib3.util.Timeout` """
-        if timeout is _Default:
-            return self.timeout.clone()
-
-        if isinstance(timeout, Timeout):
-            return timeout.clone()
-        else:
-            # User passed us an int/float. This is for backwards compatibility,
-            # can be removed later
-            return Timeout.from_float(timeout)
-
-    def _raise_timeout(self, err, url, timeout_value, exc_cls):
-        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
-
-        # exc_cls is either ReadTimeoutError or ConnectTimeoutError
-        # Only ReadTimeoutError requires the url (preserving old behaviour)
-        args = [self]
-        if exc_cls is ReadTimeoutError:
-            args.append(url)
-            desc = 'Read'
-        else:
-            desc = 'Connect'
-
-        if isinstance(err, SocketTimeout):
-            args.append("%s timed out. (%s timeout=%s)" % (desc, desc.lower(), timeout_value))
-            raise exc_cls(*args)
-
-        # See the above comment about EAGAIN in Python 3. In Python 2 we have
-        # to specifically catch it and throw the timeout error
-        elif hasattr(err, 'errno') and err.errno in _blocking_errnos:
-            args.append("%s timed out. (%s timeout=%s)" % (desc, desc.lower(), timeout_value))
-            raise exc_cls(*args)
-
-        # Catch possible read timeouts thrown as SSL errors. If not the
-        # case, rethrow the original. We need to do this because of:
-        # http://bugs.python.org/issue10272
-        elif 'timed out' in str(err) or 'did not complete (read)' in str(err):  # Python 2.6
-            args.append("%s timed out. (%s timeout=%s)" % (desc, desc.lower(), timeout_value))
-            raise exc_cls(*args)
-
-    def _make_request(self, conn, method, url, timeout=_Default, chunked=False,
-                      **httplib_request_kw):
-        """
-        Perform a request on a given urllib connection object taken from our
-        pool.
-
-        :param conn:
-            a connection from one of our connection pools
-
-        :param timeout:
-            Socket timeout in seconds for the request. This can be a
-            float or integer, which will set the same timeout value for
-            the socket connect and the socket read, or an instance of
-            :class:`urllib3.util.Timeout`, which gives you more fine-grained
-            control over your timeouts.
-        """
-        self.num_requests += 1
-
-        timeout_obj = self._get_timeout(timeout)
-        timeout_obj.start_connect()
-        conn.timeout = timeout_obj.connect_timeout
-
-        # Trigger any extra validation we need to do.
-        try:
-            self._validate_conn(conn)
-        except (SocketTimeout, BaseSSLError) as e:
-            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
-            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout,
-                                exc_cls=ConnectTimeoutError)
-            raise
-
-        # Reset the timeout for the recv() on the socket
-        read_timeout = timeout_obj.read_timeout
-
-        # App Engine doesn't have a sock attr
-        if getattr(conn, 'sock', None):
-            # In Python 3 socket.py will catch EAGAIN and return None when you
-            # try and read into the file pointer created by http.client, which
-            # instead raises a BadStatusLine exception. Instead of catching
-            # the exception and assuming all BadStatusLine exceptions are read
-            # timeouts, check for a zero timeout before making the request.
-            if read_timeout == 0:
-                raise ReadTimeoutError(
-                    self, url, "Read timed out. (read timeout=%s)" % read_timeout)
-            if read_timeout is Timeout.DEFAULT_TIMEOUT:
-                conn.sock.settimeout(socket.getdefaulttimeout())
-            else:  # None or a value
-                conn.sock.settimeout(read_timeout)
-
-        # conn.request() calls httplib.*.request, not the method in
-        # urllib3.request. It also calls makefile (recv) on the socket.
-        if chunked:
-            conn.request_chunked(method, url, **httplib_request_kw)
-        else:
-            conn.request(method, url, **httplib_request_kw)
-
-        # Receive the response from the server
-        try:
-            try:  # Python 2.7, use buffering of HTTP responses
-                httplib_response = conn.getresponse(buffering=True)
-            except TypeError:  # Python 2.6 and older, Python 3
-                try:
-                    httplib_response = conn.getresponse()
-                except Exception as e:
-                    # Remove the TypeError from the exception chain in Python 3;
-                    # otherwise it looks like a programming error was the cause.
-                    six.raise_from(e, None)
-        except (SocketTimeout, BaseSSLError, SocketError) as e:
-            self._raise_timeout(err=e, url=url, timeout_value=read_timeout,
-                                exc_cls=ReadTimeoutError)
-            raise
-
-        # AppEngine doesn't have a version attr.
-        http_version = getattr(conn, '_http_vsn_str', 'HTTP/?')
-        log.debug("%s://%s:%s \"%s %s %s\" %s %s", self.scheme, self.host, self.port,
-                  method, url, http_version, httplib_response.status,
-                  httplib_response.length)
-
-        try:
-            assert_header_parsing(httplib_response.msg)
-        except HeaderParsingError as hpe:  # Platform-specific: Python 3
-            log.warning(
-                'Failed to parse headers (url=%s): %s',
-                self._absolute_url(url), hpe, exc_info=True)
-
-        return httplib_response
-
-    def _absolute_url(self, path):
-        return Url(scheme=self.scheme, host=self.host, port=self.port, path=path).url
-
-    def close(self):
-        """
-        Close all pooled connections and disable the pool.
-        """
-        # Disable access to the pool
-        old_pool, self.pool = self.pool, None
-
-        try:
-            while True:
-                conn = old_pool.get(block=False)
-                if conn:
-                    conn.close()
-
-        except queue.Empty:
-            pass  # Done.
-
-    def is_same_host(self, url):
-        """
-        Check if the given ``url`` is a member of the same host as this
-        connection pool.
-        """
-        if url.startswith('/'):
-            return True
-
-        # TODO: Add optional support for socket.gethostbyname checking.
-        scheme, host, port = get_host(url)
-
-        host = _ipv6_host(host).lower()
-
-        # Use explicit default port for comparison when none is given
-        if self.port and not port:
-            port = port_by_scheme.get(scheme)
-        elif not self.port and port == port_by_scheme.get(scheme):
-            port = None
-
-        return (scheme, host, port) == (self.scheme, self.host, self.port)
-
-    def urlopen(self, method, url, body=None, headers=None, retries=None,
-                redirect=True, assert_same_host=True, timeout=_Default,
-                pool_timeout=None, release_conn=None, chunked=False,
-                body_pos=None, **response_kw):
-        """
-        Get a connection from the pool and perform an HTTP request. This is the
-        lowest level call for making a request, so you'll need to specify all
-        the raw details.
-
-        .. note::
-
-           More commonly, it's appropriate to use a convenience method provided
-           by :class:`.RequestMethods`, such as :meth:`request`.
-
-        .. note::
-
-           `release_conn` will only behave as expected if
-           `preload_content=False` because we want to make
-           `preload_content=False` the default behaviour someday soon without
-           breaking backwards compatibility.
-
-        :param method:
-            HTTP request method (such as GET, POST, PUT, etc.)
-
-        :param body:
-            Data to send in the request body (useful for creating
-            POST requests, see HTTPConnectionPool.post_url for
-            more convenience).
-
-        :param headers:
-            Dictionary of custom headers to send, such as User-Agent,
-            If-None-Match, etc. If None, pool headers are used. If provided,
-            these headers completely replace any pool-specific headers.
-
-        :param retries:
-            Configure the number of retries to allow before raising a
-            :class:`~urllib3.exceptions.MaxRetryError` exception.
-
-            Pass ``None`` to retry until you receive a response. Pass a
-            :class:`~urllib3.util.retry.Retry` object for fine-grained control
-            over different types of retries.
-            Pass an integer number to retry connection errors that many times,
-            but no other types of errors. Pass zero to never retry.
-
-            If ``False``, then retries are disabled and any exception is raised
-            immediately. Also, instead of raising a MaxRetryError on redirects,
-            the redirect response will be returned.
-
-        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
-
-        :param redirect:
-            If True, automatically handle redirects (status codes 301, 302,
-            303, 307, 308). Each redirect counts as a retry. Disabling retries
-            will disable redirect, too.
-
-        :param assert_same_host:
-            If ``True``, will make sure that the host of the pool requests is
-            consistent else will raise HostChangedError. When False, you can
-            use the pool on an HTTP proxy and request foreign hosts.
-
-        :param timeout:
-            If specified, overrides the default timeout for this one
-            request. It may be a float (in seconds) or an instance of
-            :class:`urllib3.util.Timeout`.
-
-        :param pool_timeout:
-            If set and the pool is set to block=True, then this method will
-            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
-            connection is available within the time period.
-
-        :param release_conn:
-            If False, then the urlopen call will not release the connection
-            back into the pool once a response is received (but will release if
-            you read the entire contents of the response such as when
-            `preload_content=True`). This is useful if you're not preloading
-            the response's content immediately. You will need to call
-            ``r.release_conn()`` on the response ``r`` to return the connection
-            back into the pool. If None, it takes the value of
-            ``response_kw.get('preload_content', True)``.
-
-        :param chunked:
-            If True, urllib3 will send the body using chunked transfer
-            encoding. Otherwise, urllib3 will send the body using the standard
-            content-length form. Defaults to False.
-
-        :param int body_pos:
-            Position to seek to in file-like body in the event of a retry or
-            redirect. Typically this won't need to be set because urllib3 will
-            auto-populate the value when needed.
-
-        :param \\**response_kw:
-            Additional parameters are passed to
-            :meth:`urllib3.response.HTTPResponse.from_httplib`
-        """
-        if headers is None:
-            headers = self.headers
-
-        if not isinstance(retries, Retry):
-            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
-
-        if release_conn is None:
-            release_conn = response_kw.get('preload_content', True)
-
-        # Check host
-        if assert_same_host and not self.is_same_host(url):
-            raise HostChangedError(self, url, retries)
-
-        conn = None
-
-        # Track whether `conn` needs to be released before
-        # returning/raising/recursing. Update this variable if necessary, and
-        # leave `release_conn` constant throughout the function. That way, if
-        # the function recurses, the original value of `release_conn` will be
-        # passed down into the recursive call, and its value will be respected.
-        #
-        # See issue #651 [1] for details.
-        #
-        # [1] <https://github.com/shazow/urllib3/issues/651>
-        release_this_conn = release_conn
-
-        # Merge the proxy headers. Only do this in HTTP. We have to copy the
-        # headers dict so we can safely change it without those changes being
-        # reflected in anyone else's copy.
-        if self.scheme == 'http':
-            headers = headers.copy()
-            headers.update(self.proxy_headers)
-
-        # Must keep the exception bound to a separate variable or else Python 3
-        # complains about UnboundLocalError.
-        err = None
-
-        # Keep track of whether we cleanly exited the except block. This
-        # ensures we do proper cleanup in finally.
-        clean_exit = False
-
-        # Rewind body position, if needed. Record current position
-        # for future rewinds in the event of a redirect/retry.
-        body_pos = set_file_position(body, body_pos)
-
-        try:
-            # Request a connection from the queue.
-            timeout_obj = self._get_timeout(timeout)
-            conn = self._get_conn(timeout=pool_timeout)
-
-            conn.timeout = timeout_obj.connect_timeout
-
-            is_new_proxy_conn = self.proxy is not None and not getattr(conn, 'sock', None)
-            if is_new_proxy_conn:
-                self._prepare_proxy(conn)
-
-            # Make the request on the httplib connection object.
-            httplib_response = self._make_request(conn, method, url,
-                                                  timeout=timeout_obj,
-                                                  body=body, headers=headers,
-                                                  chunked=chunked)
-
-            # If we're going to release the connection in ``finally:``, then
-            # the response doesn't need to know about the connection. Otherwise
-            # it will also try to release it and we'll have a double-release
-            # mess.
-            response_conn = conn if not release_conn else None
-
-            # Pass method to Response for length checking
-            response_kw['request_method'] = method
-
-            # Import httplib's response into our own wrapper object
-            response = self.ResponseCls.from_httplib(httplib_response,
-                                                     pool=self,
-                                                     connection=response_conn,
-                                                     retries=retries,
-                                                     **response_kw)
-
-            # Everything went great!
-            clean_exit = True
-
-        except queue.Empty:
-            # Timed out by queue.
-            raise EmptyPoolError(self, "No pool connections are available.")
-
-        except (BaseSSLError, CertificateError) as e:
-            # Close the connection. If a connection is reused on which there
-            # was a Certificate error, the next request will certainly raise
-            # another Certificate error.
-            clean_exit = False
-            raise SSLError(e)
-
-        except SSLError:
-            # Treat SSLError separately from BaseSSLError to preserve
-            # traceback.
-            clean_exit = False
-            raise
-
-        except (TimeoutError, HTTPException, SocketError, ProtocolError) as e:
-            # Discard the connection for these exceptions. It will be
-            # be replaced during the next _get_conn() call.
-            clean_exit = False
-
-            if isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
-                e = ProxyError('Cannot connect to proxy.', e)
-            elif isinstance(e, (SocketError, HTTPException)):
-                e = ProtocolError('Connection aborted.', e)
-
-            retries = retries.increment(method, url, error=e, _pool=self,
-                                        _stacktrace=sys.exc_info()[2])
-            retries.sleep()
-
-            # Keep track of the error for the retry warning.
-            err = e
-
-        finally:
-            if not clean_exit:
-                # We hit some kind of exception, handled or otherwise. We need
-                # to throw the connection away unless explicitly told not to.
-                # Close the connection, set the variable to None, and make sure
-                # we put the None back in the pool to avoid leaking it.
-                conn = conn and conn.close()
-                release_this_conn = True
-
-            if release_this_conn:
-                # Put the connection back to be reused. If the connection is
-                # expired then it will be None, which will get replaced with a
-                # fresh connection during _get_conn.
-                self._put_conn(conn)
-
-        if not conn:
-            # Try again
-            log.warning("Retrying (%r) after connection "
-                        "broken by '%r': %s", retries, err, url)
-            return self.urlopen(method, url, body, headers, retries,
-                                redirect, assert_same_host,
-                                timeout=timeout, pool_timeout=pool_timeout,
-                                release_conn=release_conn, body_pos=body_pos,
-                                **response_kw)
-
-        # Handle redirect?
-        redirect_location = redirect and response.get_redirect_location()
-        if redirect_location:
-            if response.status == 303:
-                method = 'GET'
-
-            try:
-                retries = retries.increment(method, url, response=response, _pool=self)
-            except MaxRetryError:
-                if retries.raise_on_redirect:
-                    # Release the connection for this response, since we're not
-                    # returning it to be released manually.
-                    response.release_conn()
-                    raise
-                return response
-
-            retries.sleep_for_retry(response)
-            log.debug("Redirecting %s -> %s", url, redirect_location)
-            return self.urlopen(
-                method, redirect_location, body, headers,
-                retries=retries, redirect=redirect,
-                assert_same_host=assert_same_host,
-                timeout=timeout, pool_timeout=pool_timeout,
-                release_conn=release_conn, body_pos=body_pos,
-                **response_kw)
-
-        # Check if we should retry the HTTP response.
-        has_retry_after = bool(response.getheader('Retry-After'))
-        if retries.is_retry(method, response.status, has_retry_after):
-            try:
-                retries = retries.increment(method, url, response=response, _pool=self)
-            except MaxRetryError:
-                if retries.raise_on_status:
-                    # Release the connection for this response, since we're not
-                    # returning it to be released manually.
-                    response.release_conn()
-                    raise
-                return response
-            retries.sleep(response)
-            log.debug("Retry: %s", url)
-            return self.urlopen(
-                method, url, body, headers,
-                retries=retries, redirect=redirect,
-                assert_same_host=assert_same_host,
-                timeout=timeout, pool_timeout=pool_timeout,
-                release_conn=release_conn,
-                body_pos=body_pos, **response_kw)
-
-        return response
-
-
-class HTTPSConnectionPool(HTTPConnectionPool):
-    """
-    Same as :class:`.HTTPConnectionPool`, but HTTPS.
-
-    When Python is compiled with the :mod:`ssl` module, then
-    :class:`.VerifiedHTTPSConnection` is used, which *can* verify certificates,
-    instead of :class:`.HTTPSConnection`.
-
-    :class:`.VerifiedHTTPSConnection` uses one of ``assert_fingerprint``,
-    ``assert_hostname`` and ``host`` in this order to verify connections.
-    If ``assert_hostname`` is False, no verification is done.
-
-    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,
-    ``ca_cert_dir``, and ``ssl_version`` are only used if :mod:`ssl` is
-    available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade
-    the connection socket into an SSL socket.
-    """
-
-    scheme = 'https'
-    ConnectionCls = HTTPSConnection
-
-    def __init__(self, host, port=None,
-                 strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1,
-                 block=False, headers=None, retries=None,
-                 _proxy=None, _proxy_headers=None,
-                 key_file=None, cert_file=None, cert_reqs=None,
-                 ca_certs=None, ssl_version=None,
-                 assert_hostname=None, assert_fingerprint=None,
-                 ca_cert_dir=None, **conn_kw):
-
-        HTTPConnectionPool.__init__(self, host, port, strict, timeout, maxsize,
-                                    block, headers, retries, _proxy, _proxy_headers,
-                                    **conn_kw)
-
-        if ca_certs and cert_reqs is None:
-            cert_reqs = 'CERT_REQUIRED'
-
-        self.key_file = key_file
-        self.cert_file = cert_file
-        self.cert_reqs = cert_reqs
-        self.ca_certs = ca_certs
-        self.ca_cert_dir = ca_cert_dir
-        self.ssl_version = ssl_version
-        self.assert_hostname = assert_hostname
-        self.assert_fingerprint = assert_fingerprint
-
-    def _prepare_conn(self, conn):
-        """
-        Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`
-        and establish the tunnel if proxy is used.
-        """
-
-        if isinstance(conn, VerifiedHTTPSConnection):
-            conn.set_cert(key_file=self.key_file,
-                          cert_file=self.cert_file,
-                          cert_reqs=self.cert_reqs,
-                          ca_certs=self.ca_certs,
-                          ca_cert_dir=self.ca_cert_dir,
-                          assert_hostname=self.assert_hostname,
-                          assert_fingerprint=self.assert_fingerprint)
-            conn.ssl_version = self.ssl_version
-        return conn
-
-    def _prepare_proxy(self, conn):
-        """
-        Establish tunnel connection early, because otherwise httplib
-        would improperly set Host: header to proxy's IP:port.
-        """
-        # Python 2.7+
-        try:
-            set_tunnel = conn.set_tunnel
-        except AttributeError:  # Platform-specific: Python 2.6
-            set_tunnel = conn._set_tunnel
-
-        if sys.version_info <= (2, 6, 4) and not self.proxy_headers:  # Python 2.6.4 and older
-            set_tunnel(self.host, self.port)
-        else:
-            set_tunnel(self.host, self.port, self.proxy_headers)
-
-        conn.connect()
-
-    def _new_conn(self):
-        """
-        Return a fresh :class:`httplib.HTTPSConnection`.
-        """
-        self.num_connections += 1
-        log.debug("Starting new HTTPS connection (%d): %s",
-                  self.num_connections, self.host)
-
-        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:
-            raise SSLError("Can't connect to HTTPS URL because the SSL "
-                           "module is not available.")
-
-        actual_host = self.host
-        actual_port = self.port
-        if self.proxy is not None:
-            actual_host = self.proxy.host
-            actual_port = self.proxy.port
-
-        conn = self.ConnectionCls(host=actual_host, port=actual_port,
-                                  timeout=self.timeout.connect_timeout,
-                                  strict=self.strict, **self.conn_kw)
-
-        return self._prepare_conn(conn)
-
-    def _validate_conn(self, conn):
-        """
-        Called right before a request is made, after the socket is created.
-        """
-        super(HTTPSConnectionPool, self)._validate_conn(conn)
-
-        if not conn.is_verified:
-            warnings.warn((
-                'Unverified HTTPS request is being made. '
-                'Adding certificate verification is strongly advised. See: '
-                'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
-                '#ssl-warnings'),
-                InsecureRequestWarning)
-
-
-def connection_from_url(url, **kw):
-    """
-    Given a url, return an :class:`.ConnectionPool` instance of its host.
-
-    This is a shortcut for not having to parse out the scheme, host, and port
-    of the url before creating an :class:`.ConnectionPool` instance.
-
-    :param url:
-        Absolute URL string that must include the scheme. Port is optional.
-
-    :param \\**kw:
-        Passes additional parameters to the constructor of the appropriate
-        :class:`.ConnectionPool`. Useful for specifying things like
-        timeout, maxsize, headers, etc.
-
-    Example::
-
-        >>> conn = connection_from_url('http://google.com/')
-        >>> r = conn.request('GET', '/')
-    """
-    scheme, host, port = get_host(url)
-    port = port or port_by_scheme.get(scheme, 80)
-    if scheme == 'https':
-        return HTTPSConnectionPool(host, port=port, **kw)
-    else:
-        return HTTPConnectionPool(host, port=port, **kw)
-
-
-def _ipv6_host(host):
-    """
-    Process IPv6 address literals
-    """
-
-    # httplib doesn't like it when we include brackets in IPv6 addresses
-    # Specifically, if we include brackets but also pass the port then
-    # httplib crazily doubles up the square brackets on the Host header.
-    # Instead, we need to make sure we never pass ``None`` as the port.
-    # However, for backward compatibility reasons we can't actually
-    # *assert* that.  See http://bugs.python.org/issue28539
-    #
-    # Also if an IPv6 address literal has a zone identifier, the
-    # percent sign might be URIencoded, convert it back into ASCII
-    if host.startswith('[') and host.endswith(']'):
-        host = host.replace('%25', '%').strip('[]')
-    return host
+from __future__ import absolute_import
+import errno
+import logging
+import sys
+import warnings
+
+from socket import error as SocketError, timeout as SocketTimeout
+import socket
+
+
+from .exceptions import (
+    ClosedPoolError,
+    ProtocolError,
+    EmptyPoolError,
+    HeaderParsingError,
+    HostChangedError,
+    LocationValueError,
+    MaxRetryError,
+    ProxyError,
+    ReadTimeoutError,
+    SSLError,
+    TimeoutError,
+    InsecureRequestWarning,
+    NewConnectionError,
+    ConnectTimeoutError,
+)
+from .packages.ssl_match_hostname import CertificateError
+from .packages import six
+from .packages.six.moves import queue
+from .connection import (
+    port_by_scheme,
+    DummyConnection,
+    HTTPConnection, HTTPSConnection, VerifiedHTTPSConnection,
+    HTTPException, BaseSSLError,
+)
+from .request import RequestMethods
+from .response import HTTPResponse
+
+from .util.connection import is_connection_dropped
+from .util.request import set_file_position
+from .util.response import assert_header_parsing
+from .util.retry import Retry
+from .util.timeout import Timeout
+from .util.url import get_host, Url
+
+
+if six.PY2:
+    # Queue is imported for side effects on MS Windows
+    import Queue as _unused_module_Queue  # noqa: F401
+
+xrange = six.moves.xrange
+
+log = logging.getLogger(__name__)
+
+_Default = object()
+
+
+# Pool objects
+class ConnectionPool(object):
+    """
+    Base class for all connection pools, such as
+    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.
+    """
+
+    scheme = None
+    QueueCls = queue.LifoQueue
+
+    def __init__(self, host, port=None):
+        if not host:
+            raise LocationValueError("No host specified.")
+
+        self.host = _ipv6_host(host).lower()
+        self.port = port
+
+    def __str__(self):
+        return '%s(host=%r, port=%r)' % (type(self).__name__,
+                                         self.host, self.port)
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.close()
+        # Return False to re-raise any potential exceptions
+        return False
+
+    def close(self):
+        """
+        Close all pooled connections and disable the pool.
+        """
+        pass
+
+
+# This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252
+_blocking_errnos = set([errno.EAGAIN, errno.EWOULDBLOCK])
+
+
+class HTTPConnectionPool(ConnectionPool, RequestMethods):
+    """
+    Thread-safe connection pool for one host.
+
+    :param host:
+        Host used for this HTTP Connection (e.g. "localhost"), passed into
+        :class:`httplib.HTTPConnection`.
+
+    :param port:
+        Port used for this HTTP Connection (None is equivalent to 80), passed
+        into :class:`httplib.HTTPConnection`.
+
+    :param strict:
+        Causes BadStatusLine to be raised if the status line can't be parsed
+        as a valid HTTP/1.0 or 1.1 status line, passed into
+        :class:`httplib.HTTPConnection`.
+
+        .. note::
+           Only works in Python 2. This parameter is ignored in Python 3.
+
+    :param timeout:
+        Socket timeout in seconds for each individual connection. This can
+        be a float or integer, which sets the timeout for the HTTP request,
+        or an instance of :class:`urllib3.util.Timeout` which gives you more
+        fine-grained control over request timeouts. After the constructor has
+        been parsed, this is always a `urllib3.util.Timeout` object.
+
+    :param maxsize:
+        Number of connections to save that can be reused. More than 1 is useful
+        in multithreaded situations. If ``block`` is set to False, more
+        connections will be created but they will not be saved once they've
+        been used.
+
+    :param block:
+        If set to True, no more than ``maxsize`` connections will be used at
+        a time. When no free connections are available, the call will block
+        until a connection has been released. This is a useful side effect for
+        particular multithreaded situations where one does not want to use more
+        than maxsize connections per host to prevent flooding.
+
+    :param headers:
+        Headers to include with all requests, unless other headers are given
+        explicitly.
+
+    :param retries:
+        Retry configuration to use by default with requests in this pool.
+
+    :param _proxy:
+        Parsed proxy URL, should not be used directly, instead, see
+        :class:`urllib3.connectionpool.ProxyManager`"
+
+    :param _proxy_headers:
+        A dictionary with proxy headers, should not be used directly,
+        instead, see :class:`urllib3.connectionpool.ProxyManager`"
+
+    :param \\**conn_kw:
+        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,
+        :class:`urllib3.connection.HTTPSConnection` instances.
+    """
+
+    scheme = 'http'
+    ConnectionCls = HTTPConnection
+    ResponseCls = HTTPResponse
+
+    def __init__(self, host, port=None, strict=False,
+                 timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False,
+                 headers=None, retries=None,
+                 _proxy=None, _proxy_headers=None,
+                 **conn_kw):
+        ConnectionPool.__init__(self, host, port)
+        RequestMethods.__init__(self, headers)
+
+        self.strict = strict
+
+        if not isinstance(timeout, Timeout):
+            timeout = Timeout.from_float(timeout)
+
+        if retries is None:
+            retries = Retry.DEFAULT
+
+        self.timeout = timeout
+        self.retries = retries
+
+        self.pool = self.QueueCls(maxsize)
+        self.block = block
+
+        self.proxy = _proxy
+        self.proxy_headers = _proxy_headers or {}
+
+        # Fill the queue up so that doing get() on it will block properly
+        for _ in xrange(maxsize):
+            self.pool.put(None)
+
+        # These are mostly for testing and debugging purposes.
+        self.num_connections = 0
+        self.num_requests = 0
+        self.conn_kw = conn_kw
+
+        if self.proxy:
+            # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.
+            # We cannot know if the user has added default socket options, so we cannot replace the
+            # list.
+            self.conn_kw.setdefault('socket_options', [])
+
+    def _new_conn(self):
+        """
+        Return a fresh :class:`HTTPConnection`.
+        """
+        self.num_connections += 1
+        log.debug("Starting new HTTP connection (%d): %s",
+                  self.num_connections, self.host)
+
+        conn = self.ConnectionCls(host=self.host, port=self.port,
+                                  timeout=self.timeout.connect_timeout,
+                                  strict=self.strict, **self.conn_kw)
+        return conn
+
+    def _get_conn(self, timeout=None):
+        """
+        Get a connection. Will return a pooled connection if one is available.
+
+        If no connections are available and :prop:`.block` is ``False``, then a
+        fresh connection is returned.
+
+        :param timeout:
+            Seconds to wait before giving up and raising
+            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and
+            :prop:`.block` is ``True``.
+        """
+        conn = None
+        try:
+            conn = self.pool.get(block=self.block, timeout=timeout)
+
+        except AttributeError:  # self.pool is None
+            raise ClosedPoolError(self, "Pool is closed.")
+
+        except queue.Empty:
+            if self.block:
+                raise EmptyPoolError(self,
+                                     "Pool reached maximum size and no more "
+                                     "connections are allowed.")
+            pass  # Oh well, we'll create a new connection then
+
+        # If this is a persistent connection, check if it got disconnected
+        if conn and is_connection_dropped(conn):
+            log.debug("Resetting dropped connection: %s", self.host)
+            conn.close()
+            if getattr(conn, 'auto_open', 1) == 0:
+                # This is a proxied connection that has been mutated by
+                # httplib._tunnel() and cannot be reused (since it would
+                # attempt to bypass the proxy)
+                conn = None
+
+        return conn or self._new_conn()
+
+    def _put_conn(self, conn):
+        """
+        Put a connection back into the pool.
+
+        :param conn:
+            Connection object for the current host and port as returned by
+            :meth:`._new_conn` or :meth:`._get_conn`.
+
+        If the pool is already full, the connection is closed and discarded
+        because we exceeded maxsize. If connections are discarded frequently,
+        then maxsize should be increased.
+
+        If the pool is closed, then the connection will be closed and discarded.
+        """
+        try:
+            self.pool.put(conn, block=False)
+            return  # Everything is dandy, done.
+        except AttributeError:
+            # self.pool is None.
+            pass
+        except queue.Full:
+            # This should never happen if self.block == True
+            log.warning(
+                "Connection pool is full, discarding connection: %s",
+                self.host)
+
+        # Connection never got put back into the pool, close it.
+        if conn:
+            conn.close()
+
+    def _validate_conn(self, conn):
+        """
+        Called right before a request is made, after the socket is created.
+        """
+        # Force connect early to allow us to set read timeout in time
+        if not getattr(conn, 'sock', None):  # AppEngine might not have  `.sock`
+            conn.connect()
+
+    def _prepare_proxy(self, conn):
+        # Nothing to do for HTTP connections.
+        pass
+
+    def _get_timeout(self, timeout):
+        """ Helper that always returns a :class:`urllib3.util.Timeout` """
+        if timeout is _Default:
+            return self.timeout.clone()
+
+        if isinstance(timeout, Timeout):
+            return timeout.clone()
+        else:
+            # User passed us an int/float. This is for backwards compatibility,
+            # can be removed later
+            return Timeout.from_float(timeout)
+
+    def _raise_timeout(self, err, url, timeout_value, exc_cls):
+        """Is the error actually a timeout? Will raise a ReadTimeout or pass"""
+
+        # exc_cls is either ReadTimeoutError or ConnectTimeoutError
+        # Only ReadTimeoutError requires the url (preserving old behaviour)
+        args = [self]
+        if exc_cls is ReadTimeoutError:
+            args.append(url)
+            desc = 'Read'
+        else:
+            desc = 'Connect'
+
+        if isinstance(err, SocketTimeout):
+            args.append("%s timed out. (%s timeout=%s)" % (desc, desc.lower(), timeout_value))
+            raise exc_cls(*args)
+
+        # See the above comment about EAGAIN in Python 3. In Python 2 we have
+        # to specifically catch it and throw the timeout error
+        elif hasattr(err, 'errno') and err.errno in _blocking_errnos:
+            args.append("%s timed out. (%s timeout=%s)" % (desc, desc.lower(), timeout_value))
+            raise exc_cls(*args)
+
+        # Catch possible read timeouts thrown as SSL errors. If not the
+        # case, rethrow the original. We need to do this because of:
+        # http://bugs.python.org/issue10272
+        elif 'timed out' in str(err) or 'did not complete (read)' in str(err):  # Python 2.6
+            args.append("%s timed out. (%s timeout=%s)" % (desc, desc.lower(), timeout_value))
+            raise exc_cls(*args)
+
+    def _make_request(self, conn, method, url, timeout=_Default, chunked=False,
+                      **httplib_request_kw):
+        """
+        Perform a request on a given urllib connection object taken from our
+        pool.
+
+        :param conn:
+            a connection from one of our connection pools
+
+        :param timeout:
+            Socket timeout in seconds for the request. This can be a
+            float or integer, which will set the same timeout value for
+            the socket connect and the socket read, or an instance of
+            :class:`urllib3.util.Timeout`, which gives you more fine-grained
+            control over your timeouts.
+        """
+        self.num_requests += 1
+
+        timeout_obj = self._get_timeout(timeout)
+        timeout_obj.start_connect()
+        conn.timeout = timeout_obj.connect_timeout
+
+        # Trigger any extra validation we need to do.
+        try:
+            self._validate_conn(conn)
+        except (SocketTimeout, BaseSSLError) as e:
+            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.
+            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout,
+                                exc_cls=ConnectTimeoutError)
+            raise
+
+        # Reset the timeout for the recv() on the socket
+        read_timeout = timeout_obj.read_timeout
+
+        # App Engine doesn't have a sock attr
+        if getattr(conn, 'sock', None):
+            # In Python 3 socket.py will catch EAGAIN and return None when you
+            # try and read into the file pointer created by http.client, which
+            # instead raises a BadStatusLine exception. Instead of catching
+            # the exception and assuming all BadStatusLine exceptions are read
+            # timeouts, check for a zero timeout before making the request.
+            if read_timeout == 0:
+                raise ReadTimeoutError(
+                    self, url, "Read timed out. (read timeout=%s)" % read_timeout)
+            if read_timeout is Timeout.DEFAULT_TIMEOUT:
+                conn.sock.settimeout(socket.getdefaulttimeout())
+            else:  # None or a value
+                conn.sock.settimeout(read_timeout)
+
+        # conn.request() calls httplib.*.request, not the method in
+        # urllib3.request. It also calls makefile (recv) on the socket.
+        if chunked:
+            conn.request_chunked(method, url, **httplib_request_kw)
+        else:
+            conn.request(method, url, **httplib_request_kw)
+
+        # Receive the response from the server
+        try:
+            try:  # Python 2.7, use buffering of HTTP responses
+                httplib_response = conn.getresponse(buffering=True)
+            except TypeError:  # Python 2.6 and older, Python 3
+                try:
+                    httplib_response = conn.getresponse()
+                except Exception as e:
+                    # Remove the TypeError from the exception chain in Python 3;
+                    # otherwise it looks like a programming error was the cause.
+                    six.raise_from(e, None)
+        except (SocketTimeout, BaseSSLError, SocketError) as e:
+            self._raise_timeout(err=e, url=url, timeout_value=read_timeout,
+                                exc_cls=ReadTimeoutError)
+            raise
+
+        # AppEngine doesn't have a version attr.
+        http_version = getattr(conn, '_http_vsn_str', 'HTTP/?')
+        log.debug("%s://%s:%s \"%s %s %s\" %s %s", self.scheme, self.host, self.port,
+                  method, url, http_version, httplib_response.status,
+                  httplib_response.length)
+
+        try:
+            assert_header_parsing(httplib_response.msg)
+        except HeaderParsingError as hpe:  # Platform-specific: Python 3
+            log.warning(
+                'Failed to parse headers (url=%s): %s',
+                self._absolute_url(url), hpe, exc_info=True)
+
+        return httplib_response
+
+    def _absolute_url(self, path):
+        return Url(scheme=self.scheme, host=self.host, port=self.port, path=path).url
+
+    def close(self):
+        """
+        Close all pooled connections and disable the pool.
+        """
+        # Disable access to the pool
+        old_pool, self.pool = self.pool, None
+
+        try:
+            while True:
+                conn = old_pool.get(block=False)
+                if conn:
+                    conn.close()
+
+        except queue.Empty:
+            pass  # Done.
+
+    def is_same_host(self, url):
+        """
+        Check if the given ``url`` is a member of the same host as this
+        connection pool.
+        """
+        if url.startswith('/'):
+            return True
+
+        # TODO: Add optional support for socket.gethostbyname checking.
+        scheme, host, port = get_host(url)
+
+        host = _ipv6_host(host).lower()
+
+        # Use explicit default port for comparison when none is given
+        if self.port and not port:
+            port = port_by_scheme.get(scheme)
+        elif not self.port and port == port_by_scheme.get(scheme):
+            port = None
+
+        return (scheme, host, port) == (self.scheme, self.host, self.port)
+
+    def urlopen(self, method, url, body=None, headers=None, retries=None,
+                redirect=True, assert_same_host=True, timeout=_Default,
+                pool_timeout=None, release_conn=None, chunked=False,
+                body_pos=None, **response_kw):
+        """
+        Get a connection from the pool and perform an HTTP request. This is the
+        lowest level call for making a request, so you'll need to specify all
+        the raw details.
+
+        .. note::
+
+           More commonly, it's appropriate to use a convenience method provided
+           by :class:`.RequestMethods`, such as :meth:`request`.
+
+        .. note::
+
+           `release_conn` will only behave as expected if
+           `preload_content=False` because we want to make
+           `preload_content=False` the default behaviour someday soon without
+           breaking backwards compatibility.
+
+        :param method:
+            HTTP request method (such as GET, POST, PUT, etc.)
+
+        :param body:
+            Data to send in the request body (useful for creating
+            POST requests, see HTTPConnectionPool.post_url for
+            more convenience).
+
+        :param headers:
+            Dictionary of custom headers to send, such as User-Agent,
+            If-None-Match, etc. If None, pool headers are used. If provided,
+            these headers completely replace any pool-specific headers.
+
+        :param retries:
+            Configure the number of retries to allow before raising a
+            :class:`~urllib3.exceptions.MaxRetryError` exception.
+
+            Pass ``None`` to retry until you receive a response. Pass a
+            :class:`~urllib3.util.retry.Retry` object for fine-grained control
+            over different types of retries.
+            Pass an integer number to retry connection errors that many times,
+            but no other types of errors. Pass zero to never retry.
+
+            If ``False``, then retries are disabled and any exception is raised
+            immediately. Also, instead of raising a MaxRetryError on redirects,
+            the redirect response will be returned.
+
+        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
+
+        :param redirect:
+            If True, automatically handle redirects (status codes 301, 302,
+            303, 307, 308). Each redirect counts as a retry. Disabling retries
+            will disable redirect, too.
+
+        :param assert_same_host:
+            If ``True``, will make sure that the host of the pool requests is
+            consistent else will raise HostChangedError. When False, you can
+            use the pool on an HTTP proxy and request foreign hosts.
+
+        :param timeout:
+            If specified, overrides the default timeout for this one
+            request. It may be a float (in seconds) or an instance of
+            :class:`urllib3.util.Timeout`.
+
+        :param pool_timeout:
+            If set and the pool is set to block=True, then this method will
+            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
+            connection is available within the time period.
+
+        :param release_conn:
+            If False, then the urlopen call will not release the connection
+            back into the pool once a response is received (but will release if
+            you read the entire contents of the response such as when
+            `preload_content=True`). This is useful if you're not preloading
+            the response's content immediately. You will need to call
+            ``r.release_conn()`` on the response ``r`` to return the connection
+            back into the pool. If None, it takes the value of
+            ``response_kw.get('preload_content', True)``.
+
+        :param chunked:
+            If True, urllib3 will send the body using chunked transfer
+            encoding. Otherwise, urllib3 will send the body using the standard
+            content-length form. Defaults to False.
+
+        :param int body_pos:
+            Position to seek to in file-like body in the event of a retry or
+            redirect. Typically this won't need to be set because urllib3 will
+            auto-populate the value when needed.
+
+        :param \\**response_kw:
+            Additional parameters are passed to
+            :meth:`urllib3.response.HTTPResponse.from_httplib`
+        """
+        if headers is None:
+            headers = self.headers
+
+        if not isinstance(retries, Retry):
+            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
+
+        if release_conn is None:
+            release_conn = response_kw.get('preload_content', True)
+
+        # Check host
+        if assert_same_host and not self.is_same_host(url):
+            raise HostChangedError(self, url, retries)
+
+        conn = None
+
+        # Track whether `conn` needs to be released before
+        # returning/raising/recursing. Update this variable if necessary, and
+        # leave `release_conn` constant throughout the function. That way, if
+        # the function recurses, the original value of `release_conn` will be
+        # passed down into the recursive call, and its value will be respected.
+        #
+        # See issue #651 [1] for details.
+        #
+        # [1] <https://github.com/shazow/urllib3/issues/651>
+        release_this_conn = release_conn
+
+        # Merge the proxy headers. Only do this in HTTP. We have to copy the
+        # headers dict so we can safely change it without those changes being
+        # reflected in anyone else's copy.
+        if self.scheme == 'http':
+            headers = headers.copy()
+            headers.update(self.proxy_headers)
+
+        # Must keep the exception bound to a separate variable or else Python 3
+        # complains about UnboundLocalError.
+        err = None
+
+        # Keep track of whether we cleanly exited the except block. This
+        # ensures we do proper cleanup in finally.
+        clean_exit = False
+
+        # Rewind body position, if needed. Record current position
+        # for future rewinds in the event of a redirect/retry.
+        body_pos = set_file_position(body, body_pos)
+
+        try:
+            # Request a connection from the queue.
+            timeout_obj = self._get_timeout(timeout)
+            conn = self._get_conn(timeout=pool_timeout)
+
+            conn.timeout = timeout_obj.connect_timeout
+
+            is_new_proxy_conn = self.proxy is not None and not getattr(conn, 'sock', None)
+            if is_new_proxy_conn:
+                self._prepare_proxy(conn)
+
+            # Make the request on the httplib connection object.
+            httplib_response = self._make_request(conn, method, url,
+                                                  timeout=timeout_obj,
+                                                  body=body, headers=headers,
+                                                  chunked=chunked)
+
+            # If we're going to release the connection in ``finally:``, then
+            # the response doesn't need to know about the connection. Otherwise
+            # it will also try to release it and we'll have a double-release
+            # mess.
+            response_conn = conn if not release_conn else None
+
+            # Pass method to Response for length checking
+            response_kw['request_method'] = method
+
+            # Import httplib's response into our own wrapper object
+            response = self.ResponseCls.from_httplib(httplib_response,
+                                                     pool=self,
+                                                     connection=response_conn,
+                                                     retries=retries,
+                                                     **response_kw)
+
+            # Everything went great!
+            clean_exit = True
+
+        except queue.Empty:
+            # Timed out by queue.
+            raise EmptyPoolError(self, "No pool connections are available.")
+
+        except (BaseSSLError, CertificateError) as e:
+            # Close the connection. If a connection is reused on which there
+            # was a Certificate error, the next request will certainly raise
+            # another Certificate error.
+            clean_exit = False
+            raise SSLError(e)
+
+        except SSLError:
+            # Treat SSLError separately from BaseSSLError to preserve
+            # traceback.
+            clean_exit = False
+            raise
+
+        except (TimeoutError, HTTPException, SocketError, ProtocolError) as e:
+            # Discard the connection for these exceptions. It will be
+            # be replaced during the next _get_conn() call.
+            clean_exit = False
+
+            if isinstance(e, (SocketError, NewConnectionError)) and self.proxy:
+                e = ProxyError('Cannot connect to proxy.', e)
+            elif isinstance(e, (SocketError, HTTPException)):
+                e = ProtocolError('Connection aborted.', e)
+
+            retries = retries.increment(method, url, error=e, _pool=self,
+                                        _stacktrace=sys.exc_info()[2])
+            retries.sleep()
+
+            # Keep track of the error for the retry warning.
+            err = e
+
+        finally:
+            if not clean_exit:
+                # We hit some kind of exception, handled or otherwise. We need
+                # to throw the connection away unless explicitly told not to.
+                # Close the connection, set the variable to None, and make sure
+                # we put the None back in the pool to avoid leaking it.
+                conn = conn and conn.close()
+                release_this_conn = True
+
+            if release_this_conn:
+                # Put the connection back to be reused. If the connection is
+                # expired then it will be None, which will get replaced with a
+                # fresh connection during _get_conn.
+                self._put_conn(conn)
+
+        if not conn:
+            # Try again
+            log.warning("Retrying (%r) after connection "
+                        "broken by '%r': %s", retries, err, url)
+            return self.urlopen(method, url, body, headers, retries,
+                                redirect, assert_same_host,
+                                timeout=timeout, pool_timeout=pool_timeout,
+                                release_conn=release_conn, body_pos=body_pos,
+                                **response_kw)
+
+        # Handle redirect?
+        redirect_location = redirect and response.get_redirect_location()
+        if redirect_location:
+            if response.status == 303:
+                method = 'GET'
+
+            try:
+                retries = retries.increment(method, url, response=response, _pool=self)
+            except MaxRetryError:
+                if retries.raise_on_redirect:
+                    # Release the connection for this response, since we're not
+                    # returning it to be released manually.
+                    response.release_conn()
+                    raise
+                return response
+
+            retries.sleep_for_retry(response)
+            log.debug("Redirecting %s -> %s", url, redirect_location)
+            return self.urlopen(
+                method, redirect_location, body, headers,
+                retries=retries, redirect=redirect,
+                assert_same_host=assert_same_host,
+                timeout=timeout, pool_timeout=pool_timeout,
+                release_conn=release_conn, body_pos=body_pos,
+                **response_kw)
+
+        # Check if we should retry the HTTP response.
+        has_retry_after = bool(response.getheader('Retry-After'))
+        if retries.is_retry(method, response.status, has_retry_after):
+            try:
+                retries = retries.increment(method, url, response=response, _pool=self)
+            except MaxRetryError:
+                if retries.raise_on_status:
+                    # Release the connection for this response, since we're not
+                    # returning it to be released manually.
+                    response.release_conn()
+                    raise
+                return response
+            retries.sleep(response)
+            log.debug("Retry: %s", url)
+            return self.urlopen(
+                method, url, body, headers,
+                retries=retries, redirect=redirect,
+                assert_same_host=assert_same_host,
+                timeout=timeout, pool_timeout=pool_timeout,
+                release_conn=release_conn,
+                body_pos=body_pos, **response_kw)
+
+        return response
+
+
+class HTTPSConnectionPool(HTTPConnectionPool):
+    """
+    Same as :class:`.HTTPConnectionPool`, but HTTPS.
+
+    When Python is compiled with the :mod:`ssl` module, then
+    :class:`.VerifiedHTTPSConnection` is used, which *can* verify certificates,
+    instead of :class:`.HTTPSConnection`.
+
+    :class:`.VerifiedHTTPSConnection` uses one of ``assert_fingerprint``,
+    ``assert_hostname`` and ``host`` in this order to verify connections.
+    If ``assert_hostname`` is False, no verification is done.
+
+    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,
+    ``ca_cert_dir``, and ``ssl_version`` are only used if :mod:`ssl` is
+    available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade
+    the connection socket into an SSL socket.
+    """
+
+    scheme = 'https'
+    ConnectionCls = HTTPSConnection
+
+    def __init__(self, host, port=None,
+                 strict=False, timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1,
+                 block=False, headers=None, retries=None,
+                 _proxy=None, _proxy_headers=None,
+                 key_file=None, cert_file=None, cert_reqs=None,
+                 ca_certs=None, ssl_version=None,
+                 assert_hostname=None, assert_fingerprint=None,
+                 ca_cert_dir=None, **conn_kw):
+
+        HTTPConnectionPool.__init__(self, host, port, strict, timeout, maxsize,
+                                    block, headers, retries, _proxy, _proxy_headers,
+                                    **conn_kw)
+
+        if ca_certs and cert_reqs is None:
+            cert_reqs = 'CERT_REQUIRED'
+
+        self.key_file = key_file
+        self.cert_file = cert_file
+        self.cert_reqs = cert_reqs
+        self.ca_certs = ca_certs
+        self.ca_cert_dir = ca_cert_dir
+        self.ssl_version = ssl_version
+        self.assert_hostname = assert_hostname
+        self.assert_fingerprint = assert_fingerprint
+
+    def _prepare_conn(self, conn):
+        """
+        Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`
+        and establish the tunnel if proxy is used.
+        """
+
+        if isinstance(conn, VerifiedHTTPSConnection):
+            conn.set_cert(key_file=self.key_file,
+                          cert_file=self.cert_file,
+                          cert_reqs=self.cert_reqs,
+                          ca_certs=self.ca_certs,
+                          ca_cert_dir=self.ca_cert_dir,
+                          assert_hostname=self.assert_hostname,
+                          assert_fingerprint=self.assert_fingerprint)
+            conn.ssl_version = self.ssl_version
+        return conn
+
+    def _prepare_proxy(self, conn):
+        """
+        Establish tunnel connection early, because otherwise httplib
+        would improperly set Host: header to proxy's IP:port.
+        """
+        # Python 2.7+
+        try:
+            set_tunnel = conn.set_tunnel
+        except AttributeError:  # Platform-specific: Python 2.6
+            set_tunnel = conn._set_tunnel
+
+        if sys.version_info <= (2, 6, 4) and not self.proxy_headers:  # Python 2.6.4 and older
+            set_tunnel(self.host, self.port)
+        else:
+            set_tunnel(self.host, self.port, self.proxy_headers)
+
+        conn.connect()
+
+    def _new_conn(self):
+        """
+        Return a fresh :class:`httplib.HTTPSConnection`.
+        """
+        self.num_connections += 1
+        log.debug("Starting new HTTPS connection (%d): %s",
+                  self.num_connections, self.host)
+
+        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:
+            raise SSLError("Can't connect to HTTPS URL because the SSL "
+                           "module is not available.")
+
+        actual_host = self.host
+        actual_port = self.port
+        if self.proxy is not None:
+            actual_host = self.proxy.host
+            actual_port = self.proxy.port
+
+        conn = self.ConnectionCls(host=actual_host, port=actual_port,
+                                  timeout=self.timeout.connect_timeout,
+                                  strict=self.strict, **self.conn_kw)
+
+        return self._prepare_conn(conn)
+
+    def _validate_conn(self, conn):
+        """
+        Called right before a request is made, after the socket is created.
+        """
+        super(HTTPSConnectionPool, self)._validate_conn(conn)
+
+        if not conn.is_verified:
+            warnings.warn((
+                'Unverified HTTPS request is being made. '
+                'Adding certificate verification is strongly advised. See: '
+                'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
+                '#ssl-warnings'),
+                InsecureRequestWarning)
+
+
+def connection_from_url(url, **kw):
+    """
+    Given a url, return an :class:`.ConnectionPool` instance of its host.
+
+    This is a shortcut for not having to parse out the scheme, host, and port
+    of the url before creating an :class:`.ConnectionPool` instance.
+
+    :param url:
+        Absolute URL string that must include the scheme. Port is optional.
+
+    :param \\**kw:
+        Passes additional parameters to the constructor of the appropriate
+        :class:`.ConnectionPool`. Useful for specifying things like
+        timeout, maxsize, headers, etc.
+
+    Example::
+
+        >>> conn = connection_from_url('http://google.com/')
+        >>> r = conn.request('GET', '/')
+    """
+    scheme, host, port = get_host(url)
+    port = port or port_by_scheme.get(scheme, 80)
+    if scheme == 'https':
+        return HTTPSConnectionPool(host, port=port, **kw)
+    else:
+        return HTTPConnectionPool(host, port=port, **kw)
+
+
+def _ipv6_host(host):
+    """
+    Process IPv6 address literals
+    """
+
+    # httplib doesn't like it when we include brackets in IPv6 addresses
+    # Specifically, if we include brackets but also pass the port then
+    # httplib crazily doubles up the square brackets on the Host header.
+    # Instead, we need to make sure we never pass ``None`` as the port.
+    # However, for backward compatibility reasons we can't actually
+    # *assert* that.  See http://bugs.python.org/issue28539
+    #
+    # Also if an IPv6 address literal has a zone identifier, the
+    # percent sign might be URIencoded, convert it back into ASCII
+    if host.startswith('[') and host.endswith(']'):
+        host = host.replace('%25', '%').strip('[]')
+    return host
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/contrib/ntlmpool.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/contrib/ntlmpool.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,112 +1,112 @@
-"""
-NTLM authenticating pool, contributed by erikcederstran
-
-Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10
-"""
-from __future__ import absolute_import
-
-from logging import getLogger
-from ntlm import ntlm
-
-from .. import HTTPSConnectionPool
-from ..packages.six.moves.http_client import HTTPSConnection
-
-
-log = getLogger(__name__)
-
-
-class NTLMConnectionPool(HTTPSConnectionPool):
-    """
-    Implements an NTLM authentication version of an urllib3 connection pool
-    """
-
-    scheme = 'https'
-
-    def __init__(self, user, pw, authurl, *args, **kwargs):
-        """
-        authurl is a random URL on the server that is protected by NTLM.
-        user is the Windows user, probably in the DOMAIN\\username format.
-        pw is the password for the user.
-        """
-        super(NTLMConnectionPool, self).__init__(*args, **kwargs)
-        self.authurl = authurl
-        self.rawuser = user
-        user_parts = user.split('\\', 1)
-        self.domain = user_parts[0].upper()
-        self.user = user_parts[1]
-        self.pw = pw
-
-    def _new_conn(self):
-        # Performs the NTLM handshake that secures the connection. The socket
-        # must be kept open while requests are performed.
-        self.num_connections += 1
-        log.debug('Starting NTLM HTTPS connection no. %d: https://%s%s',
-                  self.num_connections, self.host, self.authurl)
-
-        headers = {}
-        headers['Connection'] = 'Keep-Alive'
-        req_header = 'Authorization'
-        resp_header = 'www-authenticate'
-
-        conn = HTTPSConnection(host=self.host, port=self.port)
-
-        # Send negotiation message
-        headers[req_header] = (
-            'NTLM %s' % ntlm.create_NTLM_NEGOTIATE_MESSAGE(self.rawuser))
-        log.debug('Request headers: %s', headers)
-        conn.request('GET', self.authurl, None, headers)
-        res = conn.getresponse()
-        reshdr = dict(res.getheaders())
-        log.debug('Response status: %s %s', res.status, res.reason)
-        log.debug('Response headers: %s', reshdr)
-        log.debug('Response data: %s [...]', res.read(100))
-
-        # Remove the reference to the socket, so that it can not be closed by
-        # the response object (we want to keep the socket open)
-        res.fp = None
-
-        # Server should respond with a challenge message
-        auth_header_values = reshdr[resp_header].split(', ')
-        auth_header_value = None
-        for s in auth_header_values:
-            if s[:5] == 'NTLM ':
-                auth_header_value = s[5:]
-        if auth_header_value is None:
-            raise Exception('Unexpected %s response header: %s' %
-                            (resp_header, reshdr[resp_header]))
-
-        # Send authentication message
-        ServerChallenge, NegotiateFlags = \
-            ntlm.parse_NTLM_CHALLENGE_MESSAGE(auth_header_value)
-        auth_msg = ntlm.create_NTLM_AUTHENTICATE_MESSAGE(ServerChallenge,
-                                                         self.user,
-                                                         self.domain,
-                                                         self.pw,
-                                                         NegotiateFlags)
-        headers[req_header] = 'NTLM %s' % auth_msg
-        log.debug('Request headers: %s', headers)
-        conn.request('GET', self.authurl, None, headers)
-        res = conn.getresponse()
-        log.debug('Response status: %s %s', res.status, res.reason)
-        log.debug('Response headers: %s', dict(res.getheaders()))
-        log.debug('Response data: %s [...]', res.read()[:100])
-        if res.status != 200:
-            if res.status == 401:
-                raise Exception('Server rejected request: wrong '
-                                'username or password')
-            raise Exception('Wrong server response: %s %s' %
-                            (res.status, res.reason))
-
-        res.fp = None
-        log.debug('Connection established')
-        return conn
-
-    def urlopen(self, method, url, body=None, headers=None, retries=3,
-                redirect=True, assert_same_host=True):
-        if headers is None:
-            headers = {}
-        headers['Connection'] = 'Keep-Alive'
-        return super(NTLMConnectionPool, self).urlopen(method, url, body,
-                                                       headers, retries,
-                                                       redirect,
-                                                       assert_same_host)
+"""
+NTLM authenticating pool, contributed by erikcederstran
+
+Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10
+"""
+from __future__ import absolute_import
+
+from logging import getLogger
+from ntlm import ntlm
+
+from .. import HTTPSConnectionPool
+from ..packages.six.moves.http_client import HTTPSConnection
+
+
+log = getLogger(__name__)
+
+
+class NTLMConnectionPool(HTTPSConnectionPool):
+    """
+    Implements an NTLM authentication version of an urllib3 connection pool
+    """
+
+    scheme = 'https'
+
+    def __init__(self, user, pw, authurl, *args, **kwargs):
+        """
+        authurl is a random URL on the server that is protected by NTLM.
+        user is the Windows user, probably in the DOMAIN\\username format.
+        pw is the password for the user.
+        """
+        super(NTLMConnectionPool, self).__init__(*args, **kwargs)
+        self.authurl = authurl
+        self.rawuser = user
+        user_parts = user.split('\\', 1)
+        self.domain = user_parts[0].upper()
+        self.user = user_parts[1]
+        self.pw = pw
+
+    def _new_conn(self):
+        # Performs the NTLM handshake that secures the connection. The socket
+        # must be kept open while requests are performed.
+        self.num_connections += 1
+        log.debug('Starting NTLM HTTPS connection no. %d: https://%s%s',
+                  self.num_connections, self.host, self.authurl)
+
+        headers = {}
+        headers['Connection'] = 'Keep-Alive'
+        req_header = 'Authorization'
+        resp_header = 'www-authenticate'
+
+        conn = HTTPSConnection(host=self.host, port=self.port)
+
+        # Send negotiation message
+        headers[req_header] = (
+            'NTLM %s' % ntlm.create_NTLM_NEGOTIATE_MESSAGE(self.rawuser))
+        log.debug('Request headers: %s', headers)
+        conn.request('GET', self.authurl, None, headers)
+        res = conn.getresponse()
+        reshdr = dict(res.getheaders())
+        log.debug('Response status: %s %s', res.status, res.reason)
+        log.debug('Response headers: %s', reshdr)
+        log.debug('Response data: %s [...]', res.read(100))
+
+        # Remove the reference to the socket, so that it can not be closed by
+        # the response object (we want to keep the socket open)
+        res.fp = None
+
+        # Server should respond with a challenge message
+        auth_header_values = reshdr[resp_header].split(', ')
+        auth_header_value = None
+        for s in auth_header_values:
+            if s[:5] == 'NTLM ':
+                auth_header_value = s[5:]
+        if auth_header_value is None:
+            raise Exception('Unexpected %s response header: %s' %
+                            (resp_header, reshdr[resp_header]))
+
+        # Send authentication message
+        ServerChallenge, NegotiateFlags = \
+            ntlm.parse_NTLM_CHALLENGE_MESSAGE(auth_header_value)
+        auth_msg = ntlm.create_NTLM_AUTHENTICATE_MESSAGE(ServerChallenge,
+                                                         self.user,
+                                                         self.domain,
+                                                         self.pw,
+                                                         NegotiateFlags)
+        headers[req_header] = 'NTLM %s' % auth_msg
+        log.debug('Request headers: %s', headers)
+        conn.request('GET', self.authurl, None, headers)
+        res = conn.getresponse()
+        log.debug('Response status: %s %s', res.status, res.reason)
+        log.debug('Response headers: %s', dict(res.getheaders()))
+        log.debug('Response data: %s [...]', res.read()[:100])
+        if res.status != 200:
+            if res.status == 401:
+                raise Exception('Server rejected request: wrong '
+                                'username or password')
+            raise Exception('Wrong server response: %s %s' %
+                            (res.status, res.reason))
+
+        res.fp = None
+        log.debug('Connection established')
+        return conn
+
+    def urlopen(self, method, url, body=None, headers=None, retries=3,
+                redirect=True, assert_same_host=True):
+        if headers is None:
+            headers = {}
+        headers['Connection'] = 'Keep-Alive'
+        return super(NTLMConnectionPool, self).urlopen(method, url, body,
+                                                       headers, retries,
+                                                       redirect,
+                                                       assert_same_host)
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/contrib/pyopenssl.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/contrib/pyopenssl.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,450 +1,450 @@
-"""
-SSL with SNI_-support for Python 2. Follow these instructions if you would
-like to verify SSL certificates in Python 2. Note, the default libraries do
-*not* do certificate checking; you need to do additional work to validate
-certificates yourself.
-
-This needs the following packages installed:
-
-* pyOpenSSL (tested with 16.0.0)
-* cryptography (minimum 1.3.4, from pyopenssl)
-* idna (minimum 2.0, from cryptography)
-
-However, pyopenssl depends on cryptography, which depends on idna, so while we
-use all three directly here we end up having relatively few packages required.
-
-You can install them with the following command:
-
-    pip install pyopenssl cryptography idna
-
-To activate certificate checking, call
-:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
-before you begin making HTTP requests. This can be done in a ``sitecustomize``
-module, or at any other time before your application begins using ``urllib3``,
-like this::
-
-    try:
-        import urllib3.contrib.pyopenssl
-        urllib3.contrib.pyopenssl.inject_into_urllib3()
-    except ImportError:
-        pass
-
-Now you can use :mod:`urllib3` as you normally would, and it will support SNI
-when the required modules are installed.
-
-Activating this module also has the positive side effect of disabling SSL/TLS
-compression in Python 2 (see `CRIME attack`_).
-
-If you want to configure the default list of supported cipher suites, you can
-set the ``urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST`` variable.
-
-.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
-.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)
-"""
-from __future__ import absolute_import
-
-import OpenSSL.SSL
-from cryptography import x509
-from cryptography.hazmat.backends.openssl import backend as openssl_backend
-from cryptography.hazmat.backends.openssl.x509 import _Certificate
-
-from socket import timeout, error as SocketError
-from io import BytesIO
-
-try:  # Platform-specific: Python 2
-    from socket import _fileobject
-except ImportError:  # Platform-specific: Python 3
-    _fileobject = None
-    from ..packages.backports.makefile import backport_makefile
-
-import logging
-import ssl
-import six
-import sys
-
-from .. import util
-
-__all__ = ['inject_into_urllib3', 'extract_from_urllib3']
-
-# SNI always works.
-HAS_SNI = True
-
-# Map from urllib3 to PyOpenSSL compatible parameter-values.
-_openssl_versions = {
-    ssl.PROTOCOL_SSLv23: OpenSSL.SSL.SSLv23_METHOD,
-    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
-}
-
-if hasattr(ssl, 'PROTOCOL_TLSv1_1') and hasattr(OpenSSL.SSL, 'TLSv1_1_METHOD'):
-    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD
-
-if hasattr(ssl, 'PROTOCOL_TLSv1_2') and hasattr(OpenSSL.SSL, 'TLSv1_2_METHOD'):
-    _openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD
-
-try:
-    _openssl_versions.update({ssl.PROTOCOL_SSLv3: OpenSSL.SSL.SSLv3_METHOD})
-except AttributeError:
-    pass
-
-_stdlib_to_openssl_verify = {
-    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
-    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
-    ssl.CERT_REQUIRED:
-        OpenSSL.SSL.VERIFY_PEER + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
-}
-_openssl_to_stdlib_verify = dict(
-    (v, k) for k, v in _stdlib_to_openssl_verify.items()
-)
-
-# OpenSSL will only write 16K at a time
-SSL_WRITE_BLOCKSIZE = 16384
-
-orig_util_HAS_SNI = util.HAS_SNI
-orig_util_SSLContext = util.ssl_.SSLContext
-
-
-log = logging.getLogger(__name__)
-
-
-def inject_into_urllib3():
-    'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'
-
-    _validate_dependencies_met()
-
-    util.ssl_.SSLContext = PyOpenSSLContext
-    util.HAS_SNI = HAS_SNI
-    util.ssl_.HAS_SNI = HAS_SNI
-    util.IS_PYOPENSSL = True
-    util.ssl_.IS_PYOPENSSL = True
-
-
-def extract_from_urllib3():
-    'Undo monkey-patching by :func:`inject_into_urllib3`.'
-
-    util.ssl_.SSLContext = orig_util_SSLContext
-    util.HAS_SNI = orig_util_HAS_SNI
-    util.ssl_.HAS_SNI = orig_util_HAS_SNI
-    util.IS_PYOPENSSL = False
-    util.ssl_.IS_PYOPENSSL = False
-
-
-def _validate_dependencies_met():
-    """
-    Verifies that PyOpenSSL's package-level dependencies have been met.
-    Throws `ImportError` if they are not met.
-    """
-    # Method added in `cryptography==1.1`; not available in older versions
-    from cryptography.x509.extensions import Extensions
-    if getattr(Extensions, "get_extension_for_class", None) is None:
-        raise ImportError("'cryptography' module missing required functionality.  "
-                          "Try upgrading to v1.3.4 or newer.")
-
-    # pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509
-    # attribute is only present on those versions.
-    from OpenSSL.crypto import X509
-    x509 = X509()
-    if getattr(x509, "_x509", None) is None:
-        raise ImportError("'pyOpenSSL' module missing required functionality. "
-                          "Try upgrading to v0.14 or newer.")
-
-
-def _dnsname_to_stdlib(name):
-    """
-    Converts a dNSName SubjectAlternativeName field to the form used by the
-    standard library on the given Python version.
-
-    Cryptography produces a dNSName as a unicode string that was idna-decoded
-    from ASCII bytes. We need to idna-encode that string to get it back, and
-    then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib
-    uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).
-    """
-    def idna_encode(name):
-        """
-        Borrowed wholesale from the Python Cryptography Project. It turns out
-        that we can't just safely call `idna.encode`: it can explode for
-        wildcard names. This avoids that problem.
-        """
-        import idna
-
-        for prefix in [u'*.', u'.']:
-            if name.startswith(prefix):
-                name = name[len(prefix):]
-                return prefix.encode('ascii') + idna.encode(name)
-        return idna.encode(name)
-
-    name = idna_encode(name)
-    if sys.version_info >= (3, 0):
-        name = name.decode('utf-8')
-    return name
-
-
-def get_subj_alt_name(peer_cert):
-    """
-    Given an PyOpenSSL certificate, provides all the subject alternative names.
-    """
-    # Pass the cert to cryptography, which has much better APIs for this.
-    # This is technically using private APIs, but should work across all
-    # relevant versions until PyOpenSSL gets something proper for this.
-    cert = _Certificate(openssl_backend, peer_cert._x509)
-
-    # We want to find the SAN extension. Ask Cryptography to locate it (it's
-    # faster than looping in Python)
-    try:
-        ext = cert.extensions.get_extension_for_class(
-            x509.SubjectAlternativeName
-        ).value
-    except x509.ExtensionNotFound:
-        # No such extension, return the empty list.
-        return []
-    except (x509.DuplicateExtension, x509.UnsupportedExtension,
-            x509.UnsupportedGeneralNameType, UnicodeError) as e:
-        # A problem has been found with the quality of the certificate. Assume
-        # no SAN field is present.
-        log.warning(
-            "A problem was encountered with the certificate that prevented "
-            "urllib3 from finding the SubjectAlternativeName field. This can "
-            "affect certificate validation. The error was %s",
-            e,
-        )
-        return []
-
-    # We want to return dNSName and iPAddress fields. We need to cast the IPs
-    # back to strings because the match_hostname function wants them as
-    # strings.
-    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8
-    # decoded. This is pretty frustrating, but that's what the standard library
-    # does with certificates, and so we need to attempt to do the same.
-    names = [
-        ('DNS', _dnsname_to_stdlib(name))
-        for name in ext.get_values_for_type(x509.DNSName)
-    ]
-    names.extend(
-        ('IP Address', str(name))
-        for name in ext.get_values_for_type(x509.IPAddress)
-    )
-
-    return names
-
-
-class WrappedSocket(object):
-    '''API-compatibility wrapper for Python OpenSSL's Connection-class.
-
-    Note: _makefile_refs, _drop() and _reuse() are needed for the garbage
-    collector of pypy.
-    '''
-
-    def __init__(self, connection, socket, suppress_ragged_eofs=True):
-        self.connection = connection
-        self.socket = socket
-        self.suppress_ragged_eofs = suppress_ragged_eofs
-        self._makefile_refs = 0
-        self._closed = False
-
-    def fileno(self):
-        return self.socket.fileno()
-
-    # Copy-pasted from Python 3.5 source code
-    def _decref_socketios(self):
-        if self._makefile_refs > 0:
-            self._makefile_refs -= 1
-        if self._closed:
-            self.close()
-
-    def recv(self, *args, **kwargs):
-        try:
-            data = self.connection.recv(*args, **kwargs)
-        except OpenSSL.SSL.SysCallError as e:
-            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
-                return b''
-            else:
-                raise SocketError(str(e))
-        except OpenSSL.SSL.ZeroReturnError as e:
-            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
-                return b''
-            else:
-                raise
-        except OpenSSL.SSL.WantReadError:
-            rd = util.wait_for_read(self.socket, self.socket.gettimeout())
-            if not rd:
-                raise timeout('The read operation timed out')
-            else:
-                return self.recv(*args, **kwargs)
-        else:
-            return data
-
-    def recv_into(self, *args, **kwargs):
-        try:
-            return self.connection.recv_into(*args, **kwargs)
-        except OpenSSL.SSL.SysCallError as e:
-            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
-                return 0
-            else:
-                raise SocketError(str(e))
-        except OpenSSL.SSL.ZeroReturnError as e:
-            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
-                return 0
-            else:
-                raise
-        except OpenSSL.SSL.WantReadError:
-            rd = util.wait_for_read(self.socket, self.socket.gettimeout())
-            if not rd:
-                raise timeout('The read operation timed out')
-            else:
-                return self.recv_into(*args, **kwargs)
-
-    def settimeout(self, timeout):
-        return self.socket.settimeout(timeout)
-
-    def _send_until_done(self, data):
-        while True:
-            try:
-                return self.connection.send(data)
-            except OpenSSL.SSL.WantWriteError:
-                wr = util.wait_for_write(self.socket, self.socket.gettimeout())
-                if not wr:
-                    raise timeout()
-                continue
-
-    def sendall(self, data):
-        total_sent = 0
-        while total_sent < len(data):
-            sent = self._send_until_done(data[total_sent:total_sent + SSL_WRITE_BLOCKSIZE])
-            total_sent += sent
-
-    def shutdown(self):
-        # FIXME rethrow compatible exceptions should we ever use this
-        self.connection.shutdown()
-
-    def close(self):
-        if self._makefile_refs < 1:
-            try:
-                self._closed = True
-                return self.connection.close()
-            except OpenSSL.SSL.Error:
-                return
-        else:
-            self._makefile_refs -= 1
-
-    def getpeercert(self, binary_form=False):
-        x509 = self.connection.get_peer_certificate()
-
-        if not x509:
-            return x509
-
-        if binary_form:
-            return OpenSSL.crypto.dump_certificate(
-                OpenSSL.crypto.FILETYPE_ASN1,
-                x509)
-
-        return {
-            'subject': (
-                (('commonName', x509.get_subject().CN),),
-            ),
-            'subjectAltName': get_subj_alt_name(x509)
-        }
-
-    def _reuse(self):
-        self._makefile_refs += 1
-
-    def _drop(self):
-        if self._makefile_refs < 1:
-            self.close()
-        else:
-            self._makefile_refs -= 1
-
-
-if _fileobject:  # Platform-specific: Python 2
-    def makefile(self, mode, bufsize=-1):
-        self._makefile_refs += 1
-        return _fileobject(self, mode, bufsize, close=True)
-else:  # Platform-specific: Python 3
-    makefile = backport_makefile
-
-WrappedSocket.makefile = makefile
-
-
-class PyOpenSSLContext(object):
-    """
-    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible
-    for translating the interface of the standard library ``SSLContext`` object
-    to calls into PyOpenSSL.
-    """
-    def __init__(self, protocol):
-        self.protocol = _openssl_versions[protocol]
-        self._ctx = OpenSSL.SSL.Context(self.protocol)
-        self._options = 0
-        self.check_hostname = False
-
-    @property
-    def options(self):
-        return self._options
-
-    @options.setter
-    def options(self, value):
-        self._options = value
-        self._ctx.set_options(value)
-
-    @property
-    def verify_mode(self):
-        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]
-
-    @verify_mode.setter
-    def verify_mode(self, value):
-        self._ctx.set_verify(
-            _stdlib_to_openssl_verify[value],
-            _verify_callback
-        )
-
-    def set_default_verify_paths(self):
-        self._ctx.set_default_verify_paths()
-
-    def set_ciphers(self, ciphers):
-        if isinstance(ciphers, six.text_type):
-            ciphers = ciphers.encode('utf-8')
-        self._ctx.set_cipher_list(ciphers)
-
-    def load_verify_locations(self, cafile=None, capath=None, cadata=None):
-        if cafile is not None:
-            cafile = cafile.encode('utf-8')
-        if capath is not None:
-            capath = capath.encode('utf-8')
-        self._ctx.load_verify_locations(cafile, capath)
-        if cadata is not None:
-            self._ctx.load_verify_locations(BytesIO(cadata))
-
-    def load_cert_chain(self, certfile, keyfile=None, password=None):
-        self._ctx.use_certificate_file(certfile)
-        if password is not None:
-            self._ctx.set_passwd_cb(lambda max_length, prompt_twice, userdata: password)
-        self._ctx.use_privatekey_file(keyfile or certfile)
-
-    def wrap_socket(self, sock, server_side=False,
-                    do_handshake_on_connect=True, suppress_ragged_eofs=True,
-                    server_hostname=None):
-        cnx = OpenSSL.SSL.Connection(self._ctx, sock)
-
-        if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3
-            server_hostname = server_hostname.encode('utf-8')
-
-        if server_hostname is not None:
-            cnx.set_tlsext_host_name(server_hostname)
-
-        cnx.set_connect_state()
-
-        while True:
-            try:
-                cnx.do_handshake()
-            except OpenSSL.SSL.WantReadError:
-                rd = util.wait_for_read(sock, sock.gettimeout())
-                if not rd:
-                    raise timeout('select timed out')
-                continue
-            except OpenSSL.SSL.Error as e:
-                raise ssl.SSLError('bad handshake: %r' % e)
-            break
-
-        return WrappedSocket(cnx, sock)
-
-
-def _verify_callback(cnx, x509, err_no, err_depth, return_code):
-    return err_no == 0
+"""
+SSL with SNI_-support for Python 2. Follow these instructions if you would
+like to verify SSL certificates in Python 2. Note, the default libraries do
+*not* do certificate checking; you need to do additional work to validate
+certificates yourself.
+
+This needs the following packages installed:
+
+* pyOpenSSL (tested with 16.0.0)
+* cryptography (minimum 1.3.4, from pyopenssl)
+* idna (minimum 2.0, from cryptography)
+
+However, pyopenssl depends on cryptography, which depends on idna, so while we
+use all three directly here we end up having relatively few packages required.
+
+You can install them with the following command:
+
+    pip install pyopenssl cryptography idna
+
+To activate certificate checking, call
+:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
+before you begin making HTTP requests. This can be done in a ``sitecustomize``
+module, or at any other time before your application begins using ``urllib3``,
+like this::
+
+    try:
+        import urllib3.contrib.pyopenssl
+        urllib3.contrib.pyopenssl.inject_into_urllib3()
+    except ImportError:
+        pass
+
+Now you can use :mod:`urllib3` as you normally would, and it will support SNI
+when the required modules are installed.
+
+Activating this module also has the positive side effect of disabling SSL/TLS
+compression in Python 2 (see `CRIME attack`_).
+
+If you want to configure the default list of supported cipher suites, you can
+set the ``urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST`` variable.
+
+.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
+.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)
+"""
+from __future__ import absolute_import
+
+import OpenSSL.SSL
+from cryptography import x509
+from cryptography.hazmat.backends.openssl import backend as openssl_backend
+from cryptography.hazmat.backends.openssl.x509 import _Certificate
+
+from socket import timeout, error as SocketError
+from io import BytesIO
+
+try:  # Platform-specific: Python 2
+    from socket import _fileobject
+except ImportError:  # Platform-specific: Python 3
+    _fileobject = None
+    from ..packages.backports.makefile import backport_makefile
+
+import logging
+import ssl
+import six
+import sys
+
+from .. import util
+
+__all__ = ['inject_into_urllib3', 'extract_from_urllib3']
+
+# SNI always works.
+HAS_SNI = True
+
+# Map from urllib3 to PyOpenSSL compatible parameter-values.
+_openssl_versions = {
+    ssl.PROTOCOL_SSLv23: OpenSSL.SSL.SSLv23_METHOD,
+    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
+}
+
+if hasattr(ssl, 'PROTOCOL_TLSv1_1') and hasattr(OpenSSL.SSL, 'TLSv1_1_METHOD'):
+    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD
+
+if hasattr(ssl, 'PROTOCOL_TLSv1_2') and hasattr(OpenSSL.SSL, 'TLSv1_2_METHOD'):
+    _openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD
+
+try:
+    _openssl_versions.update({ssl.PROTOCOL_SSLv3: OpenSSL.SSL.SSLv3_METHOD})
+except AttributeError:
+    pass
+
+_stdlib_to_openssl_verify = {
+    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
+    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
+    ssl.CERT_REQUIRED:
+        OpenSSL.SSL.VERIFY_PEER + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
+}
+_openssl_to_stdlib_verify = dict(
+    (v, k) for k, v in _stdlib_to_openssl_verify.items()
+)
+
+# OpenSSL will only write 16K at a time
+SSL_WRITE_BLOCKSIZE = 16384
+
+orig_util_HAS_SNI = util.HAS_SNI
+orig_util_SSLContext = util.ssl_.SSLContext
+
+
+log = logging.getLogger(__name__)
+
+
+def inject_into_urllib3():
+    'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'
+
+    _validate_dependencies_met()
+
+    util.ssl_.SSLContext = PyOpenSSLContext
+    util.HAS_SNI = HAS_SNI
+    util.ssl_.HAS_SNI = HAS_SNI
+    util.IS_PYOPENSSL = True
+    util.ssl_.IS_PYOPENSSL = True
+
+
+def extract_from_urllib3():
+    'Undo monkey-patching by :func:`inject_into_urllib3`.'
+
+    util.ssl_.SSLContext = orig_util_SSLContext
+    util.HAS_SNI = orig_util_HAS_SNI
+    util.ssl_.HAS_SNI = orig_util_HAS_SNI
+    util.IS_PYOPENSSL = False
+    util.ssl_.IS_PYOPENSSL = False
+
+
+def _validate_dependencies_met():
+    """
+    Verifies that PyOpenSSL's package-level dependencies have been met.
+    Throws `ImportError` if they are not met.
+    """
+    # Method added in `cryptography==1.1`; not available in older versions
+    from cryptography.x509.extensions import Extensions
+    if getattr(Extensions, "get_extension_for_class", None) is None:
+        raise ImportError("'cryptography' module missing required functionality.  "
+                          "Try upgrading to v1.3.4 or newer.")
+
+    # pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509
+    # attribute is only present on those versions.
+    from OpenSSL.crypto import X509
+    x509 = X509()
+    if getattr(x509, "_x509", None) is None:
+        raise ImportError("'pyOpenSSL' module missing required functionality. "
+                          "Try upgrading to v0.14 or newer.")
+
+
+def _dnsname_to_stdlib(name):
+    """
+    Converts a dNSName SubjectAlternativeName field to the form used by the
+    standard library on the given Python version.
+
+    Cryptography produces a dNSName as a unicode string that was idna-decoded
+    from ASCII bytes. We need to idna-encode that string to get it back, and
+    then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib
+    uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).
+    """
+    def idna_encode(name):
+        """
+        Borrowed wholesale from the Python Cryptography Project. It turns out
+        that we can't just safely call `idna.encode`: it can explode for
+        wildcard names. This avoids that problem.
+        """
+        import idna
+
+        for prefix in [u'*.', u'.']:
+            if name.startswith(prefix):
+                name = name[len(prefix):]
+                return prefix.encode('ascii') + idna.encode(name)
+        return idna.encode(name)
+
+    name = idna_encode(name)
+    if sys.version_info >= (3, 0):
+        name = name.decode('utf-8')
+    return name
+
+
+def get_subj_alt_name(peer_cert):
+    """
+    Given an PyOpenSSL certificate, provides all the subject alternative names.
+    """
+    # Pass the cert to cryptography, which has much better APIs for this.
+    # This is technically using private APIs, but should work across all
+    # relevant versions until PyOpenSSL gets something proper for this.
+    cert = _Certificate(openssl_backend, peer_cert._x509)
+
+    # We want to find the SAN extension. Ask Cryptography to locate it (it's
+    # faster than looping in Python)
+    try:
+        ext = cert.extensions.get_extension_for_class(
+            x509.SubjectAlternativeName
+        ).value
+    except x509.ExtensionNotFound:
+        # No such extension, return the empty list.
+        return []
+    except (x509.DuplicateExtension, x509.UnsupportedExtension,
+            x509.UnsupportedGeneralNameType, UnicodeError) as e:
+        # A problem has been found with the quality of the certificate. Assume
+        # no SAN field is present.
+        log.warning(
+            "A problem was encountered with the certificate that prevented "
+            "urllib3 from finding the SubjectAlternativeName field. This can "
+            "affect certificate validation. The error was %s",
+            e,
+        )
+        return []
+
+    # We want to return dNSName and iPAddress fields. We need to cast the IPs
+    # back to strings because the match_hostname function wants them as
+    # strings.
+    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8
+    # decoded. This is pretty frustrating, but that's what the standard library
+    # does with certificates, and so we need to attempt to do the same.
+    names = [
+        ('DNS', _dnsname_to_stdlib(name))
+        for name in ext.get_values_for_type(x509.DNSName)
+    ]
+    names.extend(
+        ('IP Address', str(name))
+        for name in ext.get_values_for_type(x509.IPAddress)
+    )
+
+    return names
+
+
+class WrappedSocket(object):
+    '''API-compatibility wrapper for Python OpenSSL's Connection-class.
+
+    Note: _makefile_refs, _drop() and _reuse() are needed for the garbage
+    collector of pypy.
+    '''
+
+    def __init__(self, connection, socket, suppress_ragged_eofs=True):
+        self.connection = connection
+        self.socket = socket
+        self.suppress_ragged_eofs = suppress_ragged_eofs
+        self._makefile_refs = 0
+        self._closed = False
+
+    def fileno(self):
+        return self.socket.fileno()
+
+    # Copy-pasted from Python 3.5 source code
+    def _decref_socketios(self):
+        if self._makefile_refs > 0:
+            self._makefile_refs -= 1
+        if self._closed:
+            self.close()
+
+    def recv(self, *args, **kwargs):
+        try:
+            data = self.connection.recv(*args, **kwargs)
+        except OpenSSL.SSL.SysCallError as e:
+            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
+                return b''
+            else:
+                raise SocketError(str(e))
+        except OpenSSL.SSL.ZeroReturnError as e:
+            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
+                return b''
+            else:
+                raise
+        except OpenSSL.SSL.WantReadError:
+            rd = util.wait_for_read(self.socket, self.socket.gettimeout())
+            if not rd:
+                raise timeout('The read operation timed out')
+            else:
+                return self.recv(*args, **kwargs)
+        else:
+            return data
+
+    def recv_into(self, *args, **kwargs):
+        try:
+            return self.connection.recv_into(*args, **kwargs)
+        except OpenSSL.SSL.SysCallError as e:
+            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
+                return 0
+            else:
+                raise SocketError(str(e))
+        except OpenSSL.SSL.ZeroReturnError as e:
+            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
+                return 0
+            else:
+                raise
+        except OpenSSL.SSL.WantReadError:
+            rd = util.wait_for_read(self.socket, self.socket.gettimeout())
+            if not rd:
+                raise timeout('The read operation timed out')
+            else:
+                return self.recv_into(*args, **kwargs)
+
+    def settimeout(self, timeout):
+        return self.socket.settimeout(timeout)
+
+    def _send_until_done(self, data):
+        while True:
+            try:
+                return self.connection.send(data)
+            except OpenSSL.SSL.WantWriteError:
+                wr = util.wait_for_write(self.socket, self.socket.gettimeout())
+                if not wr:
+                    raise timeout()
+                continue
+
+    def sendall(self, data):
+        total_sent = 0
+        while total_sent < len(data):
+            sent = self._send_until_done(data[total_sent:total_sent + SSL_WRITE_BLOCKSIZE])
+            total_sent += sent
+
+    def shutdown(self):
+        # FIXME rethrow compatible exceptions should we ever use this
+        self.connection.shutdown()
+
+    def close(self):
+        if self._makefile_refs < 1:
+            try:
+                self._closed = True
+                return self.connection.close()
+            except OpenSSL.SSL.Error:
+                return
+        else:
+            self._makefile_refs -= 1
+
+    def getpeercert(self, binary_form=False):
+        x509 = self.connection.get_peer_certificate()
+
+        if not x509:
+            return x509
+
+        if binary_form:
+            return OpenSSL.crypto.dump_certificate(
+                OpenSSL.crypto.FILETYPE_ASN1,
+                x509)
+
+        return {
+            'subject': (
+                (('commonName', x509.get_subject().CN),),
+            ),
+            'subjectAltName': get_subj_alt_name(x509)
+        }
+
+    def _reuse(self):
+        self._makefile_refs += 1
+
+    def _drop(self):
+        if self._makefile_refs < 1:
+            self.close()
+        else:
+            self._makefile_refs -= 1
+
+
+if _fileobject:  # Platform-specific: Python 2
+    def makefile(self, mode, bufsize=-1):
+        self._makefile_refs += 1
+        return _fileobject(self, mode, bufsize, close=True)
+else:  # Platform-specific: Python 3
+    makefile = backport_makefile
+
+WrappedSocket.makefile = makefile
+
+
+class PyOpenSSLContext(object):
+    """
+    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible
+    for translating the interface of the standard library ``SSLContext`` object
+    to calls into PyOpenSSL.
+    """
+    def __init__(self, protocol):
+        self.protocol = _openssl_versions[protocol]
+        self._ctx = OpenSSL.SSL.Context(self.protocol)
+        self._options = 0
+        self.check_hostname = False
+
+    @property
+    def options(self):
+        return self._options
+
+    @options.setter
+    def options(self, value):
+        self._options = value
+        self._ctx.set_options(value)
+
+    @property
+    def verify_mode(self):
+        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]
+
+    @verify_mode.setter
+    def verify_mode(self, value):
+        self._ctx.set_verify(
+            _stdlib_to_openssl_verify[value],
+            _verify_callback
+        )
+
+    def set_default_verify_paths(self):
+        self._ctx.set_default_verify_paths()
+
+    def set_ciphers(self, ciphers):
+        if isinstance(ciphers, six.text_type):
+            ciphers = ciphers.encode('utf-8')
+        self._ctx.set_cipher_list(ciphers)
+
+    def load_verify_locations(self, cafile=None, capath=None, cadata=None):
+        if cafile is not None:
+            cafile = cafile.encode('utf-8')
+        if capath is not None:
+            capath = capath.encode('utf-8')
+        self._ctx.load_verify_locations(cafile, capath)
+        if cadata is not None:
+            self._ctx.load_verify_locations(BytesIO(cadata))
+
+    def load_cert_chain(self, certfile, keyfile=None, password=None):
+        self._ctx.use_certificate_file(certfile)
+        if password is not None:
+            self._ctx.set_passwd_cb(lambda max_length, prompt_twice, userdata: password)
+        self._ctx.use_privatekey_file(keyfile or certfile)
+
+    def wrap_socket(self, sock, server_side=False,
+                    do_handshake_on_connect=True, suppress_ragged_eofs=True,
+                    server_hostname=None):
+        cnx = OpenSSL.SSL.Connection(self._ctx, sock)
+
+        if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3
+            server_hostname = server_hostname.encode('utf-8')
+
+        if server_hostname is not None:
+            cnx.set_tlsext_host_name(server_hostname)
+
+        cnx.set_connect_state()
+
+        while True:
+            try:
+                cnx.do_handshake()
+            except OpenSSL.SSL.WantReadError:
+                rd = util.wait_for_read(sock, sock.gettimeout())
+                if not rd:
+                    raise timeout('select timed out')
+                continue
+            except OpenSSL.SSL.Error as e:
+                raise ssl.SSLError('bad handshake: %r' % e)
+            break
+
+        return WrappedSocket(cnx, sock)
+
+
+def _verify_callback(cnx, x509, err_no, err_depth, return_code):
+    return err_no == 0
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/fields.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/fields.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,178 +1,178 @@
-from __future__ import absolute_import
-import email.utils
-import mimetypes
-
-from .packages import six
-
-
-def guess_content_type(filename, default='application/octet-stream'):
-    """
-    Guess the "Content-Type" of a file.
-
-    :param filename:
-        The filename to guess the "Content-Type" of using :mod:`mimetypes`.
-    :param default:
-        If no "Content-Type" can be guessed, default to `default`.
-    """
-    if filename:
-        return mimetypes.guess_type(filename)[0] or default
-    return default
-
-
-def format_header_param(name, value):
-    """
-    Helper function to format and quote a single header parameter.
-
-    Particularly useful for header parameters which might contain
-    non-ASCII values, like file names. This follows RFC 2231, as
-    suggested by RFC 2388 Section 4.4.
-
-    :param name:
-        The name of the parameter, a string expected to be ASCII only.
-    :param value:
-        The value of the parameter, provided as a unicode string.
-    """
-    if not any(ch in value for ch in '"\\\r\n'):
-        result = '%s="%s"' % (name, value)
-        try:
-            result.encode('ascii')
-        except (UnicodeEncodeError, UnicodeDecodeError):
-            pass
-        else:
-            return result
-    if not six.PY3 and isinstance(value, six.text_type):  # Python 2:
-        value = value.encode('utf-8')
-    value = email.utils.encode_rfc2231(value, 'utf-8')
-    value = '%s*=%s' % (name, value)
-    return value
-
-
-class RequestField(object):
-    """
-    A data container for request body parameters.
-
-    :param name:
-        The name of this request field.
-    :param data:
-        The data/value body.
-    :param filename:
-        An optional filename of the request field.
-    :param headers:
-        An optional dict-like object of headers to initially use for the field.
-    """
-    def __init__(self, name, data, filename=None, headers=None):
-        self._name = name
-        self._filename = filename
-        self.data = data
-        self.headers = {}
-        if headers:
-            self.headers = dict(headers)
-
-    @classmethod
-    def from_tuples(cls, fieldname, value):
-        """
-        A :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.
-
-        Supports constructing :class:`~urllib3.fields.RequestField` from
-        parameter of key/value strings AND key/filetuple. A filetuple is a
-        (filename, data, MIME type) tuple where the MIME type is optional.
-        For example::
-
-            'foo': 'bar',
-            'fakefile': ('foofile.txt', 'contents of foofile'),
-            'realfile': ('barfile.txt', open('realfile').read()),
-            'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),
-            'nonamefile': 'contents of nonamefile field',
-
-        Field names and filenames must be unicode.
-        """
-        if isinstance(value, tuple):
-            if len(value) == 3:
-                filename, data, content_type = value
-            else:
-                filename, data = value
-                content_type = guess_content_type(filename)
-        else:
-            filename = None
-            content_type = None
-            data = value
-
-        request_param = cls(fieldname, data, filename=filename)
-        request_param.make_multipart(content_type=content_type)
-
-        return request_param
-
-    def _render_part(self, name, value):
-        """
-        Overridable helper function to format a single header parameter.
-
-        :param name:
-            The name of the parameter, a string expected to be ASCII only.
-        :param value:
-            The value of the parameter, provided as a unicode string.
-        """
-        return format_header_param(name, value)
-
-    def _render_parts(self, header_parts):
-        """
-        Helper function to format and quote a single header.
-
-        Useful for single headers that are composed of multiple items. E.g.,
-        'Content-Disposition' fields.
-
-        :param header_parts:
-            A sequence of (k, v) typles or a :class:`dict` of (k, v) to format
-            as `k1="v1"; k2="v2"; ...`.
-        """
-        parts = []
-        iterable = header_parts
-        if isinstance(header_parts, dict):
-            iterable = header_parts.items()
-
-        for name, value in iterable:
-            if value is not None:
-                parts.append(self._render_part(name, value))
-
-        return '; '.join(parts)
-
-    def render_headers(self):
-        """
-        Renders the headers for this request field.
-        """
-        lines = []
-
-        sort_keys = ['Content-Disposition', 'Content-Type', 'Content-Location']
-        for sort_key in sort_keys:
-            if self.headers.get(sort_key, False):
-                lines.append('%s: %s' % (sort_key, self.headers[sort_key]))
-
-        for header_name, header_value in self.headers.items():
-            if header_name not in sort_keys:
-                if header_value:
-                    lines.append('%s: %s' % (header_name, header_value))
-
-        lines.append('\r\n')
-        return '\r\n'.join(lines)
-
-    def make_multipart(self, content_disposition=None, content_type=None,
-                       content_location=None):
-        """
-        Makes this request field into a multipart request field.
-
-        This method overrides "Content-Disposition", "Content-Type" and
-        "Content-Location" headers to the request parameter.
-
-        :param content_type:
-            The 'Content-Type' of the request body.
-        :param content_location:
-            The 'Content-Location' of the request body.
-
-        """
-        self.headers['Content-Disposition'] = content_disposition or 'form-data'
-        self.headers['Content-Disposition'] += '; '.join([
-            '', self._render_parts(
-                (('name', self._name), ('filename', self._filename))
-            )
-        ])
-        self.headers['Content-Type'] = content_type
-        self.headers['Content-Location'] = content_location
+from __future__ import absolute_import
+import email.utils
+import mimetypes
+
+from .packages import six
+
+
+def guess_content_type(filename, default='application/octet-stream'):
+    """
+    Guess the "Content-Type" of a file.
+
+    :param filename:
+        The filename to guess the "Content-Type" of using :mod:`mimetypes`.
+    :param default:
+        If no "Content-Type" can be guessed, default to `default`.
+    """
+    if filename:
+        return mimetypes.guess_type(filename)[0] or default
+    return default
+
+
+def format_header_param(name, value):
+    """
+    Helper function to format and quote a single header parameter.
+
+    Particularly useful for header parameters which might contain
+    non-ASCII values, like file names. This follows RFC 2231, as
+    suggested by RFC 2388 Section 4.4.
+
+    :param name:
+        The name of the parameter, a string expected to be ASCII only.
+    :param value:
+        The value of the parameter, provided as a unicode string.
+    """
+    if not any(ch in value for ch in '"\\\r\n'):
+        result = '%s="%s"' % (name, value)
+        try:
+            result.encode('ascii')
+        except (UnicodeEncodeError, UnicodeDecodeError):
+            pass
+        else:
+            return result
+    if not six.PY3 and isinstance(value, six.text_type):  # Python 2:
+        value = value.encode('utf-8')
+    value = email.utils.encode_rfc2231(value, 'utf-8')
+    value = '%s*=%s' % (name, value)
+    return value
+
+
+class RequestField(object):
+    """
+    A data container for request body parameters.
+
+    :param name:
+        The name of this request field.
+    :param data:
+        The data/value body.
+    :param filename:
+        An optional filename of the request field.
+    :param headers:
+        An optional dict-like object of headers to initially use for the field.
+    """
+    def __init__(self, name, data, filename=None, headers=None):
+        self._name = name
+        self._filename = filename
+        self.data = data
+        self.headers = {}
+        if headers:
+            self.headers = dict(headers)
+
+    @classmethod
+    def from_tuples(cls, fieldname, value):
+        """
+        A :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.
+
+        Supports constructing :class:`~urllib3.fields.RequestField` from
+        parameter of key/value strings AND key/filetuple. A filetuple is a
+        (filename, data, MIME type) tuple where the MIME type is optional.
+        For example::
+
+            'foo': 'bar',
+            'fakefile': ('foofile.txt', 'contents of foofile'),
+            'realfile': ('barfile.txt', open('realfile').read()),
+            'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),
+            'nonamefile': 'contents of nonamefile field',
+
+        Field names and filenames must be unicode.
+        """
+        if isinstance(value, tuple):
+            if len(value) == 3:
+                filename, data, content_type = value
+            else:
+                filename, data = value
+                content_type = guess_content_type(filename)
+        else:
+            filename = None
+            content_type = None
+            data = value
+
+        request_param = cls(fieldname, data, filename=filename)
+        request_param.make_multipart(content_type=content_type)
+
+        return request_param
+
+    def _render_part(self, name, value):
+        """
+        Overridable helper function to format a single header parameter.
+
+        :param name:
+            The name of the parameter, a string expected to be ASCII only.
+        :param value:
+            The value of the parameter, provided as a unicode string.
+        """
+        return format_header_param(name, value)
+
+    def _render_parts(self, header_parts):
+        """
+        Helper function to format and quote a single header.
+
+        Useful for single headers that are composed of multiple items. E.g.,
+        'Content-Disposition' fields.
+
+        :param header_parts:
+            A sequence of (k, v) typles or a :class:`dict` of (k, v) to format
+            as `k1="v1"; k2="v2"; ...`.
+        """
+        parts = []
+        iterable = header_parts
+        if isinstance(header_parts, dict):
+            iterable = header_parts.items()
+
+        for name, value in iterable:
+            if value is not None:
+                parts.append(self._render_part(name, value))
+
+        return '; '.join(parts)
+
+    def render_headers(self):
+        """
+        Renders the headers for this request field.
+        """
+        lines = []
+
+        sort_keys = ['Content-Disposition', 'Content-Type', 'Content-Location']
+        for sort_key in sort_keys:
+            if self.headers.get(sort_key, False):
+                lines.append('%s: %s' % (sort_key, self.headers[sort_key]))
+
+        for header_name, header_value in self.headers.items():
+            if header_name not in sort_keys:
+                if header_value:
+                    lines.append('%s: %s' % (header_name, header_value))
+
+        lines.append('\r\n')
+        return '\r\n'.join(lines)
+
+    def make_multipart(self, content_disposition=None, content_type=None,
+                       content_location=None):
+        """
+        Makes this request field into a multipart request field.
+
+        This method overrides "Content-Disposition", "Content-Type" and
+        "Content-Location" headers to the request parameter.
+
+        :param content_type:
+            The 'Content-Type' of the request body.
+        :param content_location:
+            The 'Content-Location' of the request body.
+
+        """
+        self.headers['Content-Disposition'] = content_disposition or 'form-data'
+        self.headers['Content-Disposition'] += '; '.join([
+            '', self._render_parts(
+                (('name', self._name), ('filename', self._filename))
+            )
+        ])
+        self.headers['Content-Type'] = content_type
+        self.headers['Content-Location'] = content_location
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/backports/makefile.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/backports/makefile.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-# -*- coding: utf-8 -*-
-"""
-backports.makefile
-~~~~~~~~~~~~~~~~~~
-
-Backports the Python 3 ``socket.makefile`` method for use with anything that
-wants to create a "fake" socket object.
-"""
-import io
-
-from socket import SocketIO
-
-
-def backport_makefile(self, mode="r", buffering=None, encoding=None,
-                      errors=None, newline=None):
-    """
-    Backport of ``socket.makefile`` from Python 3.5.
-    """
-    if not set(mode) <= set(["r", "w", "b"]):
-        raise ValueError(
-            "invalid mode %r (only r, w, b allowed)" % (mode,)
-        )
-    writing = "w" in mode
-    reading = "r" in mode or not writing
-    assert reading or writing
-    binary = "b" in mode
-    rawmode = ""
-    if reading:
-        rawmode += "r"
-    if writing:
-        rawmode += "w"
-    raw = SocketIO(self, rawmode)
-    self._makefile_refs += 1
-    if buffering is None:
-        buffering = -1
-    if buffering < 0:
-        buffering = io.DEFAULT_BUFFER_SIZE
-    if buffering == 0:
-        if not binary:
-            raise ValueError("unbuffered streams must be binary")
-        return raw
-    if reading and writing:
-        buffer = io.BufferedRWPair(raw, raw, buffering)
-    elif reading:
-        buffer = io.BufferedReader(raw, buffering)
-    else:
-        assert writing
-        buffer = io.BufferedWriter(raw, buffering)
-    if binary:
-        return buffer
-    text = io.TextIOWrapper(buffer, encoding, errors, newline)
-    text.mode = mode
-    return text
+# -*- coding: utf-8 -*-
+"""
+backports.makefile
+~~~~~~~~~~~~~~~~~~
+
+Backports the Python 3 ``socket.makefile`` method for use with anything that
+wants to create a "fake" socket object.
+"""
+import io
+
+from socket import SocketIO
+
+
+def backport_makefile(self, mode="r", buffering=None, encoding=None,
+                      errors=None, newline=None):
+    """
+    Backport of ``socket.makefile`` from Python 3.5.
+    """
+    if not set(mode) <= set(["r", "w", "b"]):
+        raise ValueError(
+            "invalid mode %r (only r, w, b allowed)" % (mode,)
+        )
+    writing = "w" in mode
+    reading = "r" in mode or not writing
+    assert reading or writing
+    binary = "b" in mode
+    rawmode = ""
+    if reading:
+        rawmode += "r"
+    if writing:
+        rawmode += "w"
+    raw = SocketIO(self, rawmode)
+    self._makefile_refs += 1
+    if buffering is None:
+        buffering = -1
+    if buffering < 0:
+        buffering = io.DEFAULT_BUFFER_SIZE
+    if buffering == 0:
+        if not binary:
+            raise ValueError("unbuffered streams must be binary")
+        return raw
+    if reading and writing:
+        buffer = io.BufferedRWPair(raw, raw, buffering)
+    elif reading:
+        buffer = io.BufferedReader(raw, buffering)
+    else:
+        assert writing
+        buffer = io.BufferedWriter(raw, buffering)
+    if binary:
+        return buffer
+    text = io.TextIOWrapper(buffer, encoding, errors, newline)
+    text.mode = mode
+    return text
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/ordered_dict.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/ordered_dict.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,259 +1,259 @@
-# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
-# Passes Python2.7's test suite and incorporates all the latest updates.
-# Copyright 2009 Raymond Hettinger, released under the MIT License.
-# http://code.activestate.com/recipes/576693/
-try:
-    from thread import get_ident as _get_ident
-except ImportError:
-    from dummy_thread import get_ident as _get_ident
-
-try:
-    from _abcoll import KeysView, ValuesView, ItemsView
-except ImportError:
-    pass
-
-
-class OrderedDict(dict):
-    'Dictionary that remembers insertion order'
-    # An inherited dict maps keys to values.
-    # The inherited dict provides __getitem__, __len__, __contains__, and get.
-    # The remaining methods are order-aware.
-    # Big-O running times for all methods are the same as for regular dictionaries.
-
-    # The internal self.__map dictionary maps keys to links in a doubly linked list.
-    # The circular doubly linked list starts and ends with a sentinel element.
-    # The sentinel element never gets deleted (this simplifies the algorithm).
-    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].
-
-    def __init__(self, *args, **kwds):
-        '''Initialize an ordered dictionary.  Signature is the same as for
-        regular dictionaries, but keyword arguments are not recommended
-        because their insertion order is arbitrary.
-
-        '''
-        if len(args) > 1:
-            raise TypeError('expected at most 1 arguments, got %d' % len(args))
-        try:
-            self.__root
-        except AttributeError:
-            self.__root = root = []                     # sentinel node
-            root[:] = [root, root, None]
-            self.__map = {}
-        self.__update(*args, **kwds)
-
-    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
-        'od.__setitem__(i, y) <==> od[i]=y'
-        # Setting a new item creates a new link which goes at the end of the linked
-        # list, and the inherited dictionary is updated with the new key/value pair.
-        if key not in self:
-            root = self.__root
-            last = root[0]
-            last[1] = root[0] = self.__map[key] = [last, root, key]
-        dict_setitem(self, key, value)
-
-    def __delitem__(self, key, dict_delitem=dict.__delitem__):
-        'od.__delitem__(y) <==> del od[y]'
-        # Deleting an existing item uses self.__map to find the link which is
-        # then removed by updating the links in the predecessor and successor nodes.
-        dict_delitem(self, key)
-        link_prev, link_next, key = self.__map.pop(key)
-        link_prev[1] = link_next
-        link_next[0] = link_prev
-
-    def __iter__(self):
-        'od.__iter__() <==> iter(od)'
-        root = self.__root
-        curr = root[1]
-        while curr is not root:
-            yield curr[2]
-            curr = curr[1]
-
-    def __reversed__(self):
-        'od.__reversed__() <==> reversed(od)'
-        root = self.__root
-        curr = root[0]
-        while curr is not root:
-            yield curr[2]
-            curr = curr[0]
-
-    def clear(self):
-        'od.clear() -> None.  Remove all items from od.'
-        try:
-            for node in self.__map.itervalues():
-                del node[:]
-            root = self.__root
-            root[:] = [root, root, None]
-            self.__map.clear()
-        except AttributeError:
-            pass
-        dict.clear(self)
-
-    def popitem(self, last=True):
-        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
-        Pairs are returned in LIFO order if last is true or FIFO order if false.
-
-        '''
-        if not self:
-            raise KeyError('dictionary is empty')
-        root = self.__root
-        if last:
-            link = root[0]
-            link_prev = link[0]
-            link_prev[1] = root
-            root[0] = link_prev
-        else:
-            link = root[1]
-            link_next = link[1]
-            root[1] = link_next
-            link_next[0] = root
-        key = link[2]
-        del self.__map[key]
-        value = dict.pop(self, key)
-        return key, value
-
-    # -- the following methods do not depend on the internal structure --
-
-    def keys(self):
-        'od.keys() -> list of keys in od'
-        return list(self)
-
-    def values(self):
-        'od.values() -> list of values in od'
-        return [self[key] for key in self]
-
-    def items(self):
-        'od.items() -> list of (key, value) pairs in od'
-        return [(key, self[key]) for key in self]
-
-    def iterkeys(self):
-        'od.iterkeys() -> an iterator over the keys in od'
-        return iter(self)
-
-    def itervalues(self):
-        'od.itervalues -> an iterator over the values in od'
-        for k in self:
-            yield self[k]
-
-    def iteritems(self):
-        'od.iteritems -> an iterator over the (key, value) items in od'
-        for k in self:
-            yield (k, self[k])
-
-    def update(*args, **kwds):
-        '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.
-
-        If E is a dict instance, does:           for k in E: od[k] = E[k]
-        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
-        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
-        In either case, this is followed by:     for k, v in F.items(): od[k] = v
-
-        '''
-        if len(args) > 2:
-            raise TypeError('update() takes at most 2 positional '
-                            'arguments (%d given)' % (len(args),))
-        elif not args:
-            raise TypeError('update() takes at least 1 argument (0 given)')
-        self = args[0]
-        # Make progressively weaker assumptions about "other"
-        other = ()
-        if len(args) == 2:
-            other = args[1]
-        if isinstance(other, dict):
-            for key in other:
-                self[key] = other[key]
-        elif hasattr(other, 'keys'):
-            for key in other.keys():
-                self[key] = other[key]
-        else:
-            for key, value in other:
-                self[key] = value
-        for key, value in kwds.items():
-            self[key] = value
-
-    __update = update  # let subclasses override update without breaking __init__
-
-    __marker = object()
-
-    def pop(self, key, default=__marker):
-        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
-        If key is not found, d is returned if given, otherwise KeyError is raised.
-
-        '''
-        if key in self:
-            result = self[key]
-            del self[key]
-            return result
-        if default is self.__marker:
-            raise KeyError(key)
-        return default
-
-    def setdefault(self, key, default=None):
-        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
-        if key in self:
-            return self[key]
-        self[key] = default
-        return default
-
-    def __repr__(self, _repr_running={}):
-        'od.__repr__() <==> repr(od)'
-        call_key = id(self), _get_ident()
-        if call_key in _repr_running:
-            return '...'
-        _repr_running[call_key] = 1
-        try:
-            if not self:
-                return '%s()' % (self.__class__.__name__,)
-            return '%s(%r)' % (self.__class__.__name__, self.items())
-        finally:
-            del _repr_running[call_key]
-
-    def __reduce__(self):
-        'Return state information for pickling'
-        items = [[k, self[k]] for k in self]
-        inst_dict = vars(self).copy()
-        for k in vars(OrderedDict()):
-            inst_dict.pop(k, None)
-        if inst_dict:
-            return (self.__class__, (items,), inst_dict)
-        return self.__class__, (items,)
-
-    def copy(self):
-        'od.copy() -> a shallow copy of od'
-        return self.__class__(self)
-
-    @classmethod
-    def fromkeys(cls, iterable, value=None):
-        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
-        and values equal to v (which defaults to None).
-
-        '''
-        d = cls()
-        for key in iterable:
-            d[key] = value
-        return d
-
-    def __eq__(self, other):
-        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
-        while comparison to a regular mapping is order-insensitive.
-
-        '''
-        if isinstance(other, OrderedDict):
-            return len(self)==len(other) and self.items() == other.items()
-        return dict.__eq__(self, other)
-
-    def __ne__(self, other):
-        return not self == other
-
-    # -- the following methods are only used in Python 2.7 --
-
-    def viewkeys(self):
-        "od.viewkeys() -> a set-like object providing a view on od's keys"
-        return KeysView(self)
-
-    def viewvalues(self):
-        "od.viewvalues() -> an object providing a view on od's values"
-        return ValuesView(self)
-
-    def viewitems(self):
-        "od.viewitems() -> a set-like object providing a view on od's items"
-        return ItemsView(self)
+# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
+# Passes Python2.7's test suite and incorporates all the latest updates.
+# Copyright 2009 Raymond Hettinger, released under the MIT License.
+# http://code.activestate.com/recipes/576693/
+try:
+    from thread import get_ident as _get_ident
+except ImportError:
+    from dummy_thread import get_ident as _get_ident
+
+try:
+    from _abcoll import KeysView, ValuesView, ItemsView
+except ImportError:
+    pass
+
+
+class OrderedDict(dict):
+    'Dictionary that remembers insertion order'
+    # An inherited dict maps keys to values.
+    # The inherited dict provides __getitem__, __len__, __contains__, and get.
+    # The remaining methods are order-aware.
+    # Big-O running times for all methods are the same as for regular dictionaries.
+
+    # The internal self.__map dictionary maps keys to links in a doubly linked list.
+    # The circular doubly linked list starts and ends with a sentinel element.
+    # The sentinel element never gets deleted (this simplifies the algorithm).
+    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].
+
+    def __init__(self, *args, **kwds):
+        '''Initialize an ordered dictionary.  Signature is the same as for
+        regular dictionaries, but keyword arguments are not recommended
+        because their insertion order is arbitrary.
+
+        '''
+        if len(args) > 1:
+            raise TypeError('expected at most 1 arguments, got %d' % len(args))
+        try:
+            self.__root
+        except AttributeError:
+            self.__root = root = []                     # sentinel node
+            root[:] = [root, root, None]
+            self.__map = {}
+        self.__update(*args, **kwds)
+
+    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
+        'od.__setitem__(i, y) <==> od[i]=y'
+        # Setting a new item creates a new link which goes at the end of the linked
+        # list, and the inherited dictionary is updated with the new key/value pair.
+        if key not in self:
+            root = self.__root
+            last = root[0]
+            last[1] = root[0] = self.__map[key] = [last, root, key]
+        dict_setitem(self, key, value)
+
+    def __delitem__(self, key, dict_delitem=dict.__delitem__):
+        'od.__delitem__(y) <==> del od[y]'
+        # Deleting an existing item uses self.__map to find the link which is
+        # then removed by updating the links in the predecessor and successor nodes.
+        dict_delitem(self, key)
+        link_prev, link_next, key = self.__map.pop(key)
+        link_prev[1] = link_next
+        link_next[0] = link_prev
+
+    def __iter__(self):
+        'od.__iter__() <==> iter(od)'
+        root = self.__root
+        curr = root[1]
+        while curr is not root:
+            yield curr[2]
+            curr = curr[1]
+
+    def __reversed__(self):
+        'od.__reversed__() <==> reversed(od)'
+        root = self.__root
+        curr = root[0]
+        while curr is not root:
+            yield curr[2]
+            curr = curr[0]
+
+    def clear(self):
+        'od.clear() -> None.  Remove all items from od.'
+        try:
+            for node in self.__map.itervalues():
+                del node[:]
+            root = self.__root
+            root[:] = [root, root, None]
+            self.__map.clear()
+        except AttributeError:
+            pass
+        dict.clear(self)
+
+    def popitem(self, last=True):
+        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
+        Pairs are returned in LIFO order if last is true or FIFO order if false.
+
+        '''
+        if not self:
+            raise KeyError('dictionary is empty')
+        root = self.__root
+        if last:
+            link = root[0]
+            link_prev = link[0]
+            link_prev[1] = root
+            root[0] = link_prev
+        else:
+            link = root[1]
+            link_next = link[1]
+            root[1] = link_next
+            link_next[0] = root
+        key = link[2]
+        del self.__map[key]
+        value = dict.pop(self, key)
+        return key, value
+
+    # -- the following methods do not depend on the internal structure --
+
+    def keys(self):
+        'od.keys() -> list of keys in od'
+        return list(self)
+
+    def values(self):
+        'od.values() -> list of values in od'
+        return [self[key] for key in self]
+
+    def items(self):
+        'od.items() -> list of (key, value) pairs in od'
+        return [(key, self[key]) for key in self]
+
+    def iterkeys(self):
+        'od.iterkeys() -> an iterator over the keys in od'
+        return iter(self)
+
+    def itervalues(self):
+        'od.itervalues -> an iterator over the values in od'
+        for k in self:
+            yield self[k]
+
+    def iteritems(self):
+        'od.iteritems -> an iterator over the (key, value) items in od'
+        for k in self:
+            yield (k, self[k])
+
+    def update(*args, **kwds):
+        '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.
+
+        If E is a dict instance, does:           for k in E: od[k] = E[k]
+        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
+        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
+        In either case, this is followed by:     for k, v in F.items(): od[k] = v
+
+        '''
+        if len(args) > 2:
+            raise TypeError('update() takes at most 2 positional '
+                            'arguments (%d given)' % (len(args),))
+        elif not args:
+            raise TypeError('update() takes at least 1 argument (0 given)')
+        self = args[0]
+        # Make progressively weaker assumptions about "other"
+        other = ()
+        if len(args) == 2:
+            other = args[1]
+        if isinstance(other, dict):
+            for key in other:
+                self[key] = other[key]
+        elif hasattr(other, 'keys'):
+            for key in other.keys():
+                self[key] = other[key]
+        else:
+            for key, value in other:
+                self[key] = value
+        for key, value in kwds.items():
+            self[key] = value
+
+    __update = update  # let subclasses override update without breaking __init__
+
+    __marker = object()
+
+    def pop(self, key, default=__marker):
+        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
+        If key is not found, d is returned if given, otherwise KeyError is raised.
+
+        '''
+        if key in self:
+            result = self[key]
+            del self[key]
+            return result
+        if default is self.__marker:
+            raise KeyError(key)
+        return default
+
+    def setdefault(self, key, default=None):
+        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
+        if key in self:
+            return self[key]
+        self[key] = default
+        return default
+
+    def __repr__(self, _repr_running={}):
+        'od.__repr__() <==> repr(od)'
+        call_key = id(self), _get_ident()
+        if call_key in _repr_running:
+            return '...'
+        _repr_running[call_key] = 1
+        try:
+            if not self:
+                return '%s()' % (self.__class__.__name__,)
+            return '%s(%r)' % (self.__class__.__name__, self.items())
+        finally:
+            del _repr_running[call_key]
+
+    def __reduce__(self):
+        'Return state information for pickling'
+        items = [[k, self[k]] for k in self]
+        inst_dict = vars(self).copy()
+        for k in vars(OrderedDict()):
+            inst_dict.pop(k, None)
+        if inst_dict:
+            return (self.__class__, (items,), inst_dict)
+        return self.__class__, (items,)
+
+    def copy(self):
+        'od.copy() -> a shallow copy of od'
+        return self.__class__(self)
+
+    @classmethod
+    def fromkeys(cls, iterable, value=None):
+        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
+        and values equal to v (which defaults to None).
+
+        '''
+        d = cls()
+        for key in iterable:
+            d[key] = value
+        return d
+
+    def __eq__(self, other):
+        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
+        while comparison to a regular mapping is order-insensitive.
+
+        '''
+        if isinstance(other, OrderedDict):
+            return len(self)==len(other) and self.items() == other.items()
+        return dict.__eq__(self, other)
+
+    def __ne__(self, other):
+        return not self == other
+
+    # -- the following methods are only used in Python 2.7 --
+
+    def viewkeys(self):
+        "od.viewkeys() -> a set-like object providing a view on od's keys"
+        return KeysView(self)
+
+    def viewvalues(self):
+        "od.viewvalues() -> an object providing a view on od's values"
+        return ValuesView(self)
+
+    def viewitems(self):
+        "od.viewitems() -> a set-like object providing a view on od's items"
+        return ItemsView(self)
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/packages/ssl_match_hostname/_implementation.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/packages/ssl_match_hostname/_implementation.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,157 +1,157 @@
-"""The match_hostname() function from Python 3.3.3, essential when using SSL."""
-
-# Note: This file is under the PSF license as the code comes from the python
-# stdlib.   http://docs.python.org/3/license.html
-
-import re
-import sys
-
-# ipaddress has been backported to 2.6+ in pypi.  If it is installed on the
-# system, use it to handle IPAddress ServerAltnames (this was added in
-# python-3.5) otherwise only do DNS matching.  This allows
-# backports.ssl_match_hostname to continue to be used all the way back to
-# python-2.4.
-try:
-    import ipaddress
-except ImportError:
-    ipaddress = None
-
-__version__ = '3.5.0.1'
-
-
-class CertificateError(ValueError):
-    pass
-
-
-def _dnsname_match(dn, hostname, max_wildcards=1):
-    """Matching according to RFC 6125, section 6.4.3
-
-    http://tools.ietf.org/html/rfc6125#section-6.4.3
-    """
-    pats = []
-    if not dn:
-        return False
-
-    # Ported from python3-syntax:
-    # leftmost, *remainder = dn.split(r'.')
-    parts = dn.split(r'.')
-    leftmost = parts[0]
-    remainder = parts[1:]
-
-    wildcards = leftmost.count('*')
-    if wildcards > max_wildcards:
-        # Issue #17980: avoid denials of service by refusing more
-        # than one wildcard per fragment.  A survey of established
-        # policy among SSL implementations showed it to be a
-        # reasonable choice.
-        raise CertificateError(
-            "too many wildcards in certificate DNS name: " + repr(dn))
-
-    # speed up common case w/o wildcards
-    if not wildcards:
-        return dn.lower() == hostname.lower()
-
-    # RFC 6125, section 6.4.3, subitem 1.
-    # The client SHOULD NOT attempt to match a presented identifier in which
-    # the wildcard character comprises a label other than the left-most label.
-    if leftmost == '*':
-        # When '*' is a fragment by itself, it matches a non-empty dotless
-        # fragment.
-        pats.append('[^.]+')
-    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):
-        # RFC 6125, section 6.4.3, subitem 3.
-        # The client SHOULD NOT attempt to match a presented identifier
-        # where the wildcard character is embedded within an A-label or
-        # U-label of an internationalized domain name.
-        pats.append(re.escape(leftmost))
-    else:
-        # Otherwise, '*' matches any dotless string, e.g. www*
-        pats.append(re.escape(leftmost).replace(r'\*', '[^.]*'))
-
-    # add the remaining fragments, ignore any wildcards
-    for frag in remainder:
-        pats.append(re.escape(frag))
-
-    pat = re.compile(r'\A' + r'\.'.join(pats) + r'\Z', re.IGNORECASE)
-    return pat.match(hostname)
-
-
-def _to_unicode(obj):
-    if isinstance(obj, str) and sys.version_info < (3,):
-        obj = unicode(obj, encoding='ascii', errors='strict')
-    return obj
-
-def _ipaddress_match(ipname, host_ip):
-    """Exact matching of IP addresses.
-
-    RFC 6125 explicitly doesn't define an algorithm for this
-    (section 1.7.2 - "Out of Scope").
-    """
-    # OpenSSL may add a trailing newline to a subjectAltName's IP address
-    # Divergence from upstream: ipaddress can't handle byte str
-    ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())
-    return ip == host_ip
-
-
-def match_hostname(cert, hostname):
-    """Verify that *cert* (in decoded format as returned by
-    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
-    rules are followed, but IP addresses are not accepted for *hostname*.
-
-    CertificateError is raised on failure. On success, the function
-    returns nothing.
-    """
-    if not cert:
-        raise ValueError("empty or no certificate, match_hostname needs a "
-                         "SSL socket or SSL context with either "
-                         "CERT_OPTIONAL or CERT_REQUIRED")
-    try:
-        # Divergence from upstream: ipaddress can't handle byte str
-        host_ip = ipaddress.ip_address(_to_unicode(hostname))
-    except ValueError:
-        # Not an IP address (common case)
-        host_ip = None
-    except UnicodeError:
-        # Divergence from upstream: Have to deal with ipaddress not taking
-        # byte strings.  addresses should be all ascii, so we consider it not
-        # an ipaddress in this case
-        host_ip = None
-    except AttributeError:
-        # Divergence from upstream: Make ipaddress library optional
-        if ipaddress is None:
-            host_ip = None
-        else:
-            raise
-    dnsnames = []
-    san = cert.get('subjectAltName', ())
-    for key, value in san:
-        if key == 'DNS':
-            if host_ip is None and _dnsname_match(value, hostname):
-                return
-            dnsnames.append(value)
-        elif key == 'IP Address':
-            if host_ip is not None and _ipaddress_match(value, host_ip):
-                return
-            dnsnames.append(value)
-    if not dnsnames:
-        # The subject is only checked when there is no dNSName entry
-        # in subjectAltName
-        for sub in cert.get('subject', ()):
-            for key, value in sub:
-                # XXX according to RFC 2818, the most specific Common Name
-                # must be used.
-                if key == 'commonName':
-                    if _dnsname_match(value, hostname):
-                        return
-                    dnsnames.append(value)
-    if len(dnsnames) > 1:
-        raise CertificateError("hostname %r "
-            "doesn't match either of %s"
-            % (hostname, ', '.join(map(repr, dnsnames))))
-    elif len(dnsnames) == 1:
-        raise CertificateError("hostname %r "
-            "doesn't match %r"
-            % (hostname, dnsnames[0]))
-    else:
-        raise CertificateError("no appropriate commonName or "
-            "subjectAltName fields were found")
+"""The match_hostname() function from Python 3.3.3, essential when using SSL."""
+
+# Note: This file is under the PSF license as the code comes from the python
+# stdlib.   http://docs.python.org/3/license.html
+
+import re
+import sys
+
+# ipaddress has been backported to 2.6+ in pypi.  If it is installed on the
+# system, use it to handle IPAddress ServerAltnames (this was added in
+# python-3.5) otherwise only do DNS matching.  This allows
+# backports.ssl_match_hostname to continue to be used all the way back to
+# python-2.4.
+try:
+    import ipaddress
+except ImportError:
+    ipaddress = None
+
+__version__ = '3.5.0.1'
+
+
+class CertificateError(ValueError):
+    pass
+
+
+def _dnsname_match(dn, hostname, max_wildcards=1):
+    """Matching according to RFC 6125, section 6.4.3
+
+    http://tools.ietf.org/html/rfc6125#section-6.4.3
+    """
+    pats = []
+    if not dn:
+        return False
+
+    # Ported from python3-syntax:
+    # leftmost, *remainder = dn.split(r'.')
+    parts = dn.split(r'.')
+    leftmost = parts[0]
+    remainder = parts[1:]
+
+    wildcards = leftmost.count('*')
+    if wildcards > max_wildcards:
+        # Issue #17980: avoid denials of service by refusing more
+        # than one wildcard per fragment.  A survey of established
+        # policy among SSL implementations showed it to be a
+        # reasonable choice.
+        raise CertificateError(
+            "too many wildcards in certificate DNS name: " + repr(dn))
+
+    # speed up common case w/o wildcards
+    if not wildcards:
+        return dn.lower() == hostname.lower()
+
+    # RFC 6125, section 6.4.3, subitem 1.
+    # The client SHOULD NOT attempt to match a presented identifier in which
+    # the wildcard character comprises a label other than the left-most label.
+    if leftmost == '*':
+        # When '*' is a fragment by itself, it matches a non-empty dotless
+        # fragment.
+        pats.append('[^.]+')
+    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):
+        # RFC 6125, section 6.4.3, subitem 3.
+        # The client SHOULD NOT attempt to match a presented identifier
+        # where the wildcard character is embedded within an A-label or
+        # U-label of an internationalized domain name.
+        pats.append(re.escape(leftmost))
+    else:
+        # Otherwise, '*' matches any dotless string, e.g. www*
+        pats.append(re.escape(leftmost).replace(r'\*', '[^.]*'))
+
+    # add the remaining fragments, ignore any wildcards
+    for frag in remainder:
+        pats.append(re.escape(frag))
+
+    pat = re.compile(r'\A' + r'\.'.join(pats) + r'\Z', re.IGNORECASE)
+    return pat.match(hostname)
+
+
+def _to_unicode(obj):
+    if isinstance(obj, str) and sys.version_info < (3,):
+        obj = unicode(obj, encoding='ascii', errors='strict')
+    return obj
+
+def _ipaddress_match(ipname, host_ip):
+    """Exact matching of IP addresses.
+
+    RFC 6125 explicitly doesn't define an algorithm for this
+    (section 1.7.2 - "Out of Scope").
+    """
+    # OpenSSL may add a trailing newline to a subjectAltName's IP address
+    # Divergence from upstream: ipaddress can't handle byte str
+    ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())
+    return ip == host_ip
+
+
+def match_hostname(cert, hostname):
+    """Verify that *cert* (in decoded format as returned by
+    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
+    rules are followed, but IP addresses are not accepted for *hostname*.
+
+    CertificateError is raised on failure. On success, the function
+    returns nothing.
+    """
+    if not cert:
+        raise ValueError("empty or no certificate, match_hostname needs a "
+                         "SSL socket or SSL context with either "
+                         "CERT_OPTIONAL or CERT_REQUIRED")
+    try:
+        # Divergence from upstream: ipaddress can't handle byte str
+        host_ip = ipaddress.ip_address(_to_unicode(hostname))
+    except ValueError:
+        # Not an IP address (common case)
+        host_ip = None
+    except UnicodeError:
+        # Divergence from upstream: Have to deal with ipaddress not taking
+        # byte strings.  addresses should be all ascii, so we consider it not
+        # an ipaddress in this case
+        host_ip = None
+    except AttributeError:
+        # Divergence from upstream: Make ipaddress library optional
+        if ipaddress is None:
+            host_ip = None
+        else:
+            raise
+    dnsnames = []
+    san = cert.get('subjectAltName', ())
+    for key, value in san:
+        if key == 'DNS':
+            if host_ip is None and _dnsname_match(value, hostname):
+                return
+            dnsnames.append(value)
+        elif key == 'IP Address':
+            if host_ip is not None and _ipaddress_match(value, host_ip):
+                return
+            dnsnames.append(value)
+    if not dnsnames:
+        # The subject is only checked when there is no dNSName entry
+        # in subjectAltName
+        for sub in cert.get('subject', ()):
+            for key, value in sub:
+                # XXX according to RFC 2818, the most specific Common Name
+                # must be used.
+                if key == 'commonName':
+                    if _dnsname_match(value, hostname):
+                        return
+                    dnsnames.append(value)
+    if len(dnsnames) > 1:
+        raise CertificateError("hostname %r "
+            "doesn't match either of %s"
+            % (hostname, ', '.join(map(repr, dnsnames))))
+    elif len(dnsnames) == 1:
+        raise CertificateError("hostname %r "
+            "doesn't match %r"
+            % (hostname, dnsnames[0]))
+    else:
+        raise CertificateError("no appropriate commonName or "
+            "subjectAltName fields were found")
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/poolmanager.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/poolmanager.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,363 +1,363 @@
-from __future__ import absolute_import
-import collections
-import functools
-import logging
-
-from ._collections import RecentlyUsedContainer
-from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool
-from .connectionpool import port_by_scheme
-from .exceptions import LocationValueError, MaxRetryError, ProxySchemeUnknown
-from .packages.six.moves.urllib.parse import urljoin
-from .request import RequestMethods
-from .util.url import parse_url
-from .util.retry import Retry
-
-
-__all__ = ['PoolManager', 'ProxyManager', 'proxy_from_url']
-
-
-log = logging.getLogger(__name__)
-
-SSL_KEYWORDS = ('key_file', 'cert_file', 'cert_reqs', 'ca_certs',
-                'ssl_version', 'ca_cert_dir', 'ssl_context')
-
-# The base fields to use when determining what pool to get a connection from;
-# these do not rely on the ``connection_pool_kw`` and can be determined by the
-# URL and potentially the ``urllib3.connection.port_by_scheme`` dictionary.
-#
-# All custom key schemes should include the fields in this key at a minimum.
-BasePoolKey = collections.namedtuple('BasePoolKey', ('scheme', 'host', 'port'))
-
-# The fields to use when determining what pool to get a HTTP and HTTPS
-# connection from. All additional fields must be present in the PoolManager's
-# ``connection_pool_kw`` instance variable.
-HTTPPoolKey = collections.namedtuple(
-    'HTTPPoolKey', BasePoolKey._fields + ('timeout', 'retries', 'strict',
-                                          'block', 'source_address')
-)
-HTTPSPoolKey = collections.namedtuple(
-    'HTTPSPoolKey', HTTPPoolKey._fields + SSL_KEYWORDS
-)
-
-
-def _default_key_normalizer(key_class, request_context):
-    """
-    Create a pool key of type ``key_class`` for a request.
-
-    According to RFC 3986, both the scheme and host are case-insensitive.
-    Therefore, this function normalizes both before constructing the pool
-    key for an HTTPS request. If you wish to change this behaviour, provide
-    alternate callables to ``key_fn_by_scheme``.
-
-    :param key_class:
-        The class to use when constructing the key. This should be a namedtuple
-        with the ``scheme`` and ``host`` keys at a minimum.
-
-    :param request_context:
-        A dictionary-like object that contain the context for a request.
-        It should contain a key for each field in the :class:`HTTPPoolKey`
-    """
-    context = {}
-    for key in key_class._fields:
-        context[key] = request_context.get(key)
-    context['scheme'] = context['scheme'].lower()
-    context['host'] = context['host'].lower()
-    return key_class(**context)
-
-
-# A dictionary that maps a scheme to a callable that creates a pool key.
-# This can be used to alter the way pool keys are constructed, if desired.
-# Each PoolManager makes a copy of this dictionary so they can be configured
-# globally here, or individually on the instance.
-key_fn_by_scheme = {
-    'http': functools.partial(_default_key_normalizer, HTTPPoolKey),
-    'https': functools.partial(_default_key_normalizer, HTTPSPoolKey),
-}
-
-pool_classes_by_scheme = {
-    'http': HTTPConnectionPool,
-    'https': HTTPSConnectionPool,
-}
-
-
-class PoolManager(RequestMethods):
-    """
-    Allows for arbitrary requests while transparently keeping track of
-    necessary connection pools for you.
-
-    :param num_pools:
-        Number of connection pools to cache before discarding the least
-        recently used pool.
-
-    :param headers:
-        Headers to include with all requests, unless other headers are given
-        explicitly.
-
-    :param \\**connection_pool_kw:
-        Additional parameters are used to create fresh
-        :class:`urllib3.connectionpool.ConnectionPool` instances.
-
-    Example::
-
-        >>> manager = PoolManager(num_pools=2)
-        >>> r = manager.request('GET', 'http://google.com/')
-        >>> r = manager.request('GET', 'http://google.com/mail')
-        >>> r = manager.request('GET', 'http://yahoo.com/')
-        >>> len(manager.pools)
-        2
-
-    """
-
-    proxy = None
-
-    def __init__(self, num_pools=10, headers=None, **connection_pool_kw):
-        RequestMethods.__init__(self, headers)
-        self.connection_pool_kw = connection_pool_kw
-        self.pools = RecentlyUsedContainer(num_pools,
-                                           dispose_func=lambda p: p.close())
-
-        # Locally set the pool classes and keys so other PoolManagers can
-        # override them.
-        self.pool_classes_by_scheme = pool_classes_by_scheme
-        self.key_fn_by_scheme = key_fn_by_scheme.copy()
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.clear()
-        # Return False to re-raise any potential exceptions
-        return False
-
-    def _new_pool(self, scheme, host, port):
-        """
-        Create a new :class:`ConnectionPool` based on host, port and scheme.
-
-        This method is used to actually create the connection pools handed out
-        by :meth:`connection_from_url` and companion methods. It is intended
-        to be overridden for customization.
-        """
-        pool_cls = self.pool_classes_by_scheme[scheme]
-        kwargs = self.connection_pool_kw
-        if scheme == 'http':
-            kwargs = self.connection_pool_kw.copy()
-            for kw in SSL_KEYWORDS:
-                kwargs.pop(kw, None)
-
-        return pool_cls(host, port, **kwargs)
-
-    def clear(self):
-        """
-        Empty our store of pools and direct them all to close.
-
-        This will not affect in-flight connections, but they will not be
-        re-used after completion.
-        """
-        self.pools.clear()
-
-    def connection_from_host(self, host, port=None, scheme='http'):
-        """
-        Get a :class:`ConnectionPool` based on the host, port, and scheme.
-
-        If ``port`` isn't given, it will be derived from the ``scheme`` using
-        ``urllib3.connectionpool.port_by_scheme``.
-        """
-
-        if not host:
-            raise LocationValueError("No host specified.")
-
-        request_context = self.connection_pool_kw.copy()
-        request_context['scheme'] = scheme or 'http'
-        if not port:
-            port = port_by_scheme.get(request_context['scheme'].lower(), 80)
-        request_context['port'] = port
-        request_context['host'] = host
-
-        return self.connection_from_context(request_context)
-
-    def connection_from_context(self, request_context):
-        """
-        Get a :class:`ConnectionPool` based on the request context.
-
-        ``request_context`` must at least contain the ``scheme`` key and its
-        value must be a key in ``key_fn_by_scheme`` instance variable.
-        """
-        scheme = request_context['scheme'].lower()
-        pool_key_constructor = self.key_fn_by_scheme[scheme]
-        pool_key = pool_key_constructor(request_context)
-
-        return self.connection_from_pool_key(pool_key)
-
-    def connection_from_pool_key(self, pool_key):
-        """
-        Get a :class:`ConnectionPool` based on the provided pool key.
-
-        ``pool_key`` should be a namedtuple that only contains immutable
-        objects. At a minimum it must have the ``scheme``, ``host``, and
-        ``port`` fields.
-        """
-        with self.pools.lock:
-            # If the scheme, host, or port doesn't match existing open
-            # connections, open a new ConnectionPool.
-            pool = self.pools.get(pool_key)
-            if pool:
-                return pool
-
-            # Make a fresh ConnectionPool of the desired type
-            pool = self._new_pool(pool_key.scheme, pool_key.host, pool_key.port)
-            self.pools[pool_key] = pool
-
-        return pool
-
-    def connection_from_url(self, url):
-        """
-        Similar to :func:`urllib3.connectionpool.connection_from_url` but
-        doesn't pass any additional parameters to the
-        :class:`urllib3.connectionpool.ConnectionPool` constructor.
-
-        Additional parameters are taken from the :class:`.PoolManager`
-        constructor.
-        """
-        u = parse_url(url)
-        return self.connection_from_host(u.host, port=u.port, scheme=u.scheme)
-
-    def urlopen(self, method, url, redirect=True, **kw):
-        """
-        Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen`
-        with custom cross-host redirect logic and only sends the request-uri
-        portion of the ``url``.
-
-        The given ``url`` parameter must be absolute, such that an appropriate
-        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.
-        """
-        u = parse_url(url)
-        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)
-
-        kw['assert_same_host'] = False
-        kw['redirect'] = False
-        if 'headers' not in kw:
-            kw['headers'] = self.headers
-
-        if self.proxy is not None and u.scheme == "http":
-            response = conn.urlopen(method, url, **kw)
-        else:
-            response = conn.urlopen(method, u.request_uri, **kw)
-
-        redirect_location = redirect and response.get_redirect_location()
-        if not redirect_location:
-            return response
-
-        # Support relative URLs for redirecting.
-        redirect_location = urljoin(url, redirect_location)
-
-        # RFC 7231, Section 6.4.4
-        if response.status == 303:
-            method = 'GET'
-
-        retries = kw.get('retries')
-        if not isinstance(retries, Retry):
-            retries = Retry.from_int(retries, redirect=redirect)
-
-        try:
-            retries = retries.increment(method, url, response=response, _pool=conn)
-        except MaxRetryError:
-            if retries.raise_on_redirect:
-                raise
-            return response
-
-        kw['retries'] = retries
-        kw['redirect'] = redirect
-
-        log.info("Redirecting %s -> %s", url, redirect_location)
-        return self.urlopen(method, redirect_location, **kw)
-
-
-class ProxyManager(PoolManager):
-    """
-    Behaves just like :class:`PoolManager`, but sends all requests through
-    the defined proxy, using the CONNECT method for HTTPS URLs.
-
-    :param proxy_url:
-        The URL of the proxy to be used.
-
-    :param proxy_headers:
-        A dictionary contaning headers that will be sent to the proxy. In case
-        of HTTP they are being sent with each request, while in the
-        HTTPS/CONNECT case they are sent only once. Could be used for proxy
-        authentication.
-
-    Example:
-        >>> proxy = urllib3.ProxyManager('http://localhost:3128/')
-        >>> r1 = proxy.request('GET', 'http://google.com/')
-        >>> r2 = proxy.request('GET', 'http://httpbin.org/')
-        >>> len(proxy.pools)
-        1
-        >>> r3 = proxy.request('GET', 'https://httpbin.org/')
-        >>> r4 = proxy.request('GET', 'https://twitter.com/')
-        >>> len(proxy.pools)
-        3
-
-    """
-
-    def __init__(self, proxy_url, num_pools=10, headers=None,
-                 proxy_headers=None, **connection_pool_kw):
-
-        if isinstance(proxy_url, HTTPConnectionPool):
-            proxy_url = '%s://%s:%i' % (proxy_url.scheme, proxy_url.host,
-                                        proxy_url.port)
-        proxy = parse_url(proxy_url)
-        if not proxy.port:
-            port = port_by_scheme.get(proxy.scheme, 80)
-            proxy = proxy._replace(port=port)
-
-        if proxy.scheme not in ("http", "https"):
-            raise ProxySchemeUnknown(proxy.scheme)
-
-        self.proxy = proxy
-        self.proxy_headers = proxy_headers or {}
-
-        connection_pool_kw['_proxy'] = self.proxy
-        connection_pool_kw['_proxy_headers'] = self.proxy_headers
-
-        super(ProxyManager, self).__init__(
-            num_pools, headers, **connection_pool_kw)
-
-    def connection_from_host(self, host, port=None, scheme='http'):
-        if scheme == "https":
-            return super(ProxyManager, self).connection_from_host(
-                host, port, scheme)
-
-        return super(ProxyManager, self).connection_from_host(
-            self.proxy.host, self.proxy.port, self.proxy.scheme)
-
-    def _set_proxy_headers(self, url, headers=None):
-        """
-        Sets headers needed by proxies: specifically, the Accept and Host
-        headers. Only sets headers not provided by the user.
-        """
-        headers_ = {'Accept': '*/*'}
-
-        netloc = parse_url(url).netloc
-        if netloc:
-            headers_['Host'] = netloc
-
-        if headers:
-            headers_.update(headers)
-        return headers_
-
-    def urlopen(self, method, url, redirect=True, **kw):
-        "Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute."
-        u = parse_url(url)
-
-        if u.scheme == "http":
-            # For proxied HTTPS requests, httplib sets the necessary headers
-            # on the CONNECT to the proxy. For HTTP, we'll definitely
-            # need to set 'Host' at the very least.
-            headers = kw.get('headers', self.headers)
-            kw['headers'] = self._set_proxy_headers(url, headers)
-
-        return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)
-
-
-def proxy_from_url(url, **kw):
-    return ProxyManager(proxy_url=url, **kw)
+from __future__ import absolute_import
+import collections
+import functools
+import logging
+
+from ._collections import RecentlyUsedContainer
+from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool
+from .connectionpool import port_by_scheme
+from .exceptions import LocationValueError, MaxRetryError, ProxySchemeUnknown
+from .packages.six.moves.urllib.parse import urljoin
+from .request import RequestMethods
+from .util.url import parse_url
+from .util.retry import Retry
+
+
+__all__ = ['PoolManager', 'ProxyManager', 'proxy_from_url']
+
+
+log = logging.getLogger(__name__)
+
+SSL_KEYWORDS = ('key_file', 'cert_file', 'cert_reqs', 'ca_certs',
+                'ssl_version', 'ca_cert_dir', 'ssl_context')
+
+# The base fields to use when determining what pool to get a connection from;
+# these do not rely on the ``connection_pool_kw`` and can be determined by the
+# URL and potentially the ``urllib3.connection.port_by_scheme`` dictionary.
+#
+# All custom key schemes should include the fields in this key at a minimum.
+BasePoolKey = collections.namedtuple('BasePoolKey', ('scheme', 'host', 'port'))
+
+# The fields to use when determining what pool to get a HTTP and HTTPS
+# connection from. All additional fields must be present in the PoolManager's
+# ``connection_pool_kw`` instance variable.
+HTTPPoolKey = collections.namedtuple(
+    'HTTPPoolKey', BasePoolKey._fields + ('timeout', 'retries', 'strict',
+                                          'block', 'source_address')
+)
+HTTPSPoolKey = collections.namedtuple(
+    'HTTPSPoolKey', HTTPPoolKey._fields + SSL_KEYWORDS
+)
+
+
+def _default_key_normalizer(key_class, request_context):
+    """
+    Create a pool key of type ``key_class`` for a request.
+
+    According to RFC 3986, both the scheme and host are case-insensitive.
+    Therefore, this function normalizes both before constructing the pool
+    key for an HTTPS request. If you wish to change this behaviour, provide
+    alternate callables to ``key_fn_by_scheme``.
+
+    :param key_class:
+        The class to use when constructing the key. This should be a namedtuple
+        with the ``scheme`` and ``host`` keys at a minimum.
+
+    :param request_context:
+        A dictionary-like object that contain the context for a request.
+        It should contain a key for each field in the :class:`HTTPPoolKey`
+    """
+    context = {}
+    for key in key_class._fields:
+        context[key] = request_context.get(key)
+    context['scheme'] = context['scheme'].lower()
+    context['host'] = context['host'].lower()
+    return key_class(**context)
+
+
+# A dictionary that maps a scheme to a callable that creates a pool key.
+# This can be used to alter the way pool keys are constructed, if desired.
+# Each PoolManager makes a copy of this dictionary so they can be configured
+# globally here, or individually on the instance.
+key_fn_by_scheme = {
+    'http': functools.partial(_default_key_normalizer, HTTPPoolKey),
+    'https': functools.partial(_default_key_normalizer, HTTPSPoolKey),
+}
+
+pool_classes_by_scheme = {
+    'http': HTTPConnectionPool,
+    'https': HTTPSConnectionPool,
+}
+
+
+class PoolManager(RequestMethods):
+    """
+    Allows for arbitrary requests while transparently keeping track of
+    necessary connection pools for you.
+
+    :param num_pools:
+        Number of connection pools to cache before discarding the least
+        recently used pool.
+
+    :param headers:
+        Headers to include with all requests, unless other headers are given
+        explicitly.
+
+    :param \\**connection_pool_kw:
+        Additional parameters are used to create fresh
+        :class:`urllib3.connectionpool.ConnectionPool` instances.
+
+    Example::
+
+        >>> manager = PoolManager(num_pools=2)
+        >>> r = manager.request('GET', 'http://google.com/')
+        >>> r = manager.request('GET', 'http://google.com/mail')
+        >>> r = manager.request('GET', 'http://yahoo.com/')
+        >>> len(manager.pools)
+        2
+
+    """
+
+    proxy = None
+
+    def __init__(self, num_pools=10, headers=None, **connection_pool_kw):
+        RequestMethods.__init__(self, headers)
+        self.connection_pool_kw = connection_pool_kw
+        self.pools = RecentlyUsedContainer(num_pools,
+                                           dispose_func=lambda p: p.close())
+
+        # Locally set the pool classes and keys so other PoolManagers can
+        # override them.
+        self.pool_classes_by_scheme = pool_classes_by_scheme
+        self.key_fn_by_scheme = key_fn_by_scheme.copy()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.clear()
+        # Return False to re-raise any potential exceptions
+        return False
+
+    def _new_pool(self, scheme, host, port):
+        """
+        Create a new :class:`ConnectionPool` based on host, port and scheme.
+
+        This method is used to actually create the connection pools handed out
+        by :meth:`connection_from_url` and companion methods. It is intended
+        to be overridden for customization.
+        """
+        pool_cls = self.pool_classes_by_scheme[scheme]
+        kwargs = self.connection_pool_kw
+        if scheme == 'http':
+            kwargs = self.connection_pool_kw.copy()
+            for kw in SSL_KEYWORDS:
+                kwargs.pop(kw, None)
+
+        return pool_cls(host, port, **kwargs)
+
+    def clear(self):
+        """
+        Empty our store of pools and direct them all to close.
+
+        This will not affect in-flight connections, but they will not be
+        re-used after completion.
+        """
+        self.pools.clear()
+
+    def connection_from_host(self, host, port=None, scheme='http'):
+        """
+        Get a :class:`ConnectionPool` based on the host, port, and scheme.
+
+        If ``port`` isn't given, it will be derived from the ``scheme`` using
+        ``urllib3.connectionpool.port_by_scheme``.
+        """
+
+        if not host:
+            raise LocationValueError("No host specified.")
+
+        request_context = self.connection_pool_kw.copy()
+        request_context['scheme'] = scheme or 'http'
+        if not port:
+            port = port_by_scheme.get(request_context['scheme'].lower(), 80)
+        request_context['port'] = port
+        request_context['host'] = host
+
+        return self.connection_from_context(request_context)
+
+    def connection_from_context(self, request_context):
+        """
+        Get a :class:`ConnectionPool` based on the request context.
+
+        ``request_context`` must at least contain the ``scheme`` key and its
+        value must be a key in ``key_fn_by_scheme`` instance variable.
+        """
+        scheme = request_context['scheme'].lower()
+        pool_key_constructor = self.key_fn_by_scheme[scheme]
+        pool_key = pool_key_constructor(request_context)
+
+        return self.connection_from_pool_key(pool_key)
+
+    def connection_from_pool_key(self, pool_key):
+        """
+        Get a :class:`ConnectionPool` based on the provided pool key.
+
+        ``pool_key`` should be a namedtuple that only contains immutable
+        objects. At a minimum it must have the ``scheme``, ``host``, and
+        ``port`` fields.
+        """
+        with self.pools.lock:
+            # If the scheme, host, or port doesn't match existing open
+            # connections, open a new ConnectionPool.
+            pool = self.pools.get(pool_key)
+            if pool:
+                return pool
+
+            # Make a fresh ConnectionPool of the desired type
+            pool = self._new_pool(pool_key.scheme, pool_key.host, pool_key.port)
+            self.pools[pool_key] = pool
+
+        return pool
+
+    def connection_from_url(self, url):
+        """
+        Similar to :func:`urllib3.connectionpool.connection_from_url` but
+        doesn't pass any additional parameters to the
+        :class:`urllib3.connectionpool.ConnectionPool` constructor.
+
+        Additional parameters are taken from the :class:`.PoolManager`
+        constructor.
+        """
+        u = parse_url(url)
+        return self.connection_from_host(u.host, port=u.port, scheme=u.scheme)
+
+    def urlopen(self, method, url, redirect=True, **kw):
+        """
+        Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen`
+        with custom cross-host redirect logic and only sends the request-uri
+        portion of the ``url``.
+
+        The given ``url`` parameter must be absolute, such that an appropriate
+        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.
+        """
+        u = parse_url(url)
+        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)
+
+        kw['assert_same_host'] = False
+        kw['redirect'] = False
+        if 'headers' not in kw:
+            kw['headers'] = self.headers
+
+        if self.proxy is not None and u.scheme == "http":
+            response = conn.urlopen(method, url, **kw)
+        else:
+            response = conn.urlopen(method, u.request_uri, **kw)
+
+        redirect_location = redirect and response.get_redirect_location()
+        if not redirect_location:
+            return response
+
+        # Support relative URLs for redirecting.
+        redirect_location = urljoin(url, redirect_location)
+
+        # RFC 7231, Section 6.4.4
+        if response.status == 303:
+            method = 'GET'
+
+        retries = kw.get('retries')
+        if not isinstance(retries, Retry):
+            retries = Retry.from_int(retries, redirect=redirect)
+
+        try:
+            retries = retries.increment(method, url, response=response, _pool=conn)
+        except MaxRetryError:
+            if retries.raise_on_redirect:
+                raise
+            return response
+
+        kw['retries'] = retries
+        kw['redirect'] = redirect
+
+        log.info("Redirecting %s -> %s", url, redirect_location)
+        return self.urlopen(method, redirect_location, **kw)
+
+
+class ProxyManager(PoolManager):
+    """
+    Behaves just like :class:`PoolManager`, but sends all requests through
+    the defined proxy, using the CONNECT method for HTTPS URLs.
+
+    :param proxy_url:
+        The URL of the proxy to be used.
+
+    :param proxy_headers:
+        A dictionary contaning headers that will be sent to the proxy. In case
+        of HTTP they are being sent with each request, while in the
+        HTTPS/CONNECT case they are sent only once. Could be used for proxy
+        authentication.
+
+    Example:
+        >>> proxy = urllib3.ProxyManager('http://localhost:3128/')
+        >>> r1 = proxy.request('GET', 'http://google.com/')
+        >>> r2 = proxy.request('GET', 'http://httpbin.org/')
+        >>> len(proxy.pools)
+        1
+        >>> r3 = proxy.request('GET', 'https://httpbin.org/')
+        >>> r4 = proxy.request('GET', 'https://twitter.com/')
+        >>> len(proxy.pools)
+        3
+
+    """
+
+    def __init__(self, proxy_url, num_pools=10, headers=None,
+                 proxy_headers=None, **connection_pool_kw):
+
+        if isinstance(proxy_url, HTTPConnectionPool):
+            proxy_url = '%s://%s:%i' % (proxy_url.scheme, proxy_url.host,
+                                        proxy_url.port)
+        proxy = parse_url(proxy_url)
+        if not proxy.port:
+            port = port_by_scheme.get(proxy.scheme, 80)
+            proxy = proxy._replace(port=port)
+
+        if proxy.scheme not in ("http", "https"):
+            raise ProxySchemeUnknown(proxy.scheme)
+
+        self.proxy = proxy
+        self.proxy_headers = proxy_headers or {}
+
+        connection_pool_kw['_proxy'] = self.proxy
+        connection_pool_kw['_proxy_headers'] = self.proxy_headers
+
+        super(ProxyManager, self).__init__(
+            num_pools, headers, **connection_pool_kw)
+
+    def connection_from_host(self, host, port=None, scheme='http'):
+        if scheme == "https":
+            return super(ProxyManager, self).connection_from_host(
+                host, port, scheme)
+
+        return super(ProxyManager, self).connection_from_host(
+            self.proxy.host, self.proxy.port, self.proxy.scheme)
+
+    def _set_proxy_headers(self, url, headers=None):
+        """
+        Sets headers needed by proxies: specifically, the Accept and Host
+        headers. Only sets headers not provided by the user.
+        """
+        headers_ = {'Accept': '*/*'}
+
+        netloc = parse_url(url).netloc
+        if netloc:
+            headers_['Host'] = netloc
+
+        if headers:
+            headers_.update(headers)
+        return headers_
+
+    def urlopen(self, method, url, redirect=True, **kw):
+        "Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute."
+        u = parse_url(url)
+
+        if u.scheme == "http":
+            # For proxied HTTPS requests, httplib sets the necessary headers
+            # on the CONNECT to the proxy. For HTTP, we'll definitely
+            # need to set 'Host' at the very least.
+            headers = kw.get('headers', self.headers)
+            kw['headers'] = self._set_proxy_headers(url, headers)
+
+        return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)
+
+
+def proxy_from_url(url, **kw):
+    return ProxyManager(proxy_url=url, **kw)
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/response.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/response.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,618 +1,618 @@
-from __future__ import absolute_import
-from contextlib import contextmanager
-import zlib
-import io
-import logging
-from socket import timeout as SocketTimeout
-from socket import error as SocketError
-
-from ._collections import HTTPHeaderDict
-from .exceptions import (
-    BodyNotHttplibCompatible, ProtocolError, DecodeError, ReadTimeoutError,
-    ResponseNotChunked, IncompleteRead, InvalidHeader
-)
-from .packages.six import string_types as basestring, binary_type, PY3
-from .packages.six.moves import http_client as httplib
-from .connection import HTTPException, BaseSSLError
-from .util.response import is_fp_closed, is_response_to_head
-
-log = logging.getLogger(__name__)
-
-
-class DeflateDecoder(object):
-
-    def __init__(self):
-        self._first_try = True
-        self._data = binary_type()
-        self._obj = zlib.decompressobj()
-
-    def __getattr__(self, name):
-        return getattr(self._obj, name)
-
-    def decompress(self, data):
-        if not data:
-            return data
-
-        if not self._first_try:
-            return self._obj.decompress(data)
-
-        self._data += data
-        try:
-            return self._obj.decompress(data)
-        except zlib.error:
-            self._first_try = False
-            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
-            try:
-                return self.decompress(self._data)
-            finally:
-                self._data = None
-
-
-class GzipDecoder(object):
-
-    def __init__(self):
-        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
-
-    def __getattr__(self, name):
-        return getattr(self._obj, name)
-
-    def decompress(self, data):
-        if not data:
-            return data
-        return self._obj.decompress(data)
-
-
-def _get_decoder(mode):
-    if mode == 'gzip':
-        return GzipDecoder()
-
-    return DeflateDecoder()
-
-
-class HTTPResponse(io.IOBase):
-    """
-    HTTP Response container.
-
-    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
-    loaded and decoded on-demand when the ``data`` property is accessed.  This
-    class is also compatible with the Python standard library's :mod:`io`
-    module, and can hence be treated as a readable object in the context of that
-    framework.
-
-    Extra parameters for behaviour not present in httplib.HTTPResponse:
-
-    :param preload_content:
-        If True, the response's body will be preloaded during construction.
-
-    :param decode_content:
-        If True, attempts to decode specific content-encoding's based on headers
-        (like 'gzip' and 'deflate') will be skipped and raw data will be used
-        instead.
-
-    :param original_response:
-        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
-        object, it's convenient to include the original for debug purposes. It's
-        otherwise unused.
-
-    :param retries:
-        The retries contains the last :class:`~urllib3.util.retry.Retry` that
-        was used during the request.
-
-    :param enforce_content_length:
-        Enforce content length checking. Body returned by server must match
-        value of Content-Length header, if present. Otherwise, raise error.
-    """
-
-    CONTENT_DECODERS = ['gzip', 'deflate']
-    REDIRECT_STATUSES = [301, 302, 303, 307, 308]
-
-    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
-                 strict=0, preload_content=True, decode_content=True,
-                 original_response=None, pool=None, connection=None,
-                 retries=None, enforce_content_length=False, request_method=None):
-
-        if isinstance(headers, HTTPHeaderDict):
-            self.headers = headers
-        else:
-            self.headers = HTTPHeaderDict(headers)
-        self.status = status
-        self.version = version
-        self.reason = reason
-        self.strict = strict
-        self.decode_content = decode_content
-        self.retries = retries
-        self.enforce_content_length = enforce_content_length
-
-        self._decoder = None
-        self._body = None
-        self._fp = None
-        self._original_response = original_response
-        self._fp_bytes_read = 0
-
-        if body and isinstance(body, (basestring, binary_type)):
-            self._body = body
-
-        self._pool = pool
-        self._connection = connection
-
-        if hasattr(body, 'read'):
-            self._fp = body
-
-        # Are we using the chunked-style of transfer encoding?
-        self.chunked = False
-        self.chunk_left = None
-        tr_enc = self.headers.get('transfer-encoding', '').lower()
-        # Don't incur the penalty of creating a list and then discarding it
-        encodings = (enc.strip() for enc in tr_enc.split(","))
-        if "chunked" in encodings:
-            self.chunked = True
-
-        # Determine length of response
-        self.length_remaining = self._init_length(request_method)
-
-        # If requested, preload the body.
-        if preload_content and not self._body:
-            self._body = self.read(decode_content=decode_content)
-
-    def get_redirect_location(self):
-        """
-        Should we redirect and where to?
-
-        :returns: Truthy redirect location string if we got a redirect status
-            code and valid location. ``None`` if redirect status and no
-            location. ``False`` if not a redirect status code.
-        """
-        if self.status in self.REDIRECT_STATUSES:
-            return self.headers.get('location')
-
-        return False
-
-    def release_conn(self):
-        if not self._pool or not self._connection:
-            return
-
-        self._pool._put_conn(self._connection)
-        self._connection = None
-
-    @property
-    def data(self):
-        # For backwords-compat with earlier urllib3 0.4 and earlier.
-        if self._body:
-            return self._body
-
-        if self._fp:
-            return self.read(cache_content=True)
-
-    @property
-    def connection(self):
-        return self._connection
-
-    def tell(self):
-        """
-        Obtain the number of bytes pulled over the wire so far. May differ from
-        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
-        are encoded on the wire (e.g, compressed).
-        """
-        return self._fp_bytes_read
-
-    def _init_length(self, request_method):
-        """
-        Set initial length value for Response content if available.
-        """
-        length = self.headers.get('content-length')
-
-        if length is not None and self.chunked:
-            # This Response will fail with an IncompleteRead if it can't be
-            # received as chunked. This method falls back to attempt reading
-            # the response before raising an exception.
-            log.warning("Received response with both Content-Length and "
-                        "Transfer-Encoding set. This is expressly forbidden "
-                        "by RFC 7230 sec 3.3.2. Ignoring Content-Length and "
-                        "attempting to process response as Transfer-Encoding: "
-                        "chunked.")
-            return None
-
-        elif length is not None:
-            try:
-                # RFC 7230 section 3.3.2 specifies multiple content lengths can
-                # be sent in a single Content-Length header
-                # (e.g. Content-Length: 42, 42). This line ensures the values
-                # are all valid ints and that as long as the `set` length is 1,
-                # all values are the same. Otherwise, the header is invalid.
-                lengths = set([int(val) for val in length.split(',')])
-                if len(lengths) > 1:
-                    raise InvalidHeader("Content-Length contained multiple "
-                                        "unmatching values (%s)" % length)
-                length = lengths.pop()
-            except ValueError:
-                length = None
-            else:
-                if length < 0:
-                    length = None
-
-        # Convert status to int for comparison
-        # In some cases, httplib returns a status of "_UNKNOWN"
-        try:
-            status = int(self.status)
-        except ValueError:
-            status = 0
-
-        # Check for responses that shouldn't include a body
-        if status in (204, 304) or 100 <= status < 200 or request_method == 'HEAD':
-            length = 0
-
-        return length
-
-    def _init_decoder(self):
-        """
-        Set-up the _decoder attribute if necessary.
-        """
-        # Note: content-encoding value should be case-insensitive, per RFC 7230
-        # Section 3.2
-        content_encoding = self.headers.get('content-encoding', '').lower()
-        if self._decoder is None and content_encoding in self.CONTENT_DECODERS:
-            self._decoder = _get_decoder(content_encoding)
-
-    def _decode(self, data, decode_content, flush_decoder):
-        """
-        Decode the data passed in and potentially flush the decoder.
-        """
-        try:
-            if decode_content and self._decoder:
-                data = self._decoder.decompress(data)
-        except (IOError, zlib.error) as e:
-            content_encoding = self.headers.get('content-encoding', '').lower()
-            raise DecodeError(
-                "Received response with content-encoding: %s, but "
-                "failed to decode it." % content_encoding, e)
-
-        if flush_decoder and decode_content:
-            data += self._flush_decoder()
-
-        return data
-
-    def _flush_decoder(self):
-        """
-        Flushes the decoder. Should only be called if the decoder is actually
-        being used.
-        """
-        if self._decoder:
-            buf = self._decoder.decompress(b'')
-            return buf + self._decoder.flush()
-
-        return b''
-
-    @contextmanager
-    def _error_catcher(self):
-        """
-        Catch low-level python exceptions, instead re-raising urllib3
-        variants, so that low-level exceptions are not leaked in the
-        high-level api.
-
-        On exit, release the connection back to the pool.
-        """
-        clean_exit = False
-
-        try:
-            try:
-                yield
-
-            except SocketTimeout:
-                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
-                # there is yet no clean way to get at it from this context.
-                raise ReadTimeoutError(self._pool, None, 'Read timed out.')
-
-            except BaseSSLError as e:
-                # FIXME: Is there a better way to differentiate between SSLErrors?
-                if 'read operation timed out' not in str(e):  # Defensive:
-                    # This shouldn't happen but just in case we're missing an edge
-                    # case, let's avoid swallowing SSL errors.
-                    raise
-
-                raise ReadTimeoutError(self._pool, None, 'Read timed out.')
-
-            except (HTTPException, SocketError) as e:
-                # This includes IncompleteRead.
-                raise ProtocolError('Connection broken: %r' % e, e)
-
-            # If no exception is thrown, we should avoid cleaning up
-            # unnecessarily.
-            clean_exit = True
-        finally:
-            # If we didn't terminate cleanly, we need to throw away our
-            # connection.
-            if not clean_exit:
-                # The response may not be closed but we're not going to use it
-                # anymore so close it now to ensure that the connection is
-                # released back to the pool.
-                if self._original_response:
-                    self._original_response.close()
-
-                # Closing the response may not actually be sufficient to close
-                # everything, so if we have a hold of the connection close that
-                # too.
-                if self._connection:
-                    self._connection.close()
-
-            # If we hold the original response but it's closed now, we should
-            # return the connection back to the pool.
-            if self._original_response and self._original_response.isclosed():
-                self.release_conn()
-
-    def read(self, amt=None, decode_content=None, cache_content=False):
-        """
-        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
-        parameters: ``decode_content`` and ``cache_content``.
-
-        :param amt:
-            How much of the content to read. If specified, caching is skipped
-            because it doesn't make sense to cache partial content as the full
-            response.
-
-        :param decode_content:
-            If True, will attempt to decode the body based on the
-            'content-encoding' header.
-
-        :param cache_content:
-            If True, will save the returned data such that the same result is
-            returned despite of the state of the underlying file object. This
-            is useful if you want the ``.data`` property to continue working
-            after having ``.read()`` the file object. (Overridden if ``amt`` is
-            set.)
-        """
-        self._init_decoder()
-        if decode_content is None:
-            decode_content = self.decode_content
-
-        if self._fp is None:
-            return
-
-        flush_decoder = False
-        data = None
-
-        with self._error_catcher():
-            if amt is None:
-                # cStringIO doesn't like amt=None
-                data = self._fp.read()
-                flush_decoder = True
-            else:
-                cache_content = False
-                data = self._fp.read(amt)
-                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
-                    # Close the connection when no data is returned
-                    #
-                    # This is redundant to what httplib/http.client _should_
-                    # already do.  However, versions of python released before
-                    # December 15, 2012 (http://bugs.python.org/issue16298) do
-                    # not properly close the connection in all cases. There is
-                    # no harm in redundantly calling close.
-                    self._fp.close()
-                    flush_decoder = True
-                    if self.enforce_content_length and self.length_remaining not in (0, None):
-                        # This is an edge case that httplib failed to cover due
-                        # to concerns of backward compatibility. We're
-                        # addressing it here to make sure IncompleteRead is
-                        # raised during streaming, so all calls with incorrect
-                        # Content-Length are caught.
-                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)
-
-        if data:
-            self._fp_bytes_read += len(data)
-            if self.length_remaining is not None:
-                self.length_remaining -= len(data)
-
-            data = self._decode(data, decode_content, flush_decoder)
-
-            if cache_content:
-                self._body = data
-
-        return data
-
-    def stream(self, amt=2**16, decode_content=None):
-        """
-        A generator wrapper for the read() method. A call will block until
-        ``amt`` bytes have been read from the connection or until the
-        connection is closed.
-
-        :param amt:
-            How much of the content to read. The generator will return up to
-            much data per iteration, but may return less. This is particularly
-            likely when using compressed data. However, the empty string will
-            never be returned.
-
-        :param decode_content:
-            If True, will attempt to decode the body based on the
-            'content-encoding' header.
-        """
-        if self.chunked and self.supports_chunked_reads():
-            for line in self.read_chunked(amt, decode_content=decode_content):
-                yield line
-        else:
-            while not is_fp_closed(self._fp):
-                data = self.read(amt=amt, decode_content=decode_content)
-
-                if data:
-                    yield data
-
-    @classmethod
-    def from_httplib(ResponseCls, r, **response_kw):
-        """
-        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
-        corresponding :class:`urllib3.response.HTTPResponse` object.
-
-        Remaining parameters are passed to the HTTPResponse constructor, along
-        with ``original_response=r``.
-        """
-        headers = r.msg
-
-        if not isinstance(headers, HTTPHeaderDict):
-            if PY3:  # Python 3
-                headers = HTTPHeaderDict(headers.items())
-            else:  # Python 2
-                headers = HTTPHeaderDict.from_httplib(headers)
-
-        # HTTPResponse objects in Python 3 don't have a .strict attribute
-        strict = getattr(r, 'strict', 0)
-        resp = ResponseCls(body=r,
-                           headers=headers,
-                           status=r.status,
-                           version=r.version,
-                           reason=r.reason,
-                           strict=strict,
-                           original_response=r,
-                           **response_kw)
-        return resp
-
-    # Backwards-compatibility methods for httplib.HTTPResponse
-    def getheaders(self):
-        return self.headers
-
-    def getheader(self, name, default=None):
-        return self.headers.get(name, default)
-
-    # Overrides from io.IOBase
-    def close(self):
-        if not self.closed:
-            self._fp.close()
-
-        if self._connection:
-            self._connection.close()
-
-    @property
-    def closed(self):
-        if self._fp is None:
-            return True
-        elif hasattr(self._fp, 'isclosed'):
-            return self._fp.isclosed()
-        elif hasattr(self._fp, 'closed'):
-            return self._fp.closed
-        else:
-            return True
-
-    def fileno(self):
-        if self._fp is None:
-            raise IOError("HTTPResponse has no file to get a fileno from")
-        elif hasattr(self._fp, "fileno"):
-            return self._fp.fileno()
-        else:
-            raise IOError("The file-like object this HTTPResponse is wrapped "
-                          "around has no file descriptor")
-
-    def flush(self):
-        if self._fp is not None and hasattr(self._fp, 'flush'):
-            return self._fp.flush()
-
-    def readable(self):
-        # This method is required for `io` module compatibility.
-        return True
-
-    def readinto(self, b):
-        # This method is required for `io` module compatibility.
-        temp = self.read(len(b))
-        if len(temp) == 0:
-            return 0
-        else:
-            b[:len(temp)] = temp
-            return len(temp)
-
-    def supports_chunked_reads(self):
-        """
-        Checks if the underlying file-like object looks like a
-        httplib.HTTPResponse object. We do this by testing for the fp
-        attribute. If it is present we assume it returns raw chunks as
-        processed by read_chunked().
-        """
-        return hasattr(self._fp, 'fp')
-
-    def _update_chunk_length(self):
-        # First, we'll figure out length of a chunk and then
-        # we'll try to read it from socket.
-        if self.chunk_left is not None:
-            return
-        line = self._fp.fp.readline()
-        line = line.split(b';', 1)[0]
-        try:
-            self.chunk_left = int(line, 16)
-        except ValueError:
-            # Invalid chunked protocol response, abort.
-            self.close()
-            raise httplib.IncompleteRead(line)
-
-    def _handle_chunk(self, amt):
-        returned_chunk = None
-        if amt is None:
-            chunk = self._fp._safe_read(self.chunk_left)
-            returned_chunk = chunk
-            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
-            self.chunk_left = None
-        elif amt < self.chunk_left:
-            value = self._fp._safe_read(amt)
-            self.chunk_left = self.chunk_left - amt
-            returned_chunk = value
-        elif amt == self.chunk_left:
-            value = self._fp._safe_read(amt)
-            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
-            self.chunk_left = None
-            returned_chunk = value
-        else:  # amt > self.chunk_left
-            returned_chunk = self._fp._safe_read(self.chunk_left)
-            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
-            self.chunk_left = None
-        return returned_chunk
-
-    def read_chunked(self, amt=None, decode_content=None):
-        """
-        Similar to :meth:`HTTPResponse.read`, but with an additional
-        parameter: ``decode_content``.
-
-        :param decode_content:
-            If True, will attempt to decode the body based on the
-            'content-encoding' header.
-        """
-        self._init_decoder()
-        # FIXME: Rewrite this method and make it a class with a better structured logic.
-        if not self.chunked:
-            raise ResponseNotChunked(
-                "Response is not chunked. "
-                "Header 'transfer-encoding: chunked' is missing.")
-        if not self.supports_chunked_reads():
-            raise BodyNotHttplibCompatible(
-                "Body should be httplib.HTTPResponse like. "
-                "It should have have an fp attribute which returns raw chunks.")
-
-        # Don't bother reading the body of a HEAD request.
-        if self._original_response and is_response_to_head(self._original_response):
-            self._original_response.close()
-            return
-
-        with self._error_catcher():
-            while True:
-                self._update_chunk_length()
-                if self.chunk_left == 0:
-                    break
-                chunk = self._handle_chunk(amt)
-                decoded = self._decode(chunk, decode_content=decode_content,
-                                       flush_decoder=False)
-                if decoded:
-                    yield decoded
-
-            if decode_content:
-                # On CPython and PyPy, we should never need to flush the
-                # decoder. However, on Jython we *might* need to, so
-                # lets defensively do it anyway.
-                decoded = self._flush_decoder()
-                if decoded:  # Platform-specific: Jython.
-                    yield decoded
-
-            # Chunk content ends with \r\n: discard it.
-            while True:
-                line = self._fp.fp.readline()
-                if not line:
-                    # Some sites may not end with '\r\n'.
-                    break
-                if line == b'\r\n':
-                    break
-
-            # We read everything; close the "file".
-            if self._original_response:
-                self._original_response.close()
+from __future__ import absolute_import
+from contextlib import contextmanager
+import zlib
+import io
+import logging
+from socket import timeout as SocketTimeout
+from socket import error as SocketError
+
+from ._collections import HTTPHeaderDict
+from .exceptions import (
+    BodyNotHttplibCompatible, ProtocolError, DecodeError, ReadTimeoutError,
+    ResponseNotChunked, IncompleteRead, InvalidHeader
+)
+from .packages.six import string_types as basestring, binary_type, PY3
+from .packages.six.moves import http_client as httplib
+from .connection import HTTPException, BaseSSLError
+from .util.response import is_fp_closed, is_response_to_head
+
+log = logging.getLogger(__name__)
+
+
+class DeflateDecoder(object):
+
+    def __init__(self):
+        self._first_try = True
+        self._data = binary_type()
+        self._obj = zlib.decompressobj()
+
+    def __getattr__(self, name):
+        return getattr(self._obj, name)
+
+    def decompress(self, data):
+        if not data:
+            return data
+
+        if not self._first_try:
+            return self._obj.decompress(data)
+
+        self._data += data
+        try:
+            return self._obj.decompress(data)
+        except zlib.error:
+            self._first_try = False
+            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
+            try:
+                return self.decompress(self._data)
+            finally:
+                self._data = None
+
+
+class GzipDecoder(object):
+
+    def __init__(self):
+        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
+
+    def __getattr__(self, name):
+        return getattr(self._obj, name)
+
+    def decompress(self, data):
+        if not data:
+            return data
+        return self._obj.decompress(data)
+
+
+def _get_decoder(mode):
+    if mode == 'gzip':
+        return GzipDecoder()
+
+    return DeflateDecoder()
+
+
+class HTTPResponse(io.IOBase):
+    """
+    HTTP Response container.
+
+    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
+    loaded and decoded on-demand when the ``data`` property is accessed.  This
+    class is also compatible with the Python standard library's :mod:`io`
+    module, and can hence be treated as a readable object in the context of that
+    framework.
+
+    Extra parameters for behaviour not present in httplib.HTTPResponse:
+
+    :param preload_content:
+        If True, the response's body will be preloaded during construction.
+
+    :param decode_content:
+        If True, attempts to decode specific content-encoding's based on headers
+        (like 'gzip' and 'deflate') will be skipped and raw data will be used
+        instead.
+
+    :param original_response:
+        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
+        object, it's convenient to include the original for debug purposes. It's
+        otherwise unused.
+
+    :param retries:
+        The retries contains the last :class:`~urllib3.util.retry.Retry` that
+        was used during the request.
+
+    :param enforce_content_length:
+        Enforce content length checking. Body returned by server must match
+        value of Content-Length header, if present. Otherwise, raise error.
+    """
+
+    CONTENT_DECODERS = ['gzip', 'deflate']
+    REDIRECT_STATUSES = [301, 302, 303, 307, 308]
+
+    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
+                 strict=0, preload_content=True, decode_content=True,
+                 original_response=None, pool=None, connection=None,
+                 retries=None, enforce_content_length=False, request_method=None):
+
+        if isinstance(headers, HTTPHeaderDict):
+            self.headers = headers
+        else:
+            self.headers = HTTPHeaderDict(headers)
+        self.status = status
+        self.version = version
+        self.reason = reason
+        self.strict = strict
+        self.decode_content = decode_content
+        self.retries = retries
+        self.enforce_content_length = enforce_content_length
+
+        self._decoder = None
+        self._body = None
+        self._fp = None
+        self._original_response = original_response
+        self._fp_bytes_read = 0
+
+        if body and isinstance(body, (basestring, binary_type)):
+            self._body = body
+
+        self._pool = pool
+        self._connection = connection
+
+        if hasattr(body, 'read'):
+            self._fp = body
+
+        # Are we using the chunked-style of transfer encoding?
+        self.chunked = False
+        self.chunk_left = None
+        tr_enc = self.headers.get('transfer-encoding', '').lower()
+        # Don't incur the penalty of creating a list and then discarding it
+        encodings = (enc.strip() for enc in tr_enc.split(","))
+        if "chunked" in encodings:
+            self.chunked = True
+
+        # Determine length of response
+        self.length_remaining = self._init_length(request_method)
+
+        # If requested, preload the body.
+        if preload_content and not self._body:
+            self._body = self.read(decode_content=decode_content)
+
+    def get_redirect_location(self):
+        """
+        Should we redirect and where to?
+
+        :returns: Truthy redirect location string if we got a redirect status
+            code and valid location. ``None`` if redirect status and no
+            location. ``False`` if not a redirect status code.
+        """
+        if self.status in self.REDIRECT_STATUSES:
+            return self.headers.get('location')
+
+        return False
+
+    def release_conn(self):
+        if not self._pool or not self._connection:
+            return
+
+        self._pool._put_conn(self._connection)
+        self._connection = None
+
+    @property
+    def data(self):
+        # For backwords-compat with earlier urllib3 0.4 and earlier.
+        if self._body:
+            return self._body
+
+        if self._fp:
+            return self.read(cache_content=True)
+
+    @property
+    def connection(self):
+        return self._connection
+
+    def tell(self):
+        """
+        Obtain the number of bytes pulled over the wire so far. May differ from
+        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
+        are encoded on the wire (e.g, compressed).
+        """
+        return self._fp_bytes_read
+
+    def _init_length(self, request_method):
+        """
+        Set initial length value for Response content if available.
+        """
+        length = self.headers.get('content-length')
+
+        if length is not None and self.chunked:
+            # This Response will fail with an IncompleteRead if it can't be
+            # received as chunked. This method falls back to attempt reading
+            # the response before raising an exception.
+            log.warning("Received response with both Content-Length and "
+                        "Transfer-Encoding set. This is expressly forbidden "
+                        "by RFC 7230 sec 3.3.2. Ignoring Content-Length and "
+                        "attempting to process response as Transfer-Encoding: "
+                        "chunked.")
+            return None
+
+        elif length is not None:
+            try:
+                # RFC 7230 section 3.3.2 specifies multiple content lengths can
+                # be sent in a single Content-Length header
+                # (e.g. Content-Length: 42, 42). This line ensures the values
+                # are all valid ints and that as long as the `set` length is 1,
+                # all values are the same. Otherwise, the header is invalid.
+                lengths = set([int(val) for val in length.split(',')])
+                if len(lengths) > 1:
+                    raise InvalidHeader("Content-Length contained multiple "
+                                        "unmatching values (%s)" % length)
+                length = lengths.pop()
+            except ValueError:
+                length = None
+            else:
+                if length < 0:
+                    length = None
+
+        # Convert status to int for comparison
+        # In some cases, httplib returns a status of "_UNKNOWN"
+        try:
+            status = int(self.status)
+        except ValueError:
+            status = 0
+
+        # Check for responses that shouldn't include a body
+        if status in (204, 304) or 100 <= status < 200 or request_method == 'HEAD':
+            length = 0
+
+        return length
+
+    def _init_decoder(self):
+        """
+        Set-up the _decoder attribute if necessary.
+        """
+        # Note: content-encoding value should be case-insensitive, per RFC 7230
+        # Section 3.2
+        content_encoding = self.headers.get('content-encoding', '').lower()
+        if self._decoder is None and content_encoding in self.CONTENT_DECODERS:
+            self._decoder = _get_decoder(content_encoding)
+
+    def _decode(self, data, decode_content, flush_decoder):
+        """
+        Decode the data passed in and potentially flush the decoder.
+        """
+        try:
+            if decode_content and self._decoder:
+                data = self._decoder.decompress(data)
+        except (IOError, zlib.error) as e:
+            content_encoding = self.headers.get('content-encoding', '').lower()
+            raise DecodeError(
+                "Received response with content-encoding: %s, but "
+                "failed to decode it." % content_encoding, e)
+
+        if flush_decoder and decode_content:
+            data += self._flush_decoder()
+
+        return data
+
+    def _flush_decoder(self):
+        """
+        Flushes the decoder. Should only be called if the decoder is actually
+        being used.
+        """
+        if self._decoder:
+            buf = self._decoder.decompress(b'')
+            return buf + self._decoder.flush()
+
+        return b''
+
+    @contextmanager
+    def _error_catcher(self):
+        """
+        Catch low-level python exceptions, instead re-raising urllib3
+        variants, so that low-level exceptions are not leaked in the
+        high-level api.
+
+        On exit, release the connection back to the pool.
+        """
+        clean_exit = False
+
+        try:
+            try:
+                yield
+
+            except SocketTimeout:
+                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
+                # there is yet no clean way to get at it from this context.
+                raise ReadTimeoutError(self._pool, None, 'Read timed out.')
+
+            except BaseSSLError as e:
+                # FIXME: Is there a better way to differentiate between SSLErrors?
+                if 'read operation timed out' not in str(e):  # Defensive:
+                    # This shouldn't happen but just in case we're missing an edge
+                    # case, let's avoid swallowing SSL errors.
+                    raise
+
+                raise ReadTimeoutError(self._pool, None, 'Read timed out.')
+
+            except (HTTPException, SocketError) as e:
+                # This includes IncompleteRead.
+                raise ProtocolError('Connection broken: %r' % e, e)
+
+            # If no exception is thrown, we should avoid cleaning up
+            # unnecessarily.
+            clean_exit = True
+        finally:
+            # If we didn't terminate cleanly, we need to throw away our
+            # connection.
+            if not clean_exit:
+                # The response may not be closed but we're not going to use it
+                # anymore so close it now to ensure that the connection is
+                # released back to the pool.
+                if self._original_response:
+                    self._original_response.close()
+
+                # Closing the response may not actually be sufficient to close
+                # everything, so if we have a hold of the connection close that
+                # too.
+                if self._connection:
+                    self._connection.close()
+
+            # If we hold the original response but it's closed now, we should
+            # return the connection back to the pool.
+            if self._original_response and self._original_response.isclosed():
+                self.release_conn()
+
+    def read(self, amt=None, decode_content=None, cache_content=False):
+        """
+        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
+        parameters: ``decode_content`` and ``cache_content``.
+
+        :param amt:
+            How much of the content to read. If specified, caching is skipped
+            because it doesn't make sense to cache partial content as the full
+            response.
+
+        :param decode_content:
+            If True, will attempt to decode the body based on the
+            'content-encoding' header.
+
+        :param cache_content:
+            If True, will save the returned data such that the same result is
+            returned despite of the state of the underlying file object. This
+            is useful if you want the ``.data`` property to continue working
+            after having ``.read()`` the file object. (Overridden if ``amt`` is
+            set.)
+        """
+        self._init_decoder()
+        if decode_content is None:
+            decode_content = self.decode_content
+
+        if self._fp is None:
+            return
+
+        flush_decoder = False
+        data = None
+
+        with self._error_catcher():
+            if amt is None:
+                # cStringIO doesn't like amt=None
+                data = self._fp.read()
+                flush_decoder = True
+            else:
+                cache_content = False
+                data = self._fp.read(amt)
+                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
+                    # Close the connection when no data is returned
+                    #
+                    # This is redundant to what httplib/http.client _should_
+                    # already do.  However, versions of python released before
+                    # December 15, 2012 (http://bugs.python.org/issue16298) do
+                    # not properly close the connection in all cases. There is
+                    # no harm in redundantly calling close.
+                    self._fp.close()
+                    flush_decoder = True
+                    if self.enforce_content_length and self.length_remaining not in (0, None):
+                        # This is an edge case that httplib failed to cover due
+                        # to concerns of backward compatibility. We're
+                        # addressing it here to make sure IncompleteRead is
+                        # raised during streaming, so all calls with incorrect
+                        # Content-Length are caught.
+                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)
+
+        if data:
+            self._fp_bytes_read += len(data)
+            if self.length_remaining is not None:
+                self.length_remaining -= len(data)
+
+            data = self._decode(data, decode_content, flush_decoder)
+
+            if cache_content:
+                self._body = data
+
+        return data
+
+    def stream(self, amt=2**16, decode_content=None):
+        """
+        A generator wrapper for the read() method. A call will block until
+        ``amt`` bytes have been read from the connection or until the
+        connection is closed.
+
+        :param amt:
+            How much of the content to read. The generator will return up to
+            much data per iteration, but may return less. This is particularly
+            likely when using compressed data. However, the empty string will
+            never be returned.
+
+        :param decode_content:
+            If True, will attempt to decode the body based on the
+            'content-encoding' header.
+        """
+        if self.chunked and self.supports_chunked_reads():
+            for line in self.read_chunked(amt, decode_content=decode_content):
+                yield line
+        else:
+            while not is_fp_closed(self._fp):
+                data = self.read(amt=amt, decode_content=decode_content)
+
+                if data:
+                    yield data
+
+    @classmethod
+    def from_httplib(ResponseCls, r, **response_kw):
+        """
+        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
+        corresponding :class:`urllib3.response.HTTPResponse` object.
+
+        Remaining parameters are passed to the HTTPResponse constructor, along
+        with ``original_response=r``.
+        """
+        headers = r.msg
+
+        if not isinstance(headers, HTTPHeaderDict):
+            if PY3:  # Python 3
+                headers = HTTPHeaderDict(headers.items())
+            else:  # Python 2
+                headers = HTTPHeaderDict.from_httplib(headers)
+
+        # HTTPResponse objects in Python 3 don't have a .strict attribute
+        strict = getattr(r, 'strict', 0)
+        resp = ResponseCls(body=r,
+                           headers=headers,
+                           status=r.status,
+                           version=r.version,
+                           reason=r.reason,
+                           strict=strict,
+                           original_response=r,
+                           **response_kw)
+        return resp
+
+    # Backwards-compatibility methods for httplib.HTTPResponse
+    def getheaders(self):
+        return self.headers
+
+    def getheader(self, name, default=None):
+        return self.headers.get(name, default)
+
+    # Overrides from io.IOBase
+    def close(self):
+        if not self.closed:
+            self._fp.close()
+
+        if self._connection:
+            self._connection.close()
+
+    @property
+    def closed(self):
+        if self._fp is None:
+            return True
+        elif hasattr(self._fp, 'isclosed'):
+            return self._fp.isclosed()
+        elif hasattr(self._fp, 'closed'):
+            return self._fp.closed
+        else:
+            return True
+
+    def fileno(self):
+        if self._fp is None:
+            raise IOError("HTTPResponse has no file to get a fileno from")
+        elif hasattr(self._fp, "fileno"):
+            return self._fp.fileno()
+        else:
+            raise IOError("The file-like object this HTTPResponse is wrapped "
+                          "around has no file descriptor")
+
+    def flush(self):
+        if self._fp is not None and hasattr(self._fp, 'flush'):
+            return self._fp.flush()
+
+    def readable(self):
+        # This method is required for `io` module compatibility.
+        return True
+
+    def readinto(self, b):
+        # This method is required for `io` module compatibility.
+        temp = self.read(len(b))
+        if len(temp) == 0:
+            return 0
+        else:
+            b[:len(temp)] = temp
+            return len(temp)
+
+    def supports_chunked_reads(self):
+        """
+        Checks if the underlying file-like object looks like a
+        httplib.HTTPResponse object. We do this by testing for the fp
+        attribute. If it is present we assume it returns raw chunks as
+        processed by read_chunked().
+        """
+        return hasattr(self._fp, 'fp')
+
+    def _update_chunk_length(self):
+        # First, we'll figure out length of a chunk and then
+        # we'll try to read it from socket.
+        if self.chunk_left is not None:
+            return
+        line = self._fp.fp.readline()
+        line = line.split(b';', 1)[0]
+        try:
+            self.chunk_left = int(line, 16)
+        except ValueError:
+            # Invalid chunked protocol response, abort.
+            self.close()
+            raise httplib.IncompleteRead(line)
+
+    def _handle_chunk(self, amt):
+        returned_chunk = None
+        if amt is None:
+            chunk = self._fp._safe_read(self.chunk_left)
+            returned_chunk = chunk
+            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
+            self.chunk_left = None
+        elif amt < self.chunk_left:
+            value = self._fp._safe_read(amt)
+            self.chunk_left = self.chunk_left - amt
+            returned_chunk = value
+        elif amt == self.chunk_left:
+            value = self._fp._safe_read(amt)
+            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
+            self.chunk_left = None
+            returned_chunk = value
+        else:  # amt > self.chunk_left
+            returned_chunk = self._fp._safe_read(self.chunk_left)
+            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
+            self.chunk_left = None
+        return returned_chunk
+
+    def read_chunked(self, amt=None, decode_content=None):
+        """
+        Similar to :meth:`HTTPResponse.read`, but with an additional
+        parameter: ``decode_content``.
+
+        :param decode_content:
+            If True, will attempt to decode the body based on the
+            'content-encoding' header.
+        """
+        self._init_decoder()
+        # FIXME: Rewrite this method and make it a class with a better structured logic.
+        if not self.chunked:
+            raise ResponseNotChunked(
+                "Response is not chunked. "
+                "Header 'transfer-encoding: chunked' is missing.")
+        if not self.supports_chunked_reads():
+            raise BodyNotHttplibCompatible(
+                "Body should be httplib.HTTPResponse like. "
+                "It should have have an fp attribute which returns raw chunks.")
+
+        # Don't bother reading the body of a HEAD request.
+        if self._original_response and is_response_to_head(self._original_response):
+            self._original_response.close()
+            return
+
+        with self._error_catcher():
+            while True:
+                self._update_chunk_length()
+                if self.chunk_left == 0:
+                    break
+                chunk = self._handle_chunk(amt)
+                decoded = self._decode(chunk, decode_content=decode_content,
+                                       flush_decoder=False)
+                if decoded:
+                    yield decoded
+
+            if decode_content:
+                # On CPython and PyPy, we should never need to flush the
+                # decoder. However, on Jython we *might* need to, so
+                # lets defensively do it anyway.
+                decoded = self._flush_decoder()
+                if decoded:  # Platform-specific: Jython.
+                    yield decoded
+
+            # Chunk content ends with \r\n: discard it.
+            while True:
+                line = self._fp.fp.readline()
+                if not line:
+                    # Some sites may not end with '\r\n'.
+                    break
+                if line == b'\r\n':
+                    break
+
+            # We read everything; close the "file".
+            if self._original_response:
+                self._original_response.close()
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/connection.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/connection.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,130 +1,130 @@
-from __future__ import absolute_import
-import socket
-from .wait import wait_for_read
-from .selectors import HAS_SELECT, SelectorError
-
-
-def is_connection_dropped(conn):  # Platform-specific
-    """
-    Returns True if the connection is dropped and should be closed.
-
-    :param conn:
-        :class:`httplib.HTTPConnection` object.
-
-    Note: For platforms like AppEngine, this will always return ``False`` to
-    let the platform handle connection recycling transparently for us.
-    """
-    sock = getattr(conn, 'sock', False)
-    if sock is False:  # Platform-specific: AppEngine
-        return False
-    if sock is None:  # Connection already closed (such as by httplib).
-        return True
-
-    if not HAS_SELECT:
-        return False
-
-    try:
-        return bool(wait_for_read(sock, timeout=0.0))
-    except SelectorError:
-        return True
-
-
-# This function is copied from socket.py in the Python 2.7 standard
-# library test suite. Added to its signature is only `socket_options`.
-# One additional modification is that we avoid binding to IPv6 servers
-# discovered in DNS if the system doesn't have IPv6 functionality.
-def create_connection(address, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
-                      source_address=None, socket_options=None):
-    """Connect to *address* and return the socket object.
-
-    Convenience function.  Connect to *address* (a 2-tuple ``(host,
-    port)``) and return the socket object.  Passing the optional
-    *timeout* parameter will set the timeout on the socket instance
-    before attempting to connect.  If no *timeout* is supplied, the
-    global default timeout setting returned by :func:`getdefaulttimeout`
-    is used.  If *source_address* is set it must be a tuple of (host, port)
-    for the socket to bind as a source address before making the connection.
-    An host of '' or port 0 tells the OS to use the default.
-    """
-
-    host, port = address
-    if host.startswith('['):
-        host = host.strip('[]')
-    err = None
-
-    # Using the value from allowed_gai_family() in the context of getaddrinfo lets
-    # us select whether to work with IPv4 DNS records, IPv6 records, or both.
-    # The original create_connection function always returns all records.
-    family = allowed_gai_family()
-
-    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
-        af, socktype, proto, canonname, sa = res
-        sock = None
-        try:
-            sock = socket.socket(af, socktype, proto)
-
-            # If provided, set socket level options before connecting.
-            _set_socket_options(sock, socket_options)
-
-            if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
-                sock.settimeout(timeout)
-            if source_address:
-                sock.bind(source_address)
-            sock.connect(sa)
-            return sock
-
-        except socket.error as e:
-            err = e
-            if sock is not None:
-                sock.close()
-                sock = None
-
-    if err is not None:
-        raise err
-
-    raise socket.error("getaddrinfo returns an empty list")
-
-
-def _set_socket_options(sock, options):
-    if options is None:
-        return
-
-    for opt in options:
-        sock.setsockopt(*opt)
-
-
-def allowed_gai_family():
-    """This function is designed to work in the context of
-    getaddrinfo, where family=socket.AF_UNSPEC is the default and
-    will perform a DNS search for both IPv6 and IPv4 records."""
-
-    family = socket.AF_INET
-    if HAS_IPV6:
-        family = socket.AF_UNSPEC
-    return family
-
-
-def _has_ipv6(host):
-    """ Returns True if the system can bind an IPv6 address. """
-    sock = None
-    has_ipv6 = False
-
-    if socket.has_ipv6:
-        # has_ipv6 returns true if cPython was compiled with IPv6 support.
-        # It does not tell us if the system has IPv6 support enabled. To
-        # determine that we must bind to an IPv6 address.
-        # https://github.com/shazow/urllib3/pull/611
-        # https://bugs.python.org/issue658327
-        try:
-            sock = socket.socket(socket.AF_INET6)
-            sock.bind((host, 0))
-            has_ipv6 = True
-        except Exception:
-            pass
-
-    if sock:
-        sock.close()
-    return has_ipv6
-
-
-HAS_IPV6 = _has_ipv6('::1')
+from __future__ import absolute_import
+import socket
+from .wait import wait_for_read
+from .selectors import HAS_SELECT, SelectorError
+
+
+def is_connection_dropped(conn):  # Platform-specific
+    """
+    Returns True if the connection is dropped and should be closed.
+
+    :param conn:
+        :class:`httplib.HTTPConnection` object.
+
+    Note: For platforms like AppEngine, this will always return ``False`` to
+    let the platform handle connection recycling transparently for us.
+    """
+    sock = getattr(conn, 'sock', False)
+    if sock is False:  # Platform-specific: AppEngine
+        return False
+    if sock is None:  # Connection already closed (such as by httplib).
+        return True
+
+    if not HAS_SELECT:
+        return False
+
+    try:
+        return bool(wait_for_read(sock, timeout=0.0))
+    except SelectorError:
+        return True
+
+
+# This function is copied from socket.py in the Python 2.7 standard
+# library test suite. Added to its signature is only `socket_options`.
+# One additional modification is that we avoid binding to IPv6 servers
+# discovered in DNS if the system doesn't have IPv6 functionality.
+def create_connection(address, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
+                      source_address=None, socket_options=None):
+    """Connect to *address* and return the socket object.
+
+    Convenience function.  Connect to *address* (a 2-tuple ``(host,
+    port)``) and return the socket object.  Passing the optional
+    *timeout* parameter will set the timeout on the socket instance
+    before attempting to connect.  If no *timeout* is supplied, the
+    global default timeout setting returned by :func:`getdefaulttimeout`
+    is used.  If *source_address* is set it must be a tuple of (host, port)
+    for the socket to bind as a source address before making the connection.
+    An host of '' or port 0 tells the OS to use the default.
+    """
+
+    host, port = address
+    if host.startswith('['):
+        host = host.strip('[]')
+    err = None
+
+    # Using the value from allowed_gai_family() in the context of getaddrinfo lets
+    # us select whether to work with IPv4 DNS records, IPv6 records, or both.
+    # The original create_connection function always returns all records.
+    family = allowed_gai_family()
+
+    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
+        af, socktype, proto, canonname, sa = res
+        sock = None
+        try:
+            sock = socket.socket(af, socktype, proto)
+
+            # If provided, set socket level options before connecting.
+            _set_socket_options(sock, socket_options)
+
+            if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:
+                sock.settimeout(timeout)
+            if source_address:
+                sock.bind(source_address)
+            sock.connect(sa)
+            return sock
+
+        except socket.error as e:
+            err = e
+            if sock is not None:
+                sock.close()
+                sock = None
+
+    if err is not None:
+        raise err
+
+    raise socket.error("getaddrinfo returns an empty list")
+
+
+def _set_socket_options(sock, options):
+    if options is None:
+        return
+
+    for opt in options:
+        sock.setsockopt(*opt)
+
+
+def allowed_gai_family():
+    """This function is designed to work in the context of
+    getaddrinfo, where family=socket.AF_UNSPEC is the default and
+    will perform a DNS search for both IPv6 and IPv4 records."""
+
+    family = socket.AF_INET
+    if HAS_IPV6:
+        family = socket.AF_UNSPEC
+    return family
+
+
+def _has_ipv6(host):
+    """ Returns True if the system can bind an IPv6 address. """
+    sock = None
+    has_ipv6 = False
+
+    if socket.has_ipv6:
+        # has_ipv6 returns true if cPython was compiled with IPv6 support.
+        # It does not tell us if the system has IPv6 support enabled. To
+        # determine that we must bind to an IPv6 address.
+        # https://github.com/shazow/urllib3/pull/611
+        # https://bugs.python.org/issue658327
+        try:
+            sock = socket.socket(socket.AF_INET6)
+            sock.bind((host, 0))
+            has_ipv6 = True
+        except Exception:
+            pass
+
+    if sock:
+        sock.close()
+    return has_ipv6
+
+
+HAS_IPV6 = _has_ipv6('::1')
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/request.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/request.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,118 +1,118 @@
-from __future__ import absolute_import
-from base64 import b64encode
-
-from ..packages.six import b, integer_types
-from ..exceptions import UnrewindableBodyError
-
-ACCEPT_ENCODING = 'gzip,deflate'
-_FAILEDTELL = object()
-
-
-def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,
-                 basic_auth=None, proxy_basic_auth=None, disable_cache=None):
-    """
-    Shortcuts for generating request headers.
-
-    :param keep_alive:
-        If ``True``, adds 'connection: keep-alive' header.
-
-    :param accept_encoding:
-        Can be a boolean, list, or string.
-        ``True`` translates to 'gzip,deflate'.
-        List will get joined by comma.
-        String will be used as provided.
-
-    :param user_agent:
-        String representing the user-agent you want, such as
-        "python-urllib3/0.6"
-
-    :param basic_auth:
-        Colon-separated username:password string for 'authorization: basic ...'
-        auth header.
-
-    :param proxy_basic_auth:
-        Colon-separated username:password string for 'proxy-authorization: basic ...'
-        auth header.
-
-    :param disable_cache:
-        If ``True``, adds 'cache-control: no-cache' header.
-
-    Example::
-
-        >>> make_headers(keep_alive=True, user_agent="Batman/1.0")
-        {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}
-        >>> make_headers(accept_encoding=True)
-        {'accept-encoding': 'gzip,deflate'}
-    """
-    headers = {}
-    if accept_encoding:
-        if isinstance(accept_encoding, str):
-            pass
-        elif isinstance(accept_encoding, list):
-            accept_encoding = ','.join(accept_encoding)
-        else:
-            accept_encoding = ACCEPT_ENCODING
-        headers['accept-encoding'] = accept_encoding
-
-    if user_agent:
-        headers['user-agent'] = user_agent
-
-    if keep_alive:
-        headers['connection'] = 'keep-alive'
-
-    if basic_auth:
-        headers['authorization'] = 'Basic ' + \
-            b64encode(b(basic_auth)).decode('utf-8')
-
-    if proxy_basic_auth:
-        headers['proxy-authorization'] = 'Basic ' + \
-            b64encode(b(proxy_basic_auth)).decode('utf-8')
-
-    if disable_cache:
-        headers['cache-control'] = 'no-cache'
-
-    return headers
-
-
-def set_file_position(body, pos):
-    """
-    If a position is provided, move file to that point.
-    Otherwise, we'll attempt to record a position for future use.
-    """
-    if pos is not None:
-        rewind_body(body, pos)
-    elif getattr(body, 'tell', None) is not None:
-        try:
-            pos = body.tell()
-        except (IOError, OSError):
-            # This differentiates from None, allowing us to catch
-            # a failed `tell()` later when trying to rewind the body.
-            pos = _FAILEDTELL
-
-    return pos
-
-
-def rewind_body(body, body_pos):
-    """
-    Attempt to rewind body to a certain position.
-    Primarily used for request redirects and retries.
-
-    :param body:
-        File-like object that supports seek.
-
-    :param int pos:
-        Position to seek to in file.
-    """
-    body_seek = getattr(body, 'seek', None)
-    if body_seek is not None and isinstance(body_pos, integer_types):
-        try:
-            body_seek(body_pos)
-        except (IOError, OSError):
-            raise UnrewindableBodyError("An error occured when rewinding request "
-                                        "body for redirect/retry.")
-    elif body_pos is _FAILEDTELL:
-        raise UnrewindableBodyError("Unable to record file position for rewinding "
-                                    "request body during a redirect/retry.")
-    else:
-        raise ValueError("body_pos must be of type integer, "
-                         "instead it was %s." % type(body_pos))
+from __future__ import absolute_import
+from base64 import b64encode
+
+from ..packages.six import b, integer_types
+from ..exceptions import UnrewindableBodyError
+
+ACCEPT_ENCODING = 'gzip,deflate'
+_FAILEDTELL = object()
+
+
+def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,
+                 basic_auth=None, proxy_basic_auth=None, disable_cache=None):
+    """
+    Shortcuts for generating request headers.
+
+    :param keep_alive:
+        If ``True``, adds 'connection: keep-alive' header.
+
+    :param accept_encoding:
+        Can be a boolean, list, or string.
+        ``True`` translates to 'gzip,deflate'.
+        List will get joined by comma.
+        String will be used as provided.
+
+    :param user_agent:
+        String representing the user-agent you want, such as
+        "python-urllib3/0.6"
+
+    :param basic_auth:
+        Colon-separated username:password string for 'authorization: basic ...'
+        auth header.
+
+    :param proxy_basic_auth:
+        Colon-separated username:password string for 'proxy-authorization: basic ...'
+        auth header.
+
+    :param disable_cache:
+        If ``True``, adds 'cache-control: no-cache' header.
+
+    Example::
+
+        >>> make_headers(keep_alive=True, user_agent="Batman/1.0")
+        {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}
+        >>> make_headers(accept_encoding=True)
+        {'accept-encoding': 'gzip,deflate'}
+    """
+    headers = {}
+    if accept_encoding:
+        if isinstance(accept_encoding, str):
+            pass
+        elif isinstance(accept_encoding, list):
+            accept_encoding = ','.join(accept_encoding)
+        else:
+            accept_encoding = ACCEPT_ENCODING
+        headers['accept-encoding'] = accept_encoding
+
+    if user_agent:
+        headers['user-agent'] = user_agent
+
+    if keep_alive:
+        headers['connection'] = 'keep-alive'
+
+    if basic_auth:
+        headers['authorization'] = 'Basic ' + \
+            b64encode(b(basic_auth)).decode('utf-8')
+
+    if proxy_basic_auth:
+        headers['proxy-authorization'] = 'Basic ' + \
+            b64encode(b(proxy_basic_auth)).decode('utf-8')
+
+    if disable_cache:
+        headers['cache-control'] = 'no-cache'
+
+    return headers
+
+
+def set_file_position(body, pos):
+    """
+    If a position is provided, move file to that point.
+    Otherwise, we'll attempt to record a position for future use.
+    """
+    if pos is not None:
+        rewind_body(body, pos)
+    elif getattr(body, 'tell', None) is not None:
+        try:
+            pos = body.tell()
+        except (IOError, OSError):
+            # This differentiates from None, allowing us to catch
+            # a failed `tell()` later when trying to rewind the body.
+            pos = _FAILEDTELL
+
+    return pos
+
+
+def rewind_body(body, body_pos):
+    """
+    Attempt to rewind body to a certain position.
+    Primarily used for request redirects and retries.
+
+    :param body:
+        File-like object that supports seek.
+
+    :param int pos:
+        Position to seek to in file.
+    """
+    body_seek = getattr(body, 'seek', None)
+    if body_seek is not None and isinstance(body_pos, integer_types):
+        try:
+            body_seek(body_pos)
+        except (IOError, OSError):
+            raise UnrewindableBodyError("An error occured when rewinding request "
+                                        "body for redirect/retry.")
+    elif body_pos is _FAILEDTELL:
+        raise UnrewindableBodyError("Unable to record file position for rewinding "
+                                    "request body during a redirect/retry.")
+    else:
+        raise ValueError("body_pos must be of type integer, "
+                         "instead it was %s." % type(body_pos))
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/retry.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/retry.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,389 +1,389 @@
-from __future__ import absolute_import
-import time
-import logging
-from collections import namedtuple
-from itertools import takewhile
-import email
-import re
-
-from ..exceptions import (
-    ConnectTimeoutError,
-    MaxRetryError,
-    ProtocolError,
-    ReadTimeoutError,
-    ResponseError,
-    InvalidHeader,
-)
-from ..packages import six
-
-
-log = logging.getLogger(__name__)
-
-# Data structure for representing the metadata of requests that result in a retry.
-RequestHistory = namedtuple('RequestHistory', ["method", "url", "error",
-                                               "status", "redirect_location"])
-
-
-class Retry(object):
-    """ Retry configuration.
-
-    Each retry attempt will create a new Retry object with updated values, so
-    they can be safely reused.
-
-    Retries can be defined as a default for a pool::
-
-        retries = Retry(connect=5, read=2, redirect=5)
-        http = PoolManager(retries=retries)
-        response = http.request('GET', 'http://example.com/')
-
-    Or per-request (which overrides the default for the pool)::
-
-        response = http.request('GET', 'http://example.com/', retries=Retry(10))
-
-    Retries can be disabled by passing ``False``::
-
-        response = http.request('GET', 'http://example.com/', retries=False)
-
-    Errors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless
-    retries are disabled, in which case the causing exception will be raised.
-
-    :param int total:
-        Total number of retries to allow. Takes precedence over other counts.
-
-        Set to ``None`` to remove this constraint and fall back on other
-        counts. It's a good idea to set this to some sensibly-high value to
-        account for unexpected edge cases and avoid infinite retry loops.
-
-        Set to ``0`` to fail on the first retry.
-
-        Set to ``False`` to disable and imply ``raise_on_redirect=False``.
-
-    :param int connect:
-        How many connection-related errors to retry on.
-
-        These are errors raised before the request is sent to the remote server,
-        which we assume has not triggered the server to process the request.
-
-        Set to ``0`` to fail on the first retry of this type.
-
-    :param int read:
-        How many times to retry on read errors.
-
-        These errors are raised after the request was sent to the server, so the
-        request may have side-effects.
-
-        Set to ``0`` to fail on the first retry of this type.
-
-    :param int redirect:
-        How many redirects to perform. Limit this to avoid infinite redirect
-        loops.
-
-        A redirect is a HTTP response with a status code 301, 302, 303, 307 or
-        308.
-
-        Set to ``0`` to fail on the first retry of this type.
-
-        Set to ``False`` to disable and imply ``raise_on_redirect=False``.
-
-    :param iterable method_whitelist:
-        Set of uppercased HTTP method verbs that we should retry on.
-
-        By default, we only retry on methods which are considered to be
-        idempotent (multiple requests with the same parameters end with the
-        same state). See :attr:`Retry.DEFAULT_METHOD_WHITELIST`.
-
-        Set to a ``False`` value to retry on any verb.
-
-    :param iterable status_forcelist:
-        A set of integer HTTP status codes that we should force a retry on.
-        A retry is initiated if the request method is in ``method_whitelist``
-        and the response status code is in ``status_forcelist``.
-
-        By default, this is disabled with ``None``.
-
-    :param float backoff_factor:
-        A backoff factor to apply between attempts after the second try
-        (most errors are resolved immediately by a second try without a
-        delay). urllib3 will sleep for::
-
-            {backoff factor} * (2 ^ ({number of total retries} - 1))
-
-        seconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep
-        for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer
-        than :attr:`Retry.BACKOFF_MAX`.
-
-        By default, backoff is disabled (set to 0).
-
-    :param bool raise_on_redirect: Whether, if the number of redirects is
-        exhausted, to raise a MaxRetryError, or to return a response with a
-        response code in the 3xx range.
-
-    :param bool raise_on_status: Similar meaning to ``raise_on_redirect``:
-        whether we should raise an exception, or return a response,
-        if status falls in ``status_forcelist`` range and retries have
-        been exhausted.
-
-    :param tuple history: The history of the request encountered during
-        each call to :meth:`~Retry.increment`. The list is in the order
-        the requests occurred. Each list item is of class :class:`RequestHistory`.
-
-    :param bool respect_retry_after_header:
-        Whether to respect Retry-After header on status codes defined as
-        :attr:`Retry.RETRY_AFTER_STATUS_CODES` or not.
-
-    """
-
-    DEFAULT_METHOD_WHITELIST = frozenset([
-        'HEAD', 'GET', 'PUT', 'DELETE', 'OPTIONS', 'TRACE'])
-
-    RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])
-
-    #: Maximum backoff time.
-    BACKOFF_MAX = 120
-
-    def __init__(self, total=10, connect=None, read=None, redirect=None,
-                 method_whitelist=DEFAULT_METHOD_WHITELIST, status_forcelist=None,
-                 backoff_factor=0, raise_on_redirect=True, raise_on_status=True,
-                 history=None, respect_retry_after_header=True):
-
-        self.total = total
-        self.connect = connect
-        self.read = read
-
-        if redirect is False or total is False:
-            redirect = 0
-            raise_on_redirect = False
-
-        self.redirect = redirect
-        self.status_forcelist = status_forcelist or set()
-        self.method_whitelist = method_whitelist
-        self.backoff_factor = backoff_factor
-        self.raise_on_redirect = raise_on_redirect
-        self.raise_on_status = raise_on_status
-        self.history = history or tuple()
-        self.respect_retry_after_header = respect_retry_after_header
-
-    def new(self, **kw):
-        params = dict(
-            total=self.total,
-            connect=self.connect, read=self.read, redirect=self.redirect,
-            method_whitelist=self.method_whitelist,
-            status_forcelist=self.status_forcelist,
-            backoff_factor=self.backoff_factor,
-            raise_on_redirect=self.raise_on_redirect,
-            raise_on_status=self.raise_on_status,
-            history=self.history,
-        )
-        params.update(kw)
-        return type(self)(**params)
-
-    @classmethod
-    def from_int(cls, retries, redirect=True, default=None):
-        """ Backwards-compatibility for the old retries format."""
-        if retries is None:
-            retries = default if default is not None else cls.DEFAULT
-
-        if isinstance(retries, Retry):
-            return retries
-
-        redirect = bool(redirect) and None
-        new_retries = cls(retries, redirect=redirect)
-        log.debug("Converted retries value: %r -> %r", retries, new_retries)
-        return new_retries
-
-    def get_backoff_time(self):
-        """ Formula for computing the current backoff
-
-        :rtype: float
-        """
-        # We want to consider only the last consecutive errors sequence (Ignore redirects).
-        consecutive_errors_len = len(list(takewhile(lambda x: x.redirect_location is None,
-                                                    reversed(self.history))))
-        if consecutive_errors_len <= 1:
-            return 0
-
-        backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))
-        return min(self.BACKOFF_MAX, backoff_value)
-
-    def parse_retry_after(self, retry_after):
-        # Whitespace: https://tools.ietf.org/html/rfc7230#section-3.2.4
-        if re.match(r"^\s*[0-9]+\s*$", retry_after):
-            seconds = int(retry_after)
-        else:
-            retry_date_tuple = email.utils.parsedate(retry_after)
-            if retry_date_tuple is None:
-                raise InvalidHeader("Invalid Retry-After header: %s" % retry_after)
-            retry_date = time.mktime(retry_date_tuple)
-            seconds = retry_date - time.time()
-
-        if seconds < 0:
-            seconds = 0
-
-        return seconds
-
-    def get_retry_after(self, response):
-        """ Get the value of Retry-After in seconds. """
-
-        retry_after = response.getheader("Retry-After")
-
-        if retry_after is None:
-            return None
-
-        return self.parse_retry_after(retry_after)
-
-    def sleep_for_retry(self, response=None):
-        retry_after = self.get_retry_after(response)
-        if retry_after:
-            time.sleep(retry_after)
-            return True
-
-        return False
-
-    def _sleep_backoff(self):
-        backoff = self.get_backoff_time()
-        if backoff <= 0:
-            return
-        time.sleep(backoff)
-
-    def sleep(self, response=None):
-        """ Sleep between retry attempts.
-
-        This method will respect a server's ``Retry-After`` response header
-        and sleep the duration of the time requested. If that is not present, it
-        will use an exponential backoff. By default, the backoff factor is 0 and
-        this method will return immediately.
-        """
-
-        if response:
-            slept = self.sleep_for_retry(response)
-            if slept:
-                return
-
-        self._sleep_backoff()
-
-    def _is_connection_error(self, err):
-        """ Errors when we're fairly sure that the server did not receive the
-        request, so it should be safe to retry.
-        """
-        return isinstance(err, ConnectTimeoutError)
-
-    def _is_read_error(self, err):
-        """ Errors that occur after the request has been started, so we should
-        assume that the server began processing it.
-        """
-        return isinstance(err, (ReadTimeoutError, ProtocolError))
-
-    def _is_method_retryable(self, method):
-        """ Checks if a given HTTP method should be retried upon, depending if
-        it is included on the method whitelist.
-        """
-        if self.method_whitelist and method.upper() not in self.method_whitelist:
-            return False
-
-        return True
-
-    def is_retry(self, method, status_code, has_retry_after=False):
-        """ Is this method/status code retryable? (Based on whitelists and control
-        variables such as the number of total retries to allow, whether to
-        respect the Retry-After header, whether this header is present, and
-        whether the returned status code is on the list of status codes to
-        be retried upon on the presence of the aforementioned header)
-        """
-        if not self._is_method_retryable(method):
-            return False
-
-        if self.status_forcelist and status_code in self.status_forcelist:
-            return True
-
-        return (self.total and self.respect_retry_after_header and
-                has_retry_after and (status_code in self.RETRY_AFTER_STATUS_CODES))
-
-    def is_exhausted(self):
-        """ Are we out of retries? """
-        retry_counts = (self.total, self.connect, self.read, self.redirect)
-        retry_counts = list(filter(None, retry_counts))
-        if not retry_counts:
-            return False
-
-        return min(retry_counts) < 0
-
-    def increment(self, method=None, url=None, response=None, error=None,
-                  _pool=None, _stacktrace=None):
-        """ Return a new Retry object with incremented retry counters.
-
-        :param response: A response object, or None, if the server did not
-            return a response.
-        :type response: :class:`~urllib3.response.HTTPResponse`
-        :param Exception error: An error encountered during the request, or
-            None if the response was received successfully.
-
-        :return: A new ``Retry`` object.
-        """
-        if self.total is False and error:
-            # Disabled, indicate to re-raise the error.
-            raise six.reraise(type(error), error, _stacktrace)
-
-        total = self.total
-        if total is not None:
-            total -= 1
-
-        connect = self.connect
-        read = self.read
-        redirect = self.redirect
-        cause = 'unknown'
-        status = None
-        redirect_location = None
-
-        if error and self._is_connection_error(error):
-            # Connect retry?
-            if connect is False:
-                raise six.reraise(type(error), error, _stacktrace)
-            elif connect is not None:
-                connect -= 1
-
-        elif error and self._is_read_error(error):
-            # Read retry?
-            if read is False or not self._is_method_retryable(method):
-                raise six.reraise(type(error), error, _stacktrace)
-            elif read is not None:
-                read -= 1
-
-        elif response and response.get_redirect_location():
-            # Redirect retry?
-            if redirect is not None:
-                redirect -= 1
-            cause = 'too many redirects'
-            redirect_location = response.get_redirect_location()
-            status = response.status
-
-        else:
-            # Incrementing because of a server error like a 500 in
-            # status_forcelist and a the given method is in the whitelist
-            cause = ResponseError.GENERIC_ERROR
-            if response and response.status:
-                cause = ResponseError.SPECIFIC_ERROR.format(
-                    status_code=response.status)
-                status = response.status
-
-        history = self.history + (RequestHistory(method, url, error, status, redirect_location),)
-
-        new_retry = self.new(
-            total=total,
-            connect=connect, read=read, redirect=redirect,
-            history=history)
-
-        if new_retry.is_exhausted():
-            raise MaxRetryError(_pool, url, error or ResponseError(cause))
-
-        log.debug("Incremented Retry for (url='%s'): %r", url, new_retry)
-
-        return new_retry
-
-    def __repr__(self):
-        return ('{cls.__name__}(total={self.total}, connect={self.connect}, '
-                'read={self.read}, redirect={self.redirect})').format(
-                    cls=type(self), self=self)
-
-
-# For backwards compatibility (equivalent to pre-v1.9):
-Retry.DEFAULT = Retry(3)
+from __future__ import absolute_import
+import time
+import logging
+from collections import namedtuple
+from itertools import takewhile
+import email
+import re
+
+from ..exceptions import (
+    ConnectTimeoutError,
+    MaxRetryError,
+    ProtocolError,
+    ReadTimeoutError,
+    ResponseError,
+    InvalidHeader,
+)
+from ..packages import six
+
+
+log = logging.getLogger(__name__)
+
+# Data structure for representing the metadata of requests that result in a retry.
+RequestHistory = namedtuple('RequestHistory', ["method", "url", "error",
+                                               "status", "redirect_location"])
+
+
+class Retry(object):
+    """ Retry configuration.
+
+    Each retry attempt will create a new Retry object with updated values, so
+    they can be safely reused.
+
+    Retries can be defined as a default for a pool::
+
+        retries = Retry(connect=5, read=2, redirect=5)
+        http = PoolManager(retries=retries)
+        response = http.request('GET', 'http://example.com/')
+
+    Or per-request (which overrides the default for the pool)::
+
+        response = http.request('GET', 'http://example.com/', retries=Retry(10))
+
+    Retries can be disabled by passing ``False``::
+
+        response = http.request('GET', 'http://example.com/', retries=False)
+
+    Errors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless
+    retries are disabled, in which case the causing exception will be raised.
+
+    :param int total:
+        Total number of retries to allow. Takes precedence over other counts.
+
+        Set to ``None`` to remove this constraint and fall back on other
+        counts. It's a good idea to set this to some sensibly-high value to
+        account for unexpected edge cases and avoid infinite retry loops.
+
+        Set to ``0`` to fail on the first retry.
+
+        Set to ``False`` to disable and imply ``raise_on_redirect=False``.
+
+    :param int connect:
+        How many connection-related errors to retry on.
+
+        These are errors raised before the request is sent to the remote server,
+        which we assume has not triggered the server to process the request.
+
+        Set to ``0`` to fail on the first retry of this type.
+
+    :param int read:
+        How many times to retry on read errors.
+
+        These errors are raised after the request was sent to the server, so the
+        request may have side-effects.
+
+        Set to ``0`` to fail on the first retry of this type.
+
+    :param int redirect:
+        How many redirects to perform. Limit this to avoid infinite redirect
+        loops.
+
+        A redirect is a HTTP response with a status code 301, 302, 303, 307 or
+        308.
+
+        Set to ``0`` to fail on the first retry of this type.
+
+        Set to ``False`` to disable and imply ``raise_on_redirect=False``.
+
+    :param iterable method_whitelist:
+        Set of uppercased HTTP method verbs that we should retry on.
+
+        By default, we only retry on methods which are considered to be
+        idempotent (multiple requests with the same parameters end with the
+        same state). See :attr:`Retry.DEFAULT_METHOD_WHITELIST`.
+
+        Set to a ``False`` value to retry on any verb.
+
+    :param iterable status_forcelist:
+        A set of integer HTTP status codes that we should force a retry on.
+        A retry is initiated if the request method is in ``method_whitelist``
+        and the response status code is in ``status_forcelist``.
+
+        By default, this is disabled with ``None``.
+
+    :param float backoff_factor:
+        A backoff factor to apply between attempts after the second try
+        (most errors are resolved immediately by a second try without a
+        delay). urllib3 will sleep for::
+
+            {backoff factor} * (2 ^ ({number of total retries} - 1))
+
+        seconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep
+        for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer
+        than :attr:`Retry.BACKOFF_MAX`.
+
+        By default, backoff is disabled (set to 0).
+
+    :param bool raise_on_redirect: Whether, if the number of redirects is
+        exhausted, to raise a MaxRetryError, or to return a response with a
+        response code in the 3xx range.
+
+    :param bool raise_on_status: Similar meaning to ``raise_on_redirect``:
+        whether we should raise an exception, or return a response,
+        if status falls in ``status_forcelist`` range and retries have
+        been exhausted.
+
+    :param tuple history: The history of the request encountered during
+        each call to :meth:`~Retry.increment`. The list is in the order
+        the requests occurred. Each list item is of class :class:`RequestHistory`.
+
+    :param bool respect_retry_after_header:
+        Whether to respect Retry-After header on status codes defined as
+        :attr:`Retry.RETRY_AFTER_STATUS_CODES` or not.
+
+    """
+
+    DEFAULT_METHOD_WHITELIST = frozenset([
+        'HEAD', 'GET', 'PUT', 'DELETE', 'OPTIONS', 'TRACE'])
+
+    RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])
+
+    #: Maximum backoff time.
+    BACKOFF_MAX = 120
+
+    def __init__(self, total=10, connect=None, read=None, redirect=None,
+                 method_whitelist=DEFAULT_METHOD_WHITELIST, status_forcelist=None,
+                 backoff_factor=0, raise_on_redirect=True, raise_on_status=True,
+                 history=None, respect_retry_after_header=True):
+
+        self.total = total
+        self.connect = connect
+        self.read = read
+
+        if redirect is False or total is False:
+            redirect = 0
+            raise_on_redirect = False
+
+        self.redirect = redirect
+        self.status_forcelist = status_forcelist or set()
+        self.method_whitelist = method_whitelist
+        self.backoff_factor = backoff_factor
+        self.raise_on_redirect = raise_on_redirect
+        self.raise_on_status = raise_on_status
+        self.history = history or tuple()
+        self.respect_retry_after_header = respect_retry_after_header
+
+    def new(self, **kw):
+        params = dict(
+            total=self.total,
+            connect=self.connect, read=self.read, redirect=self.redirect,
+            method_whitelist=self.method_whitelist,
+            status_forcelist=self.status_forcelist,
+            backoff_factor=self.backoff_factor,
+            raise_on_redirect=self.raise_on_redirect,
+            raise_on_status=self.raise_on_status,
+            history=self.history,
+        )
+        params.update(kw)
+        return type(self)(**params)
+
+    @classmethod
+    def from_int(cls, retries, redirect=True, default=None):
+        """ Backwards-compatibility for the old retries format."""
+        if retries is None:
+            retries = default if default is not None else cls.DEFAULT
+
+        if isinstance(retries, Retry):
+            return retries
+
+        redirect = bool(redirect) and None
+        new_retries = cls(retries, redirect=redirect)
+        log.debug("Converted retries value: %r -> %r", retries, new_retries)
+        return new_retries
+
+    def get_backoff_time(self):
+        """ Formula for computing the current backoff
+
+        :rtype: float
+        """
+        # We want to consider only the last consecutive errors sequence (Ignore redirects).
+        consecutive_errors_len = len(list(takewhile(lambda x: x.redirect_location is None,
+                                                    reversed(self.history))))
+        if consecutive_errors_len <= 1:
+            return 0
+
+        backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))
+        return min(self.BACKOFF_MAX, backoff_value)
+
+    def parse_retry_after(self, retry_after):
+        # Whitespace: https://tools.ietf.org/html/rfc7230#section-3.2.4
+        if re.match(r"^\s*[0-9]+\s*$", retry_after):
+            seconds = int(retry_after)
+        else:
+            retry_date_tuple = email.utils.parsedate(retry_after)
+            if retry_date_tuple is None:
+                raise InvalidHeader("Invalid Retry-After header: %s" % retry_after)
+            retry_date = time.mktime(retry_date_tuple)
+            seconds = retry_date - time.time()
+
+        if seconds < 0:
+            seconds = 0
+
+        return seconds
+
+    def get_retry_after(self, response):
+        """ Get the value of Retry-After in seconds. """
+
+        retry_after = response.getheader("Retry-After")
+
+        if retry_after is None:
+            return None
+
+        return self.parse_retry_after(retry_after)
+
+    def sleep_for_retry(self, response=None):
+        retry_after = self.get_retry_after(response)
+        if retry_after:
+            time.sleep(retry_after)
+            return True
+
+        return False
+
+    def _sleep_backoff(self):
+        backoff = self.get_backoff_time()
+        if backoff <= 0:
+            return
+        time.sleep(backoff)
+
+    def sleep(self, response=None):
+        """ Sleep between retry attempts.
+
+        This method will respect a server's ``Retry-After`` response header
+        and sleep the duration of the time requested. If that is not present, it
+        will use an exponential backoff. By default, the backoff factor is 0 and
+        this method will return immediately.
+        """
+
+        if response:
+            slept = self.sleep_for_retry(response)
+            if slept:
+                return
+
+        self._sleep_backoff()
+
+    def _is_connection_error(self, err):
+        """ Errors when we're fairly sure that the server did not receive the
+        request, so it should be safe to retry.
+        """
+        return isinstance(err, ConnectTimeoutError)
+
+    def _is_read_error(self, err):
+        """ Errors that occur after the request has been started, so we should
+        assume that the server began processing it.
+        """
+        return isinstance(err, (ReadTimeoutError, ProtocolError))
+
+    def _is_method_retryable(self, method):
+        """ Checks if a given HTTP method should be retried upon, depending if
+        it is included on the method whitelist.
+        """
+        if self.method_whitelist and method.upper() not in self.method_whitelist:
+            return False
+
+        return True
+
+    def is_retry(self, method, status_code, has_retry_after=False):
+        """ Is this method/status code retryable? (Based on whitelists and control
+        variables such as the number of total retries to allow, whether to
+        respect the Retry-After header, whether this header is present, and
+        whether the returned status code is on the list of status codes to
+        be retried upon on the presence of the aforementioned header)
+        """
+        if not self._is_method_retryable(method):
+            return False
+
+        if self.status_forcelist and status_code in self.status_forcelist:
+            return True
+
+        return (self.total and self.respect_retry_after_header and
+                has_retry_after and (status_code in self.RETRY_AFTER_STATUS_CODES))
+
+    def is_exhausted(self):
+        """ Are we out of retries? """
+        retry_counts = (self.total, self.connect, self.read, self.redirect)
+        retry_counts = list(filter(None, retry_counts))
+        if not retry_counts:
+            return False
+
+        return min(retry_counts) < 0
+
+    def increment(self, method=None, url=None, response=None, error=None,
+                  _pool=None, _stacktrace=None):
+        """ Return a new Retry object with incremented retry counters.
+
+        :param response: A response object, or None, if the server did not
+            return a response.
+        :type response: :class:`~urllib3.response.HTTPResponse`
+        :param Exception error: An error encountered during the request, or
+            None if the response was received successfully.
+
+        :return: A new ``Retry`` object.
+        """
+        if self.total is False and error:
+            # Disabled, indicate to re-raise the error.
+            raise six.reraise(type(error), error, _stacktrace)
+
+        total = self.total
+        if total is not None:
+            total -= 1
+
+        connect = self.connect
+        read = self.read
+        redirect = self.redirect
+        cause = 'unknown'
+        status = None
+        redirect_location = None
+
+        if error and self._is_connection_error(error):
+            # Connect retry?
+            if connect is False:
+                raise six.reraise(type(error), error, _stacktrace)
+            elif connect is not None:
+                connect -= 1
+
+        elif error and self._is_read_error(error):
+            # Read retry?
+            if read is False or not self._is_method_retryable(method):
+                raise six.reraise(type(error), error, _stacktrace)
+            elif read is not None:
+                read -= 1
+
+        elif response and response.get_redirect_location():
+            # Redirect retry?
+            if redirect is not None:
+                redirect -= 1
+            cause = 'too many redirects'
+            redirect_location = response.get_redirect_location()
+            status = response.status
+
+        else:
+            # Incrementing because of a server error like a 500 in
+            # status_forcelist and a the given method is in the whitelist
+            cause = ResponseError.GENERIC_ERROR
+            if response and response.status:
+                cause = ResponseError.SPECIFIC_ERROR.format(
+                    status_code=response.status)
+                status = response.status
+
+        history = self.history + (RequestHistory(method, url, error, status, redirect_location),)
+
+        new_retry = self.new(
+            total=total,
+            connect=connect, read=read, redirect=redirect,
+            history=history)
+
+        if new_retry.is_exhausted():
+            raise MaxRetryError(_pool, url, error or ResponseError(cause))
+
+        log.debug("Incremented Retry for (url='%s'): %r", url, new_retry)
+
+        return new_retry
+
+    def __repr__(self):
+        return ('{cls.__name__}(total={self.total}, connect={self.connect}, '
+                'read={self.read}, redirect={self.redirect})').format(
+                    cls=type(self), self=self)
+
+
+# For backwards compatibility (equivalent to pre-v1.9):
+Retry.DEFAULT = Retry(3)
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/selectors.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/selectors.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,524 +1,524 @@
-# Backport of selectors.py from Python 3.5+ to support Python < 3.4
-# Also has the behavior specified in PEP 475 which is to retry syscalls
-# in the case of an EINTR error. This module is required because selectors34
-# does not follow this behavior and instead returns that no dile descriptor
-# events have occurred rather than retry the syscall. The decision to drop
-# support for select.devpoll is made to maintain 100% test coverage.
-
-import errno
-import math
-import select
-from collections import namedtuple, Mapping
-
-import time
-try:
-    monotonic = time.monotonic
-except (AttributeError, ImportError):  # Python 3.3<
-    monotonic = time.time
-
-EVENT_READ = (1 << 0)
-EVENT_WRITE = (1 << 1)
-
-HAS_SELECT = True  # Variable that shows whether the platform has a selector.
-_SYSCALL_SENTINEL = object()  # Sentinel in case a system call returns None.
-
-
-class SelectorError(Exception):
-    def __init__(self, errcode):
-        super(SelectorError, self).__init__()
-        self.errno = errcode
-
-    def __repr__(self):
-        return "<SelectorError errno={0}>".format(self.errno)
-
-    def __str__(self):
-        return self.__repr__()
-
-
-def _fileobj_to_fd(fileobj):
-    """ Return a file descriptor from a file object. If
-    given an integer will simply return that integer back. """
-    if isinstance(fileobj, int):
-        fd = fileobj
-    else:
-        try:
-            fd = int(fileobj.fileno())
-        except (AttributeError, TypeError, ValueError):
-            raise ValueError("Invalid file object: {0!r}".format(fileobj))
-    if fd < 0:
-        raise ValueError("Invalid file descriptor: {0}".format(fd))
-    return fd
-
-
-def _syscall_wrapper(func, recalc_timeout, *args, **kwargs):
-    """ Wrapper function for syscalls that could fail due to EINTR.
-    All functions should be retried if there is time left in the timeout
-    in accordance with PEP 475. """
-    timeout = kwargs.get("timeout", None)
-    if timeout is None:
-        expires = None
-        recalc_timeout = False
-    else:
-        timeout = float(timeout)
-        if timeout < 0.0:  # Timeout less than 0 treated as no timeout.
-            expires = None
-        else:
-            expires = monotonic() + timeout
-
-    args = list(args)
-    if recalc_timeout and "timeout" not in kwargs:
-        raise ValueError(
-            "Timeout must be in args or kwargs to be recalculated")
-
-    result = _SYSCALL_SENTINEL
-    while result is _SYSCALL_SENTINEL:
-        try:
-            result = func(*args, **kwargs)
-        # OSError is thrown by select.select
-        # IOError is thrown by select.epoll.poll
-        # select.error is thrown by select.poll.poll
-        # Aren't we thankful for Python 3.x rework for exceptions?
-        except (OSError, IOError, select.error) as e:
-            # select.error wasn't a subclass of OSError in the past.
-            errcode = None
-            if hasattr(e, "errno"):
-                errcode = e.errno
-            elif hasattr(e, "args"):
-                errcode = e.args[0]
-
-            # Also test for the Windows equivalent of EINTR.
-            is_interrupt = (errcode == errno.EINTR or (hasattr(errno, "WSAEINTR") and
-                                                       errcode == errno.WSAEINTR))
-
-            if is_interrupt:
-                if expires is not None:
-                    current_time = monotonic()
-                    if current_time > expires:
-                        raise OSError(errno=errno.ETIMEDOUT)
-                    if recalc_timeout:
-                        if "timeout" in kwargs:
-                            kwargs["timeout"] = expires - current_time
-                continue
-            if errcode:
-                raise SelectorError(errcode)
-            else:
-                raise
-    return result
-
-
-SelectorKey = namedtuple('SelectorKey', ['fileobj', 'fd', 'events', 'data'])
-
-
-class _SelectorMapping(Mapping):
-    """ Mapping of file objects to selector keys """
-
-    def __init__(self, selector):
-        self._selector = selector
-
-    def __len__(self):
-        return len(self._selector._fd_to_key)
-
-    def __getitem__(self, fileobj):
-        try:
-            fd = self._selector._fileobj_lookup(fileobj)
-            return self._selector._fd_to_key[fd]
-        except KeyError:
-            raise KeyError("{0!r} is not registered.".format(fileobj))
-
-    def __iter__(self):
-        return iter(self._selector._fd_to_key)
-
-
-class BaseSelector(object):
-    """ Abstract Selector class
-
-    A selector supports registering file objects to be monitored
-    for specific I/O events.
-
-    A file object is a file descriptor or any object with a
-    `fileno()` method. An arbitrary object can be attached to the
-    file object which can be used for example to store context info,
-    a callback, etc.
-
-    A selector can use various implementations (select(), poll(), epoll(),
-    and kqueue()) depending on the platform. The 'DefaultSelector' class uses
-    the most efficient implementation for the current platform.
-    """
-    def __init__(self):
-        # Maps file descriptors to keys.
-        self._fd_to_key = {}
-
-        # Read-only mapping returned by get_map()
-        self._map = _SelectorMapping(self)
-
-    def _fileobj_lookup(self, fileobj):
-        """ Return a file descriptor from a file object.
-        This wraps _fileobj_to_fd() to do an exhaustive
-        search in case the object is invalid but we still
-        have it in our map. Used by unregister() so we can
-        unregister an object that was previously registered
-        even if it is closed. It is also used by _SelectorMapping
-        """
-        try:
-            return _fileobj_to_fd(fileobj)
-        except ValueError:
-
-            # Search through all our mapped keys.
-            for key in self._fd_to_key.values():
-                if key.fileobj is fileobj:
-                    return key.fd
-
-            # Raise ValueError after all.
-            raise
-
-    def register(self, fileobj, events, data=None):
-        """ Register a file object for a set of events to monitor. """
-        if (not events) or (events & ~(EVENT_READ | EVENT_WRITE)):
-            raise ValueError("Invalid events: {0!r}".format(events))
-
-        key = SelectorKey(fileobj, self._fileobj_lookup(fileobj), events, data)
-
-        if key.fd in self._fd_to_key:
-            raise KeyError("{0!r} (FD {1}) is already registered"
-                           .format(fileobj, key.fd))
-
-        self._fd_to_key[key.fd] = key
-        return key
-
-    def unregister(self, fileobj):
-        """ Unregister a file object from being monitored. """
-        try:
-            key = self._fd_to_key.pop(self._fileobj_lookup(fileobj))
-        except KeyError:
-            raise KeyError("{0!r} is not registered".format(fileobj))
-        return key
-
-    def modify(self, fileobj, events, data=None):
-        """ Change a registered file object monitored events and data. """
-        # NOTE: Some subclasses optimize this operation even further.
-        try:
-            key = self._fd_to_key[self._fileobj_lookup(fileobj)]
-        except KeyError:
-            raise KeyError("{0!r} is not registered".format(fileobj))
-
-        if events != key.events:
-            self.unregister(fileobj)
-            key = self.register(fileobj, events, data)
-
-        elif data != key.data:
-            # Use a shortcut to update the data.
-            key = key._replace(data=data)
-            self._fd_to_key[key.fd] = key
-
-        return key
-
-    def select(self, timeout=None):
-        """ Perform the actual selection until some monitored file objects
-        are ready or the timeout expires. """
-        raise NotImplementedError()
-
-    def close(self):
-        """ Close the selector. This must be called to ensure that all
-        underlying resources are freed. """
-        self._fd_to_key.clear()
-        self._map = None
-
-    def get_key(self, fileobj):
-        """ Return the key associated with a registered file object. """
-        mapping = self.get_map()
-        if mapping is None:
-            raise RuntimeError("Selector is closed")
-        try:
-            return mapping[fileobj]
-        except KeyError:
-            raise KeyError("{0!r} is not registered".format(fileobj))
-
-    def get_map(self):
-        """ Return a mapping of file objects to selector keys """
-        return self._map
-
-    def _key_from_fd(self, fd):
-        """ Return the key associated to a given file descriptor
-         Return None if it is not found. """
-        try:
-            return self._fd_to_key[fd]
-        except KeyError:
-            return None
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, *args):
-        self.close()
-
-
-# Almost all platforms have select.select()
-if hasattr(select, "select"):
-    class SelectSelector(BaseSelector):
-        """ Select-based selector. """
-        def __init__(self):
-            super(SelectSelector, self).__init__()
-            self._readers = set()
-            self._writers = set()
-
-        def register(self, fileobj, events, data=None):
-            key = super(SelectSelector, self).register(fileobj, events, data)
-            if events & EVENT_READ:
-                self._readers.add(key.fd)
-            if events & EVENT_WRITE:
-                self._writers.add(key.fd)
-            return key
-
-        def unregister(self, fileobj):
-            key = super(SelectSelector, self).unregister(fileobj)
-            self._readers.discard(key.fd)
-            self._writers.discard(key.fd)
-            return key
-
-        def _select(self, r, w, timeout=None):
-            """ Wrapper for select.select because timeout is a positional arg """
-            return select.select(r, w, [], timeout)
-
-        def select(self, timeout=None):
-            # Selecting on empty lists on Windows errors out.
-            if not len(self._readers) and not len(self._writers):
-                return []
-
-            timeout = None if timeout is None else max(timeout, 0.0)
-            ready = []
-            r, w, _ = _syscall_wrapper(self._select, True, self._readers,
-                                       self._writers, timeout)
-            r = set(r)
-            w = set(w)
-            for fd in r | w:
-                events = 0
-                if fd in r:
-                    events |= EVENT_READ
-                if fd in w:
-                    events |= EVENT_WRITE
-
-                key = self._key_from_fd(fd)
-                if key:
-                    ready.append((key, events & key.events))
-            return ready
-
-
-if hasattr(select, "poll"):
-    class PollSelector(BaseSelector):
-        """ Poll-based selector """
-        def __init__(self):
-            super(PollSelector, self).__init__()
-            self._poll = select.poll()
-
-        def register(self, fileobj, events, data=None):
-            key = super(PollSelector, self).register(fileobj, events, data)
-            event_mask = 0
-            if events & EVENT_READ:
-                event_mask |= select.POLLIN
-            if events & EVENT_WRITE:
-                event_mask |= select.POLLOUT
-            self._poll.register(key.fd, event_mask)
-            return key
-
-        def unregister(self, fileobj):
-            key = super(PollSelector, self).unregister(fileobj)
-            self._poll.unregister(key.fd)
-            return key
-
-        def _wrap_poll(self, timeout=None):
-            """ Wrapper function for select.poll.poll() so that
-            _syscall_wrapper can work with only seconds. """
-            if timeout is not None:
-                if timeout <= 0:
-                    timeout = 0
-                else:
-                    # select.poll.poll() has a resolution of 1 millisecond,
-                    # round away from zero to wait *at least* timeout seconds.
-                    timeout = math.ceil(timeout * 1e3)
-
-            result = self._poll.poll(timeout)
-            return result
-
-        def select(self, timeout=None):
-            ready = []
-            fd_events = _syscall_wrapper(self._wrap_poll, True, timeout=timeout)
-            for fd, event_mask in fd_events:
-                events = 0
-                if event_mask & ~select.POLLIN:
-                    events |= EVENT_WRITE
-                if event_mask & ~select.POLLOUT:
-                    events |= EVENT_READ
-
-                key = self._key_from_fd(fd)
-                if key:
-                    ready.append((key, events & key.events))
-
-            return ready
-
-
-if hasattr(select, "epoll"):
-    class EpollSelector(BaseSelector):
-        """ Epoll-based selector """
-        def __init__(self):
-            super(EpollSelector, self).__init__()
-            self._epoll = select.epoll()
-
-        def fileno(self):
-            return self._epoll.fileno()
-
-        def register(self, fileobj, events, data=None):
-            key = super(EpollSelector, self).register(fileobj, events, data)
-            events_mask = 0
-            if events & EVENT_READ:
-                events_mask |= select.EPOLLIN
-            if events & EVENT_WRITE:
-                events_mask |= select.EPOLLOUT
-            _syscall_wrapper(self._epoll.register, False, key.fd, events_mask)
-            return key
-
-        def unregister(self, fileobj):
-            key = super(EpollSelector, self).unregister(fileobj)
-            try:
-                _syscall_wrapper(self._epoll.unregister, False, key.fd)
-            except SelectorError:
-                # This can occur when the fd was closed since registry.
-                pass
-            return key
-
-        def select(self, timeout=None):
-            if timeout is not None:
-                if timeout <= 0:
-                    timeout = 0.0
-                else:
-                    # select.epoll.poll() has a resolution of 1 millisecond
-                    # but luckily takes seconds so we don't need a wrapper
-                    # like PollSelector. Just for better rounding.
-                    timeout = math.ceil(timeout * 1e3) * 1e-3
-                timeout = float(timeout)
-            else:
-                timeout = -1.0  # epoll.poll() must have a float.
-
-            # We always want at least 1 to ensure that select can be called
-            # with no file descriptors registered. Otherwise will fail.
-            max_events = max(len(self._fd_to_key), 1)
-
-            ready = []
-            fd_events = _syscall_wrapper(self._epoll.poll, True,
-                                         timeout=timeout,
-                                         maxevents=max_events)
-            for fd, event_mask in fd_events:
-                events = 0
-                if event_mask & ~select.EPOLLIN:
-                    events |= EVENT_WRITE
-                if event_mask & ~select.EPOLLOUT:
-                    events |= EVENT_READ
-
-                key = self._key_from_fd(fd)
-                if key:
-                    ready.append((key, events & key.events))
-            return ready
-
-        def close(self):
-            self._epoll.close()
-            super(EpollSelector, self).close()
-
-
-if hasattr(select, "kqueue"):
-    class KqueueSelector(BaseSelector):
-        """ Kqueue / Kevent-based selector """
-        def __init__(self):
-            super(KqueueSelector, self).__init__()
-            self._kqueue = select.kqueue()
-
-        def fileno(self):
-            return self._kqueue.fileno()
-
-        def register(self, fileobj, events, data=None):
-            key = super(KqueueSelector, self).register(fileobj, events, data)
-            if events & EVENT_READ:
-                kevent = select.kevent(key.fd,
-                                       select.KQ_FILTER_READ,
-                                       select.KQ_EV_ADD)
-
-                _syscall_wrapper(self._kqueue.control, False, [kevent], 0, 0)
-
-            if events & EVENT_WRITE:
-                kevent = select.kevent(key.fd,
-                                       select.KQ_FILTER_WRITE,
-                                       select.KQ_EV_ADD)
-
-                _syscall_wrapper(self._kqueue.control, False, [kevent], 0, 0)
-
-            return key
-
-        def unregister(self, fileobj):
-            key = super(KqueueSelector, self).unregister(fileobj)
-            if key.events & EVENT_READ:
-                kevent = select.kevent(key.fd,
-                                       select.KQ_FILTER_READ,
-                                       select.KQ_EV_DELETE)
-                try:
-                    _syscall_wrapper(self._kqueue.control, False, [kevent], 0, 0)
-                except SelectorError:
-                    pass
-            if key.events & EVENT_WRITE:
-                kevent = select.kevent(key.fd,
-                                       select.KQ_FILTER_WRITE,
-                                       select.KQ_EV_DELETE)
-                try:
-                    _syscall_wrapper(self._kqueue.control, False, [kevent], 0, 0)
-                except SelectorError:
-                    pass
-
-            return key
-
-        def select(self, timeout=None):
-            if timeout is not None:
-                timeout = max(timeout, 0)
-
-            max_events = len(self._fd_to_key) * 2
-            ready_fds = {}
-
-            kevent_list = _syscall_wrapper(self._kqueue.control, True,
-                                           None, max_events, timeout)
-
-            for kevent in kevent_list:
-                fd = kevent.ident
-                event_mask = kevent.filter
-                events = 0
-                if event_mask == select.KQ_FILTER_READ:
-                    events |= EVENT_READ
-                if event_mask == select.KQ_FILTER_WRITE:
-                    events |= EVENT_WRITE
-
-                key = self._key_from_fd(fd)
-                if key:
-                    if key.fd not in ready_fds:
-                        ready_fds[key.fd] = (key, events & key.events)
-                    else:
-                        old_events = ready_fds[key.fd][1]
-                        ready_fds[key.fd] = (key, (events | old_events) & key.events)
-
-            return list(ready_fds.values())
-
-        def close(self):
-            self._kqueue.close()
-            super(KqueueSelector, self).close()
-
-
-# Choose the best implementation, roughly:
-# kqueue == epoll > poll > select. Devpoll not supported. (See above)
-# select() also can't accept a FD > FD_SETSIZE (usually around 1024)
-if 'KqueueSelector' in globals():  # Platform-specific: Mac OS and BSD
-    DefaultSelector = KqueueSelector
-elif 'EpollSelector' in globals():  # Platform-specific: Linux
-    DefaultSelector = EpollSelector
-elif 'PollSelector' in globals():  # Platform-specific: Linux
-    DefaultSelector = PollSelector
-elif 'SelectSelector' in globals():  # Platform-specific: Windows
-    DefaultSelector = SelectSelector
-else:  # Platform-specific: AppEngine
-    def no_selector(_):
-        raise ValueError("Platform does not have a selector")
-    DefaultSelector = no_selector
-    HAS_SELECT = False
+# Backport of selectors.py from Python 3.5+ to support Python < 3.4
+# Also has the behavior specified in PEP 475 which is to retry syscalls
+# in the case of an EINTR error. This module is required because selectors34
+# does not follow this behavior and instead returns that no dile descriptor
+# events have occurred rather than retry the syscall. The decision to drop
+# support for select.devpoll is made to maintain 100% test coverage.
+
+import errno
+import math
+import select
+from collections import namedtuple, Mapping
+
+import time
+try:
+    monotonic = time.monotonic
+except (AttributeError, ImportError):  # Python 3.3<
+    monotonic = time.time
+
+EVENT_READ = (1 << 0)
+EVENT_WRITE = (1 << 1)
+
+HAS_SELECT = True  # Variable that shows whether the platform has a selector.
+_SYSCALL_SENTINEL = object()  # Sentinel in case a system call returns None.
+
+
+class SelectorError(Exception):
+    def __init__(self, errcode):
+        super(SelectorError, self).__init__()
+        self.errno = errcode
+
+    def __repr__(self):
+        return "<SelectorError errno={0}>".format(self.errno)
+
+    def __str__(self):
+        return self.__repr__()
+
+
+def _fileobj_to_fd(fileobj):
+    """ Return a file descriptor from a file object. If
+    given an integer will simply return that integer back. """
+    if isinstance(fileobj, int):
+        fd = fileobj
+    else:
+        try:
+            fd = int(fileobj.fileno())
+        except (AttributeError, TypeError, ValueError):
+            raise ValueError("Invalid file object: {0!r}".format(fileobj))
+    if fd < 0:
+        raise ValueError("Invalid file descriptor: {0}".format(fd))
+    return fd
+
+
+def _syscall_wrapper(func, recalc_timeout, *args, **kwargs):
+    """ Wrapper function for syscalls that could fail due to EINTR.
+    All functions should be retried if there is time left in the timeout
+    in accordance with PEP 475. """
+    timeout = kwargs.get("timeout", None)
+    if timeout is None:
+        expires = None
+        recalc_timeout = False
+    else:
+        timeout = float(timeout)
+        if timeout < 0.0:  # Timeout less than 0 treated as no timeout.
+            expires = None
+        else:
+            expires = monotonic() + timeout
+
+    args = list(args)
+    if recalc_timeout and "timeout" not in kwargs:
+        raise ValueError(
+            "Timeout must be in args or kwargs to be recalculated")
+
+    result = _SYSCALL_SENTINEL
+    while result is _SYSCALL_SENTINEL:
+        try:
+            result = func(*args, **kwargs)
+        # OSError is thrown by select.select
+        # IOError is thrown by select.epoll.poll
+        # select.error is thrown by select.poll.poll
+        # Aren't we thankful for Python 3.x rework for exceptions?
+        except (OSError, IOError, select.error) as e:
+            # select.error wasn't a subclass of OSError in the past.
+            errcode = None
+            if hasattr(e, "errno"):
+                errcode = e.errno
+            elif hasattr(e, "args"):
+                errcode = e.args[0]
+
+            # Also test for the Windows equivalent of EINTR.
+            is_interrupt = (errcode == errno.EINTR or (hasattr(errno, "WSAEINTR") and
+                                                       errcode == errno.WSAEINTR))
+
+            if is_interrupt:
+                if expires is not None:
+                    current_time = monotonic()
+                    if current_time > expires:
+                        raise OSError(errno=errno.ETIMEDOUT)
+                    if recalc_timeout:
+                        if "timeout" in kwargs:
+                            kwargs["timeout"] = expires - current_time
+                continue
+            if errcode:
+                raise SelectorError(errcode)
+            else:
+                raise
+    return result
+
+
+SelectorKey = namedtuple('SelectorKey', ['fileobj', 'fd', 'events', 'data'])
+
+
+class _SelectorMapping(Mapping):
+    """ Mapping of file objects to selector keys """
+
+    def __init__(self, selector):
+        self._selector = selector
+
+    def __len__(self):
+        return len(self._selector._fd_to_key)
+
+    def __getitem__(self, fileobj):
+        try:
+            fd = self._selector._fileobj_lookup(fileobj)
+            return self._selector._fd_to_key[fd]
+        except KeyError:
+            raise KeyError("{0!r} is not registered.".format(fileobj))
+
+    def __iter__(self):
+        return iter(self._selector._fd_to_key)
+
+
+class BaseSelector(object):
+    """ Abstract Selector class
+
+    A selector supports registering file objects to be monitored
+    for specific I/O events.
+
+    A file object is a file descriptor or any object with a
+    `fileno()` method. An arbitrary object can be attached to the
+    file object which can be used for example to store context info,
+    a callback, etc.
+
+    A selector can use various implementations (select(), poll(), epoll(),
+    and kqueue()) depending on the platform. The 'DefaultSelector' class uses
+    the most efficient implementation for the current platform.
+    """
+    def __init__(self):
+        # Maps file descriptors to keys.
+        self._fd_to_key = {}
+
+        # Read-only mapping returned by get_map()
+        self._map = _SelectorMapping(self)
+
+    def _fileobj_lookup(self, fileobj):
+        """ Return a file descriptor from a file object.
+        This wraps _fileobj_to_fd() to do an exhaustive
+        search in case the object is invalid but we still
+        have it in our map. Used by unregister() so we can
+        unregister an object that was previously registered
+        even if it is closed. It is also used by _SelectorMapping
+        """
+        try:
+            return _fileobj_to_fd(fileobj)
+        except ValueError:
+
+            # Search through all our mapped keys.
+            for key in self._fd_to_key.values():
+                if key.fileobj is fileobj:
+                    return key.fd
+
+            # Raise ValueError after all.
+            raise
+
+    def register(self, fileobj, events, data=None):
+        """ Register a file object for a set of events to monitor. """
+        if (not events) or (events & ~(EVENT_READ | EVENT_WRITE)):
+            raise ValueError("Invalid events: {0!r}".format(events))
+
+        key = SelectorKey(fileobj, self._fileobj_lookup(fileobj), events, data)
+
+        if key.fd in self._fd_to_key:
+            raise KeyError("{0!r} (FD {1}) is already registered"
+                           .format(fileobj, key.fd))
+
+        self._fd_to_key[key.fd] = key
+        return key
+
+    def unregister(self, fileobj):
+        """ Unregister a file object from being monitored. """
+        try:
+            key = self._fd_to_key.pop(self._fileobj_lookup(fileobj))
+        except KeyError:
+            raise KeyError("{0!r} is not registered".format(fileobj))
+        return key
+
+    def modify(self, fileobj, events, data=None):
+        """ Change a registered file object monitored events and data. """
+        # NOTE: Some subclasses optimize this operation even further.
+        try:
+            key = self._fd_to_key[self._fileobj_lookup(fileobj)]
+        except KeyError:
+            raise KeyError("{0!r} is not registered".format(fileobj))
+
+        if events != key.events:
+            self.unregister(fileobj)
+            key = self.register(fileobj, events, data)
+
+        elif data != key.data:
+            # Use a shortcut to update the data.
+            key = key._replace(data=data)
+            self._fd_to_key[key.fd] = key
+
+        return key
+
+    def select(self, timeout=None):
+        """ Perform the actual selection until some monitored file objects
+        are ready or the timeout expires. """
+        raise NotImplementedError()
+
+    def close(self):
+        """ Close the selector. This must be called to ensure that all
+        underlying resources are freed. """
+        self._fd_to_key.clear()
+        self._map = None
+
+    def get_key(self, fileobj):
+        """ Return the key associated with a registered file object. """
+        mapping = self.get_map()
+        if mapping is None:
+            raise RuntimeError("Selector is closed")
+        try:
+            return mapping[fileobj]
+        except KeyError:
+            raise KeyError("{0!r} is not registered".format(fileobj))
+
+    def get_map(self):
+        """ Return a mapping of file objects to selector keys """
+        return self._map
+
+    def _key_from_fd(self, fd):
+        """ Return the key associated to a given file descriptor
+         Return None if it is not found. """
+        try:
+            return self._fd_to_key[fd]
+        except KeyError:
+            return None
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, *args):
+        self.close()
+
+
+# Almost all platforms have select.select()
+if hasattr(select, "select"):
+    class SelectSelector(BaseSelector):
+        """ Select-based selector. """
+        def __init__(self):
+            super(SelectSelector, self).__init__()
+            self._readers = set()
+            self._writers = set()
+
+        def register(self, fileobj, events, data=None):
+            key = super(SelectSelector, self).register(fileobj, events, data)
+            if events & EVENT_READ:
+                self._readers.add(key.fd)
+            if events & EVENT_WRITE:
+                self._writers.add(key.fd)
+            return key
+
+        def unregister(self, fileobj):
+            key = super(SelectSelector, self).unregister(fileobj)
+            self._readers.discard(key.fd)
+            self._writers.discard(key.fd)
+            return key
+
+        def _select(self, r, w, timeout=None):
+            """ Wrapper for select.select because timeout is a positional arg """
+            return select.select(r, w, [], timeout)
+
+        def select(self, timeout=None):
+            # Selecting on empty lists on Windows errors out.
+            if not len(self._readers) and not len(self._writers):
+                return []
+
+            timeout = None if timeout is None else max(timeout, 0.0)
+            ready = []
+            r, w, _ = _syscall_wrapper(self._select, True, self._readers,
+                                       self._writers, timeout)
+            r = set(r)
+            w = set(w)
+            for fd in r | w:
+                events = 0
+                if fd in r:
+                    events |= EVENT_READ
+                if fd in w:
+                    events |= EVENT_WRITE
+
+                key = self._key_from_fd(fd)
+                if key:
+                    ready.append((key, events & key.events))
+            return ready
+
+
+if hasattr(select, "poll"):
+    class PollSelector(BaseSelector):
+        """ Poll-based selector """
+        def __init__(self):
+            super(PollSelector, self).__init__()
+            self._poll = select.poll()
+
+        def register(self, fileobj, events, data=None):
+            key = super(PollSelector, self).register(fileobj, events, data)
+            event_mask = 0
+            if events & EVENT_READ:
+                event_mask |= select.POLLIN
+            if events & EVENT_WRITE:
+                event_mask |= select.POLLOUT
+            self._poll.register(key.fd, event_mask)
+            return key
+
+        def unregister(self, fileobj):
+            key = super(PollSelector, self).unregister(fileobj)
+            self._poll.unregister(key.fd)
+            return key
+
+        def _wrap_poll(self, timeout=None):
+            """ Wrapper function for select.poll.poll() so that
+            _syscall_wrapper can work with only seconds. """
+            if timeout is not None:
+                if timeout <= 0:
+                    timeout = 0
+                else:
+                    # select.poll.poll() has a resolution of 1 millisecond,
+                    # round away from zero to wait *at least* timeout seconds.
+                    timeout = math.ceil(timeout * 1e3)
+
+            result = self._poll.poll(timeout)
+            return result
+
+        def select(self, timeout=None):
+            ready = []
+            fd_events = _syscall_wrapper(self._wrap_poll, True, timeout=timeout)
+            for fd, event_mask in fd_events:
+                events = 0
+                if event_mask & ~select.POLLIN:
+                    events |= EVENT_WRITE
+                if event_mask & ~select.POLLOUT:
+                    events |= EVENT_READ
+
+                key = self._key_from_fd(fd)
+                if key:
+                    ready.append((key, events & key.events))
+
+            return ready
+
+
+if hasattr(select, "epoll"):
+    class EpollSelector(BaseSelector):
+        """ Epoll-based selector """
+        def __init__(self):
+            super(EpollSelector, self).__init__()
+            self._epoll = select.epoll()
+
+        def fileno(self):
+            return self._epoll.fileno()
+
+        def register(self, fileobj, events, data=None):
+            key = super(EpollSelector, self).register(fileobj, events, data)
+            events_mask = 0
+            if events & EVENT_READ:
+                events_mask |= select.EPOLLIN
+            if events & EVENT_WRITE:
+                events_mask |= select.EPOLLOUT
+            _syscall_wrapper(self._epoll.register, False, key.fd, events_mask)
+            return key
+
+        def unregister(self, fileobj):
+            key = super(EpollSelector, self).unregister(fileobj)
+            try:
+                _syscall_wrapper(self._epoll.unregister, False, key.fd)
+            except SelectorError:
+                # This can occur when the fd was closed since registry.
+                pass
+            return key
+
+        def select(self, timeout=None):
+            if timeout is not None:
+                if timeout <= 0:
+                    timeout = 0.0
+                else:
+                    # select.epoll.poll() has a resolution of 1 millisecond
+                    # but luckily takes seconds so we don't need a wrapper
+                    # like PollSelector. Just for better rounding.
+                    timeout = math.ceil(timeout * 1e3) * 1e-3
+                timeout = float(timeout)
+            else:
+                timeout = -1.0  # epoll.poll() must have a float.
+
+            # We always want at least 1 to ensure that select can be called
+            # with no file descriptors registered. Otherwise will fail.
+            max_events = max(len(self._fd_to_key), 1)
+
+            ready = []
+            fd_events = _syscall_wrapper(self._epoll.poll, True,
+                                         timeout=timeout,
+                                         maxevents=max_events)
+            for fd, event_mask in fd_events:
+                events = 0
+                if event_mask & ~select.EPOLLIN:
+                    events |= EVENT_WRITE
+                if event_mask & ~select.EPOLLOUT:
+                    events |= EVENT_READ
+
+                key = self._key_from_fd(fd)
+                if key:
+                    ready.append((key, events & key.events))
+            return ready
+
+        def close(self):
+            self._epoll.close()
+            super(EpollSelector, self).close()
+
+
+if hasattr(select, "kqueue"):
+    class KqueueSelector(BaseSelector):
+        """ Kqueue / Kevent-based selector """
+        def __init__(self):
+            super(KqueueSelector, self).__init__()
+            self._kqueue = select.kqueue()
+
+        def fileno(self):
+            return self._kqueue.fileno()
+
+        def register(self, fileobj, events, data=None):
+            key = super(KqueueSelector, self).register(fileobj, events, data)
+            if events & EVENT_READ:
+                kevent = select.kevent(key.fd,
+                                       select.KQ_FILTER_READ,
+                                       select.KQ_EV_ADD)
+
+                _syscall_wrapper(self._kqueue.control, False, [kevent], 0, 0)
+
+            if events & EVENT_WRITE:
+                kevent = select.kevent(key.fd,
+                                       select.KQ_FILTER_WRITE,
+                                       select.KQ_EV_ADD)
+
+                _syscall_wrapper(self._kqueue.control, False, [kevent], 0, 0)
+
+            return key
+
+        def unregister(self, fileobj):
+            key = super(KqueueSelector, self).unregister(fileobj)
+            if key.events & EVENT_READ:
+                kevent = select.kevent(key.fd,
+                                       select.KQ_FILTER_READ,
+                                       select.KQ_EV_DELETE)
+                try:
+                    _syscall_wrapper(self._kqueue.control, False, [kevent], 0, 0)
+                except SelectorError:
+                    pass
+            if key.events & EVENT_WRITE:
+                kevent = select.kevent(key.fd,
+                                       select.KQ_FILTER_WRITE,
+                                       select.KQ_EV_DELETE)
+                try:
+                    _syscall_wrapper(self._kqueue.control, False, [kevent], 0, 0)
+                except SelectorError:
+                    pass
+
+            return key
+
+        def select(self, timeout=None):
+            if timeout is not None:
+                timeout = max(timeout, 0)
+
+            max_events = len(self._fd_to_key) * 2
+            ready_fds = {}
+
+            kevent_list = _syscall_wrapper(self._kqueue.control, True,
+                                           None, max_events, timeout)
+
+            for kevent in kevent_list:
+                fd = kevent.ident
+                event_mask = kevent.filter
+                events = 0
+                if event_mask == select.KQ_FILTER_READ:
+                    events |= EVENT_READ
+                if event_mask == select.KQ_FILTER_WRITE:
+                    events |= EVENT_WRITE
+
+                key = self._key_from_fd(fd)
+                if key:
+                    if key.fd not in ready_fds:
+                        ready_fds[key.fd] = (key, events & key.events)
+                    else:
+                        old_events = ready_fds[key.fd][1]
+                        ready_fds[key.fd] = (key, (events | old_events) & key.events)
+
+            return list(ready_fds.values())
+
+        def close(self):
+            self._kqueue.close()
+            super(KqueueSelector, self).close()
+
+
+# Choose the best implementation, roughly:
+# kqueue == epoll > poll > select. Devpoll not supported. (See above)
+# select() also can't accept a FD > FD_SETSIZE (usually around 1024)
+if 'KqueueSelector' in globals():  # Platform-specific: Mac OS and BSD
+    DefaultSelector = KqueueSelector
+elif 'EpollSelector' in globals():  # Platform-specific: Linux
+    DefaultSelector = EpollSelector
+elif 'PollSelector' in globals():  # Platform-specific: Linux
+    DefaultSelector = PollSelector
+elif 'SelectSelector' in globals():  # Platform-specific: Windows
+    DefaultSelector = SelectSelector
+else:  # Platform-specific: AppEngine
+    def no_selector(_):
+        raise ValueError("Platform does not have a selector")
+    DefaultSelector = no_selector
+    HAS_SELECT = False
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/ssl_.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/ssl_.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,336 +1,336 @@
-from __future__ import absolute_import
-import errno
-import warnings
-import hmac
-
-from binascii import hexlify, unhexlify
-from hashlib import md5, sha1, sha256
-
-from ..exceptions import SSLError, InsecurePlatformWarning, SNIMissingWarning
-
-
-SSLContext = None
-HAS_SNI = False
-IS_PYOPENSSL = False
-
-# Maps the length of a digest to a possible hash function producing this digest
-HASHFUNC_MAP = {
-    32: md5,
-    40: sha1,
-    64: sha256,
-}
-
-
-def _const_compare_digest_backport(a, b):
-    """
-    Compare two digests of equal length in constant time.
-
-    The digests must be of type str/bytes.
-    Returns True if the digests match, and False otherwise.
-    """
-    result = abs(len(a) - len(b))
-    for l, r in zip(bytearray(a), bytearray(b)):
-        result |= l ^ r
-    return result == 0
-
-
-_const_compare_digest = getattr(hmac, 'compare_digest',
-                                _const_compare_digest_backport)
-
-
-try:  # Test for SSL features
-    import ssl
-    from ssl import wrap_socket, CERT_NONE, PROTOCOL_SSLv23
-    from ssl import HAS_SNI  # Has SNI?
-except ImportError:
-    pass
-
-
-try:
-    from ssl import OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION
-except ImportError:
-    OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000
-    OP_NO_COMPRESSION = 0x20000
-
-# A secure default.
-# Sources for more information on TLS ciphers:
-#
-# - https://wiki.mozilla.org/Security/Server_Side_TLS
-# - https://www.ssllabs.com/projects/best-practices/index.html
-# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
-#
-# The general intent is:
-# - Prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),
-# - prefer ECDHE over DHE for better performance,
-# - prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and
-#   security,
-# - prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,
-# - disable NULL authentication, MD5 MACs and DSS for security reasons.
-DEFAULT_CIPHERS = ':'.join([
-    'ECDH+AESGCM',
-    'ECDH+CHACHA20',
-    'DH+AESGCM',
-    'DH+CHACHA20',
-    'ECDH+AES256',
-    'DH+AES256',
-    'ECDH+AES128',
-    'DH+AES',
-    'RSA+AESGCM',
-    'RSA+AES',
-    '!aNULL',
-    '!eNULL',
-    '!MD5',
-])
-
-try:
-    from ssl import SSLContext  # Modern SSL?
-except ImportError:
-    import sys
-
-    class SSLContext(object):  # Platform-specific: Python 2 & 3.1
-        supports_set_ciphers = ((2, 7) <= sys.version_info < (3,) or
-                                (3, 2) <= sys.version_info)
-
-        def __init__(self, protocol_version):
-            self.protocol = protocol_version
-            # Use default values from a real SSLContext
-            self.check_hostname = False
-            self.verify_mode = ssl.CERT_NONE
-            self.ca_certs = None
-            self.options = 0
-            self.certfile = None
-            self.keyfile = None
-            self.ciphers = None
-
-        def load_cert_chain(self, certfile, keyfile):
-            self.certfile = certfile
-            self.keyfile = keyfile
-
-        def load_verify_locations(self, cafile=None, capath=None):
-            self.ca_certs = cafile
-
-            if capath is not None:
-                raise SSLError("CA directories not supported in older Pythons")
-
-        def set_ciphers(self, cipher_suite):
-            if not self.supports_set_ciphers:
-                raise TypeError(
-                    'Your version of Python does not support setting '
-                    'a custom cipher suite. Please upgrade to Python '
-                    '2.7, 3.2, or later if you need this functionality.'
-                )
-            self.ciphers = cipher_suite
-
-        def wrap_socket(self, socket, server_hostname=None, server_side=False):
-            warnings.warn(
-                'A true SSLContext object is not available. This prevents '
-                'urllib3 from configuring SSL appropriately and may cause '
-                'certain SSL connections to fail. You can upgrade to a newer '
-                'version of Python to solve this. For more information, see '
-                'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
-                '#ssl-warnings',
-                InsecurePlatformWarning
-            )
-            kwargs = {
-                'keyfile': self.keyfile,
-                'certfile': self.certfile,
-                'ca_certs': self.ca_certs,
-                'cert_reqs': self.verify_mode,
-                'ssl_version': self.protocol,
-                'server_side': server_side,
-            }
-            if self.supports_set_ciphers:  # Platform-specific: Python 2.7+
-                return wrap_socket(socket, ciphers=self.ciphers, **kwargs)
-            else:  # Platform-specific: Python 2.6
-                return wrap_socket(socket, **kwargs)
-
-
-def assert_fingerprint(cert, fingerprint):
-    """
-    Checks if given fingerprint matches the supplied certificate.
-
-    :param cert:
-        Certificate as bytes object.
-    :param fingerprint:
-        Fingerprint as string of hexdigits, can be interspersed by colons.
-    """
-
-    fingerprint = fingerprint.replace(':', '').lower()
-    digest_length = len(fingerprint)
-    hashfunc = HASHFUNC_MAP.get(digest_length)
-    if not hashfunc:
-        raise SSLError(
-            'Fingerprint of invalid length: {0}'.format(fingerprint))
-
-    # We need encode() here for py32; works on py2 and p33.
-    fingerprint_bytes = unhexlify(fingerprint.encode())
-
-    cert_digest = hashfunc(cert).digest()
-
-    if not _const_compare_digest(cert_digest, fingerprint_bytes):
-        raise SSLError('Fingerprints did not match. Expected "{0}", got "{1}".'
-                       .format(fingerprint, hexlify(cert_digest)))
-
-
-def resolve_cert_reqs(candidate):
-    """
-    Resolves the argument to a numeric constant, which can be passed to
-    the wrap_socket function/method from the ssl module.
-    Defaults to :data:`ssl.CERT_NONE`.
-    If given a string it is assumed to be the name of the constant in the
-    :mod:`ssl` module or its abbrevation.
-    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.
-    If it's neither `None` nor a string we assume it is already the numeric
-    constant which can directly be passed to wrap_socket.
-    """
-    if candidate is None:
-        return CERT_NONE
-
-    if isinstance(candidate, str):
-        res = getattr(ssl, candidate, None)
-        if res is None:
-            res = getattr(ssl, 'CERT_' + candidate)
-        return res
-
-    return candidate
-
-
-def resolve_ssl_version(candidate):
-    """
-    like resolve_cert_reqs
-    """
-    if candidate is None:
-        return PROTOCOL_SSLv23
-
-    if isinstance(candidate, str):
-        res = getattr(ssl, candidate, None)
-        if res is None:
-            res = getattr(ssl, 'PROTOCOL_' + candidate)
-        return res
-
-    return candidate
-
-
-def create_urllib3_context(ssl_version=None, cert_reqs=None,
-                           options=None, ciphers=None):
-    """All arguments have the same meaning as ``ssl_wrap_socket``.
-
-    By default, this function does a lot of the same work that
-    ``ssl.create_default_context`` does on Python 3.4+. It:
-
-    - Disables SSLv2, SSLv3, and compression
-    - Sets a restricted set of server ciphers
-
-    If you wish to enable SSLv3, you can do::
-
-        from urllib3.util import ssl_
-        context = ssl_.create_urllib3_context()
-        context.options &= ~ssl_.OP_NO_SSLv3
-
-    You can do the same to enable compression (substituting ``COMPRESSION``
-    for ``SSLv3`` in the last line above).
-
-    :param ssl_version:
-        The desired protocol version to use. This will default to
-        PROTOCOL_SSLv23 which will negotiate the highest protocol that both
-        the server and your installation of OpenSSL support.
-    :param cert_reqs:
-        Whether to require the certificate verification. This defaults to
-        ``ssl.CERT_REQUIRED``.
-    :param options:
-        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
-        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``.
-    :param ciphers:
-        Which cipher suites to allow the server to select.
-    :returns:
-        Constructed SSLContext object with specified options
-    :rtype: SSLContext
-    """
-    context = SSLContext(ssl_version or ssl.PROTOCOL_SSLv23)
-
-    # Setting the default here, as we may have no ssl module on import
-    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs
-
-    if options is None:
-        options = 0
-        # SSLv2 is easily broken and is considered harmful and dangerous
-        options |= OP_NO_SSLv2
-        # SSLv3 has several problems and is now dangerous
-        options |= OP_NO_SSLv3
-        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
-        # (issue #309)
-        options |= OP_NO_COMPRESSION
-
-    context.options |= options
-
-    if getattr(context, 'supports_set_ciphers', True):  # Platform-specific: Python 2.6
-        context.set_ciphers(ciphers or DEFAULT_CIPHERS)
-
-    context.verify_mode = cert_reqs
-    if getattr(context, 'check_hostname', None) is not None:  # Platform-specific: Python 3.2
-        # We do our own verification, including fingerprints and alternative
-        # hostnames. So disable it here
-        context.check_hostname = False
-    return context
-
-
-def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
-                    ca_certs=None, server_hostname=None,
-                    ssl_version=None, ciphers=None, ssl_context=None,
-                    ca_cert_dir=None):
-    """
-    All arguments except for server_hostname, ssl_context, and ca_cert_dir have
-    the same meaning as they do when using :func:`ssl.wrap_socket`.
-
-    :param server_hostname:
-        When SNI is supported, the expected hostname of the certificate
-    :param ssl_context:
-        A pre-made :class:`SSLContext` object. If none is provided, one will
-        be created using :func:`create_urllib3_context`.
-    :param ciphers:
-        A string of ciphers we wish the client to support. This is not
-        supported on Python 2.6 as the ssl module does not support it.
-    :param ca_cert_dir:
-        A directory containing CA certificates in multiple separate files, as
-        supported by OpenSSL's -CApath flag or the capath argument to
-        SSLContext.load_verify_locations().
-    """
-    context = ssl_context
-    if context is None:
-        # Note: This branch of code and all the variables in it are no longer
-        # used by urllib3 itself. We should consider deprecating and removing
-        # this code.
-        context = create_urllib3_context(ssl_version, cert_reqs,
-                                         ciphers=ciphers)
-
-    if ca_certs or ca_cert_dir:
-        try:
-            context.load_verify_locations(ca_certs, ca_cert_dir)
-        except IOError as e:  # Platform-specific: Python 2.6, 2.7, 3.2
-            raise SSLError(e)
-        # Py33 raises FileNotFoundError which subclasses OSError
-        # These are not equivalent unless we check the errno attribute
-        except OSError as e:  # Platform-specific: Python 3.3 and beyond
-            if e.errno == errno.ENOENT:
-                raise SSLError(e)
-            raise
-    elif getattr(context, 'load_default_certs', None) is not None:
-        # try to load OS default certs; works well on Windows (require Python3.4+)
-        context.load_default_certs()
-
-    if certfile:
-        context.load_cert_chain(certfile, keyfile)
-    if HAS_SNI:  # Platform-specific: OpenSSL with enabled SNI
-        return context.wrap_socket(sock, server_hostname=server_hostname)
-
-    warnings.warn(
-        'An HTTPS request has been made, but the SNI (Subject Name '
-        'Indication) extension to TLS is not available on this platform. '
-        'This may cause the server to present an incorrect TLS '
-        'certificate, which can cause validation failures. You can upgrade to '
-        'a newer version of Python to solve this. For more information, see '
-        'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
-        '#ssl-warnings',
-        SNIMissingWarning
-    )
-    return context.wrap_socket(sock)
+from __future__ import absolute_import
+import errno
+import warnings
+import hmac
+
+from binascii import hexlify, unhexlify
+from hashlib import md5, sha1, sha256
+
+from ..exceptions import SSLError, InsecurePlatformWarning, SNIMissingWarning
+
+
+SSLContext = None
+HAS_SNI = False
+IS_PYOPENSSL = False
+
+# Maps the length of a digest to a possible hash function producing this digest
+HASHFUNC_MAP = {
+    32: md5,
+    40: sha1,
+    64: sha256,
+}
+
+
+def _const_compare_digest_backport(a, b):
+    """
+    Compare two digests of equal length in constant time.
+
+    The digests must be of type str/bytes.
+    Returns True if the digests match, and False otherwise.
+    """
+    result = abs(len(a) - len(b))
+    for l, r in zip(bytearray(a), bytearray(b)):
+        result |= l ^ r
+    return result == 0
+
+
+_const_compare_digest = getattr(hmac, 'compare_digest',
+                                _const_compare_digest_backport)
+
+
+try:  # Test for SSL features
+    import ssl
+    from ssl import wrap_socket, CERT_NONE, PROTOCOL_SSLv23
+    from ssl import HAS_SNI  # Has SNI?
+except ImportError:
+    pass
+
+
+try:
+    from ssl import OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION
+except ImportError:
+    OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000
+    OP_NO_COMPRESSION = 0x20000
+
+# A secure default.
+# Sources for more information on TLS ciphers:
+#
+# - https://wiki.mozilla.org/Security/Server_Side_TLS
+# - https://www.ssllabs.com/projects/best-practices/index.html
+# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
+#
+# The general intent is:
+# - Prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),
+# - prefer ECDHE over DHE for better performance,
+# - prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and
+#   security,
+# - prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,
+# - disable NULL authentication, MD5 MACs and DSS for security reasons.
+DEFAULT_CIPHERS = ':'.join([
+    'ECDH+AESGCM',
+    'ECDH+CHACHA20',
+    'DH+AESGCM',
+    'DH+CHACHA20',
+    'ECDH+AES256',
+    'DH+AES256',
+    'ECDH+AES128',
+    'DH+AES',
+    'RSA+AESGCM',
+    'RSA+AES',
+    '!aNULL',
+    '!eNULL',
+    '!MD5',
+])
+
+try:
+    from ssl import SSLContext  # Modern SSL?
+except ImportError:
+    import sys
+
+    class SSLContext(object):  # Platform-specific: Python 2 & 3.1
+        supports_set_ciphers = ((2, 7) <= sys.version_info < (3,) or
+                                (3, 2) <= sys.version_info)
+
+        def __init__(self, protocol_version):
+            self.protocol = protocol_version
+            # Use default values from a real SSLContext
+            self.check_hostname = False
+            self.verify_mode = ssl.CERT_NONE
+            self.ca_certs = None
+            self.options = 0
+            self.certfile = None
+            self.keyfile = None
+            self.ciphers = None
+
+        def load_cert_chain(self, certfile, keyfile):
+            self.certfile = certfile
+            self.keyfile = keyfile
+
+        def load_verify_locations(self, cafile=None, capath=None):
+            self.ca_certs = cafile
+
+            if capath is not None:
+                raise SSLError("CA directories not supported in older Pythons")
+
+        def set_ciphers(self, cipher_suite):
+            if not self.supports_set_ciphers:
+                raise TypeError(
+                    'Your version of Python does not support setting '
+                    'a custom cipher suite. Please upgrade to Python '
+                    '2.7, 3.2, or later if you need this functionality.'
+                )
+            self.ciphers = cipher_suite
+
+        def wrap_socket(self, socket, server_hostname=None, server_side=False):
+            warnings.warn(
+                'A true SSLContext object is not available. This prevents '
+                'urllib3 from configuring SSL appropriately and may cause '
+                'certain SSL connections to fail. You can upgrade to a newer '
+                'version of Python to solve this. For more information, see '
+                'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
+                '#ssl-warnings',
+                InsecurePlatformWarning
+            )
+            kwargs = {
+                'keyfile': self.keyfile,
+                'certfile': self.certfile,
+                'ca_certs': self.ca_certs,
+                'cert_reqs': self.verify_mode,
+                'ssl_version': self.protocol,
+                'server_side': server_side,
+            }
+            if self.supports_set_ciphers:  # Platform-specific: Python 2.7+
+                return wrap_socket(socket, ciphers=self.ciphers, **kwargs)
+            else:  # Platform-specific: Python 2.6
+                return wrap_socket(socket, **kwargs)
+
+
+def assert_fingerprint(cert, fingerprint):
+    """
+    Checks if given fingerprint matches the supplied certificate.
+
+    :param cert:
+        Certificate as bytes object.
+    :param fingerprint:
+        Fingerprint as string of hexdigits, can be interspersed by colons.
+    """
+
+    fingerprint = fingerprint.replace(':', '').lower()
+    digest_length = len(fingerprint)
+    hashfunc = HASHFUNC_MAP.get(digest_length)
+    if not hashfunc:
+        raise SSLError(
+            'Fingerprint of invalid length: {0}'.format(fingerprint))
+
+    # We need encode() here for py32; works on py2 and p33.
+    fingerprint_bytes = unhexlify(fingerprint.encode())
+
+    cert_digest = hashfunc(cert).digest()
+
+    if not _const_compare_digest(cert_digest, fingerprint_bytes):
+        raise SSLError('Fingerprints did not match. Expected "{0}", got "{1}".'
+                       .format(fingerprint, hexlify(cert_digest)))
+
+
+def resolve_cert_reqs(candidate):
+    """
+    Resolves the argument to a numeric constant, which can be passed to
+    the wrap_socket function/method from the ssl module.
+    Defaults to :data:`ssl.CERT_NONE`.
+    If given a string it is assumed to be the name of the constant in the
+    :mod:`ssl` module or its abbrevation.
+    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.
+    If it's neither `None` nor a string we assume it is already the numeric
+    constant which can directly be passed to wrap_socket.
+    """
+    if candidate is None:
+        return CERT_NONE
+
+    if isinstance(candidate, str):
+        res = getattr(ssl, candidate, None)
+        if res is None:
+            res = getattr(ssl, 'CERT_' + candidate)
+        return res
+
+    return candidate
+
+
+def resolve_ssl_version(candidate):
+    """
+    like resolve_cert_reqs
+    """
+    if candidate is None:
+        return PROTOCOL_SSLv23
+
+    if isinstance(candidate, str):
+        res = getattr(ssl, candidate, None)
+        if res is None:
+            res = getattr(ssl, 'PROTOCOL_' + candidate)
+        return res
+
+    return candidate
+
+
+def create_urllib3_context(ssl_version=None, cert_reqs=None,
+                           options=None, ciphers=None):
+    """All arguments have the same meaning as ``ssl_wrap_socket``.
+
+    By default, this function does a lot of the same work that
+    ``ssl.create_default_context`` does on Python 3.4+. It:
+
+    - Disables SSLv2, SSLv3, and compression
+    - Sets a restricted set of server ciphers
+
+    If you wish to enable SSLv3, you can do::
+
+        from urllib3.util import ssl_
+        context = ssl_.create_urllib3_context()
+        context.options &= ~ssl_.OP_NO_SSLv3
+
+    You can do the same to enable compression (substituting ``COMPRESSION``
+    for ``SSLv3`` in the last line above).
+
+    :param ssl_version:
+        The desired protocol version to use. This will default to
+        PROTOCOL_SSLv23 which will negotiate the highest protocol that both
+        the server and your installation of OpenSSL support.
+    :param cert_reqs:
+        Whether to require the certificate verification. This defaults to
+        ``ssl.CERT_REQUIRED``.
+    :param options:
+        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
+        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``.
+    :param ciphers:
+        Which cipher suites to allow the server to select.
+    :returns:
+        Constructed SSLContext object with specified options
+    :rtype: SSLContext
+    """
+    context = SSLContext(ssl_version or ssl.PROTOCOL_SSLv23)
+
+    # Setting the default here, as we may have no ssl module on import
+    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs
+
+    if options is None:
+        options = 0
+        # SSLv2 is easily broken and is considered harmful and dangerous
+        options |= OP_NO_SSLv2
+        # SSLv3 has several problems and is now dangerous
+        options |= OP_NO_SSLv3
+        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
+        # (issue #309)
+        options |= OP_NO_COMPRESSION
+
+    context.options |= options
+
+    if getattr(context, 'supports_set_ciphers', True):  # Platform-specific: Python 2.6
+        context.set_ciphers(ciphers or DEFAULT_CIPHERS)
+
+    context.verify_mode = cert_reqs
+    if getattr(context, 'check_hostname', None) is not None:  # Platform-specific: Python 3.2
+        # We do our own verification, including fingerprints and alternative
+        # hostnames. So disable it here
+        context.check_hostname = False
+    return context
+
+
+def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
+                    ca_certs=None, server_hostname=None,
+                    ssl_version=None, ciphers=None, ssl_context=None,
+                    ca_cert_dir=None):
+    """
+    All arguments except for server_hostname, ssl_context, and ca_cert_dir have
+    the same meaning as they do when using :func:`ssl.wrap_socket`.
+
+    :param server_hostname:
+        When SNI is supported, the expected hostname of the certificate
+    :param ssl_context:
+        A pre-made :class:`SSLContext` object. If none is provided, one will
+        be created using :func:`create_urllib3_context`.
+    :param ciphers:
+        A string of ciphers we wish the client to support. This is not
+        supported on Python 2.6 as the ssl module does not support it.
+    :param ca_cert_dir:
+        A directory containing CA certificates in multiple separate files, as
+        supported by OpenSSL's -CApath flag or the capath argument to
+        SSLContext.load_verify_locations().
+    """
+    context = ssl_context
+    if context is None:
+        # Note: This branch of code and all the variables in it are no longer
+        # used by urllib3 itself. We should consider deprecating and removing
+        # this code.
+        context = create_urllib3_context(ssl_version, cert_reqs,
+                                         ciphers=ciphers)
+
+    if ca_certs or ca_cert_dir:
+        try:
+            context.load_verify_locations(ca_certs, ca_cert_dir)
+        except IOError as e:  # Platform-specific: Python 2.6, 2.7, 3.2
+            raise SSLError(e)
+        # Py33 raises FileNotFoundError which subclasses OSError
+        # These are not equivalent unless we check the errno attribute
+        except OSError as e:  # Platform-specific: Python 3.3 and beyond
+            if e.errno == errno.ENOENT:
+                raise SSLError(e)
+            raise
+    elif getattr(context, 'load_default_certs', None) is not None:
+        # try to load OS default certs; works well on Windows (require Python3.4+)
+        context.load_default_certs()
+
+    if certfile:
+        context.load_cert_chain(certfile, keyfile)
+    if HAS_SNI:  # Platform-specific: OpenSSL with enabled SNI
+        return context.wrap_socket(sock, server_hostname=server_hostname)
+
+    warnings.warn(
+        'An HTTPS request has been made, but the SNI (Subject Name '
+        'Indication) extension to TLS is not available on this platform. '
+        'This may cause the server to present an incorrect TLS '
+        'certificate, which can cause validation failures. You can upgrade to '
+        'a newer version of Python to solve this. For more information, see '
+        'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
+        '#ssl-warnings',
+        SNIMissingWarning
+    )
+    return context.wrap_socket(sock)
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/timeout.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/timeout.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,242 +1,242 @@
-from __future__ import absolute_import
-# The default socket timeout, used by httplib to indicate that no timeout was
-# specified by the user
-from socket import _GLOBAL_DEFAULT_TIMEOUT
-import time
-
-from ..exceptions import TimeoutStateError
-
-# A sentinel value to indicate that no timeout was specified by the user in
-# urllib3
-_Default = object()
-
-
-# Use time.monotonic if available.
-current_time = getattr(time, "monotonic", time.time)
-
-
-class Timeout(object):
-    """ Timeout configuration.
-
-    Timeouts can be defined as a default for a pool::
-
-        timeout = Timeout(connect=2.0, read=7.0)
-        http = PoolManager(timeout=timeout)
-        response = http.request('GET', 'http://example.com/')
-
-    Or per-request (which overrides the default for the pool)::
-
-        response = http.request('GET', 'http://example.com/', timeout=Timeout(10))
-
-    Timeouts can be disabled by setting all the parameters to ``None``::
-
-        no_timeout = Timeout(connect=None, read=None)
-        response = http.request('GET', 'http://example.com/, timeout=no_timeout)
-
-
-    :param total:
-        This combines the connect and read timeouts into one; the read timeout
-        will be set to the time leftover from the connect attempt. In the
-        event that both a connect timeout and a total are specified, or a read
-        timeout and a total are specified, the shorter timeout will be applied.
-
-        Defaults to None.
-
-    :type total: integer, float, or None
-
-    :param connect:
-        The maximum amount of time to wait for a connection attempt to a server
-        to succeed. Omitting the parameter will default the connect timeout to
-        the system default, probably `the global default timeout in socket.py
-        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
-        None will set an infinite timeout for connection attempts.
-
-    :type connect: integer, float, or None
-
-    :param read:
-        The maximum amount of time to wait between consecutive
-        read operations for a response from the server. Omitting
-        the parameter will default the read timeout to the system
-        default, probably `the global default timeout in socket.py
-        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
-        None will set an infinite timeout.
-
-    :type read: integer, float, or None
-
-    .. note::
-
-        Many factors can affect the total amount of time for urllib3 to return
-        an HTTP response.
-
-        For example, Python's DNS resolver does not obey the timeout specified
-        on the socket. Other factors that can affect total request time include
-        high CPU load, high swap, the program running at a low priority level,
-        or other behaviors.
-
-        In addition, the read and total timeouts only measure the time between
-        read operations on the socket connecting the client and the server,
-        not the total amount of time for the request to return a complete
-        response. For most requests, the timeout is raised because the server
-        has not sent the first byte in the specified time. This is not always
-        the case; if a server streams one byte every fifteen seconds, a timeout
-        of 20 seconds will not trigger, even though the request will take
-        several minutes to complete.
-
-        If your goal is to cut off any request after a set amount of wall clock
-        time, consider having a second "watcher" thread to cut off a slow
-        request.
-    """
-
-    #: A sentinel object representing the default timeout value
-    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT
-
-    def __init__(self, total=None, connect=_Default, read=_Default):
-        self._connect = self._validate_timeout(connect, 'connect')
-        self._read = self._validate_timeout(read, 'read')
-        self.total = self._validate_timeout(total, 'total')
-        self._start_connect = None
-
-    def __str__(self):
-        return '%s(connect=%r, read=%r, total=%r)' % (
-            type(self).__name__, self._connect, self._read, self.total)
-
-    @classmethod
-    def _validate_timeout(cls, value, name):
-        """ Check that a timeout attribute is valid.
-
-        :param value: The timeout value to validate
-        :param name: The name of the timeout attribute to validate. This is
-            used to specify in error messages.
-        :return: The validated and casted version of the given value.
-        :raises ValueError: If it is a numeric value less than or equal to
-            zero, or the type is not an integer, float, or None.
-        """
-        if value is _Default:
-            return cls.DEFAULT_TIMEOUT
-
-        if value is None or value is cls.DEFAULT_TIMEOUT:
-            return value
-
-        if isinstance(value, bool):
-            raise ValueError("Timeout cannot be a boolean value. It must "
-                             "be an int, float or None.")
-        try:
-            float(value)
-        except (TypeError, ValueError):
-            raise ValueError("Timeout value %s was %s, but it must be an "
-                             "int, float or None." % (name, value))
-
-        try:
-            if value <= 0:
-                raise ValueError("Attempted to set %s timeout to %s, but the "
-                                 "timeout cannot be set to a value less "
-                                 "than or equal to 0." % (name, value))
-        except TypeError:  # Python 3
-            raise ValueError("Timeout value %s was %s, but it must be an "
-                             "int, float or None." % (name, value))
-
-        return value
-
-    @classmethod
-    def from_float(cls, timeout):
-        """ Create a new Timeout from a legacy timeout value.
-
-        The timeout value used by httplib.py sets the same timeout on the
-        connect(), and recv() socket requests. This creates a :class:`Timeout`
-        object that sets the individual timeouts to the ``timeout`` value
-        passed to this function.
-
-        :param timeout: The legacy timeout value.
-        :type timeout: integer, float, sentinel default object, or None
-        :return: Timeout object
-        :rtype: :class:`Timeout`
-        """
-        return Timeout(read=timeout, connect=timeout)
-
-    def clone(self):
-        """ Create a copy of the timeout object
-
-        Timeout properties are stored per-pool but each request needs a fresh
-        Timeout object to ensure each one has its own start/stop configured.
-
-        :return: a copy of the timeout object
-        :rtype: :class:`Timeout`
-        """
-        # We can't use copy.deepcopy because that will also create a new object
-        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to
-        # detect the user default.
-        return Timeout(connect=self._connect, read=self._read,
-                       total=self.total)
-
-    def start_connect(self):
-        """ Start the timeout clock, used during a connect() attempt
-
-        :raises urllib3.exceptions.TimeoutStateError: if you attempt
-            to start a timer that has been started already.
-        """
-        if self._start_connect is not None:
-            raise TimeoutStateError("Timeout timer has already been started.")
-        self._start_connect = current_time()
-        return self._start_connect
-
-    def get_connect_duration(self):
-        """ Gets the time elapsed since the call to :meth:`start_connect`.
-
-        :return: Elapsed time.
-        :rtype: float
-        :raises urllib3.exceptions.TimeoutStateError: if you attempt
-            to get duration for a timer that hasn't been started.
-        """
-        if self._start_connect is None:
-            raise TimeoutStateError("Can't get connect duration for timer "
-                                    "that has not started.")
-        return current_time() - self._start_connect
-
-    @property
-    def connect_timeout(self):
-        """ Get the value to use when setting a connection timeout.
-
-        This will be a positive float or integer, the value None
-        (never timeout), or the default system timeout.
-
-        :return: Connect timeout.
-        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
-        """
-        if self.total is None:
-            return self._connect
-
-        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:
-            return self.total
-
-        return min(self._connect, self.total)
-
-    @property
-    def read_timeout(self):
-        """ Get the value for the read timeout.
-
-        This assumes some time has elapsed in the connection timeout and
-        computes the read timeout appropriately.
-
-        If self.total is set, the read timeout is dependent on the amount of
-        time taken by the connect timeout. If the connection time has not been
-        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be
-        raised.
-
-        :return: Value to use for the read timeout.
-        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
-        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`
-            has not yet been called on this object.
-        """
-        if (self.total is not None and
-                self.total is not self.DEFAULT_TIMEOUT and
-                self._read is not None and
-                self._read is not self.DEFAULT_TIMEOUT):
-            # In case the connect timeout has not yet been established.
-            if self._start_connect is None:
-                return self._read
-            return max(0, min(self.total - self.get_connect_duration(),
-                              self._read))
-        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:
-            return max(0, self.total - self.get_connect_duration())
-        else:
-            return self._read
+from __future__ import absolute_import
+# The default socket timeout, used by httplib to indicate that no timeout was
+# specified by the user
+from socket import _GLOBAL_DEFAULT_TIMEOUT
+import time
+
+from ..exceptions import TimeoutStateError
+
+# A sentinel value to indicate that no timeout was specified by the user in
+# urllib3
+_Default = object()
+
+
+# Use time.monotonic if available.
+current_time = getattr(time, "monotonic", time.time)
+
+
+class Timeout(object):
+    """ Timeout configuration.
+
+    Timeouts can be defined as a default for a pool::
+
+        timeout = Timeout(connect=2.0, read=7.0)
+        http = PoolManager(timeout=timeout)
+        response = http.request('GET', 'http://example.com/')
+
+    Or per-request (which overrides the default for the pool)::
+
+        response = http.request('GET', 'http://example.com/', timeout=Timeout(10))
+
+    Timeouts can be disabled by setting all the parameters to ``None``::
+
+        no_timeout = Timeout(connect=None, read=None)
+        response = http.request('GET', 'http://example.com/, timeout=no_timeout)
+
+
+    :param total:
+        This combines the connect and read timeouts into one; the read timeout
+        will be set to the time leftover from the connect attempt. In the
+        event that both a connect timeout and a total are specified, or a read
+        timeout and a total are specified, the shorter timeout will be applied.
+
+        Defaults to None.
+
+    :type total: integer, float, or None
+
+    :param connect:
+        The maximum amount of time to wait for a connection attempt to a server
+        to succeed. Omitting the parameter will default the connect timeout to
+        the system default, probably `the global default timeout in socket.py
+        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
+        None will set an infinite timeout for connection attempts.
+
+    :type connect: integer, float, or None
+
+    :param read:
+        The maximum amount of time to wait between consecutive
+        read operations for a response from the server. Omitting
+        the parameter will default the read timeout to the system
+        default, probably `the global default timeout in socket.py
+        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
+        None will set an infinite timeout.
+
+    :type read: integer, float, or None
+
+    .. note::
+
+        Many factors can affect the total amount of time for urllib3 to return
+        an HTTP response.
+
+        For example, Python's DNS resolver does not obey the timeout specified
+        on the socket. Other factors that can affect total request time include
+        high CPU load, high swap, the program running at a low priority level,
+        or other behaviors.
+
+        In addition, the read and total timeouts only measure the time between
+        read operations on the socket connecting the client and the server,
+        not the total amount of time for the request to return a complete
+        response. For most requests, the timeout is raised because the server
+        has not sent the first byte in the specified time. This is not always
+        the case; if a server streams one byte every fifteen seconds, a timeout
+        of 20 seconds will not trigger, even though the request will take
+        several minutes to complete.
+
+        If your goal is to cut off any request after a set amount of wall clock
+        time, consider having a second "watcher" thread to cut off a slow
+        request.
+    """
+
+    #: A sentinel object representing the default timeout value
+    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT
+
+    def __init__(self, total=None, connect=_Default, read=_Default):
+        self._connect = self._validate_timeout(connect, 'connect')
+        self._read = self._validate_timeout(read, 'read')
+        self.total = self._validate_timeout(total, 'total')
+        self._start_connect = None
+
+    def __str__(self):
+        return '%s(connect=%r, read=%r, total=%r)' % (
+            type(self).__name__, self._connect, self._read, self.total)
+
+    @classmethod
+    def _validate_timeout(cls, value, name):
+        """ Check that a timeout attribute is valid.
+
+        :param value: The timeout value to validate
+        :param name: The name of the timeout attribute to validate. This is
+            used to specify in error messages.
+        :return: The validated and casted version of the given value.
+        :raises ValueError: If it is a numeric value less than or equal to
+            zero, or the type is not an integer, float, or None.
+        """
+        if value is _Default:
+            return cls.DEFAULT_TIMEOUT
+
+        if value is None or value is cls.DEFAULT_TIMEOUT:
+            return value
+
+        if isinstance(value, bool):
+            raise ValueError("Timeout cannot be a boolean value. It must "
+                             "be an int, float or None.")
+        try:
+            float(value)
+        except (TypeError, ValueError):
+            raise ValueError("Timeout value %s was %s, but it must be an "
+                             "int, float or None." % (name, value))
+
+        try:
+            if value <= 0:
+                raise ValueError("Attempted to set %s timeout to %s, but the "
+                                 "timeout cannot be set to a value less "
+                                 "than or equal to 0." % (name, value))
+        except TypeError:  # Python 3
+            raise ValueError("Timeout value %s was %s, but it must be an "
+                             "int, float or None." % (name, value))
+
+        return value
+
+    @classmethod
+    def from_float(cls, timeout):
+        """ Create a new Timeout from a legacy timeout value.
+
+        The timeout value used by httplib.py sets the same timeout on the
+        connect(), and recv() socket requests. This creates a :class:`Timeout`
+        object that sets the individual timeouts to the ``timeout`` value
+        passed to this function.
+
+        :param timeout: The legacy timeout value.
+        :type timeout: integer, float, sentinel default object, or None
+        :return: Timeout object
+        :rtype: :class:`Timeout`
+        """
+        return Timeout(read=timeout, connect=timeout)
+
+    def clone(self):
+        """ Create a copy of the timeout object
+
+        Timeout properties are stored per-pool but each request needs a fresh
+        Timeout object to ensure each one has its own start/stop configured.
+
+        :return: a copy of the timeout object
+        :rtype: :class:`Timeout`
+        """
+        # We can't use copy.deepcopy because that will also create a new object
+        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to
+        # detect the user default.
+        return Timeout(connect=self._connect, read=self._read,
+                       total=self.total)
+
+    def start_connect(self):
+        """ Start the timeout clock, used during a connect() attempt
+
+        :raises urllib3.exceptions.TimeoutStateError: if you attempt
+            to start a timer that has been started already.
+        """
+        if self._start_connect is not None:
+            raise TimeoutStateError("Timeout timer has already been started.")
+        self._start_connect = current_time()
+        return self._start_connect
+
+    def get_connect_duration(self):
+        """ Gets the time elapsed since the call to :meth:`start_connect`.
+
+        :return: Elapsed time.
+        :rtype: float
+        :raises urllib3.exceptions.TimeoutStateError: if you attempt
+            to get duration for a timer that hasn't been started.
+        """
+        if self._start_connect is None:
+            raise TimeoutStateError("Can't get connect duration for timer "
+                                    "that has not started.")
+        return current_time() - self._start_connect
+
+    @property
+    def connect_timeout(self):
+        """ Get the value to use when setting a connection timeout.
+
+        This will be a positive float or integer, the value None
+        (never timeout), or the default system timeout.
+
+        :return: Connect timeout.
+        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
+        """
+        if self.total is None:
+            return self._connect
+
+        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:
+            return self.total
+
+        return min(self._connect, self.total)
+
+    @property
+    def read_timeout(self):
+        """ Get the value for the read timeout.
+
+        This assumes some time has elapsed in the connection timeout and
+        computes the read timeout appropriately.
+
+        If self.total is set, the read timeout is dependent on the amount of
+        time taken by the connect timeout. If the connection time has not been
+        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be
+        raised.
+
+        :return: Value to use for the read timeout.
+        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
+        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`
+            has not yet been called on this object.
+        """
+        if (self.total is not None and
+                self.total is not self.DEFAULT_TIMEOUT and
+                self._read is not None and
+                self._read is not self.DEFAULT_TIMEOUT):
+            # In case the connect timeout has not yet been established.
+            if self._start_connect is None:
+                return self._read
+            return max(0, min(self.total - self.get_connect_duration(),
+                              self._read))
+        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:
+            return max(0, self.total - self.get_connect_duration())
+        else:
+            return self._read
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/url.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/url.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,226 +1,226 @@
-from __future__ import absolute_import
-from collections import namedtuple
-
-from ..exceptions import LocationParseError
-
-
-url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']
-
-
-class Url(namedtuple('Url', url_attrs)):
-    """
-    Datastructure for representing an HTTP URL. Used as a return value for
-    :func:`parse_url`. Both the scheme and host are normalized as they are
-    both case-insensitive according to RFC 3986.
-    """
-    __slots__ = ()
-
-    def __new__(cls, scheme=None, auth=None, host=None, port=None, path=None,
-                query=None, fragment=None):
-        if path and not path.startswith('/'):
-            path = '/' + path
-        if scheme:
-            scheme = scheme.lower()
-        if host:
-            host = host.lower()
-        return super(Url, cls).__new__(cls, scheme, auth, host, port, path,
-                                       query, fragment)
-
-    @property
-    def hostname(self):
-        """For backwards-compatibility with urlparse. We're nice like that."""
-        return self.host
-
-    @property
-    def request_uri(self):
-        """Absolute path including the query string."""
-        uri = self.path or '/'
-
-        if self.query is not None:
-            uri += '?' + self.query
-
-        return uri
-
-    @property
-    def netloc(self):
-        """Network location including host and port"""
-        if self.port:
-            return '%s:%d' % (self.host, self.port)
-        return self.host
-
-    @property
-    def url(self):
-        """
-        Convert self into a url
-
-        This function should more or less round-trip with :func:`.parse_url`. The
-        returned url may not be exactly the same as the url inputted to
-        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls
-        with a blank port will have : removed).
-
-        Example: ::
-
-            >>> U = parse_url('http://google.com/mail/')
-            >>> U.url
-            'http://google.com/mail/'
-            >>> Url('http', 'username:password', 'host.com', 80,
-            ... '/path', 'query', 'fragment').url
-            'http://username:password@host.com:80/path?query#fragment'
-        """
-        scheme, auth, host, port, path, query, fragment = self
-        url = ''
-
-        # We use "is not None" we want things to happen with empty strings (or 0 port)
-        if scheme is not None:
-            url += scheme + '://'
-        if auth is not None:
-            url += auth + '@'
-        if host is not None:
-            url += host
-        if port is not None:
-            url += ':' + str(port)
-        if path is not None:
-            url += path
-        if query is not None:
-            url += '?' + query
-        if fragment is not None:
-            url += '#' + fragment
-
-        return url
-
-    def __str__(self):
-        return self.url
-
-
-def split_first(s, delims):
-    """
-    Given a string and an iterable of delimiters, split on the first found
-    delimiter. Return two split parts and the matched delimiter.
-
-    If not found, then the first part is the full input string.
-
-    Example::
-
-        >>> split_first('foo/bar?baz', '?/=')
-        ('foo', 'bar?baz', '/')
-        >>> split_first('foo/bar?baz', '123')
-        ('foo/bar?baz', '', None)
-
-    Scales linearly with number of delims. Not ideal for large number of delims.
-    """
-    min_idx = None
-    min_delim = None
-    for d in delims:
-        idx = s.find(d)
-        if idx < 0:
-            continue
-
-        if min_idx is None or idx < min_idx:
-            min_idx = idx
-            min_delim = d
-
-    if min_idx is None or min_idx < 0:
-        return s, '', None
-
-    return s[:min_idx], s[min_idx + 1:], min_delim
-
-
-def parse_url(url):
-    """
-    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is
-    performed to parse incomplete urls. Fields not provided will be None.
-
-    Partly backwards-compatible with :mod:`urlparse`.
-
-    Example::
-
-        >>> parse_url('http://google.com/mail/')
-        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)
-        >>> parse_url('google.com:80')
-        Url(scheme=None, host='google.com', port=80, path=None, ...)
-        >>> parse_url('/foo?bar')
-        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)
-    """
-
-    # While this code has overlap with stdlib's urlparse, it is much
-    # simplified for our needs and less annoying.
-    # Additionally, this implementations does silly things to be optimal
-    # on CPython.
-
-    if not url:
-        # Empty
-        return Url()
-
-    scheme = None
-    auth = None
-    host = None
-    port = None
-    path = None
-    fragment = None
-    query = None
-
-    # Scheme
-    if '://' in url:
-        scheme, url = url.split('://', 1)
-
-    # Find the earliest Authority Terminator
-    # (http://tools.ietf.org/html/rfc3986#section-3.2)
-    url, path_, delim = split_first(url, ['/', '?', '#'])
-
-    if delim:
-        # Reassemble the path
-        path = delim + path_
-
-    # Auth
-    if '@' in url:
-        # Last '@' denotes end of auth part
-        auth, url = url.rsplit('@', 1)
-
-    # IPv6
-    if url and url[0] == '[':
-        host, url = url.split(']', 1)
-        host += ']'
-
-    # Port
-    if ':' in url:
-        _host, port = url.split(':', 1)
-
-        if not host:
-            host = _host
-
-        if port:
-            # If given, ports must be integers. No whitespace, no plus or
-            # minus prefixes, no non-integer digits such as ^2 (superscript).
-            if not port.isdigit():
-                raise LocationParseError(url)
-            try:
-                port = int(port)
-            except ValueError:
-                raise LocationParseError(url)
-        else:
-            # Blank ports are cool, too. (rfc3986#section-3.2.3)
-            port = None
-
-    elif not host and url:
-        host = url
-
-    if not path:
-        return Url(scheme, auth, host, port, path, query, fragment)
-
-    # Fragment
-    if '#' in path:
-        path, fragment = path.split('#', 1)
-
-    # Query
-    if '?' in path:
-        path, query = path.split('?', 1)
-
-    return Url(scheme, auth, host, port, path, query, fragment)
-
-
-def get_host(url):
-    """
-    Deprecated. Use :func:`parse_url` instead.
-    """
-    p = parse_url(url)
-    return p.scheme or 'http', p.hostname, p.port
+from __future__ import absolute_import
+from collections import namedtuple
+
+from ..exceptions import LocationParseError
+
+
+url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']
+
+
+class Url(namedtuple('Url', url_attrs)):
+    """
+    Datastructure for representing an HTTP URL. Used as a return value for
+    :func:`parse_url`. Both the scheme and host are normalized as they are
+    both case-insensitive according to RFC 3986.
+    """
+    __slots__ = ()
+
+    def __new__(cls, scheme=None, auth=None, host=None, port=None, path=None,
+                query=None, fragment=None):
+        if path and not path.startswith('/'):
+            path = '/' + path
+        if scheme:
+            scheme = scheme.lower()
+        if host:
+            host = host.lower()
+        return super(Url, cls).__new__(cls, scheme, auth, host, port, path,
+                                       query, fragment)
+
+    @property
+    def hostname(self):
+        """For backwards-compatibility with urlparse. We're nice like that."""
+        return self.host
+
+    @property
+    def request_uri(self):
+        """Absolute path including the query string."""
+        uri = self.path or '/'
+
+        if self.query is not None:
+            uri += '?' + self.query
+
+        return uri
+
+    @property
+    def netloc(self):
+        """Network location including host and port"""
+        if self.port:
+            return '%s:%d' % (self.host, self.port)
+        return self.host
+
+    @property
+    def url(self):
+        """
+        Convert self into a url
+
+        This function should more or less round-trip with :func:`.parse_url`. The
+        returned url may not be exactly the same as the url inputted to
+        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls
+        with a blank port will have : removed).
+
+        Example: ::
+
+            >>> U = parse_url('http://google.com/mail/')
+            >>> U.url
+            'http://google.com/mail/'
+            >>> Url('http', 'username:password', 'host.com', 80,
+            ... '/path', 'query', 'fragment').url
+            'http://username:password@host.com:80/path?query#fragment'
+        """
+        scheme, auth, host, port, path, query, fragment = self
+        url = ''
+
+        # We use "is not None" we want things to happen with empty strings (or 0 port)
+        if scheme is not None:
+            url += scheme + '://'
+        if auth is not None:
+            url += auth + '@'
+        if host is not None:
+            url += host
+        if port is not None:
+            url += ':' + str(port)
+        if path is not None:
+            url += path
+        if query is not None:
+            url += '?' + query
+        if fragment is not None:
+            url += '#' + fragment
+
+        return url
+
+    def __str__(self):
+        return self.url
+
+
+def split_first(s, delims):
+    """
+    Given a string and an iterable of delimiters, split on the first found
+    delimiter. Return two split parts and the matched delimiter.
+
+    If not found, then the first part is the full input string.
+
+    Example::
+
+        >>> split_first('foo/bar?baz', '?/=')
+        ('foo', 'bar?baz', '/')
+        >>> split_first('foo/bar?baz', '123')
+        ('foo/bar?baz', '', None)
+
+    Scales linearly with number of delims. Not ideal for large number of delims.
+    """
+    min_idx = None
+    min_delim = None
+    for d in delims:
+        idx = s.find(d)
+        if idx < 0:
+            continue
+
+        if min_idx is None or idx < min_idx:
+            min_idx = idx
+            min_delim = d
+
+    if min_idx is None or min_idx < 0:
+        return s, '', None
+
+    return s[:min_idx], s[min_idx + 1:], min_delim
+
+
+def parse_url(url):
+    """
+    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is
+    performed to parse incomplete urls. Fields not provided will be None.
+
+    Partly backwards-compatible with :mod:`urlparse`.
+
+    Example::
+
+        >>> parse_url('http://google.com/mail/')
+        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)
+        >>> parse_url('google.com:80')
+        Url(scheme=None, host='google.com', port=80, path=None, ...)
+        >>> parse_url('/foo?bar')
+        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)
+    """
+
+    # While this code has overlap with stdlib's urlparse, it is much
+    # simplified for our needs and less annoying.
+    # Additionally, this implementations does silly things to be optimal
+    # on CPython.
+
+    if not url:
+        # Empty
+        return Url()
+
+    scheme = None
+    auth = None
+    host = None
+    port = None
+    path = None
+    fragment = None
+    query = None
+
+    # Scheme
+    if '://' in url:
+        scheme, url = url.split('://', 1)
+
+    # Find the earliest Authority Terminator
+    # (http://tools.ietf.org/html/rfc3986#section-3.2)
+    url, path_, delim = split_first(url, ['/', '?', '#'])
+
+    if delim:
+        # Reassemble the path
+        path = delim + path_
+
+    # Auth
+    if '@' in url:
+        # Last '@' denotes end of auth part
+        auth, url = url.rsplit('@', 1)
+
+    # IPv6
+    if url and url[0] == '[':
+        host, url = url.split(']', 1)
+        host += ']'
+
+    # Port
+    if ':' in url:
+        _host, port = url.split(':', 1)
+
+        if not host:
+            host = _host
+
+        if port:
+            # If given, ports must be integers. No whitespace, no plus or
+            # minus prefixes, no non-integer digits such as ^2 (superscript).
+            if not port.isdigit():
+                raise LocationParseError(url)
+            try:
+                port = int(port)
+            except ValueError:
+                raise LocationParseError(url)
+        else:
+            # Blank ports are cool, too. (rfc3986#section-3.2.3)
+            port = None
+
+    elif not host and url:
+        host = url
+
+    if not path:
+        return Url(scheme, auth, host, port, path, query, fragment)
+
+    # Fragment
+    if '#' in path:
+        path, fragment = path.split('#', 1)
+
+    # Query
+    if '?' in path:
+        path, query = path.split('?', 1)
+
+    return Url(scheme, auth, host, port, path, query, fragment)
+
+
+def get_host(url):
+    """
+    Deprecated. Use :func:`parse_url` instead.
+    """
+    p = parse_url(url)
+    return p.scheme or 'http', p.hostname, p.port
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/util/wait.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/util/wait.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-from .selectors import (
-    HAS_SELECT,
-    DefaultSelector,
-    EVENT_READ,
-    EVENT_WRITE
-)
-
-
-def _wait_for_io_events(socks, events, timeout=None):
-    """ Waits for IO events to be available from a list of sockets
-    or optionally a single socket if passed in. Returns a list of
-    sockets that can be interacted with immediately. """
-    if not HAS_SELECT:
-        raise ValueError('Platform does not have a selector')
-    if not isinstance(socks, list):
-        # Probably just a single socket.
-        if hasattr(socks, "fileno"):
-            socks = [socks]
-        # Otherwise it might be a non-list iterable.
-        else:
-            socks = list(socks)
-    with DefaultSelector() as selector:
-        for sock in socks:
-            selector.register(sock, events)
-        return [key[0].fileobj for key in
-                selector.select(timeout) if key[1] & events]
-
-
-def wait_for_read(socks, timeout=None):
-    """ Waits for reading to be available from a list of sockets
-    or optionally a single socket if passed in. Returns a list of
-    sockets that can be read from immediately. """
-    return _wait_for_io_events(socks, EVENT_READ, timeout)
-
-
-def wait_for_write(socks, timeout=None):
-    """ Waits for writing to be available from a list of sockets
-    or optionally a single socket if passed in. Returns a list of
-    sockets that can be written to immediately. """
-    return _wait_for_io_events(socks, EVENT_WRITE, timeout)
+from .selectors import (
+    HAS_SELECT,
+    DefaultSelector,
+    EVENT_READ,
+    EVENT_WRITE
+)
+
+
+def _wait_for_io_events(socks, events, timeout=None):
+    """ Waits for IO events to be available from a list of sockets
+    or optionally a single socket if passed in. Returns a list of
+    sockets that can be interacted with immediately. """
+    if not HAS_SELECT:
+        raise ValueError('Platform does not have a selector')
+    if not isinstance(socks, list):
+        # Probably just a single socket.
+        if hasattr(socks, "fileno"):
+            socks = [socks]
+        # Otherwise it might be a non-list iterable.
+        else:
+            socks = list(socks)
+    with DefaultSelector() as selector:
+        for sock in socks:
+            selector.register(sock, events)
+        return [key[0].fileobj for key in
+                selector.select(timeout) if key[1] & events]
+
+
+def wait_for_read(socks, timeout=None):
+    """ Waits for reading to be available from a list of sockets
+    or optionally a single socket if passed in. Returns a list of
+    sockets that can be read from immediately. """
+    return _wait_for_io_events(socks, EVENT_READ, timeout)
+
+
+def wait_for_write(socks, timeout=None):
+    """ Waits for writing to be available from a list of sockets
+    or optionally a single socket if passed in. Returns a list of
+    sockets that can be written to immediately. """
+    return _wait_for_io_events(socks, EVENT_WRITE, timeout)
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/_collections.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/_collections.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,324 +1,324 @@
-from __future__ import absolute_import
-from collections import Mapping, MutableMapping
-try:
-    from threading import RLock
-except ImportError:  # Platform-specific: No threads available
-    class RLock:
-        def __enter__(self):
-            pass
-
-        def __exit__(self, exc_type, exc_value, traceback):
-            pass
-
-
-try:  # Python 2.7+
-    from collections import OrderedDict
-except ImportError:
-    from .packages.ordered_dict import OrderedDict
-from .packages.six import iterkeys, itervalues, PY3
-
-
-__all__ = ['RecentlyUsedContainer', 'HTTPHeaderDict']
-
-
-_Null = object()
-
-
-class RecentlyUsedContainer(MutableMapping):
-    """
-    Provides a thread-safe dict-like container which maintains up to
-    ``maxsize`` keys while throwing away the least-recently-used keys beyond
-    ``maxsize``.
-
-    :param maxsize:
-        Maximum number of recent elements to retain.
-
-    :param dispose_func:
-        Every time an item is evicted from the container,
-        ``dispose_func(value)`` is called.  Callback which will get called
-    """
-
-    ContainerCls = OrderedDict
-
-    def __init__(self, maxsize=10, dispose_func=None):
-        self._maxsize = maxsize
-        self.dispose_func = dispose_func
-
-        self._container = self.ContainerCls()
-        self.lock = RLock()
-
-    def __getitem__(self, key):
-        # Re-insert the item, moving it to the end of the eviction line.
-        with self.lock:
-            item = self._container.pop(key)
-            self._container[key] = item
-            return item
-
-    def __setitem__(self, key, value):
-        evicted_value = _Null
-        with self.lock:
-            # Possibly evict the existing value of 'key'
-            evicted_value = self._container.get(key, _Null)
-            self._container[key] = value
-
-            # If we didn't evict an existing value, we might have to evict the
-            # least recently used item from the beginning of the container.
-            if len(self._container) > self._maxsize:
-                _key, evicted_value = self._container.popitem(last=False)
-
-        if self.dispose_func and evicted_value is not _Null:
-            self.dispose_func(evicted_value)
-
-    def __delitem__(self, key):
-        with self.lock:
-            value = self._container.pop(key)
-
-        if self.dispose_func:
-            self.dispose_func(value)
-
-    def __len__(self):
-        with self.lock:
-            return len(self._container)
-
-    def __iter__(self):
-        raise NotImplementedError('Iteration over this class is unlikely to be threadsafe.')
-
-    def clear(self):
-        with self.lock:
-            # Copy pointers to all values, then wipe the mapping
-            values = list(itervalues(self._container))
-            self._container.clear()
-
-        if self.dispose_func:
-            for value in values:
-                self.dispose_func(value)
-
-    def keys(self):
-        with self.lock:
-            return list(iterkeys(self._container))
-
-
-class HTTPHeaderDict(MutableMapping):
-    """
-    :param headers:
-        An iterable of field-value pairs. Must not contain multiple field names
-        when compared case-insensitively.
-
-    :param kwargs:
-        Additional field-value pairs to pass in to ``dict.update``.
-
-    A ``dict`` like container for storing HTTP Headers.
-
-    Field names are stored and compared case-insensitively in compliance with
-    RFC 7230. Iteration provides the first case-sensitive key seen for each
-    case-insensitive pair.
-
-    Using ``__setitem__`` syntax overwrites fields that compare equal
-    case-insensitively in order to maintain ``dict``'s api. For fields that
-    compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``
-    in a loop.
-
-    If multiple fields that are equal case-insensitively are passed to the
-    constructor or ``.update``, the behavior is undefined and some will be
-    lost.
-
-    >>> headers = HTTPHeaderDict()
-    >>> headers.add('Set-Cookie', 'foo=bar')
-    >>> headers.add('set-cookie', 'baz=quxx')
-    >>> headers['content-length'] = '7'
-    >>> headers['SET-cookie']
-    'foo=bar, baz=quxx'
-    >>> headers['Content-Length']
-    '7'
-    """
-
-    def __init__(self, headers=None, **kwargs):
-        super(HTTPHeaderDict, self).__init__()
-        self._container = OrderedDict()
-        if headers is not None:
-            if isinstance(headers, HTTPHeaderDict):
-                self._copy_from(headers)
-            else:
-                self.extend(headers)
-        if kwargs:
-            self.extend(kwargs)
-
-    def __setitem__(self, key, val):
-        self._container[key.lower()] = (key, val)
-        return self._container[key.lower()]
-
-    def __getitem__(self, key):
-        val = self._container[key.lower()]
-        return ', '.join(val[1:])
-
-    def __delitem__(self, key):
-        del self._container[key.lower()]
-
-    def __contains__(self, key):
-        return key.lower() in self._container
-
-    def __eq__(self, other):
-        if not isinstance(other, Mapping) and not hasattr(other, 'keys'):
-            return False
-        if not isinstance(other, type(self)):
-            other = type(self)(other)
-        return (dict((k.lower(), v) for k, v in self.itermerged()) ==
-                dict((k.lower(), v) for k, v in other.itermerged()))
-
-    def __ne__(self, other):
-        return not self.__eq__(other)
-
-    if not PY3:  # Python 2
-        iterkeys = MutableMapping.iterkeys
-        itervalues = MutableMapping.itervalues
-
-    __marker = object()
-
-    def __len__(self):
-        return len(self._container)
-
-    def __iter__(self):
-        # Only provide the originally cased names
-        for vals in self._container.values():
-            yield vals[0]
-
-    def pop(self, key, default=__marker):
-        '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
-          If key is not found, d is returned if given, otherwise KeyError is raised.
-        '''
-        # Using the MutableMapping function directly fails due to the private marker.
-        # Using ordinary dict.pop would expose the internal structures.
-        # So let's reinvent the wheel.
-        try:
-            value = self[key]
-        except KeyError:
-            if default is self.__marker:
-                raise
-            return default
-        else:
-            del self[key]
-            return value
-
-    def discard(self, key):
-        try:
-            del self[key]
-        except KeyError:
-            pass
-
-    def add(self, key, val):
-        """Adds a (name, value) pair, doesn't overwrite the value if it already
-        exists.
-
-        >>> headers = HTTPHeaderDict(foo='bar')
-        >>> headers.add('Foo', 'baz')
-        >>> headers['foo']
-        'bar, baz'
-        """
-        key_lower = key.lower()
-        new_vals = key, val
-        # Keep the common case aka no item present as fast as possible
-        vals = self._container.setdefault(key_lower, new_vals)
-        if new_vals is not vals:
-            # new_vals was not inserted, as there was a previous one
-            if isinstance(vals, list):
-                # If already several items got inserted, we have a list
-                vals.append(val)
-            else:
-                # vals should be a tuple then, i.e. only one item so far
-                # Need to convert the tuple to list for further extension
-                self._container[key_lower] = [vals[0], vals[1], val]
-
-    def extend(self, *args, **kwargs):
-        """Generic import function for any type of header-like object.
-        Adapted version of MutableMapping.update in order to insert items
-        with self.add instead of self.__setitem__
-        """
-        if len(args) > 1:
-            raise TypeError("extend() takes at most 1 positional "
-                            "arguments ({0} given)".format(len(args)))
-        other = args[0] if len(args) >= 1 else ()
-
-        if isinstance(other, HTTPHeaderDict):
-            for key, val in other.iteritems():
-                self.add(key, val)
-        elif isinstance(other, Mapping):
-            for key in other:
-                self.add(key, other[key])
-        elif hasattr(other, "keys"):
-            for key in other.keys():
-                self.add(key, other[key])
-        else:
-            for key, value in other:
-                self.add(key, value)
-
-        for key, value in kwargs.items():
-            self.add(key, value)
-
-    def getlist(self, key):
-        """Returns a list of all the values for the named field. Returns an
-        empty list if the key doesn't exist."""
-        try:
-            vals = self._container[key.lower()]
-        except KeyError:
-            return []
-        else:
-            if isinstance(vals, tuple):
-                return [vals[1]]
-            else:
-                return vals[1:]
-
-    # Backwards compatibility for httplib
-    getheaders = getlist
-    getallmatchingheaders = getlist
-    iget = getlist
-
-    def __repr__(self):
-        return "%s(%s)" % (type(self).__name__, dict(self.itermerged()))
-
-    def _copy_from(self, other):
-        for key in other:
-            val = other.getlist(key)
-            if isinstance(val, list):
-                # Don't need to convert tuples
-                val = list(val)
-            self._container[key.lower()] = [key] + val
-
-    def copy(self):
-        clone = type(self)()
-        clone._copy_from(self)
-        return clone
-
-    def iteritems(self):
-        """Iterate over all header lines, including duplicate ones."""
-        for key in self:
-            vals = self._container[key.lower()]
-            for val in vals[1:]:
-                yield vals[0], val
-
-    def itermerged(self):
-        """Iterate over all headers, merging duplicate ones together."""
-        for key in self:
-            val = self._container[key.lower()]
-            yield val[0], ', '.join(val[1:])
-
-    def items(self):
-        return list(self.iteritems())
-
-    @classmethod
-    def from_httplib(cls, message):  # Python 2
-        """Read headers from a Python 2 httplib message object."""
-        # python2.7 does not expose a proper API for exporting multiheaders
-        # efficiently. This function re-reads raw lines from the message
-        # object and extracts the multiheaders properly.
-        headers = []
-
-        for line in message.headers:
-            if line.startswith((' ', '\t')):
-                key, value = headers[-1]
-                headers[-1] = (key, value + '\r\n' + line.rstrip())
-                continue
-
-            key, value = line.split(':', 1)
-            headers.append((key, value.strip()))
-
-        return cls(headers)
+from __future__ import absolute_import
+from collections import Mapping, MutableMapping
+try:
+    from threading import RLock
+except ImportError:  # Platform-specific: No threads available
+    class RLock:
+        def __enter__(self):
+            pass
+
+        def __exit__(self, exc_type, exc_value, traceback):
+            pass
+
+
+try:  # Python 2.7+
+    from collections import OrderedDict
+except ImportError:
+    from .packages.ordered_dict import OrderedDict
+from .packages.six import iterkeys, itervalues, PY3
+
+
+__all__ = ['RecentlyUsedContainer', 'HTTPHeaderDict']
+
+
+_Null = object()
+
+
+class RecentlyUsedContainer(MutableMapping):
+    """
+    Provides a thread-safe dict-like container which maintains up to
+    ``maxsize`` keys while throwing away the least-recently-used keys beyond
+    ``maxsize``.
+
+    :param maxsize:
+        Maximum number of recent elements to retain.
+
+    :param dispose_func:
+        Every time an item is evicted from the container,
+        ``dispose_func(value)`` is called.  Callback which will get called
+    """
+
+    ContainerCls = OrderedDict
+
+    def __init__(self, maxsize=10, dispose_func=None):
+        self._maxsize = maxsize
+        self.dispose_func = dispose_func
+
+        self._container = self.ContainerCls()
+        self.lock = RLock()
+
+    def __getitem__(self, key):
+        # Re-insert the item, moving it to the end of the eviction line.
+        with self.lock:
+            item = self._container.pop(key)
+            self._container[key] = item
+            return item
+
+    def __setitem__(self, key, value):
+        evicted_value = _Null
+        with self.lock:
+            # Possibly evict the existing value of 'key'
+            evicted_value = self._container.get(key, _Null)
+            self._container[key] = value
+
+            # If we didn't evict an existing value, we might have to evict the
+            # least recently used item from the beginning of the container.
+            if len(self._container) > self._maxsize:
+                _key, evicted_value = self._container.popitem(last=False)
+
+        if self.dispose_func and evicted_value is not _Null:
+            self.dispose_func(evicted_value)
+
+    def __delitem__(self, key):
+        with self.lock:
+            value = self._container.pop(key)
+
+        if self.dispose_func:
+            self.dispose_func(value)
+
+    def __len__(self):
+        with self.lock:
+            return len(self._container)
+
+    def __iter__(self):
+        raise NotImplementedError('Iteration over this class is unlikely to be threadsafe.')
+
+    def clear(self):
+        with self.lock:
+            # Copy pointers to all values, then wipe the mapping
+            values = list(itervalues(self._container))
+            self._container.clear()
+
+        if self.dispose_func:
+            for value in values:
+                self.dispose_func(value)
+
+    def keys(self):
+        with self.lock:
+            return list(iterkeys(self._container))
+
+
+class HTTPHeaderDict(MutableMapping):
+    """
+    :param headers:
+        An iterable of field-value pairs. Must not contain multiple field names
+        when compared case-insensitively.
+
+    :param kwargs:
+        Additional field-value pairs to pass in to ``dict.update``.
+
+    A ``dict`` like container for storing HTTP Headers.
+
+    Field names are stored and compared case-insensitively in compliance with
+    RFC 7230. Iteration provides the first case-sensitive key seen for each
+    case-insensitive pair.
+
+    Using ``__setitem__`` syntax overwrites fields that compare equal
+    case-insensitively in order to maintain ``dict``'s api. For fields that
+    compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``
+    in a loop.
+
+    If multiple fields that are equal case-insensitively are passed to the
+    constructor or ``.update``, the behavior is undefined and some will be
+    lost.
+
+    >>> headers = HTTPHeaderDict()
+    >>> headers.add('Set-Cookie', 'foo=bar')
+    >>> headers.add('set-cookie', 'baz=quxx')
+    >>> headers['content-length'] = '7'
+    >>> headers['SET-cookie']
+    'foo=bar, baz=quxx'
+    >>> headers['Content-Length']
+    '7'
+    """
+
+    def __init__(self, headers=None, **kwargs):
+        super(HTTPHeaderDict, self).__init__()
+        self._container = OrderedDict()
+        if headers is not None:
+            if isinstance(headers, HTTPHeaderDict):
+                self._copy_from(headers)
+            else:
+                self.extend(headers)
+        if kwargs:
+            self.extend(kwargs)
+
+    def __setitem__(self, key, val):
+        self._container[key.lower()] = (key, val)
+        return self._container[key.lower()]
+
+    def __getitem__(self, key):
+        val = self._container[key.lower()]
+        return ', '.join(val[1:])
+
+    def __delitem__(self, key):
+        del self._container[key.lower()]
+
+    def __contains__(self, key):
+        return key.lower() in self._container
+
+    def __eq__(self, other):
+        if not isinstance(other, Mapping) and not hasattr(other, 'keys'):
+            return False
+        if not isinstance(other, type(self)):
+            other = type(self)(other)
+        return (dict((k.lower(), v) for k, v in self.itermerged()) ==
+                dict((k.lower(), v) for k, v in other.itermerged()))
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    if not PY3:  # Python 2
+        iterkeys = MutableMapping.iterkeys
+        itervalues = MutableMapping.itervalues
+
+    __marker = object()
+
+    def __len__(self):
+        return len(self._container)
+
+    def __iter__(self):
+        # Only provide the originally cased names
+        for vals in self._container.values():
+            yield vals[0]
+
+    def pop(self, key, default=__marker):
+        '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
+          If key is not found, d is returned if given, otherwise KeyError is raised.
+        '''
+        # Using the MutableMapping function directly fails due to the private marker.
+        # Using ordinary dict.pop would expose the internal structures.
+        # So let's reinvent the wheel.
+        try:
+            value = self[key]
+        except KeyError:
+            if default is self.__marker:
+                raise
+            return default
+        else:
+            del self[key]
+            return value
+
+    def discard(self, key):
+        try:
+            del self[key]
+        except KeyError:
+            pass
+
+    def add(self, key, val):
+        """Adds a (name, value) pair, doesn't overwrite the value if it already
+        exists.
+
+        >>> headers = HTTPHeaderDict(foo='bar')
+        >>> headers.add('Foo', 'baz')
+        >>> headers['foo']
+        'bar, baz'
+        """
+        key_lower = key.lower()
+        new_vals = key, val
+        # Keep the common case aka no item present as fast as possible
+        vals = self._container.setdefault(key_lower, new_vals)
+        if new_vals is not vals:
+            # new_vals was not inserted, as there was a previous one
+            if isinstance(vals, list):
+                # If already several items got inserted, we have a list
+                vals.append(val)
+            else:
+                # vals should be a tuple then, i.e. only one item so far
+                # Need to convert the tuple to list for further extension
+                self._container[key_lower] = [vals[0], vals[1], val]
+
+    def extend(self, *args, **kwargs):
+        """Generic import function for any type of header-like object.
+        Adapted version of MutableMapping.update in order to insert items
+        with self.add instead of self.__setitem__
+        """
+        if len(args) > 1:
+            raise TypeError("extend() takes at most 1 positional "
+                            "arguments ({0} given)".format(len(args)))
+        other = args[0] if len(args) >= 1 else ()
+
+        if isinstance(other, HTTPHeaderDict):
+            for key, val in other.iteritems():
+                self.add(key, val)
+        elif isinstance(other, Mapping):
+            for key in other:
+                self.add(key, other[key])
+        elif hasattr(other, "keys"):
+            for key in other.keys():
+                self.add(key, other[key])
+        else:
+            for key, value in other:
+                self.add(key, value)
+
+        for key, value in kwargs.items():
+            self.add(key, value)
+
+    def getlist(self, key):
+        """Returns a list of all the values for the named field. Returns an
+        empty list if the key doesn't exist."""
+        try:
+            vals = self._container[key.lower()]
+        except KeyError:
+            return []
+        else:
+            if isinstance(vals, tuple):
+                return [vals[1]]
+            else:
+                return vals[1:]
+
+    # Backwards compatibility for httplib
+    getheaders = getlist
+    getallmatchingheaders = getlist
+    iget = getlist
+
+    def __repr__(self):
+        return "%s(%s)" % (type(self).__name__, dict(self.itermerged()))
+
+    def _copy_from(self, other):
+        for key in other:
+            val = other.getlist(key)
+            if isinstance(val, list):
+                # Don't need to convert tuples
+                val = list(val)
+            self._container[key.lower()] = [key] + val
+
+    def copy(self):
+        clone = type(self)()
+        clone._copy_from(self)
+        return clone
+
+    def iteritems(self):
+        """Iterate over all header lines, including duplicate ones."""
+        for key in self:
+            vals = self._container[key.lower()]
+            for val in vals[1:]:
+                yield vals[0], val
+
+    def itermerged(self):
+        """Iterate over all headers, merging duplicate ones together."""
+        for key in self:
+            val = self._container[key.lower()]
+            yield val[0], ', '.join(val[1:])
+
+    def items(self):
+        return list(self.iteritems())
+
+    @classmethod
+    def from_httplib(cls, message):  # Python 2
+        """Read headers from a Python 2 httplib message object."""
+        # python2.7 does not expose a proper API for exporting multiheaders
+        # efficiently. This function re-reads raw lines from the message
+        # object and extracts the multiheaders properly.
+        headers = []
+
+        for line in message.headers:
+            if line.startswith((' ', '\t')):
+                key, value = headers[-1]
+                headers[-1] = (key, value + '\r\n' + line.rstrip())
+                continue
+
+            key, value = line.split(':', 1)
+            headers.append((key, value.strip()))
+
+        return cls(headers)
```

### Comparing `python-telegram-bot-8.1.1/telegram/vendor/ptb_urllib3/urllib3/__init__.py` & `python-telegram-bot-9.0.0/telegram/vendor/ptb_urllib3/urllib3/__init__.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,96 +1,96 @@
-"""
-urllib3 - Thread-safe connection pooling and re-using.
-"""
-from __future__ import absolute_import
-import warnings
-
-from .connectionpool import (
-    HTTPConnectionPool,
-    HTTPSConnectionPool,
-    connection_from_url
-)
-
-from . import exceptions
-from .filepost import encode_multipart_formdata
-from .poolmanager import PoolManager, ProxyManager, proxy_from_url
-from .response import HTTPResponse
-from .util.request import make_headers
-from .util.url import get_host
-from .util.timeout import Timeout
-from .util.retry import Retry
-
-
-# Set default logging handler to avoid "No handler found" warnings.
-import logging
-try:  # Python 2.7+
-    from logging import NullHandler
-except ImportError:
-    class NullHandler(logging.Handler):
-        def emit(self, record):
-            pass
-
-__author__ = 'Andrey Petrov (andrey.petrov@shazow.net)'
-__license__ = 'MIT'
-__version__ = 'dev'
-
-__all__ = (
-    'HTTPConnectionPool',
-    'HTTPSConnectionPool',
-    'PoolManager',
-    'ProxyManager',
-    'HTTPResponse',
-    'Retry',
-    'Timeout',
-    'add_stderr_logger',
-    'connection_from_url',
-    'disable_warnings',
-    'encode_multipart_formdata',
-    'get_host',
-    'make_headers',
-    'proxy_from_url',
-)
-
-logging.getLogger(__name__).addHandler(NullHandler())
-
-
-def add_stderr_logger(level=logging.DEBUG):
-    """
-    Helper for quickly adding a StreamHandler to the logger. Useful for
-    debugging.
-
-    Returns the handler after adding it.
-    """
-    # This method needs to be in this __init__.py to get the __name__ correct
-    # even if urllib3 is vendored within another package.
-    logger = logging.getLogger(__name__)
-    handler = logging.StreamHandler()
-    handler.setFormatter(logging.Formatter('%(asctime)s %(levelname)s %(message)s'))
-    logger.addHandler(handler)
-    logger.setLevel(level)
-    logger.debug('Added a stderr logging handler to logger: %s', __name__)
-    return handler
-
-
-# ... Clean up.
-del NullHandler
-
-
-# All warning filters *must* be appended unless you're really certain that they
-# shouldn't be: otherwise, it's very hard for users to use most Python
-# mechanisms to silence them.
-# SecurityWarning's always go off by default.
-warnings.simplefilter('always', exceptions.SecurityWarning, append=True)
-# SubjectAltNameWarning's should go off once per host
-warnings.simplefilter('default', exceptions.SubjectAltNameWarning, append=True)
-# InsecurePlatformWarning's don't vary between requests, so we keep it default.
-warnings.simplefilter('default', exceptions.InsecurePlatformWarning,
-                      append=True)
-# SNIMissingWarnings should go off only once.
-warnings.simplefilter('default', exceptions.SNIMissingWarning, append=True)
-
-
-def disable_warnings(category=exceptions.HTTPWarning):
-    """
-    Helper for quickly disabling all urllib3 warnings.
-    """
-    warnings.simplefilter('ignore', category)
+"""
+urllib3 - Thread-safe connection pooling and re-using.
+"""
+from __future__ import absolute_import
+import warnings
+
+from .connectionpool import (
+    HTTPConnectionPool,
+    HTTPSConnectionPool,
+    connection_from_url
+)
+
+from . import exceptions
+from .filepost import encode_multipart_formdata
+from .poolmanager import PoolManager, ProxyManager, proxy_from_url
+from .response import HTTPResponse
+from .util.request import make_headers
+from .util.url import get_host
+from .util.timeout import Timeout
+from .util.retry import Retry
+
+
+# Set default logging handler to avoid "No handler found" warnings.
+import logging
+try:  # Python 2.7+
+    from logging import NullHandler
+except ImportError:
+    class NullHandler(logging.Handler):
+        def emit(self, record):
+            pass
+
+__author__ = 'Andrey Petrov (andrey.petrov@shazow.net)'
+__license__ = 'MIT'
+__version__ = 'dev'
+
+__all__ = (
+    'HTTPConnectionPool',
+    'HTTPSConnectionPool',
+    'PoolManager',
+    'ProxyManager',
+    'HTTPResponse',
+    'Retry',
+    'Timeout',
+    'add_stderr_logger',
+    'connection_from_url',
+    'disable_warnings',
+    'encode_multipart_formdata',
+    'get_host',
+    'make_headers',
+    'proxy_from_url',
+)
+
+logging.getLogger(__name__).addHandler(NullHandler())
+
+
+def add_stderr_logger(level=logging.DEBUG):
+    """
+    Helper for quickly adding a StreamHandler to the logger. Useful for
+    debugging.
+
+    Returns the handler after adding it.
+    """
+    # This method needs to be in this __init__.py to get the __name__ correct
+    # even if urllib3 is vendored within another package.
+    logger = logging.getLogger(__name__)
+    handler = logging.StreamHandler()
+    handler.setFormatter(logging.Formatter('%(asctime)s %(levelname)s %(message)s'))
+    logger.addHandler(handler)
+    logger.setLevel(level)
+    logger.debug('Added a stderr logging handler to logger: %s', __name__)
+    return handler
+
+
+# ... Clean up.
+del NullHandler
+
+
+# All warning filters *must* be appended unless you're really certain that they
+# shouldn't be: otherwise, it's very hard for users to use most Python
+# mechanisms to silence them.
+# SecurityWarning's always go off by default.
+warnings.simplefilter('always', exceptions.SecurityWarning, append=True)
+# SubjectAltNameWarning's should go off once per host
+warnings.simplefilter('default', exceptions.SubjectAltNameWarning, append=True)
+# InsecurePlatformWarning's don't vary between requests, so we keep it default.
+warnings.simplefilter('default', exceptions.InsecurePlatformWarning,
+                      append=True)
+# SNIMissingWarnings should go off only once.
+warnings.simplefilter('default', exceptions.SNIMissingWarning, append=True)
+
+
+def disable_warnings(category=exceptions.HTTPWarning):
+    """
+    Helper for quickly disabling all urllib3 warnings.
+    """
+    warnings.simplefilter('ignore', category)
```

### Comparing `python-telegram-bot-8.1.1/telegram/version.py` & `python-telegram-bot-9.0.0/telegram/version.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-
-__version__ = '8.1.1'
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+
+__version__ = '9.0.0'
```

### Comparing `python-telegram-bot-8.1.1/telegram/webhookinfo.py` & `python-telegram-bot-9.0.0/telegram/webhookinfo.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,79 +1,79 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""This module contains an object that represents a Telegram WebhookInfo."""
-
-from telegram import TelegramObject
-
-
-class WebhookInfo(TelegramObject):
-    """This object represents a Telegram WebhookInfo.
-
-    Contains information about the current status of a webhook.
-
-    Attributes:
-        url (:obj:`str`): Webhook URL.
-        has_custom_certificate (:obj:`bool`): If a custom certificate was provided for webhook.
-        pending_update_count (:obj:`int`): Number of updates awaiting delivery.
-        last_error_date (:obj:`int`): Optional. Unix time for the most recent error that happened.
-        last_error_message (:obj:`str`): Optional. Error message in human-readable format.
-        max_connections (:obj:`int`): Optional. Maximum allowed number of simultaneous HTTPS
-            connections.
-        allowed_updates (List[:obj:`str`]): Optional. A list of update types the bot is subscribed
-            to.
-
-    Args:
-        url (:obj:`str`): Webhook URL, may be empty if webhook is not set up.
-        has_custom_certificate (:obj:`bool`): True, if a custom certificate was provided for
-            webhook certificate checks.
-        pending_update_count (:obj:`int`): Number of updates awaiting delivery.
-        last_error_date (:obj:`int`, optional): Unix time for the most recent error that happened
-            when trying todeliver an update via webhook.
-        last_error_message (:obj:`str`, optional): Error message in human-readable format for the
-            most recent error that happened when trying to deliver an update via webhook.
-        max_connections (:obj:`int`, optional): Maximum allowed number of simultaneous HTTPS
-            connections to the webhook for update delivery.
-        allowed_updates (List[:obj:`str`], optional): A list of update types the bot is subscribed
-            to. Defaults to all update types.
-
-    """
-
-    def __init__(self,
-                 url,
-                 has_custom_certificate,
-                 pending_update_count,
-                 last_error_date=None,
-                 last_error_message=None,
-                 max_connections=None,
-                 allowed_updates=None,
-                 **kwargs):
-        # Required
-        self.url = url
-        self.has_custom_certificate = has_custom_certificate
-        self.pending_update_count = pending_update_count
-        self.last_error_date = last_error_date
-        self.last_error_message = last_error_message
-        self.max_connections = max_connections
-        self.allowed_updates = allowed_updates
-
-    @classmethod
-    def de_json(cls, data, bot):
-        if not data:
-            return None
-
-        return cls(**data)
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""This module contains an object that represents a Telegram WebhookInfo."""
+
+from telegram import TelegramObject
+
+
+class WebhookInfo(TelegramObject):
+    """This object represents a Telegram WebhookInfo.
+
+    Contains information about the current status of a webhook.
+
+    Attributes:
+        url (:obj:`str`): Webhook URL.
+        has_custom_certificate (:obj:`bool`): If a custom certificate was provided for webhook.
+        pending_update_count (:obj:`int`): Number of updates awaiting delivery.
+        last_error_date (:obj:`int`): Optional. Unix time for the most recent error that happened.
+        last_error_message (:obj:`str`): Optional. Error message in human-readable format.
+        max_connections (:obj:`int`): Optional. Maximum allowed number of simultaneous HTTPS
+            connections.
+        allowed_updates (List[:obj:`str`]): Optional. A list of update types the bot is subscribed
+            to.
+
+    Args:
+        url (:obj:`str`): Webhook URL, may be empty if webhook is not set up.
+        has_custom_certificate (:obj:`bool`): True, if a custom certificate was provided for
+            webhook certificate checks.
+        pending_update_count (:obj:`int`): Number of updates awaiting delivery.
+        last_error_date (:obj:`int`, optional): Unix time for the most recent error that happened
+            when trying todeliver an update via webhook.
+        last_error_message (:obj:`str`, optional): Error message in human-readable format for the
+            most recent error that happened when trying to deliver an update via webhook.
+        max_connections (:obj:`int`, optional): Maximum allowed number of simultaneous HTTPS
+            connections to the webhook for update delivery.
+        allowed_updates (List[:obj:`str`], optional): A list of update types the bot is subscribed
+            to. Defaults to all update types.
+
+    """
+
+    def __init__(self,
+                 url,
+                 has_custom_certificate,
+                 pending_update_count,
+                 last_error_date=None,
+                 last_error_message=None,
+                 max_connections=None,
+                 allowed_updates=None,
+                 **kwargs):
+        # Required
+        self.url = url
+        self.has_custom_certificate = has_custom_certificate
+        self.pending_update_count = pending_update_count
+        self.last_error_date = last_error_date
+        self.last_error_message = last_error_message
+        self.max_connections = max_connections
+        self.allowed_updates = allowed_updates
+
+    @classmethod
+    def de_json(cls, data, bot):
+        if not data:
+            return None
+
+        return cls(**data)
```

### Comparing `python-telegram-bot-8.1.1/telegram/__init__.py` & `python-telegram-bot-9.0.0/telegram/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,125 +1,129 @@
-#!/usr/bin/env python
-#
-# A library that provides a Python interface to the Telegram Bot API
-# Copyright (C) 2015-2017
-# Leandro Toledo de Souza <devs@python-telegram-bot.org>
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU Lesser Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU Lesser Public License for more details.
-#
-# You should have received a copy of the GNU Lesser Public License
-# along with this program.  If not, see [http://www.gnu.org/licenses/].
-"""A library that provides a Python interface to the Telegram Bot API"""
-
-from .base import TelegramObject
-from .user import User
-from .files.chatphoto import ChatPhoto
-from .chat import Chat
-from .chatmember import ChatMember
-from .files.photosize import PhotoSize
-from .files.audio import Audio
-from .files.voice import Voice
-from .files.document import Document
-from .files.sticker import Sticker, StickerSet, MaskPosition
-from .files.video import Video
-from .files.contact import Contact
-from .files.location import Location
-from .files.venue import Venue
-from .files.videonote import VideoNote
-from .chataction import ChatAction
-from .userprofilephotos import UserProfilePhotos
-from .keyboardbutton import KeyboardButton
-from .replymarkup import ReplyMarkup
-from .replykeyboardmarkup import ReplyKeyboardMarkup
-from .replykeyboardremove import ReplyKeyboardRemove
-from .forcereply import ForceReply
-from .error import TelegramError
-from .files.inputfile import InputFile
-from .files.file import File
-from .parsemode import ParseMode
-from .messageentity import MessageEntity
-from .games.animation import Animation
-from .games.game import Game
-from .games.callbackgame import CallbackGame
-from .payment.shippingaddress import ShippingAddress
-from .payment.orderinfo import OrderInfo
-from .payment.successfulpayment import SuccessfulPayment
-from .payment.invoice import Invoice
-from .message import Message
-from .callbackquery import CallbackQuery
-from .choseninlineresult import ChosenInlineResult
-from .inline.inlinekeyboardbutton import InlineKeyboardButton
-from .inline.inlinekeyboardmarkup import InlineKeyboardMarkup
-from .inline.inputmessagecontent import InputMessageContent
-from .inline.inlinequery import InlineQuery
-from .inline.inlinequeryresult import InlineQueryResult
-from .inline.inlinequeryresultarticle import InlineQueryResultArticle
-from .inline.inlinequeryresultaudio import InlineQueryResultAudio
-from .inline.inlinequeryresultcachedaudio import InlineQueryResultCachedAudio
-from .inline.inlinequeryresultcacheddocument import InlineQueryResultCachedDocument
-from .inline.inlinequeryresultcachedgif import InlineQueryResultCachedGif
-from .inline.inlinequeryresultcachedmpeg4gif import InlineQueryResultCachedMpeg4Gif
-from .inline.inlinequeryresultcachedphoto import InlineQueryResultCachedPhoto
-from .inline.inlinequeryresultcachedsticker import InlineQueryResultCachedSticker
-from .inline.inlinequeryresultcachedvideo import InlineQueryResultCachedVideo
-from .inline.inlinequeryresultcachedvoice import InlineQueryResultCachedVoice
-from .inline.inlinequeryresultcontact import InlineQueryResultContact
-from .inline.inlinequeryresultdocument import InlineQueryResultDocument
-from .inline.inlinequeryresultgif import InlineQueryResultGif
-from .inline.inlinequeryresultlocation import InlineQueryResultLocation
-from .inline.inlinequeryresultmpeg4gif import InlineQueryResultMpeg4Gif
-from .inline.inlinequeryresultphoto import InlineQueryResultPhoto
-from .inline.inlinequeryresultvenue import InlineQueryResultVenue
-from .inline.inlinequeryresultvideo import InlineQueryResultVideo
-from .inline.inlinequeryresultvoice import InlineQueryResultVoice
-from .inline.inlinequeryresultgame import InlineQueryResultGame
-from .inline.inputtextmessagecontent import InputTextMessageContent
-from .inline.inputlocationmessagecontent import InputLocationMessageContent
-from .inline.inputvenuemessagecontent import InputVenueMessageContent
-from .inline.inputcontactmessagecontent import InputContactMessageContent
-from .payment.labeledprice import LabeledPrice
-from .payment.shippingoption import ShippingOption
-from .payment.precheckoutquery import PreCheckoutQuery
-from .payment.shippingquery import ShippingQuery
-from .webhookinfo import WebhookInfo
-from .games.gamehighscore import GameHighScore
-from .update import Update
-from .bot import Bot
-from .constants import (MAX_MESSAGE_LENGTH, MAX_CAPTION_LENGTH, SUPPORTED_WEBHOOK_PORTS,
-                        MAX_FILESIZE_DOWNLOAD, MAX_FILESIZE_UPLOAD,
-                        MAX_MESSAGES_PER_SECOND_PER_CHAT, MAX_MESSAGES_PER_SECOND,
-                        MAX_MESSAGES_PER_MINUTE_PER_GROUP)
-from .version import __version__  # flake8: noqa
-
-__author__ = 'devs@python-telegram-bot.org'
-
-__all__ = [
-    'Audio', 'Bot', 'Chat', 'ChatMember', 'ChatAction', 'ChosenInlineResult', 'CallbackQuery',
-    'Contact', 'Document', 'File', 'ForceReply', 'InlineKeyboardButton',
-    'InlineKeyboardMarkup', 'InlineQuery', 'InlineQueryResult', 'InlineQueryResult',
-    'InlineQueryResultArticle', 'InlineQueryResultAudio', 'InlineQueryResultCachedAudio',
-    'InlineQueryResultCachedDocument', 'InlineQueryResultCachedGif',
-    'InlineQueryResultCachedMpeg4Gif', 'InlineQueryResultCachedPhoto',
-    'InlineQueryResultCachedSticker', 'InlineQueryResultCachedVideo',
-    'InlineQueryResultCachedVoice', 'InlineQueryResultContact', 'InlineQueryResultDocument',
-    'InlineQueryResultGif', 'InlineQueryResultLocation', 'InlineQueryResultMpeg4Gif',
-    'InlineQueryResultPhoto', 'InlineQueryResultVenue', 'InlineQueryResultVideo',
-    'InlineQueryResultVoice', 'InlineQueryResultGame', 'InputContactMessageContent', 'InputFile',
-    'InputLocationMessageContent', 'InputMessageContent', 'InputTextMessageContent',
-    'InputVenueMessageContent', 'KeyboardButton', 'Location', 'Message', 'MessageEntity',
-    'ParseMode', 'PhotoSize', 'ReplyKeyboardRemove', 'ReplyKeyboardMarkup', 'ReplyMarkup',
-    'Sticker', 'TelegramError', 'TelegramObject', 'Update', 'User', 'UserProfilePhotos', 'Venue',
-    'Video', 'Voice', 'MAX_MESSAGE_LENGTH', 'MAX_CAPTION_LENGTH', 'SUPPORTED_WEBHOOK_PORTS',
-    'MAX_FILESIZE_DOWNLOAD', 'MAX_FILESIZE_UPLOAD', 'MAX_MESSAGES_PER_SECOND_PER_CHAT',
-    'MAX_MESSAGES_PER_SECOND', 'MAX_MESSAGES_PER_MINUTE_PER_GROUP', 'WebhookInfo', 'Animation',
-    'Game', 'GameHighScore', 'VideoNote', 'LabeledPrice', 'SuccessfulPayment', 'ShippingOption',
-    'ShippingAddress', 'PreCheckoutQuery', 'OrderInfo', 'Invoice', 'ShippingQuery', 'ChatPhoto',
-    'StickerSet', 'MaskPosition', 'CallbackGame'
-]
+#!/usr/bin/env python
+#
+# A library that provides a Python interface to the Telegram Bot API
+# Copyright (C) 2015-2017
+# Leandro Toledo de Souza <devs@python-telegram-bot.org>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser Public License for more details.
+#
+# You should have received a copy of the GNU Lesser Public License
+# along with this program.  If not, see [http://www.gnu.org/licenses/].
+"""A library that provides a Python interface to the Telegram Bot API"""
+
+from .base import TelegramObject
+from .user import User
+from .files.chatphoto import ChatPhoto
+from .chat import Chat
+from .chatmember import ChatMember
+from .files.photosize import PhotoSize
+from .files.audio import Audio
+from .files.voice import Voice
+from .files.document import Document
+from .files.sticker import Sticker, StickerSet, MaskPosition
+from .files.video import Video
+from .files.contact import Contact
+from .files.location import Location
+from .files.venue import Venue
+from .files.videonote import VideoNote
+from .chataction import ChatAction
+from .userprofilephotos import UserProfilePhotos
+from .keyboardbutton import KeyboardButton
+from .replymarkup import ReplyMarkup
+from .replykeyboardmarkup import ReplyKeyboardMarkup
+from .replykeyboardremove import ReplyKeyboardRemove
+from .forcereply import ForceReply
+from .error import TelegramError
+from .files.inputfile import InputFile
+from .files.file import File
+from .parsemode import ParseMode
+from .messageentity import MessageEntity
+from .games.animation import Animation
+from .games.game import Game
+from .games.callbackgame import CallbackGame
+from .payment.shippingaddress import ShippingAddress
+from .payment.orderinfo import OrderInfo
+from .payment.successfulpayment import SuccessfulPayment
+from .payment.invoice import Invoice
+from .message import Message
+from .callbackquery import CallbackQuery
+from .choseninlineresult import ChosenInlineResult
+from .inline.inlinekeyboardbutton import InlineKeyboardButton
+from .inline.inlinekeyboardmarkup import InlineKeyboardMarkup
+from .inline.inputmessagecontent import InputMessageContent
+from .inline.inlinequery import InlineQuery
+from .inline.inlinequeryresult import InlineQueryResult
+from .inline.inlinequeryresultarticle import InlineQueryResultArticle
+from .inline.inlinequeryresultaudio import InlineQueryResultAudio
+from .inline.inlinequeryresultcachedaudio import InlineQueryResultCachedAudio
+from .inline.inlinequeryresultcacheddocument import InlineQueryResultCachedDocument
+from .inline.inlinequeryresultcachedgif import InlineQueryResultCachedGif
+from .inline.inlinequeryresultcachedmpeg4gif import InlineQueryResultCachedMpeg4Gif
+from .inline.inlinequeryresultcachedphoto import InlineQueryResultCachedPhoto
+from .inline.inlinequeryresultcachedsticker import InlineQueryResultCachedSticker
+from .inline.inlinequeryresultcachedvideo import InlineQueryResultCachedVideo
+from .inline.inlinequeryresultcachedvoice import InlineQueryResultCachedVoice
+from .inline.inlinequeryresultcontact import InlineQueryResultContact
+from .inline.inlinequeryresultdocument import InlineQueryResultDocument
+from .inline.inlinequeryresultgif import InlineQueryResultGif
+from .inline.inlinequeryresultlocation import InlineQueryResultLocation
+from .inline.inlinequeryresultmpeg4gif import InlineQueryResultMpeg4Gif
+from .inline.inlinequeryresultphoto import InlineQueryResultPhoto
+from .inline.inlinequeryresultvenue import InlineQueryResultVenue
+from .inline.inlinequeryresultvideo import InlineQueryResultVideo
+from .inline.inlinequeryresultvoice import InlineQueryResultVoice
+from .inline.inlinequeryresultgame import InlineQueryResultGame
+from .inline.inputtextmessagecontent import InputTextMessageContent
+from .inline.inputlocationmessagecontent import InputLocationMessageContent
+from .inline.inputvenuemessagecontent import InputVenueMessageContent
+from .inline.inputcontactmessagecontent import InputContactMessageContent
+from .payment.labeledprice import LabeledPrice
+from .payment.shippingoption import ShippingOption
+from .payment.precheckoutquery import PreCheckoutQuery
+from .payment.shippingquery import ShippingQuery
+from .webhookinfo import WebhookInfo
+from .games.gamehighscore import GameHighScore
+from .update import Update
+from .bot import Bot
+from .constants import (MAX_MESSAGE_LENGTH, MAX_CAPTION_LENGTH, SUPPORTED_WEBHOOK_PORTS,
+                        MAX_FILESIZE_DOWNLOAD, MAX_FILESIZE_UPLOAD,
+                        MAX_MESSAGES_PER_SECOND_PER_CHAT, MAX_MESSAGES_PER_SECOND,
+                        MAX_MESSAGES_PER_MINUTE_PER_GROUP)
+from .files.inputmedia import InputMedia
+from .files.inputmediavideo import InputMediaVideo
+from .files.inputmediaphoto import InputMediaPhoto
+from .version import __version__  # flake8: noqa
+
+__author__ = 'devs@python-telegram-bot.org'
+
+__all__ = [
+    'Audio', 'Bot', 'Chat', 'ChatMember', 'ChatAction', 'ChosenInlineResult', 'CallbackQuery',
+    'Contact', 'Document', 'File', 'ForceReply', 'InlineKeyboardButton',
+    'InlineKeyboardMarkup', 'InlineQuery', 'InlineQueryResult', 'InlineQueryResult',
+    'InlineQueryResultArticle', 'InlineQueryResultAudio', 'InlineQueryResultCachedAudio',
+    'InlineQueryResultCachedDocument', 'InlineQueryResultCachedGif',
+    'InlineQueryResultCachedMpeg4Gif', 'InlineQueryResultCachedPhoto',
+    'InlineQueryResultCachedSticker', 'InlineQueryResultCachedVideo',
+    'InlineQueryResultCachedVoice', 'InlineQueryResultContact', 'InlineQueryResultDocument',
+    'InlineQueryResultGif', 'InlineQueryResultLocation', 'InlineQueryResultMpeg4Gif',
+    'InlineQueryResultPhoto', 'InlineQueryResultVenue', 'InlineQueryResultVideo',
+    'InlineQueryResultVoice', 'InlineQueryResultGame', 'InputContactMessageContent', 'InputFile',
+    'InputLocationMessageContent', 'InputMessageContent', 'InputTextMessageContent',
+    'InputVenueMessageContent', 'KeyboardButton', 'Location', 'Message', 'MessageEntity',
+    'ParseMode', 'PhotoSize', 'ReplyKeyboardRemove', 'ReplyKeyboardMarkup', 'ReplyMarkup',
+    'Sticker', 'TelegramError', 'TelegramObject', 'Update', 'User', 'UserProfilePhotos', 'Venue',
+    'Video', 'Voice', 'MAX_MESSAGE_LENGTH', 'MAX_CAPTION_LENGTH', 'SUPPORTED_WEBHOOK_PORTS',
+    'MAX_FILESIZE_DOWNLOAD', 'MAX_FILESIZE_UPLOAD', 'MAX_MESSAGES_PER_SECOND_PER_CHAT',
+    'MAX_MESSAGES_PER_SECOND', 'MAX_MESSAGES_PER_MINUTE_PER_GROUP', 'WebhookInfo', 'Animation',
+    'Game', 'GameHighScore', 'VideoNote', 'LabeledPrice', 'SuccessfulPayment', 'ShippingOption',
+    'ShippingAddress', 'PreCheckoutQuery', 'OrderInfo', 'Invoice', 'ShippingQuery', 'ChatPhoto',
+    'StickerSet', 'MaskPosition', 'CallbackGame', 'InputMedia', 'InputMediaPhoto',
+    'InputMediaVideo'
+]
```

