# Comparing `tmp/switchboard_hw-0.2.1-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/switchboard_hw-0.2.2-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,90 +1,100 @@
-Zip file size: 328505 bytes, number of entries: 88
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard_hw.libs/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard_hw-0.2.1.dist-info/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/
--rwxr-xr-x  2.0 unx   603792 b- defN 24-May-11 00:53 _switchboard.cpython-39-x86_64-linux-gnu.so
--rw-r--r--  2.0 unx    10766 b- defN 24-May-11 00:53 switchboard_hw-0.2.1.dist-info/LICENSE
--rw-r--r--  2.0 unx    18115 b- defN 24-May-11 00:53 switchboard_hw-0.2.1.dist-info/METADATA
--rw-rw-r--  2.0 unx     6780 b- defN 24-May-11 00:53 switchboard_hw-0.2.1.dist-info/RECORD
--rw-r--r--  2.0 unx       25 b- defN 24-May-11 00:53 switchboard_hw-0.2.1.dist-info/top_level.txt
--rw-r--r--  2.0 unx       92 b- defN 24-May-11 00:53 switchboard_hw-0.2.1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx      148 b- defN 24-May-11 00:53 switchboard_hw-0.2.1.dist-info/WHEEL
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/verilog/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/dpi/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/verilator/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/vpi/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/cpp/
--rw-r--r--  2.0 unx     2088 b- defN 24-May-11 00:53 switchboard/icarus.py
--rw-r--r--  2.0 unx    25257 b- defN 24-May-11 00:53 switchboard/sbdut.py
--rw-r--r--  2.0 unx     2706 b- defN 24-May-11 00:53 switchboard/gpio.py
--rw-r--r--  2.0 unx    26939 b- defN 24-May-11 00:53 switchboard/umi.py
--rw-r--r--  2.0 unx     1701 b- defN 24-May-11 00:53 switchboard/uart_xactor.py
--rw-r--r--  2.0 unx     1506 b- defN 24-May-11 00:53 switchboard/switchboard.py
--rw-r--r--  2.0 unx     1311 b- defN 24-May-11 00:53 switchboard/test_util.py
--rw-r--r--  2.0 unx     4902 b- defN 24-May-11 00:53 switchboard/cmdline.py
--rw-r--r--  2.0 unx    17506 b- defN 24-May-11 00:53 switchboard/autowrap.py
--rw-r--r--  2.0 unx     7465 b- defN 24-May-11 00:53 switchboard/network.py
--rw-r--r--  2.0 unx     8247 b- defN 24-May-11 00:53 switchboard/sbtcp.py
--rw-r--r--  2.0 unx    12870 b- defN 24-May-11 00:53 switchboard/axil.py
--rw-r--r--  2.0 unx      941 b- defN 24-May-11 00:53 switchboard/__init__.py
--rw-r--r--  2.0 unx    18067 b- defN 24-May-11 00:53 switchboard/ams.py
--rw-r--r--  2.0 unx     5246 b- defN 24-May-11 00:53 switchboard/loopback.py
--rw-r--r--  2.0 unx      311 b- defN 24-May-11 00:53 switchboard/warn.py
--rw-r--r--  2.0 unx     3398 b- defN 24-May-11 00:53 switchboard/bitvector.py
--rw-r--r--  2.0 unx      547 b- defN 24-May-11 00:53 switchboard/xyce.py
--rw-r--r--  2.0 unx     2341 b- defN 24-May-11 00:53 switchboard/util.py
--rw-r--r--  2.0 unx     1012 b- defN 24-May-11 00:53 switchboard/verilator.py
--rw-r--r--  2.0 unx    19799 b- defN 24-May-11 00:53 switchboard/axi.py
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/verilog/fpga/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/verilog/common/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/verilog/sim/
-drwxr-xr-x  2.0 unx        0 b- stor 24-May-11 00:53 switchboard/verilog/fpga/include/
--rw-r--r--  2.0 unx     1005 b- defN 24-May-11 00:53 switchboard/verilog/fpga/memory_fault.sv
--rw-r--r--  2.0 unx     2061 b- defN 24-May-11 00:53 switchboard/verilog/fpga/axi_reader.sv
--rw-r--r--  2.0 unx     7608 b- defN 24-May-11 00:53 switchboard/verilog/fpga/sb_tx_fpga.sv
--rw-r--r--  2.0 unx     3171 b- defN 24-May-11 00:53 switchboard/verilog/fpga/axi_writer.sv
--rw-r--r--  2.0 unx     7821 b- defN 24-May-11 00:53 switchboard/verilog/fpga/sb_rx_fpga.sv
--rw-r--r--  2.0 unx    13623 b- defN 24-May-11 00:53 switchboard/verilog/fpga/sb_fpga_queues.sv
--rw-r--r--  2.0 unx     4341 b- defN 24-May-11 00:53 switchboard/verilog/fpga/umi_fpga_queues.sv
--rw-r--r--  2.0 unx     8478 b- defN 24-May-11 00:53 switchboard/verilog/fpga/config_registers.sv
--rw-r--r--  2.0 unx      789 b- defN 24-May-11 00:53 switchboard/verilog/fpga/include/sb_queue_regmap.vh
--rw-r--r--  2.0 unx      272 b- defN 24-May-11 00:53 switchboard/verilog/fpga/include/spsc_queue.vh
--rw-r--r--  2.0 unx     7590 b- defN 24-May-11 00:53 switchboard/verilog/common/umi_gpio.v
--rw-r--r--  2.0 unx    31459 b- defN 24-May-11 00:53 switchboard/verilog/common/switchboard.vh
--rw-r--r--  2.0 unx     7372 b- defN 24-May-11 00:53 switchboard/verilog/common/uart_xactor.sv
--rw-r--r--  2.0 unx     5670 b- defN 24-May-11 00:53 switchboard/verilog/sim/sb_axi_m.sv
--rw-r--r--  2.0 unx     4556 b- defN 24-May-11 00:53 switchboard/verilog/sim/sb_jtag_rbb_sim.sv
--rw-r--r--  2.0 unx     2207 b- defN 24-May-11 00:53 switchboard/verilog/sim/sb_clk_gen.sv
--rw-r--r--  2.0 unx     3310 b- defN 24-May-11 00:53 switchboard/verilog/sim/perf_meas_sim.sv
--rw-r--r--  2.0 unx     1283 b- defN 24-May-11 00:53 switchboard/verilog/sim/sb_tx_sim.sv
--rw-r--r--  2.0 unx     4577 b- defN 24-May-11 00:53 switchboard/verilog/sim/sb_axil_s.sv
--rw-r--r--  2.0 unx     1286 b- defN 24-May-11 00:53 switchboard/verilog/sim/sb_rx_sim.sv
--rw-r--r--  2.0 unx     1419 b- defN 24-May-11 00:53 switchboard/verilog/sim/umi_tx_sim.sv
--rw-r--r--  2.0 unx     5504 b- defN 24-May-11 00:53 switchboard/verilog/sim/queue_to_sb_sim.sv
--rw-r--r--  2.0 unx     1423 b- defN 24-May-11 00:53 switchboard/verilog/sim/umi_rx_sim.sv
--rw-r--r--  2.0 unx     1902 b- defN 24-May-11 00:53 switchboard/verilog/sim/xyce_intf.sv
--rw-r--r--  2.0 unx     1506 b- defN 24-May-11 00:53 switchboard/verilog/sim/queue_to_umi_sim.sv
--rw-r--r--  2.0 unx      468 b- defN 24-May-11 00:53 switchboard/verilog/sim/auto_stop_sim.sv
--rw-r--r--  2.0 unx     4577 b- defN 24-May-11 00:53 switchboard/verilog/sim/sb_axil_m.sv
--rw-r--r--  2.0 unx     6424 b- defN 24-May-11 00:53 switchboard/verilog/sim/sb_to_queue_sim.sv
--rw-r--r--  2.0 unx     1535 b- defN 24-May-11 00:53 switchboard/verilog/sim/umi_to_queue_sim.sv
--rw-r--r--  2.0 unx     1103 b- defN 24-May-11 00:53 switchboard/dpi/xyce_dpi.cc
--rw-r--r--  2.0 unx     3469 b- defN 24-May-11 00:53 switchboard/dpi/switchboard_dpi.cc
--rw-r--r--  2.0 unx      526 b- defN 24-May-11 00:53 switchboard/verilator/config.vlt
--rw-r--r--  2.0 unx     4571 b- defN 24-May-11 00:53 switchboard/verilator/testbench.cc
--rw-r--r--  2.0 unx    11038 b- defN 24-May-11 00:53 switchboard/vpi/switchboard_vpi.cc
--rw-r--r--  2.0 unx     4954 b- defN 24-May-11 00:53 switchboard/vpi/xyce_vpi.cc
--rw-r--r--  2.0 unx      291 b- defN 24-May-11 00:53 switchboard/cpp/Makefile
--rw-r--r--  2.0 unx     6188 b- defN 24-May-11 00:53 switchboard/cpp/switchboard_pcie.hpp
--rw-r--r--  2.0 unx     2351 b- defN 24-May-11 00:53 switchboard/cpp/xyce.hpp
--rw-r--r--  2.0 unx      979 b- defN 24-May-11 00:53 switchboard/cpp/bitutil.h
--rw-r--r--  2.0 unx     9987 b- defN 24-May-11 00:53 switchboard/cpp/umisb.hpp
--rw-r--r--  2.0 unx     2376 b- defN 24-May-11 00:53 switchboard/cpp/pagemap.h
--rw-r--r--  2.0 unx     6479 b- defN 24-May-11 00:53 switchboard/cpp/spsc_queue.h
--rw-r--r--  2.0 unx     2786 b- defN 24-May-11 00:53 switchboard/cpp/router.cc
--rw-r--r--  2.0 unx     6064 b- defN 24-May-11 00:53 switchboard/cpp/switchboard.hpp
--rw-r--r--  2.0 unx     3809 b- defN 24-May-11 00:53 switchboard/cpp/umilib.hpp
--rw-r--r--  2.0 unx     2514 b- defN 24-May-11 00:53 switchboard/cpp/switchboard_tlm.hpp
--rw-r--r--  2.0 unx     4477 b- defN 24-May-11 00:53 switchboard/cpp/umilib.h
--rw-r--r--  2.0 unx     4047 b- defN 24-May-11 00:53 switchboard/cpp/pciedev.h
-88 files, 1025124 bytes uncompressed, 316417 bytes compressed:  69.1%
+Zip file size: 333843 bytes, number of entries: 98
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard_hw-0.2.2.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard_hw.libs/
+-rwxr-xr-x  2.0 unx   603792 b- defN 24-May-20 18:35 _switchboard.cpython-39-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx      148 b- defN 24-May-20 18:35 switchboard_hw-0.2.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx    10766 b- defN 24-May-20 18:35 switchboard_hw-0.2.2.dist-info/LICENSE
+-rw-r--r--  2.0 unx       25 b- defN 24-May-20 18:35 switchboard_hw-0.2.2.dist-info/top_level.txt
+-rw-r--r--  2.0 unx       92 b- defN 24-May-20 18:35 switchboard_hw-0.2.2.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx     7378 b- defN 24-May-20 18:35 switchboard_hw-0.2.2.dist-info/RECORD
+-rw-r--r--  2.0 unx    18115 b- defN 24-May-20 18:35 switchboard_hw-0.2.2.dist-info/METADATA
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/cpp/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/verilog/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/dpi/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/verilator/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/vpi/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/sc/
+-rw-r--r--  2.0 unx      941 b- defN 24-May-20 18:35 switchboard/__init__.py
+-rw-r--r--  2.0 unx     1333 b- defN 24-May-20 18:35 switchboard/test_util.py
+-rw-r--r--  2.0 unx     5598 b- defN 24-May-20 18:35 switchboard/cmdline.py
+-rw-r--r--  2.0 unx      547 b- defN 24-May-20 18:35 switchboard/xyce.py
+-rw-r--r--  2.0 unx    12870 b- defN 24-May-20 18:35 switchboard/axil.py
+-rw-r--r--  2.0 unx    19799 b- defN 24-May-20 18:35 switchboard/axi.py
+-rw-r--r--  2.0 unx    19774 b- defN 24-May-20 18:35 switchboard/autowrap.py
+-rw-r--r--  2.0 unx      311 b- defN 24-May-20 18:35 switchboard/warn.py
+-rw-r--r--  2.0 unx     8247 b- defN 24-May-20 18:35 switchboard/sbtcp.py
+-rw-r--r--  2.0 unx     2341 b- defN 24-May-20 18:35 switchboard/util.py
+-rw-r--r--  2.0 unx     2088 b- defN 24-May-20 18:35 switchboard/icarus.py
+-rw-r--r--  2.0 unx     1701 b- defN 24-May-20 18:35 switchboard/uart_xactor.py
+-rw-r--r--  2.0 unx    26939 b- defN 24-May-20 18:35 switchboard/umi.py
+-rw-r--r--  2.0 unx     5246 b- defN 24-May-20 18:35 switchboard/loopback.py
+-rw-r--r--  2.0 unx    11902 b- defN 24-May-20 18:35 switchboard/network.py
+-rw-r--r--  2.0 unx     1012 b- defN 24-May-20 18:35 switchboard/verilator.py
+-rw-r--r--  2.0 unx     1506 b- defN 24-May-20 18:35 switchboard/switchboard.py
+-rw-r--r--  2.0 unx     3398 b- defN 24-May-20 18:35 switchboard/bitvector.py
+-rw-r--r--  2.0 unx    28459 b- defN 24-May-20 18:35 switchboard/sbdut.py
+-rw-r--r--  2.0 unx     2706 b- defN 24-May-20 18:35 switchboard/gpio.py
+-rw-r--r--  2.0 unx    18067 b- defN 24-May-20 18:35 switchboard/ams.py
+-rw-r--r--  2.0 unx     4047 b- defN 24-May-20 18:35 switchboard/cpp/pciedev.h
+-rw-r--r--  2.0 unx     2376 b- defN 24-May-20 18:35 switchboard/cpp/pagemap.h
+-rw-r--r--  2.0 unx     2351 b- defN 24-May-20 18:35 switchboard/cpp/xyce.hpp
+-rw-r--r--  2.0 unx     6064 b- defN 24-May-20 18:35 switchboard/cpp/switchboard.hpp
+-rw-r--r--  2.0 unx     6479 b- defN 24-May-20 18:35 switchboard/cpp/spsc_queue.h
+-rw-r--r--  2.0 unx     3809 b- defN 24-May-20 18:35 switchboard/cpp/umilib.hpp
+-rw-r--r--  2.0 unx      291 b- defN 24-May-20 18:35 switchboard/cpp/Makefile
+-rw-r--r--  2.0 unx      979 b- defN 24-May-20 18:35 switchboard/cpp/bitutil.h
+-rw-r--r--  2.0 unx     9987 b- defN 24-May-20 18:35 switchboard/cpp/umisb.hpp
+-rw-r--r--  2.0 unx     2786 b- defN 24-May-20 18:35 switchboard/cpp/router.cc
+-rw-r--r--  2.0 unx     6188 b- defN 24-May-20 18:35 switchboard/cpp/switchboard_pcie.hpp
+-rw-r--r--  2.0 unx     2514 b- defN 24-May-20 18:35 switchboard/cpp/switchboard_tlm.hpp
+-rw-r--r--  2.0 unx     4477 b- defN 24-May-20 18:35 switchboard/cpp/umilib.h
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/verilog/common/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/verilog/sim/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/verilog/fpga/
+-rw-r--r--  2.0 unx     7372 b- defN 24-May-20 18:35 switchboard/verilog/common/uart_xactor.sv
+-rw-r--r--  2.0 unx    31459 b- defN 24-May-20 18:35 switchboard/verilog/common/switchboard.vh
+-rw-r--r--  2.0 unx     7590 b- defN 24-May-20 18:35 switchboard/verilog/common/umi_gpio.v
+-rw-r--r--  2.0 unx     1423 b- defN 24-May-20 18:35 switchboard/verilog/sim/umi_rx_sim.sv
+-rw-r--r--  2.0 unx     6424 b- defN 24-May-20 18:35 switchboard/verilog/sim/sb_to_queue_sim.sv
+-rw-r--r--  2.0 unx     5670 b- defN 24-May-20 18:35 switchboard/verilog/sim/sb_axi_m.sv
+-rw-r--r--  2.0 unx     1902 b- defN 24-May-20 18:35 switchboard/verilog/sim/xyce_intf.sv
+-rw-r--r--  2.0 unx     4556 b- defN 24-May-20 18:35 switchboard/verilog/sim/sb_jtag_rbb_sim.sv
+-rw-r--r--  2.0 unx     1283 b- defN 24-May-20 18:35 switchboard/verilog/sim/sb_tx_sim.sv
+-rw-r--r--  2.0 unx     4577 b- defN 24-May-20 18:35 switchboard/verilog/sim/sb_axil_s.sv
+-rw-r--r--  2.0 unx     5504 b- defN 24-May-20 18:35 switchboard/verilog/sim/queue_to_sb_sim.sv
+-rw-r--r--  2.0 unx     3310 b- defN 24-May-20 18:35 switchboard/verilog/sim/perf_meas_sim.sv
+-rw-r--r--  2.0 unx     2207 b- defN 24-May-20 18:35 switchboard/verilog/sim/sb_clk_gen.sv
+-rw-r--r--  2.0 unx     1535 b- defN 24-May-20 18:35 switchboard/verilog/sim/umi_to_queue_sim.sv
+-rw-r--r--  2.0 unx     1419 b- defN 24-May-20 18:35 switchboard/verilog/sim/umi_tx_sim.sv
+-rw-r--r--  2.0 unx      468 b- defN 24-May-20 18:35 switchboard/verilog/sim/auto_stop_sim.sv
+-rw-r--r--  2.0 unx     1506 b- defN 24-May-20 18:35 switchboard/verilog/sim/queue_to_umi_sim.sv
+-rw-r--r--  2.0 unx     4577 b- defN 24-May-20 18:35 switchboard/verilog/sim/sb_axil_m.sv
+-rw-r--r--  2.0 unx     1286 b- defN 24-May-20 18:35 switchboard/verilog/sim/sb_rx_sim.sv
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/verilog/fpga/include/
+-rw-r--r--  2.0 unx     7821 b- defN 24-May-20 18:35 switchboard/verilog/fpga/sb_rx_fpga.sv
+-rw-r--r--  2.0 unx     7608 b- defN 24-May-20 18:35 switchboard/verilog/fpga/sb_tx_fpga.sv
+-rw-r--r--  2.0 unx     1005 b- defN 24-May-20 18:35 switchboard/verilog/fpga/memory_fault.sv
+-rw-r--r--  2.0 unx     4341 b- defN 24-May-20 18:35 switchboard/verilog/fpga/umi_fpga_queues.sv
+-rw-r--r--  2.0 unx    13623 b- defN 24-May-20 18:35 switchboard/verilog/fpga/sb_fpga_queues.sv
+-rw-r--r--  2.0 unx     8478 b- defN 24-May-20 18:35 switchboard/verilog/fpga/config_registers.sv
+-rw-r--r--  2.0 unx     2061 b- defN 24-May-20 18:35 switchboard/verilog/fpga/axi_reader.sv
+-rw-r--r--  2.0 unx     3171 b- defN 24-May-20 18:35 switchboard/verilog/fpga/axi_writer.sv
+-rw-r--r--  2.0 unx      272 b- defN 24-May-20 18:35 switchboard/verilog/fpga/include/spsc_queue.vh
+-rw-r--r--  2.0 unx      789 b- defN 24-May-20 18:35 switchboard/verilog/fpga/include/sb_queue_regmap.vh
+-rw-r--r--  2.0 unx     1103 b- defN 24-May-20 18:35 switchboard/dpi/xyce_dpi.cc
+-rw-r--r--  2.0 unx     3469 b- defN 24-May-20 18:35 switchboard/dpi/switchboard_dpi.cc
+-rw-r--r--  2.0 unx     4571 b- defN 24-May-20 18:35 switchboard/verilator/testbench.cc
+-rw-r--r--  2.0 unx      526 b- defN 24-May-20 18:35 switchboard/verilator/config.vlt
+-rw-r--r--  2.0 unx    11038 b- defN 24-May-20 18:35 switchboard/vpi/switchboard_vpi.cc
+-rw-r--r--  2.0 unx     4954 b- defN 24-May-20 18:35 switchboard/vpi/xyce_vpi.cc
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/sc/morty/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-20 18:35 switchboard/sc/sed/
+-rw-r--r--  2.0 unx        0 b- defN 24-May-20 18:35 switchboard/sc/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-20 18:35 switchboard/sc/morty/__init__.py
+-rw-r--r--  2.0 unx     1790 b- defN 24-May-20 18:35 switchboard/sc/morty/uniquify.py
+-rw-r--r--  2.0 unx      353 b- defN 24-May-20 18:35 switchboard/sc/morty/morty.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-20 18:35 switchboard/sc/sed/__init__.py
+-rw-r--r--  2.0 unx     1082 b- defN 24-May-20 18:35 switchboard/sc/sed/remove.py
+-rw-r--r--  2.0 unx      238 b- defN 24-May-20 18:35 switchboard/sc/sed/sed.py
+98 files, 1039810 bytes uncompressed, 320481 bytes compressed:  69.2%
```

## zipnote {}

```diff
@@ -1,265 +1,295 @@
-Filename: switchboard_hw.libs/
+Filename: switchboard_hw-0.2.2.dist-info/
 Comment: 
 
-Filename: switchboard_hw-0.2.1.dist-info/
+Filename: switchboard/
 Comment: 
 
-Filename: switchboard/
+Filename: switchboard_hw.libs/
 Comment: 
 
 Filename: _switchboard.cpython-39-x86_64-linux-gnu.so
 Comment: 
 
-Filename: switchboard_hw-0.2.1.dist-info/LICENSE
+Filename: switchboard_hw-0.2.2.dist-info/WHEEL
 Comment: 
 
-Filename: switchboard_hw-0.2.1.dist-info/METADATA
+Filename: switchboard_hw-0.2.2.dist-info/LICENSE
 Comment: 
 
-Filename: switchboard_hw-0.2.1.dist-info/RECORD
+Filename: switchboard_hw-0.2.2.dist-info/top_level.txt
 Comment: 
 
-Filename: switchboard_hw-0.2.1.dist-info/top_level.txt
+Filename: switchboard_hw-0.2.2.dist-info/entry_points.txt
 Comment: 
 
-Filename: switchboard_hw-0.2.1.dist-info/entry_points.txt
+Filename: switchboard_hw-0.2.2.dist-info/RECORD
 Comment: 
 
-Filename: switchboard_hw-0.2.1.dist-info/WHEEL
+Filename: switchboard_hw-0.2.2.dist-info/METADATA
+Comment: 
+
+Filename: switchboard/cpp/
 Comment: 
 
 Filename: switchboard/verilog/
 Comment: 
 
 Filename: switchboard/dpi/
 Comment: 
 
 Filename: switchboard/verilator/
 Comment: 
 
 Filename: switchboard/vpi/
 Comment: 
 
-Filename: switchboard/cpp/
+Filename: switchboard/sc/
 Comment: 
 
-Filename: switchboard/icarus.py
+Filename: switchboard/__init__.py
 Comment: 
 
-Filename: switchboard/sbdut.py
+Filename: switchboard/test_util.py
 Comment: 
 
-Filename: switchboard/gpio.py
+Filename: switchboard/cmdline.py
 Comment: 
 
-Filename: switchboard/umi.py
+Filename: switchboard/xyce.py
 Comment: 
 
-Filename: switchboard/uart_xactor.py
+Filename: switchboard/axil.py
 Comment: 
 
-Filename: switchboard/switchboard.py
+Filename: switchboard/axi.py
 Comment: 
 
-Filename: switchboard/test_util.py
+Filename: switchboard/autowrap.py
 Comment: 
 
-Filename: switchboard/cmdline.py
+Filename: switchboard/warn.py
 Comment: 
 
-Filename: switchboard/autowrap.py
+Filename: switchboard/sbtcp.py
 Comment: 
 
-Filename: switchboard/network.py
+Filename: switchboard/util.py
 Comment: 
 
-Filename: switchboard/sbtcp.py
+Filename: switchboard/icarus.py
 Comment: 
 
-Filename: switchboard/axil.py
+Filename: switchboard/uart_xactor.py
 Comment: 
 
-Filename: switchboard/__init__.py
+Filename: switchboard/umi.py
 Comment: 
 
-Filename: switchboard/ams.py
+Filename: switchboard/loopback.py
 Comment: 
 
-Filename: switchboard/loopback.py
+Filename: switchboard/network.py
 Comment: 
 
-Filename: switchboard/warn.py
+Filename: switchboard/verilator.py
+Comment: 
+
+Filename: switchboard/switchboard.py
 Comment: 
 
 Filename: switchboard/bitvector.py
 Comment: 
 
-Filename: switchboard/xyce.py
+Filename: switchboard/sbdut.py
 Comment: 
 
-Filename: switchboard/util.py
+Filename: switchboard/gpio.py
 Comment: 
 
-Filename: switchboard/verilator.py
+Filename: switchboard/ams.py
 Comment: 
 
-Filename: switchboard/axi.py
+Filename: switchboard/cpp/pciedev.h
 Comment: 
 
-Filename: switchboard/verilog/fpga/
+Filename: switchboard/cpp/pagemap.h
 Comment: 
 
-Filename: switchboard/verilog/common/
+Filename: switchboard/cpp/xyce.hpp
 Comment: 
 
-Filename: switchboard/verilog/sim/
+Filename: switchboard/cpp/switchboard.hpp
 Comment: 
 
-Filename: switchboard/verilog/fpga/include/
+Filename: switchboard/cpp/spsc_queue.h
 Comment: 
 
-Filename: switchboard/verilog/fpga/memory_fault.sv
+Filename: switchboard/cpp/umilib.hpp
 Comment: 
 
-Filename: switchboard/verilog/fpga/axi_reader.sv
+Filename: switchboard/cpp/Makefile
 Comment: 
 
-Filename: switchboard/verilog/fpga/sb_tx_fpga.sv
+Filename: switchboard/cpp/bitutil.h
 Comment: 
 
-Filename: switchboard/verilog/fpga/axi_writer.sv
+Filename: switchboard/cpp/umisb.hpp
 Comment: 
 
-Filename: switchboard/verilog/fpga/sb_rx_fpga.sv
+Filename: switchboard/cpp/router.cc
 Comment: 
 
-Filename: switchboard/verilog/fpga/sb_fpga_queues.sv
+Filename: switchboard/cpp/switchboard_pcie.hpp
 Comment: 
 
-Filename: switchboard/verilog/fpga/umi_fpga_queues.sv
+Filename: switchboard/cpp/switchboard_tlm.hpp
 Comment: 
 
-Filename: switchboard/verilog/fpga/config_registers.sv
+Filename: switchboard/cpp/umilib.h
 Comment: 
 
-Filename: switchboard/verilog/fpga/include/sb_queue_regmap.vh
+Filename: switchboard/verilog/common/
 Comment: 
 
-Filename: switchboard/verilog/fpga/include/spsc_queue.vh
+Filename: switchboard/verilog/sim/
 Comment: 
 
-Filename: switchboard/verilog/common/umi_gpio.v
+Filename: switchboard/verilog/fpga/
+Comment: 
+
+Filename: switchboard/verilog/common/uart_xactor.sv
 Comment: 
 
 Filename: switchboard/verilog/common/switchboard.vh
 Comment: 
 
-Filename: switchboard/verilog/common/uart_xactor.sv
+Filename: switchboard/verilog/common/umi_gpio.v
 Comment: 
 
-Filename: switchboard/verilog/sim/sb_axi_m.sv
+Filename: switchboard/verilog/sim/umi_rx_sim.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/sb_jtag_rbb_sim.sv
+Filename: switchboard/verilog/sim/sb_to_queue_sim.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/sb_clk_gen.sv
+Filename: switchboard/verilog/sim/sb_axi_m.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/perf_meas_sim.sv
+Filename: switchboard/verilog/sim/xyce_intf.sv
+Comment: 
+
+Filename: switchboard/verilog/sim/sb_jtag_rbb_sim.sv
 Comment: 
 
 Filename: switchboard/verilog/sim/sb_tx_sim.sv
 Comment: 
 
 Filename: switchboard/verilog/sim/sb_axil_s.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/sb_rx_sim.sv
+Filename: switchboard/verilog/sim/queue_to_sb_sim.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/umi_tx_sim.sv
+Filename: switchboard/verilog/sim/perf_meas_sim.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/queue_to_sb_sim.sv
+Filename: switchboard/verilog/sim/sb_clk_gen.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/umi_rx_sim.sv
+Filename: switchboard/verilog/sim/umi_to_queue_sim.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/xyce_intf.sv
+Filename: switchboard/verilog/sim/umi_tx_sim.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/queue_to_umi_sim.sv
+Filename: switchboard/verilog/sim/auto_stop_sim.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/auto_stop_sim.sv
+Filename: switchboard/verilog/sim/queue_to_umi_sim.sv
 Comment: 
 
 Filename: switchboard/verilog/sim/sb_axil_m.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/sb_to_queue_sim.sv
+Filename: switchboard/verilog/sim/sb_rx_sim.sv
 Comment: 
 
-Filename: switchboard/verilog/sim/umi_to_queue_sim.sv
+Filename: switchboard/verilog/fpga/include/
 Comment: 
 
-Filename: switchboard/dpi/xyce_dpi.cc
+Filename: switchboard/verilog/fpga/sb_rx_fpga.sv
 Comment: 
 
-Filename: switchboard/dpi/switchboard_dpi.cc
+Filename: switchboard/verilog/fpga/sb_tx_fpga.sv
 Comment: 
 
-Filename: switchboard/verilator/config.vlt
+Filename: switchboard/verilog/fpga/memory_fault.sv
 Comment: 
 
-Filename: switchboard/verilator/testbench.cc
+Filename: switchboard/verilog/fpga/umi_fpga_queues.sv
 Comment: 
 
-Filename: switchboard/vpi/switchboard_vpi.cc
+Filename: switchboard/verilog/fpga/sb_fpga_queues.sv
 Comment: 
 
-Filename: switchboard/vpi/xyce_vpi.cc
+Filename: switchboard/verilog/fpga/config_registers.sv
 Comment: 
 
-Filename: switchboard/cpp/Makefile
+Filename: switchboard/verilog/fpga/axi_reader.sv
 Comment: 
 
-Filename: switchboard/cpp/switchboard_pcie.hpp
+Filename: switchboard/verilog/fpga/axi_writer.sv
 Comment: 
 
-Filename: switchboard/cpp/xyce.hpp
+Filename: switchboard/verilog/fpga/include/spsc_queue.vh
 Comment: 
 
-Filename: switchboard/cpp/bitutil.h
+Filename: switchboard/verilog/fpga/include/sb_queue_regmap.vh
 Comment: 
 
-Filename: switchboard/cpp/umisb.hpp
+Filename: switchboard/dpi/xyce_dpi.cc
 Comment: 
 
-Filename: switchboard/cpp/pagemap.h
+Filename: switchboard/dpi/switchboard_dpi.cc
 Comment: 
 
-Filename: switchboard/cpp/spsc_queue.h
+Filename: switchboard/verilator/testbench.cc
 Comment: 
 
-Filename: switchboard/cpp/router.cc
+Filename: switchboard/verilator/config.vlt
 Comment: 
 
-Filename: switchboard/cpp/switchboard.hpp
+Filename: switchboard/vpi/switchboard_vpi.cc
 Comment: 
 
-Filename: switchboard/cpp/umilib.hpp
+Filename: switchboard/vpi/xyce_vpi.cc
 Comment: 
 
-Filename: switchboard/cpp/switchboard_tlm.hpp
+Filename: switchboard/sc/morty/
 Comment: 
 
-Filename: switchboard/cpp/umilib.h
+Filename: switchboard/sc/sed/
 Comment: 
 
-Filename: switchboard/cpp/pciedev.h
+Filename: switchboard/sc/__init__.py
+Comment: 
+
+Filename: switchboard/sc/morty/__init__.py
+Comment: 
+
+Filename: switchboard/sc/morty/uniquify.py
+Comment: 
+
+Filename: switchboard/sc/morty/morty.py
+Comment: 
+
+Filename: switchboard/sc/sed/__init__.py
+Comment: 
+
+Filename: switchboard/sc/sed/remove.py
+Comment: 
+
+Filename: switchboard/sc/sed/sed.py
 Comment: 
 
 Zip file comment:
```

## switchboard/sbdut.py

```diff
@@ -24,15 +24,14 @@
 from .xyce import xyce_flags
 from .ams import make_ams_spice_wrapper, make_ams_verilog_wrapper, parse_spice_subckts
 from .autowrap import (normalize_clocks, normalize_interfaces, normalize_resets, normalize_tieoffs,
     normalize_parameters, create_intf_objs)
 from .cmdline import get_cmdline_args
 
 import siliconcompiler
-from siliconcompiler.flows import dvflow
 
 SB_DIR = sb_path()
 
 
 class SbDut(siliconcompiler.Chip):
     def __init__(
         self,
@@ -58,15 +57,18 @@
         parameters=None,
         interfaces=None,
         clocks=None,
         resets=None,
         tieoffs=None,
         buildroot=None,
         builddir=None,
-        args=None
+        args=None,
+        subcomponent=False,
+        suffix=None,
+        threads=None
     ):
         """
         Parameters
         ----------
         design: string
             Name of the top level chip design module.
 
@@ -133,41 +135,42 @@
             to be made available.  The keys of the dictionary are the arguments ("-n", "--test",
             etc.) and the values are themselves dictionaries that contain keyword arguments
             accepted by argparse ("action": "store_true", "default": 42, etc.)
         """
 
         # call the super constructor
 
-        if autowrap:
+        if autowrap and (not subcomponent):
             toplevel = 'testbench'
         else:
             toplevel = design
 
         super().__init__(toplevel)
 
         # parse command-line options if desired
 
         if cmdline:
             self.args = get_cmdline_args(tool=tool, trace=trace, trace_type=trace_type,
                 frequency=frequency, period=period, fast=fast, max_rate=max_rate,
-                start_delay=start_delay, extra_args=extra_args)
+                start_delay=start_delay, threads=threads, extra_args=extra_args)
         elif args is not None:
             self.args = args
         else:
             self.args = None
 
         if self.args is not None:
             trace = self.args.trace
             trace_type = self.args.trace_type
             fast = self.args.fast
             tool = self.args.tool
             frequency = self.args.frequency
             period = self.args.period
             max_rate = self.args.max_rate
             start_delay = self.args.start_delay
+            threads = self.args.threads
 
         # input validation
 
         if trace_type not in ('vcd', 'fst'):
             raise ValueError('Invalid trace_type, expected one of "vcd" or "fst"')
 
         # save settings
@@ -182,19 +185,31 @@
 
         if (period is None) and (frequency is not None):
             period = 1 / frequency
         self.period = period
         self.max_rate = max_rate
         self.start_delay = start_delay
 
+        self.threads = threads
+
         self.timeunit = timeunit
         self.timeprecision = timeprecision
 
         self.autowrap = autowrap
-        self.dut = design
+
+        if (suffix is None) and subcomponent:
+            suffix = f'_unq_{design}'
+
+        self.suffix = suffix
+
+        if suffix is not None:
+            self.dut = f'{design}{suffix}'
+        else:
+            self.dut = design
+
         self.parameters = normalize_parameters(parameters)
         self.intf_defs = normalize_interfaces(interfaces)
         self.clocks = normalize_clocks(clocks)
         self.resets = normalize_resets(resets)
         self.tieoffs = normalize_tieoffs(tieoffs)
 
         # initialization
@@ -205,60 +220,88 @@
 
         if builddir is None:
             if buildroot is None:
                 buildroot = 'build'
 
             buildroot = Path(buildroot).resolve()
 
-            builddir = buildroot / metadata_str(design=design, parameters=parameters, tool=tool,
-                trace=trace, trace_type=trace_type)
+            if subcomponent:
+                # the subcomponent build flow is tool-agnostic, producing a single Verilog
+                # file as output, as opposed to a simulator binary
+                builddir = buildroot / metadata_str(design=design, parameters=parameters)
+            else:
+                builddir = buildroot / metadata_str(design=design, parameters=parameters,
+                    tool=tool, trace=trace, trace_type=trace_type, threads=threads)
 
         self.set('option', 'builddir', str(Path(builddir).resolve()))
 
-        if fpga:
-            # library dirs
-            self.set('option', 'ydir', sb_path() / 'verilog' / 'fpga')
-            self.add('option', 'ydir', sb_path() / 'deps' / 'verilog-axi' / 'rtl')
-
-            # include dirs
-            self.set('option', 'idir', sb_path() / 'verilog' / 'fpga' / 'include')
-
-        for opt in ['ydir', 'idir']:
-            if not fpga:
-                self.set('option', opt, sb_path() / 'verilog' / 'sim')
-            self.add('option', opt, sb_path() / 'verilog' / 'common')
-
         self.set('option', 'mode', 'sim')
 
-        if trace:
-            self.set('option', 'trace', True)
-            self.set('option', 'define', 'SB_TRACE')
+        if not subcomponent:
+            if fpga:
+                # library dirs
+                self.set('option', 'ydir', sb_path() / 'verilog' / 'fpga')
+                self.add('option', 'ydir', sb_path() / 'deps' / 'verilog-axi' / 'rtl')
+
+                # include dirs
+                self.set('option', 'idir', sb_path() / 'verilog' / 'fpga' / 'include')
+
+            for opt in ['ydir', 'idir']:
+                if not fpga:
+                    self.set('option', opt, sb_path() / 'verilog' / 'sim')
+                self.add('option', opt, sb_path() / 'verilog' / 'common')
+
+            if trace:
+                self.set('option', 'trace', True)
+                self.set('option', 'define', 'SB_TRACE')
+
+            if self.trace_type == 'fst':
+                self.set('option', 'define', 'SB_TRACE_FST')
 
-        if self.trace_type == 'fst':
-            self.set('option', 'define', 'SB_TRACE_FST')
+            if tool == 'icarus':
+                self._configure_icarus()
+            else:
+                if module is None:
+                    if tool == 'verilator':
+                        module = 'siliconcompiler'
+                    else:
+                        raise ValueError('Must specify the "module" argument,'
+                            ' which is the name of the module containing the'
+                            ' SiliconCompiler driver for this simulator.')
+
+                self._configure_build(
+                    module=module,
+                    default_main=default_main,
+                    fpga=fpga
+                )
 
-        if tool == 'icarus':
-            self._configure_icarus()
+            if xyce:
+                self._configure_xyce()
         else:
-            if module is None:
-                if tool == 'verilator':
-                    module = 'siliconcompiler'
-                else:
-                    raise ValueError('Must specify the "module" argument,'
-                        ' which is the name of the module containing the'
-                        ' SiliconCompiler driver for this simulator.')
-
-            self._configure_build(
-                module=module,
-                default_main=default_main,
-                fpga=fpga
-            )
+            # special mode that produces a standalone Verilog netlist
+            # rather than building/running a simulation
+
+            flowname = 'package'
+
+            self.package_flow = siliconcompiler.Flow(self, flowname)
 
-        if xyce:
-            self._configure_xyce()
+            from siliconcompiler.tools.surelog import parse
+            self.package_flow.node(flowname, 'parse', parse)
+
+            from .sc.sed import remove
+            self.package_flow.node(flowname, 'remove', remove)
+
+            from .sc.morty import uniquify
+            self.package_flow.node(flowname, 'uniquify', uniquify)
+
+            self.package_flow.edge(flowname, 'parse', 'remove')
+            self.package_flow.edge(flowname, 'remove', 'uniquify')
+
+            self.use(self.package_flow)
+            self.set('option', 'flow', flowname)
 
     def _configure_build(
         self,
         module: str,
         default_main: bool = False,
         fpga: bool = False
     ):
@@ -302,29 +345,35 @@
                 if timeprecision is None:
                     timeprecision = '1ps'  # default from Verilator documentation
 
                 timescale = f'{timeunit}/{timeprecision}'
                 self.add('tool', 'verilator', 'task', 'compile', 'option', '--timescale')
                 self.add('tool', 'verilator', 'task', 'compile', 'option', timescale)
 
+        if (self.threads is not None) and (self.tool == 'verilator'):
+            self.add('tool', 'verilator', 'task', 'compile', 'option', '--threads')
+            self.add('tool', 'verilator', 'task', 'compile', 'option', str(self.threads))
+
         self.set('option', 'libext', ['v', 'sv'])
 
         # Set up flow that compiles RTL
         # TODO: this will be built into SC
         self.set('option', 'flow', 'simflow')
 
         compile = importlib.import_module(f'{module}.tools.{self.tool}.compile')
         self.node('simflow', 'compile', compile)
 
     def _configure_icarus(self):
         self.add('option', 'libext', 'sv')
         self.set('tool', 'icarus', 'task', 'compile', 'var', 'verilog_generation', '2012')
 
         # use dvflow to execute Icarus, but set steplist so we don't run sim
+        from siliconcompiler.flows import dvflow
         self.use(dvflow)
+
         self.set('option', 'flow', 'dvflow')
         self.set('option', 'to', 'compile')
 
     def _configure_xyce(self):
         if self.xyce:
             # already configured, so return early
             return
@@ -385,17 +434,25 @@
         if self.autowrap:
             from .autowrap import autowrap
 
             filename = Path(self.get('option', 'builddir')).resolve() / 'testbench.sv'
 
             filename.parent.mkdir(exist_ok=True, parents=True)
 
-            autowrap(design=self.dut, parameters=self.parameters,
-                interfaces=self.intf_defs, clocks=self.clocks, resets=self.resets,
-                tieoffs=self.tieoffs, filename=filename)
+            instance = f'{self.dut}_i'
+
+            autowrap(
+                instances={instance: self.dut},
+                parameters={instance: self.parameters},
+                interfaces={instance: self.intf_defs},
+                clocks={instance: self.clocks},
+                resets={instance: self.resets},
+                tieoffs={instance: self.tieoffs},
+                filename=filename
+            )
 
             self.input(filename)
 
         # if we get to this point, then we need to rebuild
         # the simulation binary
         self.run()
 
@@ -493,15 +550,15 @@
         if start_delay is not None:
             carefully_add_plusarg(
                 key='start-delay', value=start_delay, args=args, plusargs=plusargs)
 
         # add plusargs that define queue connections
 
         for name, value in self.intf_defs.items():
-            plusargs += [(name, value['uri'])]
+            plusargs += [(value['wire'], value['uri'])]
 
         # run-specific configurations (if running the same simulator build multiple times
         # in parallel)
 
         if run is not None:
             dumpfile = f'{run}.{self.trace_type}'
             plusargs.append(('dumpfile', dumpfile))
@@ -667,32 +724,71 @@
             filename=spice_wrapper,
             pins=pins,
             dir=dir
         )
 
         self.input(verilog_wrapper)
 
+    def package(self, suffix=None, fast=None):
+        # set defaults
+
+        if suffix is None:
+            suffix = self.suffix
+
+        if fast is None:
+            fast = self.fast
+
+        # see if we can exit early
+
+        if fast:
+            package = self.find_package(suffix=suffix)
+
+            if package is not None:
+                return package
+
+        # if not, parse with surelog and postprocess with morty
+
+        if suffix:
+            self.set('tool', 'morty', 'task', 'uniquify', 'var', 'suffix', suffix)
+
+        self.set('tool', 'sed', 'task', 'remove', 'var', 'to_remove', '`resetall')
+
+        self.run()
 
-def metadata_str(design: str, tool: str, trace: bool, trace_type: str,
-    parameters: dict = None) -> Path:
+        # return the path to the output
+        return self.find_package(suffix=suffix)
+
+    def find_package(self, suffix=None):
+        if suffix is None:
+            return self.find_result('v', step='parse')
+        else:
+            return self.find_result('v', step='uniquify')
+
+
+def metadata_str(design: str, tool: str = None, trace: bool = False,
+    trace_type: str = None, threads: int = None, parameters: dict = None) -> Path:
 
     opts = []
 
     opts += [design]
 
     if parameters is not None:
         for k, v in parameters.items():
             opts += [k, v]
 
-    opts += [tool]
+    if tool is not None:
+        opts += [tool]
 
     if trace:
         assert trace_type is not None
         opts += [trace_type]
 
+    if threads is not None:
+        opts += ['threads', threads]
+
     return '-'.join(str(opt) for opt in opts)
 
 
 def carefully_add_plusarg(key, args, plusargs, value=None):
     for plusarg in plusargs:
         if isinstance(plusarg, (list, tuple)):
             if (len(plusarg) >= 1) and (key == plusarg[0]):
```

## switchboard/test_util.py

```diff
@@ -20,27 +20,27 @@
     else:
         cwd = None
 
     # run the command, capturing the output
     if isinstance(args, str):
         args = [args]
     args = [str(arg) for arg in args]
-    result = subprocess.run(args, check=True, capture_output=True,
-        text=True, cwd=cwd)
 
-    # print the output
+    process = subprocess.Popen(args, stdout=subprocess.PIPE,
+        stderr=subprocess.STDOUT, bufsize=1, text=True, cwd=cwd)
 
-    stdout = result.stdout
-    if (stdout is not None) and (stdout != ''):
-        print(stdout, end='', flush=True)
+    # print output while saving it
+    stdout = ''
+    for line in process.stdout:
+        print(line, end='')
+        stdout += line
 
-    stderr = result.stderr
-    if (stderr is not None) and (stderr != ''):
-        print('### STDERR ###')
-        print(stderr, end='', flush=True)
+    # make sure that process exits cleanly
+    returncode = process.wait()
+    assert returncode == 0, f'Exited with non-zero code: {returncode}'
 
     # check the results
     if expected is not None:
         if isinstance(expected, str):
             expected = [expected]
         for elem in expected:
             assert elem in stdout
```

## switchboard/cmdline.py

```diff
@@ -6,14 +6,16 @@
     trace: bool = True,
     trace_type: str = 'vcd',
     frequency: float = 100e6,
     period: float = None,
     max_rate: float = -1,
     start_delay: float = None,
     fast: bool = False,
+    single_netlist: bool = False,
+    threads: int = None,
     extra_args: dict = None
 ):
     """
     Sets up and runs a command-line option parser (argparse) using the arguments
     provided as defaults.  The object returned is an argparse.Namespace object,
     which is the same object type returned by ArgumentParser.parse_args()
 
@@ -101,26 +103,40 @@
     parser.add_argument('--max-rate', type=float, default=max_rate,
         help='Maximum real-world rate that the simulation is allowed to run at, in Hz.')
 
     parser.add_argument('--start-delay', type=float, default=start_delay,
         help='Delay before starting simulation, in seconds.  Can be useful to prevent'
         ' simulations from stepping on each others toes when starting up.')
 
+    if not single_netlist:
+        parser.add_argument('--single-netlist', action='store_true', help='Run in single-netlist'
+            ' mode, where the network is constructed in Verilog and run in a single simulator.')
+    else:
+        parser.add_argument('--distributed', action='store_true', help='Run in distributed'
+            ' simulation mode, rather than single-netlist mode.')
+
+    parser.add_argument('--threads', type=int, default=threads,
+        help='Number of threads to use when running a simulation.')
+
     if extra_args is not None:
         for k, v in extra_args.items():
             parser.add_argument(k, **v)
 
-    args = parser.parse_args()
+    args, _ = parser.parse_known_args()
 
     # standardize boolean flags
 
     if trace:
         args.trace = not args.no_trace
         del args.no_trace
 
     if fast:
         args.fast = not args.rebuild
         del args.rebuild
 
+    if single_netlist:
+        args.single_netlist = not args.distributed
+        del args.distributed
+
     # return arguments
 
     return args
```

## switchboard/autowrap.py

```diff
@@ -18,14 +18,20 @@
     value = deepcopy(value)
 
     assert isinstance(value, dict)
 
     if 'type' not in value:
         value['type'] = 'sb'
 
+    if 'wire' not in value:
+        value['wire'] = name
+
+    if 'external' not in value:
+        value['external'] = True
+
     assert 'type' in value
     value['type'] = normalize_intf_type(value['type'])
     type = value['type']
 
     assert 'direction' in value
     value['direction'] = normalize_direction(type=type, direction=value['direction'])
 
@@ -180,32 +186,32 @@
         key, value = normalize_parameter(key, value)
         retval[key] = value
 
     return retval
 
 
 def autowrap(
-    design,
+    instances,
     toplevel='testbench',
     parameters=None,
     interfaces=None,
     clocks=None,
     resets=None,
     tieoffs=None,
     filename=None,
     nl='\n',
     tab='    '
 ):
     # normalize inputs
 
-    parameters = normalize_parameters(parameters)
-    interfaces = normalize_interfaces(interfaces)
-    clocks = normalize_clocks(clocks)
-    resets = normalize_resets(resets)
-    tieoffs = normalize_tieoffs(tieoffs)
+    parameters = {k: normalize_parameters(v) for k, v in parameters.items()}
+    interfaces = {k: normalize_interfaces(v) for k, v in interfaces.items()}
+    clocks = {k: normalize_clocks(v) for k, v in clocks.items()}
+    resets = {k: normalize_resets(v) for k, v in resets.items()}
+    tieoffs = {k: normalize_tieoffs(v) for k, v in tieoffs.items()}
 
     # build up output lines
 
     lines = []
 
     lines += [
         '`default_nettype none',
@@ -219,76 +225,115 @@
         ');',
         tab + '`ifndef VERILATOR',
         (2 * tab) + '`SB_CREATE_CLOCK(clk)',
         tab + '`endif',
         ''
     ]
 
+    # wire declarations
+
+    wires = {}
+
     lines += ['']
 
-    for name, value in interfaces.items():
-        type = value['type']
-        direction = value['direction']
+    for instance in instances:
+        for name, value in interfaces[instance].items():
+            type = value['type']
+
+            if type not in wires:
+                wires[type] = set()
+
+            wire = value['wire']
+
+            if wire not in wires[type]:
+                decl_wire = True
+                wires[type].add(wire)
+            else:
+                decl_wire = False
 
-        if type == 'sb':
-            dw = value['dw']
+            direction = value['direction']
 
-            lines += [tab + f'`SB_WIRES({name}, {dw});']
+            external = value['external']
 
-            if direction_is_input(direction):
-                lines += [tab + f'`QUEUE_TO_SB_SIM({name}, {dw}, "");']
-            elif direction_is_output(direction):
-                lines += [tab + f'`SB_TO_QUEUE_SIM({name}, {dw}, "");']
-            else:
-                raise Exception(f'Unsupported SB direction: {direction}')
-        elif type == 'umi':
-            dw = value['dw']
-            cw = value['cw']
-            aw = value['aw']
-
-            lines += [tab + f'`SB_UMI_WIRES({name}, {dw}, {cw}, {aw});']
-
-            if direction_is_input(direction):
-                lines += [tab + f'`QUEUE_TO_UMI_SIM({name}, {dw}, {cw}, {aw}, "");']
-            elif direction_is_output(direction):
-                lines += [tab + f'`UMI_TO_QUEUE_SIM({name}, {dw}, {cw}, {aw}, "");']
-            else:
-                raise Exception(f'Unsupported UMI direction: {direction}')
-        elif type == 'axi':
-            dw = value['dw']
-            aw = value['aw']
-            idw = value['idw']
-
-            lines += [tab + f'`SB_AXI_WIRES({name}, {dw}, {aw}, {idw});']
-
-            if direction_is_subordinate(direction):
-                lines += [tab + f'`SB_AXI_M({name}, {dw}, {aw}, {idw}, "");']
-            elif direction_is_manager(direction):
-                lines += [tab + f'`SB_AXI_S({name}, {dw}, {aw}, "");']
-            else:
-                raise Exception(f'Unsupported AXI direction: {direction}')
-        elif type == 'axil':
-            dw = value['dw']
-            aw = value['aw']
-
-            lines += [tab + f'`SB_AXIL_WIRES({name}, {dw}, {aw});']
-
-            if direction_is_subordinate(direction):
-                lines += [tab + f'`SB_AXIL_M({name}, {dw}, {aw}, "");']
-            elif direction_is_manager(direction):
-                lines += [tab + f'`SB_AXIL_S({name}, {dw}, {aw}, "");']
+            if type == 'sb':
+                dw = value['dw']
+
+                if decl_wire:
+                    lines += [tab + f'`SB_WIRES({wire}, {dw});']
+
+                if external:
+                    if direction_is_input(direction):
+                        lines += [tab + f'`QUEUE_TO_SB_SIM({wire}, {dw}, "");']
+                    elif direction_is_output(direction):
+                        lines += [tab + f'`SB_TO_QUEUE_SIM({wire}, {dw}, "");']
+                    else:
+                        raise Exception(f'Unsupported SB direction: {direction}')
+            elif type == 'umi':
+                dw = value['dw']
+                cw = value['cw']
+                aw = value['aw']
+
+                if decl_wire:
+                    lines += [tab + f'`SB_UMI_WIRES({wire}, {dw}, {cw}, {aw});']
+
+                if external:
+                    if direction_is_input(direction):
+                        lines += [tab + f'`QUEUE_TO_UMI_SIM({wire}, {dw}, {cw}, {aw}, "");']
+                    elif direction_is_output(direction):
+                        lines += [tab + f'`UMI_TO_QUEUE_SIM({wire}, {dw}, {cw}, {aw}, "");']
+                    else:
+                        raise Exception(f'Unsupported UMI direction: {direction}')
+            elif type == 'axi':
+                dw = value['dw']
+                aw = value['aw']
+                idw = value['idw']
+
+                if decl_wire:
+                    lines += [tab + f'`SB_AXI_WIRES({wire}, {dw}, {aw}, {idw});']
+
+                if external:
+                    if direction_is_subordinate(direction):
+                        lines += [tab + f'`SB_AXI_M({wire}, {dw}, {aw}, {idw}, "");']
+                    elif direction_is_manager(direction):
+                        lines += [tab + f'`SB_AXI_S({wire}, {dw}, {aw}, "");']
+                    else:
+                        raise Exception(f'Unsupported AXI direction: {direction}')
+            elif type == 'axil':
+                dw = value['dw']
+                aw = value['aw']
+
+                if decl_wire:
+                    lines += [tab + f'`SB_AXIL_WIRES({wire}, {dw}, {aw});']
+
+                if external:
+                    if direction_is_subordinate(direction):
+                        lines += [tab + f'`SB_AXIL_M({wire}, {dw}, {aw}, "");']
+                    elif direction_is_manager(direction):
+                        lines += [tab + f'`SB_AXIL_S({wire}, {dw}, {aw}, "");']
+                    else:
+                        raise Exception(f'Unsupported AXI-Lite direction: {direction}')
             else:
-                raise Exception(f'Unsupported AXI-Lite direction: {direction}')
-        else:
-            raise Exception(f'Unsupported interface type: "{type}"')
+                raise Exception(f'Unsupported interface type: "{type}"')
 
-        lines += ['']
+            lines += ['']
 
-    if len(resets) > 0:
-        max_rst_dly = max(reset['delay'] for reset in resets)
+    max_rst_dly = None
+
+    for inst_resets in resets.values():
+        if len(inst_resets) > 0:
+            # find the max reset delay for this instance
+            inst_max_rst_dly = max(reset['delay'] for reset in inst_resets)
+
+            # update the overall max reset delay
+            if (max_rst_dly is None) or (inst_max_rst_dly > max_rst_dly):
+                max_rst_dly = inst_max_rst_dly
+
+    if max_rst_dly is not None:
+        max_rst_dly = max(max(reset['delay'] for reset in inst_resets)
+            for inst_resets in resets.values())
 
         lines += [
             tab + f"reg [{max_rst_dly}:0] rstvec = '1;"
             '',
             tab + 'always @(posedge clk) begin'
         ]
 
@@ -298,96 +343,108 @@
             lines += [(2 * tab) + "rstvec <= 1'b0;"]
 
         lines += [
             tab + 'end',
             ''
         ]
 
-    if len(parameters) > 0:
-        lines += [tab + f'{design} #(']
-        for n, (key, value) in enumerate(parameters.items()):
-            line = (2 * tab) + f'.{key}({value})'
+    for instance, module in instances.items():
+        # start of the instantiation
 
-            if n != len(parameters) - 1:
-                line += ','
+        if len(parameters[instance]) > 0:
+            lines += [tab + f'{module} #(']
+            for n, (key, value) in enumerate(parameters[instance].items()):
+                line = (2 * tab) + f'.{key}({value})'
 
-            lines += [line]
-        lines += [tab + f') {design}_i (']
-    else:
-        lines += [tab + f'{design} {design}_i (']
+                if n != len(parameters[instance]) - 1:
+                    line += ','
 
-    connections = []
+                lines += [line]
+            lines += [tab + f') {instance} (']
+        else:
+            lines += [tab + f'{module} {instance} (']
 
-    # interfaces
+        connections = []
 
-    for name, value in interfaces.items():
-        type = value['type']
+        # interfaces
 
-        if type_is_sb(type):
-            connections += [f'`SB_CONNECT({name}, {name})']
-        elif type_is_umi(type):
-            connections += [f'`SB_UMI_CONNECT({name}, {name})']
-        elif type_is_axi(type):
-            connections += [f'`SB_AXI_CONNECT({name}, {name})']
-        elif type_is_axil(type):
-            connections += [f'`SB_AXIL_CONNECT({name}, {name})']
+        for name, value in interfaces[instance].items():
+            type = value['type']
+            wire = value['wire']
 
-    # clocks
+            if type_is_sb(type):
+                connections += [f'`SB_CONNECT({name}, {wire})']
+            elif type_is_umi(type):
+                connections += [f'`SB_UMI_CONNECT({name}, {wire})']
+            elif type_is_axi(type):
+                connections += [f'`SB_AXI_CONNECT({name}, {wire})']
+            elif type_is_axil(type):
+                connections += [f'`SB_AXIL_CONNECT({name}, {wire})']
 
-    for clock in clocks:
-        connections += [f'.{clock["name"]}(clk)']
+        # clocks
 
-    # resets
+        for clock in clocks[instance]:
+            connections += [f'.{clock["name"]}(clk)']
 
-    for reset in resets:
-        name = reset['name']
-        polarity = reset['polarity']
-        delay = reset['delay']
-
-        if polarity_is_positive(polarity):
-            value = f'rstvec[{delay}]'
-        elif polarity_is_negative(polarity):
-            value = f'~rstvec[{delay}]'
-        else:
-            raise ValueError(f'Unsupported reset polarity: "{polarity}"')
+        # resets
 
-        connections += [f'.{name}({value})']
+        for reset in resets[instance]:
+            name = reset['name']
+            polarity = reset['polarity']
+            delay = reset['delay']
 
-    # tieoffs
+            if polarity_is_positive(polarity):
+                value = f'rstvec[{delay}]'
+            elif polarity_is_negative(polarity):
+                value = f'~rstvec[{delay}]'
+            else:
+                raise ValueError(f'Unsupported reset polarity: "{polarity}"')
 
-    for key, value in tieoffs.items():
-        if value is None:
-            value = ''
-        else:
-            value = str(value)
-        connections += [f'.{key}({value})']
+            connections += [f'.{name}({value})']
 
-    for n, connection in enumerate(connections):
-        if n != len(connections) - 1:
-            connection += ','
-        lines += [(2 * tab) + connection]
+        # tieoffs
 
-    lines += [tab + ');']
-    lines += ['']
+        for key, value in tieoffs[instance].items():
+            if value is None:
+                value = ''
+            else:
+                value = str(value)
+            connections += [f'.{key}({value})']
+
+        for n, connection in enumerate(connections):
+            if n != len(connections) - 1:
+                connection += ','
+            lines += [(2 * tab) + connection]
+
+        lines += [tab + ');']
+        lines += ['']
 
-    # initialize queue connections
+    # initialize queue connections for this instance
 
     lines += [
         tab + 'string uri_sb_value;',
         '',
         tab + 'initial begin',
         (2 * tab) + '/* verilator lint_off IGNOREDRETURN */'
     ]
 
-    for name, value in interfaces.items():
-        lines += [
-            (2 * tab) + f'if($value$plusargs("{name}=%s", uri_sb_value)) begin',
-            (3 * tab) + f'{name}_sb_inst.init(uri_sb_value);',
-            (2 * tab) + 'end'
-        ]
+    for inst_interfaces in interfaces.values():
+        for value in inst_interfaces.values():
+            external = value['external']
+
+            if not external:
+                continue
+
+            wire = value['wire']
+
+            lines += [
+                (2 * tab) + f'if($value$plusargs("{wire}=%s", uri_sb_value)) begin',
+                (3 * tab) + f'{wire}_sb_inst.init(uri_sb_value);',
+                (2 * tab) + 'end'
+            ]
 
     lines += [
         (2 * tab) + '/* verilator lint_on IGNOREDRETURN */',
         tab + 'end'
     ]
 
     lines += ['']
```

## switchboard/network.py

```diff
@@ -1,17 +1,20 @@
 # Copyright (c) 2024 Zero ASIC Corporation
 # This code is licensed under Apache License 2.0 (see LICENSE for details)
 
+
+from pathlib import Path
 from copy import deepcopy
 from itertools import count
 
 from .sbdut import SbDut
 from .axi import axi_uris
 from .autowrap import (directions_are_compatible, normalize_intf_type,
-    type_is_umi, type_is_sb, create_intf_objs, type_is_axi, type_is_axil)
+    type_is_umi, type_is_sb, create_intf_objs, type_is_axi, type_is_axil,
+    autowrap)
 from .cmdline import get_cmdline_args
 
 from _switchboard import delete_queues
 
 
 class SbIntf:
     def __init__(self, inst, name):
@@ -20,95 +23,122 @@
 
 
 class SbInst:
     def __init__(self, name, block):
         self.name = name
         self.block = block
         self.mapping = {}
+        self.external = set()
 
         for name, value in block.intf_defs.items():
-            self.mapping[name] = None
+            self.mapping[name] = dict(uri=None, wire=None)
             self.__setattr__(name, SbIntf(inst=self, name=name))
 
 
 class SbNetwork:
     def __init__(self, cmdline=False, tool: str = 'verilator', trace: bool = False,
         trace_type: str = 'vcd', frequency: float = 100e6, period: float = None,
-        max_rate: float = None, start_delay: float = None, fast: bool = False,
-        extra_args: dict = None, cleanup: bool = True, args=None):
+        max_rate: float = -1, start_delay: float = None, fast: bool = False,
+        extra_args: dict = None, cleanup: bool = True, args=None,
+        single_netlist: bool = False, threads: int = None, name: str = None):
 
         self.insts = {}
 
         self.inst_name_set = set()
         self.inst_name_counters = {}
 
         self.uri_set = set()
         self.uri_counters = {}
 
-        self.intf_defs = {}
-
         if cmdline:
             self.args = get_cmdline_args(tool=tool, trace=trace, trace_type=trace_type,
                 frequency=frequency, period=period, fast=fast, max_rate=max_rate,
-                start_delay=start_delay, extra_args=extra_args)
+                start_delay=start_delay, single_netlist=single_netlist, threads=threads,
+                extra_args=extra_args)
         elif args is not None:
             self.args = args
         else:
             self.args = None
 
         if self.args is not None:
             trace = self.args.trace
             trace_type = self.args.trace_type
             fast = self.args.fast
             tool = self.args.tool
             frequency = self.args.frequency
             period = self.args.period
             max_rate = self.args.max_rate
             start_delay = self.args.start_delay
+            single_netlist = self.args.single_netlist
 
         # save settings
 
         self.tool = tool
         self.trace = trace
         self.trace_type = trace_type
         self.fast = fast
 
         if (period is None) and (frequency is not None):
             period = 1 / frequency
         self.period = period
         self.max_rate = max_rate
         self.start_delay = start_delay
 
+        self.single_netlist = single_netlist
+
+        if single_netlist:
+            self.dut = SbDut(args=self.args)
+        else:
+            self._intf_defs = {}
+
+        self.name = name
+
         if cleanup:
             import atexit
 
             def cleanup_func(uri_set=self.uri_set):
                 if len(uri_set) > 0:
                     delete_queues(list(uri_set))
 
             atexit.register(cleanup_func)
 
-    def instantiate(self, block: SbDut, name: str = None):
+    @property
+    def intf_defs(self):
+        if self.single_netlist:
+            return self.dut.intf_defs
+        else:
+            return self._intf_defs
+
+    def instantiate(self, block, name: str = None):
         # generate a name if needed
         if name is None:
-            name = self.generate_inst_name(prefix=block.dut)
+            if isinstance(block, SbDut):
+                prefix = block.dut
+            else:
+                prefix = block.name
+
+            assert prefix is not None, ('Cannot generate name for this instance.'
+                '  When block is an SbNetwork, make sure that its constructor set'
+                ' "name" if you want name generation to work here.')
+
+            name = self.generate_inst_name(prefix=prefix)
 
         # make sure the name hasn't been used already
         assert name not in self.inst_name_set
 
         # add the name to the set of names in use
         self.inst_name_set.add(name)
 
         # create the instance object
         self.insts[name] = SbInst(name=name, block=block)
 
         # return the instance object
         return self.insts[name]
 
-    def connect(self, a, b, uri=None):
+    def connect(self, a, b, uri=None, wire=None):
         # retrieve the two interface definitions
         intf_def_a = a.inst.block.intf_defs[a.name]
         intf_def_b = b.inst.block.intf_defs[b.name]
 
         # make sure that the interfaces are the same
         type_a = normalize_intf_type(intf_def_a['type'])
         type_b = normalize_intf_type(intf_def_b['type'])
@@ -116,56 +146,117 @@
 
         # make sure that the directions are compatible
         assert directions_are_compatible(type=type_a,
             a=intf_def_a['direction'], b=intf_def_b['direction'])
 
         # determine what the queue will be called that connects the two
 
+        if wire is None:
+            wire = f'{a.inst.name}_{a.name}_conn_{b.inst.name}_{b.name}'
+
         if uri is None:
-            uri = f'{a.inst.name}_{a.name}_conn_{b.inst.name}_{b.name}'
+            uri = wire
 
             if type_is_sb(type_a) or type_is_umi(type_a):
                 uri = uri + '.q'
 
-        self.register_uri(type=type_a, uri=uri)
+        if not self.single_netlist:
+            # internal connection, no need to register it for cleanup
+            self.register_uri(type=type_a, uri=uri)
 
         # tell both instances what they are connected to
-        a.inst.mapping[a.name] = uri
-        b.inst.mapping[b.name] = uri
+
+        a.inst.mapping[a.name]['wire'] = wire
+        b.inst.mapping[b.name]['wire'] = wire
+
+        a.inst.mapping[a.name]['uri'] = uri
+        b.inst.mapping[b.name]['uri'] = uri
 
     def build(self):
         unique_blocks = set(inst.block for inst in self.insts.values())
 
-        for block in unique_blocks:
-            block.build()
+        if self.single_netlist:
+            passthroughs = [
+                ('tool', 'verilator', 'task', 'compile', 'warningoff')
+            ]
+
+            for block in unique_blocks:
+                self.dut.input(block.package())
+
+                for passthrough in passthroughs:
+                    self.dut.add(*passthrough, block.get(*passthrough))
+
+            filename = Path(self.dut.get('option', 'builddir')).resolve() / 'testbench.sv'
+
+            filename.parent.mkdir(exist_ok=True, parents=True)
+
+            # populate the interfaces dictionary
+            interfaces = {}
+
+            for inst_name, inst in self.insts.items():
+                # make a copy of the interface definitions for this block
+                intf_defs = deepcopy(inst.block.intf_defs)
+
+                # wiring
+                for intf_name, props in inst.mapping.items():
+                    intf_defs[intf_name]['wire'] = props['wire']
+                    intf_defs[intf_name]['external'] = intf_name in inst.external
+
+                interfaces[inst_name] = intf_defs
+
+            # generate netlist that connects everything together, and input() it
+            self.dut.input(
+                autowrap(
+                    instances={inst.name: inst.block.dut for inst in self.insts.values()},
+                    toplevel='testbench',
+                    parameters={inst.name: inst.block.parameters for inst in self.insts.values()},
+                    interfaces=interfaces,
+                    clocks={inst.name: inst.block.clocks for inst in self.insts.values()},
+                    resets={inst.name: inst.block.resets for inst in self.insts.values()},
+                    tieoffs={inst.name: inst.block.tieoffs for inst in self.insts.values()},
+                    filename=filename
+                )
+            )
 
-    def external(self, intf, name=None, txrx=None, uri=None):
+            # build the single-netlist simulation
+            self.dut.build()
+        else:
+            for block in unique_blocks:
+                block.build()
+
+    def external(self, intf, name=None, txrx=None, uri=None, wire=None):
         # make a copy of the interface definition since we will be modifying it
 
         intf_def = deepcopy(intf.inst.block.intf_defs[intf.name])
 
         # generate URI if needed
 
         type = intf_def['type']
 
+        if wire is None:
+            wire = f'{intf.inst.name}_{intf.name}'
+
+        intf_def['wire'] = wire
+
         if uri is None:
-            uri = f'{intf.inst.name}_{intf.name}'
+            uri = wire
 
             if type_is_sb(type) or type_is_umi(type):
                 uri = uri + '.q'
 
+        intf_def['uri'] = uri
+
         # register the URI to make sure it doesn't collide with anything else
 
         self.register_uri(type=type, uri=uri)
 
         # propagate information about the URI mapping
 
-        intf_def['uri'] = uri
-
-        intf.inst.mapping[intf.name] = uri
+        intf.inst.mapping[intf.name] = dict(uri=uri, wire=wire)
+        intf.inst.external.add(intf.name)
 
         # set txrx
 
         intf_def['txrx'] = txrx
 
         # set max rate
 
@@ -178,57 +269,73 @@
             name = f'{intf.inst.name}_{intf.name}'
 
         assert name not in self.intf_defs, \
             f'Network already contains an external interface called "{name}".'
 
         self.intf_defs[name] = intf_def
 
-    def simulate(self):
+        return name
+
+    def simulate(self, start_delay=None, run=None, intf_objs=True):
+        # set defaults
+
+        if start_delay is None:
+            start_delay = self.start_delay
+
         # create interface objects
 
-        self.intfs = create_intf_objs(self.intf_defs)
+        if self.single_netlist:
+            self.dut.simulate(start_delay=start_delay, run=run, intf_objs=intf_objs)
+
+            if intf_objs:
+                self.intfs = self.dut.intfs
+        else:
+            if intf_objs:
+                self.intfs = create_intf_objs(self.intf_defs)
+
+            if start_delay is not None:
+                import time
+                start = time.time()
 
-        if self.start_delay is not None:
-            import time
-            start = time.time()
+            insts = self.insts.values()
 
-        insts = self.insts.values()
+            try:
+                from tqdm import tqdm
+                insts = tqdm(insts)
+            except ModuleNotFoundError:
+                pass
 
-        try:
-            from tqdm import tqdm
-            insts = tqdm(insts)
-        except ModuleNotFoundError:
-            pass
+            for inst in insts:
+                block = inst.block
 
-        for inst in insts:
-            block = inst.block
+                for intf_name, props in inst.mapping.items():
+                    # check that the interface is wired up
 
-            for intf_name, uri in inst.mapping.items():
-                # check that the interface is wired up
+                    uri = props['uri']
 
-                if uri is None:
-                    raise Exception(f'{inst.name}.{intf_name} not connected')
+                    if uri is None:
+                        raise Exception(f'{inst.name}.{intf_name} not connected')
 
-                block.intf_defs[intf_name]['uri'] = uri
+                    block.intf_defs[intf_name]['uri'] = uri
 
-            # calculate the start delay for this process by measuring the
-            # time left until the start delay for the whole network is over
+                # calculate the start delay for this process by measuring the
+                # time left until the start delay for the whole network is over
 
-            if self.start_delay is not None:
-                now = time.time()
-                dt = now - start
-                if dt < self.start_delay:
-                    start_delay = self.start_delay - dt
+                if start_delay is not None:
+                    now = time.time()
+                    dt = now - start
+                    if dt < start_delay:
+                        start_delay = start_delay - dt
+                    else:
+                        start_delay = None
                 else:
                     start_delay = None
-            else:
-                start_delay = None
 
-            # launch an instance of simulation
-            block.simulate(run=inst.name, intf_objs=False, start_delay=start_delay)
+                # launch an instance of simulation
+                block.simulate(start_delay=start_delay, run=inst.name, intf_objs=False)
 
     def generate_inst_name(self, prefix):
         if prefix not in self.inst_name_counters:
             self.inst_name_counters[prefix] = count(0)
 
         counter = self.inst_name_counters[prefix]
 
@@ -248,7 +355,32 @@
 
         assert self.uri_set.isdisjoint(uris)
 
         self.uri_set.update(uris)
 
         if fresh:
             delete_queues(uris)
+
+    def make_dut(self, *args, **kwargs):
+        # argument customizations
+
+        cfg = {}
+
+        cfg['args'] = self.args
+
+        if self.single_netlist:
+            cfg['autowrap'] = False
+            cfg['subcomponent'] = True
+        else:
+            cfg['autowrap'] = True
+            cfg['subcomponent'] = False
+
+        # add to keyword arguments without clobbering
+        # existing entries
+
+        kwargs = deepcopy(kwargs)
+
+        for k, v in cfg.items():
+            if k not in kwargs:
+                kwargs[k] = v
+
+        return SbDut(*args, **kwargs)
```

## Comparing `switchboard_hw-0.2.1.dist-info/LICENSE` & `switchboard_hw-0.2.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `switchboard_hw-0.2.1.dist-info/METADATA` & `switchboard_hw-0.2.2.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: switchboard-hw
-Version: 0.2.1
+Version: 0.2.2
 Summary: A low-latency communication library for RTL simulation and emulation.
 Home-page: https://github.com/zeroasiccorp/switchboard
 Author: Zero ASIC
 License: Apache License 2.0
 Project-URL: Documentation, https://zeroasiccorp.github.io/switchboard/
 Project-URL: Bug Tracker, https://github.com/zeroasiccorp/switchboard/issues
 Requires-Python: >=3.7
```

## Comparing `switchboard_hw-0.2.1.dist-info/RECORD` & `switchboard_hw-0.2.2.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,76 +1,83 @@
 _switchboard.cpython-39-x86_64-linux-gnu.so,sha256=HPe7IO3Ag_-bWQ3HHQ7Y1noWB9a3Ty3QK--wqsvfMK8,603792
-switchboard_hw-0.2.1.dist-info/LICENSE,sha256=2dqsbMlc1IxGnBJVsoUb3HtT1N0kAJnAGF9MBTqSjkw,10766
-switchboard_hw-0.2.1.dist-info/METADATA,sha256=Wx_n8IAtIXXewtnvXMi2nvvdOvOS4cMnwsI-HpB-oBE,18115
-switchboard_hw-0.2.1.dist-info/RECORD,,
-switchboard_hw-0.2.1.dist-info/top_level.txt,sha256=hDPbMY9dCMf4f2ObR5n7sLpXJwKaln0h0IvIDd_ufK8,25
-switchboard_hw-0.2.1.dist-info/entry_points.txt,sha256=6IqVCv_W_Wiyuzmje1pemxosVG_P2h35JiHyK0r2I7k,92
-switchboard_hw-0.2.1.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
-switchboard/icarus.py,sha256=jcxwNUN0Kb3OblY_kw_I41wDRcrPA26zACJWT0-CEYo,2088
-switchboard/sbdut.py,sha256=MIbmtwhndIK0V4XMSRSrUKcDwFoinw6DkFOAPSrev_c,25257
-switchboard/gpio.py,sha256=HReAzzVoiN3MM1Xr7SstkIIr3gdV6n-BZNrdxwdfGrc,2706
-switchboard/umi.py,sha256=6N3yFnvFmN3jXzsaVUFCluNoj2Xd5xjUVMK0W-PMf_0,26939
-switchboard/uart_xactor.py,sha256=5LEA0lVYo4483wOcSwyCIO26LkHJwloA5LkldrpJwjU,1701
-switchboard/switchboard.py,sha256=DZI1pao3WQEAlPyQxSZPcH57NwM4epPfeuch48vsSLI,1506
-switchboard/test_util.py,sha256=uHfOKfoAerTzp5FaAswxadUWzIp5nv9MABZZUN_qDE0,1311
-switchboard/cmdline.py,sha256=B8f5d2-jVVZF7RrY2QppkgyTF2JzEy5bXMvh7uZfCnk,4902
-switchboard/autowrap.py,sha256=h9rpGfhVmivqw1q54nxQAVImMkXvETZa8dqYk24m6jQ,17506
-switchboard/network.py,sha256=RDFPpV1v86Rxsw0K81Jgw4ScjuE5YFXXQSVGn1Ft140,7465
-switchboard/sbtcp.py,sha256=aKMF-kdWP33S9C2V8scAaigTK62pmfAXvp7LdPZ3ixc,8247
-switchboard/axil.py,sha256=KNGbqNKdq0Pybzxt1I8KDvIG-bPnFv6B7A2fDHa_0e8,12870
+switchboard_hw-0.2.2.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
+switchboard_hw-0.2.2.dist-info/LICENSE,sha256=2dqsbMlc1IxGnBJVsoUb3HtT1N0kAJnAGF9MBTqSjkw,10766
+switchboard_hw-0.2.2.dist-info/top_level.txt,sha256=hDPbMY9dCMf4f2ObR5n7sLpXJwKaln0h0IvIDd_ufK8,25
+switchboard_hw-0.2.2.dist-info/entry_points.txt,sha256=6IqVCv_W_Wiyuzmje1pemxosVG_P2h35JiHyK0r2I7k,92
+switchboard_hw-0.2.2.dist-info/RECORD,,
+switchboard_hw-0.2.2.dist-info/METADATA,sha256=bztkejc-RGCdipwrNalGL8ySrwi6oTNsK9Aj2Vfq1ko,18115
 switchboard/__init__.py,sha256=934rQoi9b81uBx1cGmM2C6PDTFn8tppRA6B1CNPjA7s,941
-switchboard/ams.py,sha256=6nLQZ2qha5gvaeLHiCxDQCIn2P3lFswnOrYh_HTIOTs,18067
-switchboard/loopback.py,sha256=Zx1wBDrXYpUdoV04ru4QG5LfDMy59n91PTeE2eoST88,5246
-switchboard/warn.py,sha256=YLI6T_WrB3mPcASvSqrSa6Nkj5X84HofPm0TOZDS4s8,311
-switchboard/bitvector.py,sha256=ER5c-SRIebnDYch_CfTyy0b6Uw5SlYlY2CmKatHoH0M,3398
+switchboard/test_util.py,sha256=hIC3p4v6sjanwDSUKEt-IjA2OuAkMf7_sxk6Rsp9aVw,1333
+switchboard/cmdline.py,sha256=oQPL3Zo8RZteQSr5kmYlb_kSd4wOwnFjWQMPEdhW-Sc,5598
 switchboard/xyce.py,sha256=sZ02vJn0PujzuIbxZ4lKaoggmQVrBdQjMzZWUNfayuo,547
+switchboard/axil.py,sha256=KNGbqNKdq0Pybzxt1I8KDvIG-bPnFv6B7A2fDHa_0e8,12870
+switchboard/axi.py,sha256=wH-dI2cCH-A8K1QvbE14diBpbbwP3UjCWYwyukD4pvw,19799
+switchboard/autowrap.py,sha256=z4sDMJxbpy5vh8c-ouhgi259_LYto201kYkbFXqpVZY,19774
+switchboard/warn.py,sha256=YLI6T_WrB3mPcASvSqrSa6Nkj5X84HofPm0TOZDS4s8,311
+switchboard/sbtcp.py,sha256=aKMF-kdWP33S9C2V8scAaigTK62pmfAXvp7LdPZ3ixc,8247
 switchboard/util.py,sha256=bE6ZcgbvYGU3agXMH3IO1Y2ZYJIBGWt5cb8z-6kYvSc,2341
+switchboard/icarus.py,sha256=jcxwNUN0Kb3OblY_kw_I41wDRcrPA26zACJWT0-CEYo,2088
+switchboard/uart_xactor.py,sha256=5LEA0lVYo4483wOcSwyCIO26LkHJwloA5LkldrpJwjU,1701
+switchboard/umi.py,sha256=6N3yFnvFmN3jXzsaVUFCluNoj2Xd5xjUVMK0W-PMf_0,26939
+switchboard/loopback.py,sha256=Zx1wBDrXYpUdoV04ru4QG5LfDMy59n91PTeE2eoST88,5246
+switchboard/network.py,sha256=SmIMXzoAzsxzgeMW1v06faxWBj5QCz2opt2k5DBQgsA,11902
 switchboard/verilator.py,sha256=apmqm_a49mSqvBN08lRHrDjmxl-ChU3rgYElq5alzTo,1012
-switchboard/axi.py,sha256=wH-dI2cCH-A8K1QvbE14diBpbbwP3UjCWYwyukD4pvw,19799
-switchboard/verilog/fpga/memory_fault.sv,sha256=Hs0M3P-pxHuavDB2WVWnh0vY2CIuC7ZRIqJFvdU3K9c,1005
-switchboard/verilog/fpga/axi_reader.sv,sha256=BvKRDDss7rhXbd9QRCioXzTSVWhbIWbw1gIGYavVfck,2061
-switchboard/verilog/fpga/sb_tx_fpga.sv,sha256=fE94Vrdgbom_8sXonBh9hDcJtxitMA-AwIwLokxmMrI,7608
-switchboard/verilog/fpga/axi_writer.sv,sha256=47DH1wXOs-OErNpvBpQ0qYuodBgeS75SwZf8KQyrZ5I,3171
-switchboard/verilog/fpga/sb_rx_fpga.sv,sha256=Ophq7CC_fxkgqIPs0gSQyOiVY1toC28Do4AD0HGcqRk,7821
-switchboard/verilog/fpga/sb_fpga_queues.sv,sha256=MSEjp52no5YpKXnYjVK5YEi_n7fMj41XfNcW04GqnPA,13623
-switchboard/verilog/fpga/umi_fpga_queues.sv,sha256=DeZ_0ibOvJ7JRMr7QoiTZ_wRpwkbsWKgCzlXlQQROOw,4341
-switchboard/verilog/fpga/config_registers.sv,sha256=Nec_5D30NgIVekjdqhIVbkeUUREdduzTsetj68WiOyY,8478
-switchboard/verilog/fpga/include/sb_queue_regmap.vh,sha256=_HUvT4wceII4hi_m2f46y32FDjczWq4Z5mablfDr3OE,789
-switchboard/verilog/fpga/include/spsc_queue.vh,sha256=Ae640uy8p9r8mdojX1jrfb2c3iKayTMf_2tPj31i8lU,272
-switchboard/verilog/common/umi_gpio.v,sha256=CGdrTZ8Uik7q8qI3lA6AHtdWL0UbOHojWGSzFmWtOoA,7590
-switchboard/verilog/common/switchboard.vh,sha256=AjmrzJFuGdAfnQ5aR2gI4eqs4IhYzq9GXqIj_Z7t6Yo,31459
+switchboard/switchboard.py,sha256=DZI1pao3WQEAlPyQxSZPcH57NwM4epPfeuch48vsSLI,1506
+switchboard/bitvector.py,sha256=ER5c-SRIebnDYch_CfTyy0b6Uw5SlYlY2CmKatHoH0M,3398
+switchboard/sbdut.py,sha256=Ur37lus4XF0TvxarK731-GE0TsacNlSLXcXU6OkN4LY,28459
+switchboard/gpio.py,sha256=HReAzzVoiN3MM1Xr7SstkIIr3gdV6n-BZNrdxwdfGrc,2706
+switchboard/ams.py,sha256=6nLQZ2qha5gvaeLHiCxDQCIn2P3lFswnOrYh_HTIOTs,18067
+switchboard/cpp/pciedev.h,sha256=wyLaeCYBjvn8FZi-2JTNqOG2Ko5VR7zBUEmQHJ2_Mrg,4047
+switchboard/cpp/pagemap.h,sha256=AfydFiJNa6buIfOc24bMMhxd_JKL74zwSa8SsY9JIgQ,2376
+switchboard/cpp/xyce.hpp,sha256=pBJ8gEArUoUSL-KoQWYuxCV7y2MrJqozAWxV5g5h2RE,2351
+switchboard/cpp/switchboard.hpp,sha256=Y1fUV7cjRIPgenOe_PWlGLsKGSb4Mr1BZ9-cUKwutKg,6064
+switchboard/cpp/spsc_queue.h,sha256=D2EmoLVLh7fShsoL51eVW29TN7FF5Wq48Yt5_wFdJt0,6479
+switchboard/cpp/umilib.hpp,sha256=ktxWbbj0Lx6xAPJFryF121Sh2_v6PL6W_zqq0e9AJug,3809
+switchboard/cpp/Makefile,sha256=-xItDPwG4HxKLoxqUix9jWLXK5oRN44erXFG99HCPKo,291
+switchboard/cpp/bitutil.h,sha256=kTj81I2lVfN1QFXgX_plMH8zeBpERqcFJ8pmwivPoBs,979
+switchboard/cpp/umisb.hpp,sha256=zfxFK1LhUv5_z9l0HZF4KGUQQ-yTcR9ZTCt0US3adxs,9987
+switchboard/cpp/router.cc,sha256=VcNZ49M00iZFsftcC-YadQH22kR0B7Kcof_jF2H8Pj0,2786
+switchboard/cpp/switchboard_pcie.hpp,sha256=-p00WsgH3y-Hhxjb-ixXKwZYRsuuR4AjR2pMPcgVVIM,6188
+switchboard/cpp/switchboard_tlm.hpp,sha256=jUA1Ixb6SnuRz_auH0QzBZn26ATeR-H3a9vCuaKZhCc,2514
+switchboard/cpp/umilib.h,sha256=O0jjh_CtRCLRFuWyQL3B5LkpHdaStwg5VGJGaV2QZQ0,4477
 switchboard/verilog/common/uart_xactor.sv,sha256=XALJOleyOtV-TIawBBYO0YXYwnjezZjxCyfN27TB-q8,7372
+switchboard/verilog/common/switchboard.vh,sha256=AjmrzJFuGdAfnQ5aR2gI4eqs4IhYzq9GXqIj_Z7t6Yo,31459
+switchboard/verilog/common/umi_gpio.v,sha256=CGdrTZ8Uik7q8qI3lA6AHtdWL0UbOHojWGSzFmWtOoA,7590
+switchboard/verilog/sim/umi_rx_sim.sv,sha256=rqlO4l9nDQLelacmU2mnk9D0L3qfTlnmFOgE9FBslbk,1423
+switchboard/verilog/sim/sb_to_queue_sim.sv,sha256=UCY5buiLxcWeW8MjmaI378hEPV3AdSfiJdzo7zL7sqg,6424
 switchboard/verilog/sim/sb_axi_m.sv,sha256=gxfzhZqNCZH_zt0Ov2ODBxtPqeugBPux3tpql5vpdIU,5670
+switchboard/verilog/sim/xyce_intf.sv,sha256=PVC5BDCWjn3-nzHvkJ_GwonqWMsf3pI0XXscPgSFPwA,1902
 switchboard/verilog/sim/sb_jtag_rbb_sim.sv,sha256=fC64xh3sd7HwPhB95cvKubNHp1WwhtgempRbNqcwnsU,4556
-switchboard/verilog/sim/sb_clk_gen.sv,sha256=fwTCvi1Z6ZjpIbVvtdKqJBCaA4JIkxcrDPMv2jl_Zr4,2207
-switchboard/verilog/sim/perf_meas_sim.sv,sha256=l40bL8V5A_ofiYm03RfWarcka_7WTSjj_3uROpFkbHY,3310
 switchboard/verilog/sim/sb_tx_sim.sv,sha256=57cvx6pEUbwH5e1pZJezNoGdRU_VcfNYGhUO_4zt6Hk,1283
 switchboard/verilog/sim/sb_axil_s.sv,sha256=-VYjEgnuOqs8B59GWy9ualRAxRoUskJVu6WgAA730KY,4577
-switchboard/verilog/sim/sb_rx_sim.sv,sha256=_lZNoC2ltrH7VepawVPmu1Yz5-lALnB0tfq7llmbNzg,1286
-switchboard/verilog/sim/umi_tx_sim.sv,sha256=oYEtgVWaouKLC69IP7FpQS0ru4tYBGL0IVsHDPKMAO8,1419
 switchboard/verilog/sim/queue_to_sb_sim.sv,sha256=Ek-FJaYDGbpIDVACnx4ovxDlJqJJAv-iVY-K38Kxe5M,5504
-switchboard/verilog/sim/umi_rx_sim.sv,sha256=rqlO4l9nDQLelacmU2mnk9D0L3qfTlnmFOgE9FBslbk,1423
-switchboard/verilog/sim/xyce_intf.sv,sha256=PVC5BDCWjn3-nzHvkJ_GwonqWMsf3pI0XXscPgSFPwA,1902
-switchboard/verilog/sim/queue_to_umi_sim.sv,sha256=yJw-lBE_UjuKZbwO5ZmxgkLL1Wf1m7Ctue2FmRZLkNA,1506
+switchboard/verilog/sim/perf_meas_sim.sv,sha256=l40bL8V5A_ofiYm03RfWarcka_7WTSjj_3uROpFkbHY,3310
+switchboard/verilog/sim/sb_clk_gen.sv,sha256=fwTCvi1Z6ZjpIbVvtdKqJBCaA4JIkxcrDPMv2jl_Zr4,2207
+switchboard/verilog/sim/umi_to_queue_sim.sv,sha256=aINQWMTK3-iC1NHBeAJ4O3BDhOsfg6I9GhQvDAuwfhE,1535
+switchboard/verilog/sim/umi_tx_sim.sv,sha256=oYEtgVWaouKLC69IP7FpQS0ru4tYBGL0IVsHDPKMAO8,1419
 switchboard/verilog/sim/auto_stop_sim.sv,sha256=DqWknItCjgUdLS04FknzGMdU3q3H04CmKlzA5Go39EY,468
+switchboard/verilog/sim/queue_to_umi_sim.sv,sha256=yJw-lBE_UjuKZbwO5ZmxgkLL1Wf1m7Ctue2FmRZLkNA,1506
 switchboard/verilog/sim/sb_axil_m.sv,sha256=5lqwtmf2rkv_V0AarHeyCFcmMv9106bPNtC8-amuPKE,4577
-switchboard/verilog/sim/sb_to_queue_sim.sv,sha256=UCY5buiLxcWeW8MjmaI378hEPV3AdSfiJdzo7zL7sqg,6424
-switchboard/verilog/sim/umi_to_queue_sim.sv,sha256=aINQWMTK3-iC1NHBeAJ4O3BDhOsfg6I9GhQvDAuwfhE,1535
+switchboard/verilog/sim/sb_rx_sim.sv,sha256=_lZNoC2ltrH7VepawVPmu1Yz5-lALnB0tfq7llmbNzg,1286
+switchboard/verilog/fpga/sb_rx_fpga.sv,sha256=Ophq7CC_fxkgqIPs0gSQyOiVY1toC28Do4AD0HGcqRk,7821
+switchboard/verilog/fpga/sb_tx_fpga.sv,sha256=fE94Vrdgbom_8sXonBh9hDcJtxitMA-AwIwLokxmMrI,7608
+switchboard/verilog/fpga/memory_fault.sv,sha256=Hs0M3P-pxHuavDB2WVWnh0vY2CIuC7ZRIqJFvdU3K9c,1005
+switchboard/verilog/fpga/umi_fpga_queues.sv,sha256=DeZ_0ibOvJ7JRMr7QoiTZ_wRpwkbsWKgCzlXlQQROOw,4341
+switchboard/verilog/fpga/sb_fpga_queues.sv,sha256=MSEjp52no5YpKXnYjVK5YEi_n7fMj41XfNcW04GqnPA,13623
+switchboard/verilog/fpga/config_registers.sv,sha256=Nec_5D30NgIVekjdqhIVbkeUUREdduzTsetj68WiOyY,8478
+switchboard/verilog/fpga/axi_reader.sv,sha256=BvKRDDss7rhXbd9QRCioXzTSVWhbIWbw1gIGYavVfck,2061
+switchboard/verilog/fpga/axi_writer.sv,sha256=47DH1wXOs-OErNpvBpQ0qYuodBgeS75SwZf8KQyrZ5I,3171
+switchboard/verilog/fpga/include/spsc_queue.vh,sha256=Ae640uy8p9r8mdojX1jrfb2c3iKayTMf_2tPj31i8lU,272
+switchboard/verilog/fpga/include/sb_queue_regmap.vh,sha256=_HUvT4wceII4hi_m2f46y32FDjczWq4Z5mablfDr3OE,789
 switchboard/dpi/xyce_dpi.cc,sha256=czJOYoBvAHXBYWLn88Ua9M6oPX1-7a56Gjf0W0skWeo,1103
 switchboard/dpi/switchboard_dpi.cc,sha256=dWl2s6_G3orzDaYIWFsBWbtgHYfcH5cVicu0hoqHnnQ,3469
-switchboard/verilator/config.vlt,sha256=3M7kr2VAnIBS8zEJUFKiJtq-aZrinXHk9itZOn3MlTs,526
 switchboard/verilator/testbench.cc,sha256=bGAcj82luYYm9Gapd4VQQiTJSAE6J__cEiJboEDwENQ,4571
+switchboard/verilator/config.vlt,sha256=3M7kr2VAnIBS8zEJUFKiJtq-aZrinXHk9itZOn3MlTs,526
 switchboard/vpi/switchboard_vpi.cc,sha256=rZeZ9N-KuT97KG7jvtKOUMipY5JgPesMhtsz-lhDXIs,11038
 switchboard/vpi/xyce_vpi.cc,sha256=VyAFGyUztbllLnXYhhmr2PAkUwGE124XZ9haSRWONKg,4954
-switchboard/cpp/Makefile,sha256=-xItDPwG4HxKLoxqUix9jWLXK5oRN44erXFG99HCPKo,291
-switchboard/cpp/switchboard_pcie.hpp,sha256=-p00WsgH3y-Hhxjb-ixXKwZYRsuuR4AjR2pMPcgVVIM,6188
-switchboard/cpp/xyce.hpp,sha256=pBJ8gEArUoUSL-KoQWYuxCV7y2MrJqozAWxV5g5h2RE,2351
-switchboard/cpp/bitutil.h,sha256=kTj81I2lVfN1QFXgX_plMH8zeBpERqcFJ8pmwivPoBs,979
-switchboard/cpp/umisb.hpp,sha256=zfxFK1LhUv5_z9l0HZF4KGUQQ-yTcR9ZTCt0US3adxs,9987
-switchboard/cpp/pagemap.h,sha256=AfydFiJNa6buIfOc24bMMhxd_JKL74zwSa8SsY9JIgQ,2376
-switchboard/cpp/spsc_queue.h,sha256=D2EmoLVLh7fShsoL51eVW29TN7FF5Wq48Yt5_wFdJt0,6479
-switchboard/cpp/router.cc,sha256=VcNZ49M00iZFsftcC-YadQH22kR0B7Kcof_jF2H8Pj0,2786
-switchboard/cpp/switchboard.hpp,sha256=Y1fUV7cjRIPgenOe_PWlGLsKGSb4Mr1BZ9-cUKwutKg,6064
-switchboard/cpp/umilib.hpp,sha256=ktxWbbj0Lx6xAPJFryF121Sh2_v6PL6W_zqq0e9AJug,3809
-switchboard/cpp/switchboard_tlm.hpp,sha256=jUA1Ixb6SnuRz_auH0QzBZn26ATeR-H3a9vCuaKZhCc,2514
-switchboard/cpp/umilib.h,sha256=O0jjh_CtRCLRFuWyQL3B5LkpHdaStwg5VGJGaV2QZQ0,4477
-switchboard/cpp/pciedev.h,sha256=wyLaeCYBjvn8FZi-2JTNqOG2Ko5VR7zBUEmQHJ2_Mrg,4047
+switchboard/sc/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+switchboard/sc/morty/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+switchboard/sc/morty/uniquify.py,sha256=dXYLQeUn_K5WGbNJ79Vfp8DnEKfDPFSOdPiwr3HYyQk,1790
+switchboard/sc/morty/morty.py,sha256=I4ePKQNqigyOzAQk5SACNctnJf2r1mSWoG2qQwBculM,353
+switchboard/sc/sed/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+switchboard/sc/sed/remove.py,sha256=_k6vPMYFEOEOdQkLHUw0-bYiZTV179oT0xzHCxocGpg,1082
+switchboard/sc/sed/sed.py,sha256=2uouVwTAkur-LTbrON31L8Sai-w_SD_L8Va1qs5rxKI,238
```

