# Comparing `tmp/zibuyu_llm-2.1.20-py3-none-any.whl.zip` & `tmp/zibuyu_llm-2.1.22-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,23 @@
-Zip file size: 79074 bytes, number of entries: 21
+Zip file size: 79274 bytes, number of entries: 21
 -rw-rw-rw-  2.0 fat      305 b- defN 24-May-11 08:41 zibuyu_llm_api/__init__.py
 -rw-rw-rw-  2.0 fat    30976 b- defN 24-May-16 04:34 zibuyu_llm_api/minmax_api.py
 -rw-rw-rw-  2.0 fat      965 b- defN 24-May-19 04:58 zibuyu_llm_web/__init__.py
--rw-rw-rw-  2.0 fat     7376 b- defN 24-May-11 14:22 zibuyu_llm_web/baichuan.py
+-rw-rw-rw-  2.0 fat     7453 b- defN 24-May-20 13:39 zibuyu_llm_web/baichuan.py
 -rw-rw-rw-  2.0 fat     8509 b- defN 24-May-17 16:48 zibuyu_llm_web/base.py
--rw-rw-rw-  2.0 fat    15556 b- defN 24-May-17 16:17 zibuyu_llm_web/deepseek.py
--rw-rw-rw-  2.0 fat     2783 b- defN 24-May-17 13:53 zibuyu_llm_web/emohaa.py
+-rw-rw-rw-  2.0 fat    15842 b- defN 24-May-20 13:39 zibuyu_llm_web/deepseek.py
+-rw-rw-rw-  2.0 fat     2802 b- defN 24-May-20 13:39 zibuyu_llm_web/emohaa.py
 -rw-rw-rw-  2.0 fat      807 b- defN 24-May-12 10:11 zibuyu_llm_web/errors.py
--rw-rw-rw-  2.0 fat    11618 b- defN 24-May-19 08:53 zibuyu_llm_web/kimi.py
--rw-rw-rw-  2.0 fat    11531 b- defN 24-May-17 16:17 zibuyu_llm_web/metaso.py
--rw-rw-rw-  2.0 fat    45441 b- defN 24-May-19 08:59 zibuyu_llm_web/minmax.py
--rw-rw-rw-  2.0 fat    37730 b- defN 24-May-11 13:49 zibuyu_llm_web/qwen.py
--rw-rw-rw-  2.0 fat    14134 b- defN 24-May-18 12:42 zibuyu_llm_web/step_chat.py
+-rw-rw-rw-  2.0 fat    11810 b- defN 24-May-20 13:39 zibuyu_llm_web/kimi.py
+-rw-rw-rw-  2.0 fat    11752 b- defN 24-May-20 13:39 zibuyu_llm_web/metaso.py
+-rw-rw-rw-  2.0 fat    46017 b- defN 24-May-20 13:39 zibuyu_llm_web/minmax.py
+-rw-rw-rw-  2.0 fat    38067 b- defN 24-May-20 13:39 zibuyu_llm_web/qwen.py
+-rw-rw-rw-  2.0 fat    14284 b- defN 24-May-20 13:39 zibuyu_llm_web/step_chat.py
 -rw-rw-rw-  2.0 fat     5393 b- defN 24-May-19 07:11 zibuyu_llm_web/types.py
--rw-rw-rw-  2.0 fat     8097 b- defN 24-May-17 14:20 zibuyu_llm_web/wanxiang.py
+-rw-rw-rw-  2.0 fat     8152 b- defN 24-May-20 13:39 zibuyu_llm_web/wanxiang.py
 -rw-rw-rw-  2.0 fat    14705 b- defN 24-May-17 14:20 zibuyu_llm_web/xinchen.py
--rw-rw-rw-  2.0 fat    62458 b- defN 24-May-16 05:13 zibuyu_llm_web/xunfei.py
--rw-rw-rw-  2.0 fat      857 b- defN 24-May-19 08:59 zibuyu_llm-2.1.20.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-May-19 08:59 zibuyu_llm-2.1.20.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       30 b- defN 24-May-19 08:59 zibuyu_llm-2.1.20.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1707 b- defN 24-May-19 08:59 zibuyu_llm-2.1.20.dist-info/RECORD
-21 files, 281070 bytes uncompressed, 76330 bytes compressed:  72.8%
+-rw-rw-rw-  2.0 fat    63160 b- defN 24-May-20 13:39 zibuyu_llm_web/xunfei.py
+-rw-rw-rw-  2.0 fat      857 b- defN 24-May-20 13:41 zibuyu_llm-2.1.22.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-May-20 13:41 zibuyu_llm-2.1.22.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       30 b- defN 24-May-20 13:41 zibuyu_llm-2.1.22.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1707 b- defN 24-May-20 13:41 zibuyu_llm-2.1.22.dist-info/RECORD
+21 files, 283685 bytes uncompressed, 76530 bytes compressed:  73.0%
```

## zipnote {}

```diff
@@ -45,20 +45,20 @@
 
 Filename: zibuyu_llm_web/xinchen.py
 Comment: 
 
 Filename: zibuyu_llm_web/xunfei.py
 Comment: 
 
-Filename: zibuyu_llm-2.1.20.dist-info/METADATA
+Filename: zibuyu_llm-2.1.22.dist-info/METADATA
 Comment: 
 
-Filename: zibuyu_llm-2.1.20.dist-info/WHEEL
+Filename: zibuyu_llm-2.1.22.dist-info/WHEEL
 Comment: 
 
-Filename: zibuyu_llm-2.1.20.dist-info/top_level.txt
+Filename: zibuyu_llm-2.1.22.dist-info/top_level.txt
 Comment: 
 
-Filename: zibuyu_llm-2.1.20.dist-info/RECORD
+Filename: zibuyu_llm-2.1.22.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## zibuyu_llm_web/baichuan.py

```diff
@@ -140,40 +140,40 @@
                 continue
 
             # 正常AI交互时接收的是bytes类型数据，如果出现str类型数据，说明cookies过期或cookies不合法
             # if isinstance(chunk, bytes):
             #     print('接收到bytes数据')
 
             if isinstance(chunk, str):
-                self.logger.error("cookies过期，需要重新登录")
-                raise NeedLoginError("cookies过期，需要重新登录")
+                self.logger.error("[BaiChuan] cookies过期，需要重新登录")
+                raise NeedLoginError("[BaiChuan] cookies过期，需要重新登录")
 
             chunk_str = chunk.decode().strip()
             pending += chunk_str
 
             # Incomplete chunk
             if not chunk_str.endswith("}"):
-                self.logger.debug("The chunk is incomplete.")
+                self.logger.debug("[BaiChuan] The chunk is incomplete.")
                 continue
 
-            self.logger.debug(f"Receive a chunk and this chunk is complete.")
+            self.logger.debug(f"[BaiChuan] Receive a chunk and this chunk is complete.")
 
             resp_json = json.loads(pending)
             pending = ''
 
             if 'answer' not in resp_json:
                 continue
 
             answer_chunk = resp_json.get("answer", {}).get("data", "")
             self.single_answer += answer_chunk
 
             if callable(callback_func):
                 try:
                     callback_func(answer_chunk)
-                    self.logger.debug(f"{callback_func.__name__} be executed successfully.")
+                    self.logger.debug(f"[BaiChuan] {callback_func.__name__} be executed successfully.")
                 except:
                     pass
 
             if 'usage' in resp_json:
                 self.input_tokens += resp_json.get("usage", {}).get("prompt_tokens", 0)
                 self.output_tokens += resp_json.get("usage", {}).get("answer_tokens", 0)
 
@@ -202,15 +202,15 @@
             headers=self.headers
         )
 
         data = result.json()
         code = data.get("code")
 
         if code != 200:
-            self.logger.error(f"获取会话列表失败，错误码：{code}")
+            self.logger.error(f"[BaiChuan] 获取会话列表失败，错误码：{code}")
 
         session_list = []
         data = data.get("data", {})
         for session in data:
             session_obj = BaiChuanSession(**session)
             session_list.append(session_obj)
 
@@ -228,15 +228,15 @@
         )
 
         resp_data = result.json()
 
         code = resp_data.get("code")
 
         if code != 200:
-            self.logger.error(f"获取会话历史记录失败，错误码：{code}")
+            self.logger.error(f"[BaiChuan] 获取会话历史记录失败，错误码：{code}")
             return []
 
         data = resp_data.get("data", [])
         chat_list = []
         for chat in data:
             chat_obj = BaiChuanChat(**chat)
             chat_list.append(chat_obj)
```

## zibuyu_llm_web/deepseek.py

```diff
@@ -120,31 +120,31 @@
             headers=headers,
             json=data,
             stream=True,
             timeout=60
         )
 
         if response.status_code != 200:
-            self.logger.error(f'请求失败，响应状态码为：【{response.status_code}】')
+            self.logger.error(f'[DeepSeek] 请求失败，响应状态码为：【{response.status_code}】')
             return
 
         padding = ''
         for line in response.iter_lines():
 
             if not line:
                 continue
 
             padding += line.decode('utf-8')
 
             if not padding.endswith('}'):
                 continue
 
             if not padding.startswith('data'):
-                self.logger.error(f'请求不正常，响应数据为：【{padding}】')
-                raise NeedLoginError("cookies可能过期了，需要重新登录")
+                self.logger.error(f'[DeepSeek] 请求不正常，响应数据为：【{padding}】')
+                raise NeedLoginError("[DeepSeek] cookies可能过期了，需要重新登录")
 
             data = json.loads(padding[6:])
             padding = ''
 
             self.__single_padding = data.get('choices', [])[0].get('delta', {}).get('content', {})
 
             if callable(callback_func):
@@ -156,15 +156,15 @@
             finish_reason = data.get('choices', [])[0].get('finish_reason', {})
 
             if finish_reason == 'stop':
                 if callable(callback_func):
                     try:
                         callback_func(self.end_signal)
                     except:
-                        self.logger.error(f'回调函数【{callback_func.__name__}】执行失败', exc_info=True)
+                        self.logger.error(f'[DeepSeek] 回调函数【{callback_func.__name__}】执行失败', exc_info=True)
 
             if self.__single_padding:
                 self.__single_answer += self.__single_padding
 
         self.single_answer_obj.content = self.__single_answer
         self.single_answer_obj.is_success = True
 
@@ -189,15 +189,15 @@
                 headers=headers,
                 params=params
             )
 
             resp_json = response.json()
             return resp_json
         except:
-            self.logger.error(f'get_history方法请求失败！')
+            self.logger.error(f'[DeepSeek] get_history方法请求失败！')
 
     def login(self) -> bool:
         """登录"""
 
         uri = '/api/v0/users/login'
 
         if self.account_email:
@@ -211,15 +211,15 @@
             data = {
                 "email": "",
                 "mobile": self.account_phone,
                 "password": self.password,
                 "area_code": "+86"
             }
         else:
-            self.logger.error('未传入账号信息【手机号或邮箱】，停止登录')
+            self.logger.error('[DeepSeek] 未传入账号信息【手机号或邮箱】，停止登录')
             return False
 
         headers = self.__headers.copy()
 
         headers['Content-Type'] = 'application/json'
 
         try:
@@ -228,24 +228,24 @@
                 headers=headers,
                 json=data
             )
 
             resp_json = response.json()
 
             if response.status_code != 200:
-                self.logger.error(f'登录失败，响应数据: 【{resp_json}】')
+                self.logger.error(f'[DeepSeek] 登录失败，响应数据: 【{resp_json}】')
                 return False
 
             self._token = resp_json.get('data', {}).get('user', {}).get('token')
 
             if not self.token:
-                self.logger.error(f'登录失败，响应数据: 【{resp_json}】')
+                self.logger.error(f'[DeepSeek] 登录失败，响应数据: 【{resp_json}】')
                 return False
 
-            self.logger.info(f'登录成功，获取到请求Token')
+            self.logger.info(f'[DeepSeek] 登录成功，获取到请求Token')
             return True
         except:
             return False
 
     def clear_content(self) -> bool:
 
         uri = '/api/v0/chat/clear_context'
@@ -265,18 +265,18 @@
             json=data
         )
 
         resp_json = response.json()
         code = resp_json.get('code')
 
         if code == 0:
-            self.logger.info(f'清除上下文成功')
+            self.logger.info(f'[DeepSeek] 清除上下文成功')
             return True
         else:
-            self.logger.error(f'清除上下文失败，响应数据: 【{resp_json}】')
+            self.logger.error(f'[DeepSeek] 清除上下文失败，响应数据: 【{resp_json}】')
             return False
 
     def ask_code(self, question: str, callback_func=None) -> AiAnswer:
         """
         代码助手
         :param question:
         :param callback_func:
@@ -285,19 +285,19 @@
         model = "deepseek_code"
 
         for i in range(3):
 
             try:
                 return self.__ask(question, model, callback_func=callback_func)
             except:
-                self.logger.error(f'ask_code方法请求失败！', exc_info=True)
-                self.logger.info(f'尝试重新登录，后再发送请求。')
+                self.logger.error(f'[DeepSeek] ask_code方法请求失败！', exc_info=True)
+                self.logger.info(f'[DeepSeek] 尝试重新登录，后再发送请求。')
 
                 if not self.login():
-                    self.logger.error(f'重新登录失败')
+                    self.logger.error(f'[DeepSeek] 重新登录失败')
                     return self.single_answer_obj
 
     def ask(self, question: str, callback_func=None) -> AiAnswer:
         """
         通用助手
         :param question:
         :param callback_func:
@@ -307,19 +307,19 @@
         model = "deepseek_chat"
 
         for i in range(3):
 
             try:
                 return self.__ask(question, model, callback_func=callback_func)
             except:
-                self.logger.error(f'ask方法请求失败！', exc_info=True)
-                self.logger.info(f'尝试重新登录，后再发送请求。')
+                self.logger.error(f'[DeepSeek] ask方法请求失败！', exc_info=True)
+                self.logger.info(f'[DeepSeek] 尝试重新登录，后再发送请求。')
 
                 if not self.login():
-                    self.logger.error(f'重新登录失败')
+                    self.logger.error(f'[DeepSeek] 重新登录失败')
                     return self.single_answer_obj
 
     def get_chat_history(self):
         """
         获取通用助手聊天记录
         :return:
         """
@@ -363,43 +363,43 @@
         )
         response_json = response.json()
 
         code = response_json.get('data', {}).get('code')
         msg = response_json.get('data', {}).get('msg')
 
         if code == 0:
-            self.logger.info(f'发送验证码成功，返回消息:【{msg}】')
+            self.logger.info(f'[DeepSeek] 发送验证码成功，返回消息:【{msg}】')
             return True
 
-        self.logger.error(f'发送验证码失败，返回消息:【{msg}】')
+        self.logger.error(f'[DeepSeek] 发送验证码失败，返回消息:【{msg}】')
         return False
 
     def send_email_code(self, email: str):
         """
         发送验证码
         :param email:
         :return:
         """
 
         if not self.is_valid_email(email):
-            self.logger.error(f'邮箱格式错误，请检查邮箱格式')
+            self.logger.error(f'[DeepSeek] 邮箱格式错误，请检查邮箱格式')
             return False
 
         uri = '/api/v0/users/create_email_verification_code'
         data = {
             "email": email,
             "locale": "zh_CN",
             "turnstile_token": TURNSTILE_TOKEN,
         }
         return self.send_code(uri=uri, data=data)
 
     def send_phone_code(self, phone: str):
 
         if not self.is_valid_cn_phone(phone):
-            self.logger.error(f'输入号码【{phone}】不是合法的手机号')
+            self.logger.error(f'[DeepSeek] 输入号码【{phone}】不是合法的手机号')
             return False
 
         uri = '/api/v0/users/create_sms_verification_code'
 
         data = {
             "mobile_phone_number": phone,
             "locale": "zh_CN",
@@ -421,33 +421,33 @@
             )
 
             resp_json = response.json()
 
             token = resp_json.get('data', {}).get('user', {}).get('token')
 
             if token:
-                self.logger.info(f'注册成功，已更新token')
-                self.logger.info(f'token:【{token}】')
+                self.logger.info(f'[DeepSeek] 注册成功，已更新token')
+                self.logger.info(f'[DeepSeek] token:【{token}】')
                 self._token = token
                 return token
 
         except:
-            self.logger.error(f'注册失败', exc_info=True)
+            self.logger.error(f'[DeepSeek] 注册失败', exc_info=True)
 
     def register_by_email(self, email: str, code: str, password: str = None):
         """
         通过邮箱注册
         :param email: 邮箱
         :param code: 邮箱验证码
         :param password: 密码
         :return: 注册成功时，返回token
         """
 
         if not self.is_valid_email(email):
-            self.logger.error(f'邮箱格式错误，请检查邮箱格式')
+            self.logger.error(f'[DeepSeek] 邮箱格式错误，请检查邮箱格式')
             return
 
         uri = '/api/v0/users/register'
 
         data = {
             "locale": "zh_CN",
             "region": "FR",
@@ -466,15 +466,15 @@
         :param phone: 手机号
         :param code: 手机验证码
         :param password: 密码
         :return: 注册成功时，返回token
         """
 
         if not self.is_valid_cn_phone(phone):
-            self.logger.error(f'输入号码【{phone}】不是合法的国内手机号')
+            self.logger.error(f'[DeepSeek] 输入号码【{phone}】不是合法的国内手机号')
             return False
 
         uri = '/api/v0/users/register_by_mobile'
 
         data = {
             "locale": "zh_CN",
             "region": "CN",
```

## zibuyu_llm_web/emohaa.py

```diff
@@ -2,15 +2,15 @@
 
 """
 --------------------------------------------
 project: zibuyu_LLM
 author: 子不语
 date: 2024/5/17
 contact: 【公众号】思维兵工厂
-description: 
+description: 目前只实现了文本转语音功能
 --------------------------------------------
 """
 
 import base64
 import logging
 from typing import Literal
 
@@ -74,21 +74,20 @@
 
         host = 'https://ai-role.cn/echo-prod/tts'
 
         try:
             response = self.request_session.get(host, params=params, headers=self.__headers)
 
             if response.status_code != 200:
-                self.logger.error(f'{output_file_path} 语音生成失败')
-                print(response.text)
+                self.logger.error(f'[Emohaa] {output_file_path} 语音生成失败')
                 return False
 
             # 解码
             decoded_data = base64.b64decode(response.content)
 
             with open(output_file_path, 'wb') as f:
                 f.write(decoded_data)
 
             return True
         except:
-            self.logger.error(f'{output_file_path} 语音生成失败')
+            self.logger.error(f'[Emohaa] {output_file_path} 语音生成失败')
             return False
```

## zibuyu_llm_web/kimi.py

```diff
@@ -145,18 +145,18 @@
             "is_example": False
         }
 
         try:
             r = requests.post(url, headers=headers, json=data)
             if r.status_code == 200:
                 self._chat_id = r.json()['id']
-                self.logger.info(f'成功新建聊天id，chat_id: 【{self._chat_id}】')
+                self.logger.info(f'[Kimi] 成功新建聊天id，chat_id: 【{self._chat_id}】')
                 return self._chat_id
         except:
-            self.logger.error(f'获取聊天id失败')
+            self.logger.error(f'[Kimi] 获取聊天id失败')
 
     def ask(
             self,
             question: str,
             search_model: bool = True,
             chat_id: str = None,
             kimi_plus_id: str = None,
@@ -180,15 +180,15 @@
             self._chat_id = chat_id
 
         if not kimi_plus_id and perfect_prompt:
             kimi_plus_id = 'conpg00t7lagbbsfqkq0'
 
         # 如果用户没有传入chat_id，则新建，kimi的通讯必须要有chat_id
         if not self.chat_id:
-            self.logger.error(f'chat_id为空，通讯失败')
+            self.logger.error(f'[Kimi] chat_id为空，通讯失败')
             return AiAnswer()
 
         data = {
             "messages": [
                 {
                     "role": "user",
                     "content": question
@@ -208,37 +208,37 @@
             self.base_host + uri,
             json=data,
             headers=headers,
             stream=True
         )
 
         if response.status_code != 200:
-            self.logger.error(f'AI交互请求失败，状态码：{response.status_code}')
+            self.logger.error(f'[Kimi] AI交互请求失败，状态码：{response.status_code}')
             return AiAnswer()
 
         for line in response.iter_lines():
 
             if not line:
                 continue
 
             try:
                 error_msg = json.loads(line)
                 error_type = error_msg['error_type']
                 message = error_msg['message']
 
                 if error_type == 'auth.token.invalid':
-                    self.logger.error(f'{message}')
+                    self.logger.error(f'[Kimi] {message}')
                     raise NeedLoginError(message)
             except JSONDecodeError:
                 pass
 
             try:
                 self.parse_data(line, callback_func)
             except:
-                self.logger.error(f'解析数据失败，line: {line.decode()}')
+                self.logger.error(f'[Kimi] 解析数据失败，line: {line.decode()}')
 
         # 封装回答
         self.single_answer_obj.is_success = True
         self.single_answer_obj.content = self.single_answer.replace('^', '')
         self.single_answer_obj.conversation_id = self.chat_id
 
         return self.single_answer_obj
@@ -259,21 +259,25 @@
         elif event == 'cmpl':  # 流式输出回复
             padding = json_data.get('text', '').replace('^', '')
 
             if callable(callback_func):
                 try:
                     callback_func(padding)
                 except:
-                    self.logger.error(f'回调函数执行失败')
+                    self.logger.error(f'[Kimi] 回调函数执行失败')
 
             self.single_answer += padding
         elif event == 'ref_docs':
             pass
         elif event == 'search_plus':
 
+            msg = json_data['msg']
+            if 'successNum' not in msg:
+                pass
+
             index = json_data['msg']['successNum']
 
             if index in self.reference_link_index_list:
                 pass
 
             self.reference_link_index_list.append(index)
 
@@ -285,25 +289,25 @@
             self.single_answer_obj.reference_link_list.append(obj)
 
         elif event == 'all_done':
             if callable(callback_func):
                 try:
                     callback_func(self.end_signal)
                 except:
-                    self.logger.error(f'回调函数执行失败')
+                    self.logger.error(f'[Kimi] 回调函数执行失败')
 
     def send_sms_code(self, phone: str) -> bool:
         """
         发送验证码。与login方法配合实现登录
         :param phone: 手机号
         :return: 成功时返回True, 失败时返回False
         """
 
         if len(phone) != 11:
-            self.logger.error(f'目前仅支持国内手机，手机号格式错误')
+            self.logger.error(f'[Kimi] 目前仅支持国内手机，手机号格式错误')
             return False
 
         uri = '/api/user/sms/verify-code'
 
         data = {
             "action": "register",
             "phone": phone,
@@ -317,18 +321,18 @@
         response = requests.post(
             self.base_host + uri,
             json=data,
             headers=headers,
         )
 
         if response.status_code == 200:
-            self.logger.info(f'发送验证码成功')
+            self.logger.info(f'[Kimi] 发送验证码成功')
             return True
 
-        self.logger.error(f'发送验证码失败')
+        self.logger.error(f'[Kimi] 发送验证码失败')
         return False
 
     def login(self, phone: str, sms_code: str):
         """
         登录
         :param phone: 手机号
         :param sms_code: 验证码
@@ -351,16 +355,16 @@
         response = requests.post(
             self.base_host + uri,
             json=data,
             headers=headers,
         )
 
         if response.status_code == 200:
-            self.logger.info(f'登录成功')
+            self.logger.info(f'[Kimi] 登录成功')
             data = response.json()
 
             self._access_token = data['access_token']
             self.refresh_token = data['refresh_token']
             return True
 
-        self.logger.error(f'登录失败')
+        self.logger.error(f'[Kimi] 登录失败')
         return False
```

## zibuyu_llm_web/metaso.py

```diff
@@ -89,18 +89,18 @@
         response = self.request_session.get(url=url, headers=headers)
 
         main_soup = BeautifulSoup(response.text, 'html.parser')
 
         token = main_soup.find('meta', attrs={'id': 'meta-token'})['content']
 
         if not token:
-            self.logger.error('获取token失败')
-            raise Exception('获取token失败')
+            self.logger.error('[Metaso] 获取token失败')
+            raise Exception('[Metaso] 获取token失败')
 
-        self.logger.info(f'成功获取token: 【{token}】')
+        self.logger.info(f'[Metaso] 成功获取token: 【{token}】')
         return token
 
     def get_session_id(
             self,
             question: str,
             engine_type: str = '',
             scholar_search_domain: str = 'all',
@@ -127,18 +127,18 @@
             headers=headers,
         )
 
         resp_json = response.json()
 
         session_id = resp_json.get('data', {}).get('id')
         if not session_id:
-            self.logger.error('获取session_id失败')
-            raise Exception('获取session_id失败')
+            self.logger.error('[Metaso] 获取session_id失败')
+            raise Exception('[Metaso] 获取session_id失败')
 
-        self.logger.info(f'成功获取session_id: 【{session_id}】')
+        self.logger.info(f'[Metaso] 成功获取session_id: 【{session_id}】')
         return session_id
 
     def ask(
             self,
             question: str,
             lang: str = 'zh',
             engine_type: Literal['podcast', 'scholar',] = '',
@@ -156,19 +156,19 @@
         :param callback_func: 回调函数
         :return:
         """
 
         uri = '/api/searchV2'
 
         if mode not in ['concise', 'detail', 'research']:
-            self.logger.error('mode参数错误，使用默认【concise】')
+            self.logger.error('[Metaso] mode参数错误，使用默认【concise】')
             mode = 'concise'
 
         if engine_type not in ['podcast', 'scholar', ]:
-            self.logger.error('engineType参数错误，使用默认【concise】')
+            self.logger.error('[Metaso] engineType参数错误，使用默认【concise】')
             mode = ''
 
         session_id = self.get_session_id(
             question=question,
             mode=mode,
             engine_type=engine_type
         )
@@ -200,24 +200,24 @@
 
             if not line:
                 continue
 
             padding += line.decode('utf-8')
 
             if not padding.endswith('}') and not padding.endswith(']'):
-                print('数据不完全')
+                self.logger.warning('[Metaso] 数据不完全')
                 continue
 
             if padding == 'data:[DONE]':
 
                 if callable(callback_func):
                     try:
                         callback_func(END_SIGNAL)
                     except:
-                        self.logger.error('回调函数执行失败')
+                        self.logger.error('[Metaso] 回调函数执行失败')
 
                 self.single_answer_obj.content = self.single_answer
 
                 return self.single_answer_obj
 
             data = json.loads(padding.split(':', maxsplit=1)[-1])
             padding = ''
@@ -232,15 +232,15 @@
                 content = data.get('text')
                 self.single_answer += content
 
                 if callable(callback_func):
                     try:
                         callback_func(content)
                     except:
-                        self.logger.error('回调函数执行失败')
+                        self.logger.error('[Metaso] 回调函数执行失败')
 
             elif message_type == 'set-reference':
                 # 相关链接
                 reference_list = data.get('list', [])
                 for index, reference in enumerate(reference_list, start=1):
                     reference_link = ReferenceLink(
                         title=reference.get('title'),
@@ -250,15 +250,15 @@
                     self.single_answer_obj.reference_link_list.append(reference_link)
 
         return self.single_answer_obj
 
     def send_sms_code(self, phone: str) -> bool:
 
         if not self.is_valid_cn_phone(phone):
-            self.logger.error(f'输入号码【{phone}】不是合法的国内手机号')
+            self.logger.error(f'[Metaso] 输入号码【{phone}】不是合法的国内手机号')
             return False
 
         host = 'https://metaso.cn/verify?type=sms'
         data = {"phone": f"86-{phone}"}
 
         headers = self.__headers.copy()
         headers['Token'] = self.token
@@ -272,21 +272,21 @@
             )
 
             resp_data = response.json()
 
             code = resp_data.get('code')
 
             if code == 0:
-                self.logger.info('发送成功')
+                self.logger.info('[Metaso] 发送成功')
                 return True
 
-            self.logger.error(f'发送失败，错误码：{code}')
+            self.logger.error(f'[Metaso] 发送失败，错误码：{code}')
             return False
         except:
-            self.logger.error('发送手机验证码发送未知错误！', exc_info=True)
+            self.logger.error('[Metaso] 发送手机验证码发送未知错误！', exc_info=True)
             return False
 
     def login_by_phone(self, code: str):
         """
         手机验证码登录
         :param code: 验证码
         :return: 登录之后，请求头的cookie更新了
@@ -303,33 +303,33 @@
                 url=host,
                 headers=headers,
             )
 
             resp_data = response.json()
             code = resp_data.get('code')
             if code != 0:
-                self.logger.info('手机登录失败')
+                self.logger.info('[Metaso] 手机登录失败')
                 return
 
             uid = resp_data.get('data', {}).get('uid')
             sid = resp_data.get('data', {}).get('sid')
 
             cookie = self.request_session.cookies.get_dict()
             self._sid = cookie.get('sid')
             self._uid = cookie.get('uid')
 
             if self._sid == uid and self._uid == sid:
-                self.logger.info('成功更新token')
+                self.logger.info('[Metaso] 成功更新token')
                 return True
 
-            self.logger.error('手机登录失败')
+            self.logger.error('[Metaso] 手机登录失败')
             return False
 
         except:
-            self.logger.error('手机登录失败', exc_info=True)
+            self.logger.error('[Metaso] 手机登录失败', exc_info=True)
             return False
 
     def login_by_pwd(self, account: str, pwd: str):
         """
         登录
         :param account: 账号
         :param pwd: 密码的密文形式
@@ -354,27 +354,27 @@
                 json=data,
                 headers=headers,
             )
 
             resp_data = response.json()
             code = resp_data.get('code')
             if code != 0:
-                self.logger.info('密码登录失败')
+                self.logger.info('[Metaso] 密码登录失败')
                 return
 
             uid = resp_data.get('data', {}).get('uid')
             sid = resp_data.get('data', {}).get('sid')
 
             cookie = self.request_session.cookies.get_dict()
             self._sid = cookie.get('sid')
             self._uid = cookie.get('uid')
 
             if self._sid == uid and self._uid == sid:
-                self.logger.info('成功更新token')
+                self.logger.info('[Metaso] 成功更新token')
                 return True
 
-            self.logger.error('密码登录失败')
+            self.logger.error('[Metaso] 密码登录失败')
             return False
 
         except:
-            self.logger.error('密码登录失败', exc_info=True)
+            self.logger.error('[Metaso] 密码登录失败', exc_info=True)
             return False
```

## zibuyu_llm_web/minmax.py

```diff
@@ -194,20 +194,20 @@
         self.is_anonymous: bool = True  # 是否是匿名用户；默认为匿名用户
         self.single_answer: str = ''
         self.single_answer_obj: AiAnswer = AiAnswer()
         self.single_padding: str = ''  # 流式输出时，每次接收到的回答中的增量部分
         self.single_answer_audio_url_list: Optional[list] = None  # 单次回复时，音频文件的url列表
 
         if self.token_str:
-            self.logger.info(f'实例化时传入Token_str，开始解析')
+            self.logger.info(f'[MinMax] 实例化时传入Token_str，开始解析')
             self.parse_token_str()
         elif self.anonymity_login():
-            self.logger.info(f'未传入Token，进行匿名登录，成功获取token_str')
+            self.logger.info(f'[MinMax] 未传入Token，进行匿名登录，成功获取token_str')
         else:
-            self.logger.error(f'未传入Token，且匿名登录失败')
+            self.logger.error(f'[MinMax] 未传入Token，且匿名登录失败')
 
     @property
     def voice_list(self):
         """ 获取所有支持的音色列表 """
 
         for k, v in self.voice_info_dict.items():
             print(v['voiceName'])
@@ -295,18 +295,19 @@
         try:
 
             data = self.parse_jwt_token(self.token_str)
 
             device_id = data.get('user', {}).get('deviceID', '')
             self.is_anonymous = data.get('user', {}).get('isAnonymous', True)
             self.__device_id = device_id
-            self.logger.info(f'成功解析JWT\n\n设备ID：【{device_id}】\n用户类型：isAnonymous【{self.is_anonymous}】\n')
+            self.logger.info(
+                f'[MinMax] 成功解析JWT\n\n设备ID：【{device_id}】\n用户类型：isAnonymous【{self.is_anonymous}】\n')
             return True
         except:
-            self.logger.error(f'解析JWT失败', exc_info=True)
+            self.logger.error(f'[MinMax] 解析JWT失败', exc_info=True)
             return False
 
     def renew_token_str(self) -> bool:
         """
         更新token_str的有效期：一般40天后过期
         :return: 成功时返回True，失败返回False
         """
@@ -336,25 +337,25 @@
                 headers=headers,
                 json=user_data
             )
 
             resp_data = response.json()
             request_status = resp_data.get('statusInfo', {}).get('code', )
             if request_status != 200:
-                self.logger.error(f'token_str更新失败，错误码：{request_status}')
+                self.logger.error(f'[MinMax] token_str更新失败，错误码：{request_status}')
                 return False
 
             token = resp_data.get('data', {}).get('token')
             if not token:
-                self.logger.error(f'token_str更新失败，token为空')
+                self.logger.error(f'[MinMax] token_str更新失败，token为空')
                 return False
 
             self.token_str = token
         except:
-            self.logger.error(f'token_str更新失败', exc_info=True)
+            self.logger.error(f'[MinMax] token_str更新失败', exc_info=True)
             return False
 
     def anonymity_login(self) -> bool:
         """ 匿名登录，获取token_str """
 
         uri = '/v1/api/user/login/phone'
 
@@ -402,15 +403,15 @@
 
             self.token_str = token_str
             self.__headers['Token'] = token_str
             self.__device_id = device_id
             self.__user_id = user_id
             self.__device_info_expire = (int(time.time()) + 10800) * 1000
 
-            self.logger.info(f'成功获取到token_str：{token_str}')
+            self.logger.info(f'[MinMax] 成功获取到token_str：{token_str}')
             return True
 
         return False
 
     def post(
             self,
             url: str,
@@ -428,54 +429,54 @@
         :param multipart_encode: 是否使用multipart/form-data格式
         :return:
         """
 
         for i in range(3):
 
             if multipart_encode:
-                self.logger.info(f"使用multipart/form-data格式发送POST请求")
+                self.logger.info(f"[MinMax] 使用multipart/form-data格式发送POST请求")
 
                 multipart_data = MultipartEncoder(data)
                 headers["Content-Type"] = multipart_data.content_type
                 headers["Token"] = self.token_str
                 response = self.request_session.post(
                     url,
                     headers=headers,
                     data=multipart_data,
                     stream=stream
                 )
             else:
-                self.logger.info(f"使用json格式发送POST请求")
+                self.logger.info(f"[MinMax] 使用json格式发送POST请求")
 
                 headers["Token"] = self.token_str
                 response = self.request_session.post(
                     url,
                     headers=headers,
                     data=data,
                     stream=stream
                 )
 
             if response.status_code == 200:
                 self.logger.info(f"POST请求成功")
                 return response
 
-            self.logger.error(f"POST请求失败，状态码：{response.status_code}")
-            self.logger.error(f"POST请求失败，响应内容：{response.text}")
+            self.logger.error(f"[MinMax] POST请求失败，状态码：{response.status_code}")
+            self.logger.error(f"[MinMax] POST请求失败，响应内容：{response.text}")
 
             if not self.is_anonymous:
-                self.logger.info(f"并非匿名用户，不进行自动登录")
+                self.logger.info(f"[MinMax] 并非匿名用户，不进行自动登录")
                 return
 
             result = self.re_login_by_anonymous(data)
             if not result:
-                self.logger.error(f"重新匿名登录失败，不再尝试发送POST请求")
+                self.logger.error(f"[MinMax] 重新匿名登录失败，不再尝试发送POST请求")
                 return
-            self.logger.info(f"重新匿名登录成功，即将重新发送请求")
+            self.logger.info(f"[MinMax] 重新匿名登录成功，即将重新发送请求")
 
-        self.logger.error(f"请求3次仍然失败，退出")
+        self.logger.error(f"[MinMax] 请求3次仍然失败，退出")
 
     def get(self, url: str, headers: dict, params: dict, stream: bool = False) -> Optional[requests.Response]:
         pass
 
     def update_device_id(
             self,
             request_uuid: str = None,
@@ -515,30 +516,30 @@
         )
 
         resp_json = response.json()
 
         status_code = resp_json.get('statusInfo', {}).get('code')
 
         if status_code != 0:
-            self.logger.error(f'获取设备信息出错')
-            self.logger.info(f'响应数据: {resp_json}')
+            self.logger.error(f'[MinMax] 获取设备信息出错')
+            self.logger.info(f'[MinMax] 响应数据: {resp_json}')
             raise RequestsError(resp_json)
 
         self.__device_id = resp_json.get('data', {}).get('deviceIDStr')
         self.__user_id = resp_json.get('data', {}).get('userID')
 
         if self.__device_id:
-            self.logger.info(f'成功更新设备ID: 【{self.__device_id}】')
+            self.logger.info(f'[MinMax] 成功更新设备ID: 【{self.__device_id}】')
 
             self.__device_info_expire = (int(time.time()) + 10800) * 1000
 
-            self.logger.info(f'成功更新设备过期时间: 【{self.__device_info_expire}】')
+            self.logger.info(f'[MinMax] 成功更新设备过期时间: 【{self.__device_info_expire}】')
 
         if self.__user_id:
-            self.logger.info(f'成功更新用户ID: 【{self.__user_id}】')
+            self.logger.info(f'[MinMax] 成功更新用户ID: 【{self.__user_id}】')
 
     def get_yy(
             self,
             uri,
             unix: str,
             user_data: dict,
             data: dict = None,
@@ -646,20 +647,20 @@
         :param request_uuid: 配音音色ID
         :param request_device_id: 配音音色ID
         :param device_info_expire: 配音音色ID
         :return: AiAnswer
         """
 
         if search_mode not in ['0', '1']:
-            raise ValueError("search_mode参数错误，请传入0或1")
+            raise ValueError("[MinMax] search_mode参数错误，请传入0或1")
 
         self.check_request_info(request_uuid, request_device_id, device_info_expire)
 
         if chat_id:
-            self.logger.info(f'使用传入的会话ID: 【{chat_id}】')
+            self.logger.info(f'[MinMax] 使用传入的会话ID: 【{chat_id}】')
             self.chat_id = chat_id
 
         uri = "/v4/api/chat/msg"
 
         unix = self.get_timestamp()
 
         # 1. 处理请求参数
@@ -715,43 +716,43 @@
                     voice_id=voice_id
                 )
 
                 return self.single_answer_obj
             except NeedLoginError:
 
                 if not self.is_anonymous:
-                    self.logger.info('该用户并非匿名用户，不进行自动登录')
+                    self.logger.info('[MinMax] 该用户并非匿名用户，不进行自动登录')
                     return AiAnswer()
 
                 result = self.re_login_by_anonymous(data)
                 if not result:
-                    self.logger.error(f"重新匿名登录失败，AI回答获取失败，返回空对象")
+                    self.logger.error(f"[MinMax] 重新匿名登录失败，AI回答获取失败，返回空对象")
                     return AiAnswer()
 
-        self.logger.error(f"多次获取AI回答都失败，返回空对象")
+        self.logger.error(f"[MinMax] 多次获取AI回答都失败，返回空对象")
         return AiAnswer()
 
     def re_login_by_anonymous(self, data: dict) -> bool:
         """重新进行匿名登录"""
 
-        self.logger.info(f"尝试重新匿名登录...")
+        self.logger.info(f"[MinMax] 尝试重新匿名登录...")
         result = self.anonymity_login()
 
         if not result:
-            self.logger.error(f"重新匿名登录失败")
+            self.logger.error(f"[MinMax] 重新匿名登录失败")
             return False
 
-        self.logger.info(f"重新匿名登录成功")
+        self.logger.info(f"[MinMax] 重新匿名登录成功")
         self.__headers["Token"] = self.token_str
 
         # 匿名登录后，就没法保持原来的会话了
         if 'chatID' in data:
             data['chatID'] = '0'
             self.chat_id = None
-            self.logger.info(f"原会话ID失效，已清除")
+            self.logger.info(f"[MinMax] 原会话ID失效，已清除")
 
         return True
 
     def parse_ask_result(
             self,
             response: requests.Response,
             callback_func,
@@ -781,65 +782,65 @@
 
                 event = pending.split(":", maxsplit=1)[-1].strip()
                 pending = ""
                 continue
 
             # Incomplete chunk
             if not pending.endswith("}"):
-                self.logger.debug("The chunk is incomplete.")
+                self.logger.debug("[MinMax] The chunk is incomplete.")
                 continue
 
-            self.logger.debug(f"The chunk is complete.")
+            self.logger.debug(f"[MinMax] The chunk is complete.")
 
             # Remove the 'data:' prefix, convert JSON to dict
             pending = pending[5:]
             resp_json = json.loads(pending)
             pending = ""
 
             message_type = resp_json.get('type')
             status_code = resp_json.get('statusInfo', {}).get('code')
             error_message = resp_json.get('statusInfo', {}).get('message')
 
             if status_code == 0:
                 pass
             else:
-                self.logger.error(f"解析请求数据时发送错误，状态码：【{status_code}】，消息：【{error_message}】")
+                self.logger.error(f"[MinMax] 解析请求数据时发送错误，状态码：【{status_code}】，消息：【{error_message}】")
                 raise NeedLoginError('error_message')
 
             if event == "send_result" and message_type == 1:
                 self.handle_send_result(resp_json)
                 continue
             elif event == "message_result" and message_type == 2:
                 self.handle_message_result(resp_json, callback_func)
                 continue
             elif event == "follow_up_question_result" and message_type == 4:
                 self.handle_follow_up_question_result(resp_json)
                 continue
             else:
-                self.logger.error(f"MinMax响应出现未知数据，可能需要重新逆向，数据类型：{event}")
-                self.logger.info(f"MinMax响应数据：{pending}")
+                self.logger.error(f"[MinMax] 响应出现未知数据，可能需要重新逆向，数据类型：{event}")
+                self.logger.info(f"[MinMax] 响应数据：{pending}")
 
         # 检查是否收到任何响应
         if index == 0:
-            self.logger.error("MinMax请求没有收到任何响应")
+            self.logger.error("[MinMax] 请求没有收到任何响应")
 
         if audio_output_dir:
-            self.logger.info(f"接收到音频存放路径【{audio_output_dir}】，MinMax音频获取中...")
+            self.logger.info(f"[MinMax] 接收到音频存放路径【{audio_output_dir}】，MinMax音频获取中...")
 
             audio_path_list = self.download_audios(output_dir=audio_output_dir, voice_id=voice_id)
 
             if not audio_path_list:
-                self.logger.error("MinMax音频获取失败")
+                self.logger.error("[MinMax] 音频获取失败")
                 return self.single_answer_obj
 
-            self.logger.info(f"已将文本转为音频，存放到【{audio_output_dir}】，共计{len(audio_path_list)}条音频")
+            self.logger.info(f"[MinMax] 已将文本转为音频，存放到【{audio_output_dir}】，共计{len(audio_path_list)}条音频")
 
             self.single_answer_obj.audio_path_list = audio_path_list
             return self.single_answer_obj
-        self.logger.info(f'没有接收到音频存放路径，无需处理音频回复')
+        self.logger.info(f'[MinMax] 没有接收到音频存放路径，无需处理音频回复')
 
     def handle_follow_up_question_result(self, data: dict):
         """服务端返回最后总结信息"""
 
         try:
             self.single_answer = data.get('data', {}).get('messageResult', {}).get('content')
 
@@ -863,28 +864,28 @@
             self.single_padding = content.replace(self.single_answer, '')
             self.single_answer = content
 
             if callable(callback_func):
                 try:
                     callback_func(self.single_padding)
                 except:
-                    self.logger.error("回调函数执行失败")
+                    self.logger.error("[MinMax] 回调函数执行失败")
 
             is_end = data.get('data', {}).get('messageResult', {}).get('isEnd')
 
             if is_end == 0:
                 self.single_answer_obj.is_success = True
                 self.single_answer_obj.content = self.single_answer
                 self.single_answer_obj.conversation_id = self.chat_id
 
             if is_end == 0 and callable(callback_func):
                 try:
                     callback_func(self.end_signal)
                 except:
-                    self.logger.error("回调函数执行失败")
+                    self.logger.error("[MinMax] 回调函数执行失败")
         except:
             self.logger.error(f"[MinMax] 解析请求数据【message_result】时发送错误")
 
     def handle_send_result(self, data: dict):
         """服务端接收到用户文本，返回chatID等信息"""
 
         try:
@@ -894,18 +895,18 @@
         except:
             self.logger.error(f"[MinMax] 解析请求数据【send_result】时发送错误")
 
     def __get_voice_url(self, msg_id: str = None, voice_id: str = 'male-botong'):
 
         uri = "/v1/api/chat/msg_tts"
 
-        self.logger.info(f"语音ID：【{voice_id}】")
+        self.logger.info(f"[MinMax] 语音ID：【{voice_id}】")
 
         if voice_id not in self.voice_info_dict:
-            self.logger.error(f"输入的语音ID不存在，使用默认值【{voice_id}】")
+            self.logger.error(f"[MinMax] 输入的语音ID不存在，使用默认值【{voice_id}】")
             voice_id = 'male-botong'
             # raise ValueError("语音ID不存在")
 
         msg_id = msg_id or self.system_msg_id
 
         if not msg_id:
             raise ValueError("msg_id不能为空")
@@ -944,16 +945,16 @@
                 url=self.base_host + uri + f'?{query_str}',
                 headers=headers,
             )
 
             data = response.json()
 
             if data.get('statusInfo', {}).get('code') != 0:
-                self.logger.error(f"配音结果获取失败")
-                self.logger.info(f"MinMax响应数据：{data}")
+                self.logger.error(f"[MinMax] 配音结果获取失败")
+                self.logger.info(f"[MinMax] 响应数据：{data}")
                 break
 
             self.single_answer_audio_url_list = data.get('data', {}).get('result', [])
             request_status = data.get('data', {}).get('requestStatus', 2)
             time.sleep(0.2)
 
         return self.single_answer_audio_url_list
@@ -963,18 +964,18 @@
             if response.status == 200:
                 with open(file_name, 'wb') as f:
                     while True:
                         chunk = await response.content.read(1024)
                         if not chunk:
                             break
                         f.write(chunk)
-                self.logger.info(f"【{file_name}】 downloaded successfully.")
+                self.logger.info(f"[MinMax] 【{file_name}】 downloaded successfully.")
                 # print(f"{file_name} downloaded successfully.")
             else:
-                self.logger.error(f"Failed to download 【{file_name}】. Status code: {response.status}")
+                self.logger.error(f"[MinMax] Failed to download 【{file_name}】. Status code: {response.status}")
                 # print(f"Failed to download {file_name}. Status code: {response.status}")
 
     async def __download_all_audios(self, audio_urls, output_dir):
         """ 并发下载所有音频 """
 
         async with aiohttp.ClientSession() as session:
             tasks = []
@@ -1000,22 +1001,22 @@
         :return:
         """
 
         if not msg_id:
             msg_id = self.system_msg_id
 
         if not msg_id:
-            self.logger.error("没有传入消息ID")
+            self.logger.error("[MinMax] 没有传入消息ID")
             return
 
         if not audio_url_list:
             audio_url_list = self.__get_voice_url(msg_id=msg_id, voice_id=voice_id)
 
         if not audio_url_list:
-            self.logger.error("没有找到任何音频")
+            self.logger.error("[MinMax] 没有找到任何音频")
             return
 
         if not os.path.exists(output_dir):
             os.makedirs(output_dir)
 
         asyncio.run(self.__download_all_audios(audio_url_list, output_dir))
 
@@ -1025,15 +1026,15 @@
         """
         发送验证码
         :param phone_num: 手机号码
         :return: 成功时返回True，失败时返回False
         """
 
         if not self.is_valid_cn_phone(phone_num):
-            self.logger.error(f'输入号码【{phone_num}】不是合法的国内手机号')
+            self.logger.error(f'[MinMax] 输入号码【{phone_num}】不是合法的国内手机号')
             return False
 
         uri = '/v1/api/user/login/sms/send'
 
         unix = self.get_timestamp()
 
         # 1. 处理请求参数
@@ -1059,36 +1060,36 @@
             )
 
             data = response.json()
 
             status_code = data.get('statusInfo', {}).get('code')
 
             if status_code == 0:
-                self.logger.info(f"发送验证码成功")
+                self.logger.info(f"[MinMax] 发送验证码成功")
                 return True
 
-            self.logger.error(f"发送验证码失败")
+            self.logger.error(f"[MinMax] 发送验证码失败")
 
         except:
-            self.logger.error(f"发送验证码失败")
+            self.logger.error(f"[MinMax] 发送验证码失败")
 
     def login(
             self,
             phone: str,
             sms_code: str,
     ) -> bool:
         """
         账号登录
         :param phone: 手机号
         :param sms_code: 手机验证码
         :return: 登录成功时返回获取到的Token
         """
 
         if len(sms_code) != 6:
-            self.logger.error(f"验证码长度错误")
+            self.logger.error(f"[MinMax] 验证码长度错误")
             return False
 
         uri = '/v1/api/user/login/phone'
 
         data = {
             "phone": phone,
             "code": sms_code,
@@ -1115,40 +1116,40 @@
                 data=json.dumps(data),
             )
 
             response_data = response.json()
 
             status_code = response_data.get('statusInfo', {}).get('code')
             if status_code != 0:
-                self.logger.error(f"登录失败")
+                self.logger.error(f"[MinMax] 登录失败")
                 return False
 
-            self.logger.info(f"登录成功，已获取到Token")
+            self.logger.info(f"[MinMax] 登录成功，已获取到Token")
             token = response_data.get('data', {}).get('token')
 
             if not token:
-                self.logger.error(f"登录失败")
+                self.logger.error(f"[MinMax] 登录失败")
                 return False
 
             self.token_str = token
             return True
 
         except:
-            self.logger.error(f"登录失败")
+            self.logger.error(f"[MinMax] 登录失败")
             return False
 
     def update_voice_config(self, voice_id: str = 'female-shaonv') -> bool:
         """
         更新语音配置
         :param voice_id: 语音ID
         :return: 成功时返回True；失败时返回False
         """
 
         if voice_id not in self.voice_info_dict:
-            self.logger.error(f"输入的语音ID错误")
+            self.logger.error(f"[MinMax] 输入的语音ID错误")
             return False
 
         uri = '/v1/api/chat/update_robot_custom_config'
 
         data = {
             "robotID": "1",
             "config": {
@@ -1188,35 +1189,35 @@
         )
 
         try:
             resp_data = response.json()
 
             code = resp_data.get('statusInfo', {}).get('code')
             if code == 0:
-                self.logger.info(f"更新语音配置成功")
+                self.logger.info(f"[MinMax] 更新语音配置成功")
                 return True
 
-            self.logger.error(f"更新语音配置失败")
+            self.logger.error(f"[MinMax] 更新语音配置失败")
             return False
 
         except:
-            self.logger.error(f"更新语音配置时出现位置错误", exc_info=True)
+            self.logger.error(f"[MinMax] 更新语音配置时出现位置错误", exc_info=True)
             return False
 
     # ######################## 未完成 ########################
 
     def voice2voice(self, audio_path: str):
         """
         【未完成】语音输入 + 语音输出
         :param audio_path: 音频文件路径
         :return:
         """
 
         if not os.path.exists(audio_path):
-            self.logger.error("音频文件不存在")
+            self.logger.error("[MinMax] 音频文件不存在")
             return
 
         uri = "/v1/api/chat/phone_msg"
 
         unix = self.get_timestamp()
 
         # 1. 处理请求参数
@@ -1254,15 +1255,15 @@
             headers=headers,
             data=multipart_data,
         )
 
         print(response.status_code)
 
         if response.status_code != 200:
-            self.logger.error(f"MinMax音频交互失败，响应数据：{response.content}")
+            self.logger.error(f"[MinMax] 音频交互失败，响应数据：{response.content}")
             return
 
         for line in response.iter_lines():
             line = line.decode('utf-8')
             print(line)
 
     def test(self):
```

## zibuyu_llm_web/qwen.py

```diff
@@ -37,19 +37,20 @@
     file_size_limit: int = 150 * 1024 * 1024  # 上传文档时，对单个文档的大小限制
     file_count_limit: int = 100  # 上传文档时，对文档数量的限制
 
     model_name = 'Qwen'
 
     api_base: str = "https://qianwen.biz.aliyun.com/dialog"
 
-    def __init__(self,
-                 cookies_str: str = None,
-                 cookies_dict: dict = None,
-                 logger_obj: logging.Logger = None,
-                 error_dir: str = None):
+    def __init__(
+            self,
+            cookies_str: str = None,
+            cookies_dict: dict = None,
+            logger_obj: logging.Logger = None,
+            error_dir: str = None):
         """
         QwenWeb初始化
         :param cookies_str: cookies字符串
         :param cookies_dict: cookies字典
         :param logger_obj: 日志记录对象
         :param error_dir: 错误请求记录的保存目录，当出现请求失败时，会将关于该请求的URL、请求参数、响应数据整理成文件，存放于此目录
         """
@@ -62,15 +63,15 @@
             self.logger = logger_obj
 
         # 2. 错误请求记录的保存目录
         self.error_dir = error_dir
 
         # 3. 处理cookies
         if cookies_str and cookies_dict:
-            self.logger.warning("cookies_str和cookies_dict同时传入；使用cookies_dict，cookies_str将失效")
+            self.logger.warning("[Qwen] cookies_str和cookies_dict同时传入；使用cookies_dict，cookies_str将失效")
         self.cookies_str = cookies_str
         self.cookies_dict = cookies_dict
 
         super().__init__()
 
         # 4. 公用请求头
         self.headers = {
@@ -99,26 +100,26 @@
 
         request_id = uuid.uuid4().hex  # uuid无分隔符
         return request_id
 
     def check_file_list(self, file_path_list: list[str]):
         for file_path in file_path_list:
 
-            self.logger.info(f"checking file: 【{file_path}】")
+            self.logger.info(f"[Qwen] checking file: 【{file_path}】")
 
             # 检查文件是否存在
             if not os.path.exists(file_path):
-                raise FileNotFoundError(f"【{file_path}】 does not exist")
+                raise FileNotFoundError(f"[Qwen] 【{file_path}】 does not exist")
 
             # 检查文件大小是否超过限制
             if os.path.getsize(file_path) > self.file_size_limit:
                 raise InvalidFileError(
-                    f"【{file_path}】 size exceeds the limit of 【{self.file_size_limit / 1024 / 1024}】MB")
+                    f"[Qwen] 【{file_path}】 size exceeds the limit of 【{self.file_size_limit / 1024 / 1024}】MB")
 
-            self.logger.info(f"checking done: 【{file_path}】 ")
+            self.logger.info(f"[Qwen] checking done: 【{file_path}】 ")
 
     def ask(
             self,
             question: str,
             callback_func=None,
             parent_id: str = '',
             session_id: str = '',
@@ -146,22 +147,22 @@
             raise InvalidFileError("image and file cannot be set at the same time")
 
         # 本地图片和网络图片不能同时进行
         if image_path and image_url:
             raise InvalidFileError("image_path and image_url cannot be set at the same time")
 
         if not (parent_id is None) == (session_id is None):
-            self.logger.error("parent_id and session_id have to be set at the same time", exc_info=True)
-            raise InvalidFileError("parent_id and session_id have to be set at the same time")
+            self.logger.error("[Qwen] parent_id and session_id have to be set at the same time", exc_info=True)
+            raise InvalidFileError("[Qwen] parent_id and session_id have to be set at the same time")
 
         if session_id and parent_id:
-            self.logger.info(f"parent_id：【{parent_id}】")
-            self.logger.info(f"session_id：【{session_id}】")
+            self.logger.info(f"[Qwen] parent_id：【{parent_id}】")
+            self.logger.info(f"[Qwen] session_id：【{session_id}】")
         else:
-            self.logger.info("parent_id and session_id are not set, using default values")
+            self.logger.info("[Qwen] parent_id and session_id are not set, using default values")
 
         self.parent_id = parent_id
         self.session_id = session_id
 
         self.timeout = timeout
 
         # 获取请求体数据
@@ -196,18 +197,18 @@
 
             index += 1
             chunk = str(chunk).strip()
             pending += chunk
 
             # Incomplete chunk
             if not chunk.endswith("}"):
-                self.logger.debug("The chunk is incomplete.")
+                self.logger.debug("[Qwen] The chunk is incomplete.")
                 continue
 
-            self.logger.debug(f"The chunk is complete.")
+            self.logger.debug(f"[Qwen] The chunk is complete.")
 
             # Complete chunk
             try:
                 pending = pending.split("\n")[-1]
                 pending = pending[6:]
 
                 resp_json = json.loads(pending)
@@ -224,31 +225,31 @@
 
                 self.parent_id = resp_json["msgId"]
                 self.session_id = resp_json.get("sessionId")
 
                 content_list = resp_json.get("contents")
 
                 if not content_list:
-                    self.logger.info("This content_list is empty.")
+                    self.logger.info("[Qwen] This content_list is empty.")
                     continue
 
                 msg_status = resp_json["msgStatus"]
 
                 # 处理最后一帧：包含完整回复文本
                 if msg_status == 'finished':
 
                     session_warn_new = resp_json.get("sessionWarnNew")
                     if session_warn_new:
-                        self.logger.warning("sessionWarnNew为True。可能需要重置【parent_id】和【session_id】")
-                        self.logger.info(f"收到的响应内容是：【{resp_json}】")
+                        self.logger.warning("[Qwen] sessionWarnNew为True。可能需要重置【parent_id】和【session_id】")
+                        self.logger.info(f"[Qwen] 收到的响应内容是：【{resp_json}】")
 
                     can_regenerate = resp_json["canRegenerate"]
                     if not can_regenerate:
-                        self.logger.warning("canRegenerate为False。可能需要重置【parent_id】和【session_id】")
-                        self.logger.info(f"收到的响应内容是：【{resp_json}】")
+                        self.logger.warning("[Qwen] canRegenerate为False。可能需要重置【parent_id】和【session_id】")
+                        self.logger.info(f"[Qwen] 收到的响应内容是：【{resp_json}】")
 
                     self.single_answer_obj = QwenWebResponse(
                         msg_status=msg_status,
                         web_search_list=[],
                         content_list=[],
                         reference_link_list=[],
                         image_url_list=[],
@@ -314,26 +315,26 @@
                 request_data = json.dumps(data)
                 request_response = pending
                 traceback_info = f"\n--- Error Log Entry ---\n{traceback.format_exc()}\n--- End of Entry ---\n"
 
                 all_data = f"{request_url}\n\n{request_data}\n\n{request_response}\n\n{traceback_info}"
                 file_path = self.save_bad_request_data('AI交互请求-官方提示错误', all_data)
 
-                self.logger.error(f"AI交互请求出现官方提示错误，相关数据已写入【{file_path}】", exc_info=True)
+                self.logger.error(f"[Qwen] AI交互请求出现官方提示错误，相关数据已写入【{file_path}】", exc_info=True)
             except Exception:
 
                 request_url = self.api_base + "/conversation"
                 request_data = json.dumps(data)
                 request_response = pending
                 traceback_info = f"\n--- Error Log Entry ---\n{traceback.format_exc()}\n--- End of Entry ---\n"
 
                 all_data = f"{request_url}\n\n{request_data}\n\n{request_response}\n\n{traceback_info}"
                 file_path = self.save_bad_request_data('AI交互请求-出现未知错误', all_data)
 
-                self.logger.error(f"AI交互请求出现未知错误，相关数据已写入【{file_path}】", exc_info=True)
+                self.logger.error(f"[Qwen] AI交互请求出现未知错误，相关数据已写入【{file_path}】", exc_info=True)
 
         answer = AiAnswer(
             content=self.single_answer,
             latest_msg_id=self.parent_id,
             conversation_id=self.session_id,
             reference_link_list=self.single_answer_obj.reference_link_list
         )
@@ -386,17 +387,17 @@
             request_url = upload_token["data"]["host"] + "/"
             request_data = json.dumps(files_data)
             request_response = '这个请求不需要返回'
 
             all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
             file_path = self.save_bad_request_data('上传文件-出现未知错误', all_data)
 
-            self.logger.error(f"上传文件时出现未知错误，相关数据已写入【{file_path}】", exc_info=True)
+            self.logger.error(f"[Qwen] 上传文件时出现未知错误，相关数据已写入【{file_path}】", exc_info=True)
 
-            raise RequestsError(f"function [upload] got an unexpected response. Status Code: {resp.status_code}")
+            raise RequestsError(f"[Qwen] function [upload] got an unexpected response. Status Code: {resp.status_code}")
 
     def upload_file(self, file_path: str) -> dict:
         """
         上传文档
         :param file_path:
         :return:
         """
@@ -462,18 +463,18 @@
 
             with open(image_path, 'rb') as f:
                 image = f.read()
         else:
             image = requests.get(image_url).content
             image_type = imghdr.what(None, image)
             if not image_type:
-                self.logger.error(f"传入的image_url存在问题，可能非图片。【{image_url}】")
+                self.logger.error(f"[Qwen] 传入的image_url存在问题，可能非图片。【{image_url}】")
                 raise InvalidFileError("invalid file")
 
-            self.logger.info(f"图像数据为二进制，并且格式为: {image_type}")
+            self.logger.info(f"[Qwen] 图像数据为二进制，并且格式为: {image_type}")
 
         # 类型及名称
         file_type = filetype.guess_mime(image)
         if "image/" not in file_type:
             raise InvalidFileError("invalid file")
         file_name = "image-" + hashlib.md5(image).hexdigest() + "." + file_type[6:]
 
@@ -504,36 +505,36 @@
             "parentMsgId": self.parent_id,
             "sessionId": self.session_id,
             "sessionType": "text_chat" if not image_path else "image_chat",
             "userAction": "chat" if self.session_id and self.parent_id else "new_top"
         }
 
         if image_path:
-            self.logger.info("This is a image chat.")
+            self.logger.info("[Qwen] This is a image chat.")
 
             data_dict = self.upload_image(image_path=image_path)
 
             data["contents"].append({
                 "contentType": "image",
                 "content": data_dict['url'],
                 "role": "user"
             })
         elif image_url:
-            self.logger.info("This is a image chat.")
+            self.logger.info("[Qwen] This is a image chat.")
 
             data_dict = self.upload_image(image_url=image_url)
 
             data["contents"].append({
                 "contentType": "image",
                 "content": data_dict['url'],
                 "role": "user"
             })
         elif file_path_list:
-            self.logger.info("This is a file chat.")
-            self.logger.info(f"There are {len(file_path_list)} files")
+            self.logger.info("[Qwen] This is a file chat.")
+            self.logger.info(f"[Qwen] There are {len(file_path_list)} files")
 
             self.check_file_list(file_path_list)
 
             for file_path in file_path_list:
                 data_dict = self.upload_file(file_path)
                 item = {
                     "contentType": "file",
@@ -543,15 +544,15 @@
                         "fileSize": data_dict['file_size'],
                         "docId": data_dict['doc_id'],
                     }
                 }
                 # noinspection PyTypeChecker
                 data["contents"].append(item)
         else:
-            self.logger.info("This is a text chat.")
+            self.logger.info("[Qwen] This is a text chat.")
 
         return data
 
     def _get_upload_token(self) -> dict:
         """
         获取上传token
         :return:
@@ -572,18 +573,18 @@
             request_url = self.api_base + "/uploadToken"
             request_data = json.dumps({})
             request_response = resp_json
 
             all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
             file_path = self.save_bad_request_data('获取上传文件的token-出现未知错误', all_data)
 
-            self.logger.error(f"获取上传文件的token请求，出现未知错误，相关数据已写入【{file_path}】", exc_info=True)
+            self.logger.error(f"[Qwen] 获取上传文件的token请求，出现未知错误，相关数据已写入【{file_path}】", exc_info=True)
 
             # 抛出错误，程序终止
-            raise RequestsError("function 【_get_upload_token】got an unexpected response.")
+            raise RequestsError("[Qwen] function 【_get_upload_token】got an unexpected response.")
 
     def _get_download_link_image(self, upload_token: dict, file_name: str) -> dict:
         """
         上传图片之后，获取图片链接
         :param upload_token:
         :param file_name:
         :return:
@@ -610,15 +611,15 @@
 
             request_url = upload_token["data"]["host"] + "/"
             request_data = json.dumps(request_data)
             request_response = resp.text
 
             all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
             file_path = self.save_bad_request_data('获取图片链接-出现未知错误', all_data)
-            self.logger.error(f"获取图片链接时出现未知错误，相关数据已写入【{file_path}】")
+            self.logger.error(f"[Qwen] 获取图片链接时出现未知错误，相关数据已写入【{file_path}】")
 
             raise RequestsError("function [_get_download_link_image] got an unexpected response.")
 
     def _get_download_link_file(self, upload_token: dict, file_name: str) -> dict:
         """
         上传文档之后，获取文档链接
         :param upload_token:
@@ -651,17 +652,17 @@
 
             request_url = self.api_base + "/downloadLink/batch"
             request_data = json.dumps(request_data)
             request_response = resp.text
 
             all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
             file_path = self.save_bad_request_data('获取文档链接-出现未知错误', all_data)
-            self.logger.error(f"获取文档链接时出现未知错误，相关数据已写入【{file_path}】")
+            self.logger.error(f"[Qwen] 获取文档链接时出现未知错误，相关数据已写入【{file_path}】")
 
-            raise RequestsError("function [_get_download_link_file] got an unexpected response.")
+            raise RequestsError("[Qwen] function [_get_download_link_file] got an unexpected response.")
 
     def handle_response_text(self, data: dict):
         """
         处理回复内容中的AI生成文本
         :param data:
         :return:
         """
@@ -769,17 +770,17 @@
         content = data["content"]
 
         re_path = r"!\[.*\]\((https:\/\/.*?)\)"
 
         result = re.findall(re_path, content)
 
         if not result:
-            self.logger.warning("AI交互中包含text2image字段，但未找到图片链接，可能是匹配正则出了问题")
-            self.logger.info(f"用于匹配图片的正则表达式是：【{re_path}】")
-            self.logger.info(f"响应的内容是：【{content}】")
+            self.logger.warning("[Qwen] AI交互中包含text2image字段，但未找到图片链接，可能是匹配正则出了问题")
+            self.logger.info(f"[Qwen] 用于匹配图片的正则表达式是：【{re_path}】")
+            self.logger.info(f"[Qwen] 响应的内容是：【{content}】")
             return
 
         image_url_list = []
         for url in result:
             image_url_list.append(url)
 
         self.single_answer_obj.image_url_list = image_url_list
@@ -856,27 +857,27 @@
                 request_data = json.dumps({
                     "sessionId": session_id
                 })
                 request_response = resp.text
 
                 all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
                 file_path = self.save_bad_request_data('获取历史会话失败', all_data)
-                self.logger.error(f"获取历史会话失败，相关数据已写入【{file_path}】")
+                self.logger.error(f"[Qwen] 获取历史会话失败，相关数据已写入【{file_path}】")
 
         except Exception:
-            self.logger.error("get_session_history failed", exc_info=True)
+            self.logger.error("[Qwen] get_session_history failed", exc_info=True)
 
     def get_session_list(self) -> list[QwenSession]:
         """
         获取账号的会话列表
         :return:
         """
 
         try:
-            self.logger.info("获取账号的会话列表")
+            self.logger.info("[Qwen] 获取账号的会话列表")
 
             resp = requests.post(
                 url=self.api_base + "/session/list",
                 cookies=self.cookies_dict,
                 headers=self.headers,
                 json={
                     "keyword": ""
@@ -897,30 +898,30 @@
                         summary=item.get('summary'),
                         session_type=item.get('sessionType'),
                         error_msg=item.get('errorMsg'),
                         status=item.get('status'),
                         can_share=item.get('canShare'),
                     )
                     session_list.append(session_obj)
-                self.logger.info(f"获取账号的会话列表成功，共{len(session_list)}个会话")
+                self.logger.info(f"[Qwen] 获取账号的会话列表成功，共{len(session_list)}个会话")
                 return session_list
             else:
 
                 request_url = self.api_base + "/session/list"
                 request_data = json.dumps({
                     "keyword": ""
                 })
                 request_response = resp.text
 
                 all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
                 file_path = self.save_bad_request_data('获取会话列表失败', all_data)
-                self.logger.error(f"获取会话列表失败，相关数据已写入【{file_path}】")
+                self.logger.error(f"[Qwen] 获取会话列表失败，相关数据已写入【{file_path}】")
 
         except:
-            self.logger.error("get_session_list failed", exc_info=True)
+            self.logger.error("[Qwen] get_session_list failed", exc_info=True)
 
     def delete_session(self, session_id: str) -> bool:
         """
         根据session_id删除会话
         :param session_id:
         :return:
         """
@@ -933,64 +934,64 @@
                 data=json.dumps({
                     "sessionId": session_id
                 }),
                 timeout=10
             ).json()
 
             if 'success' in resp and resp['success']:
-                self.logger.info(f"删除会话成功！session_id：【{session_id}】")
+                self.logger.info(f"[Qwen] 删除会话成功！session_id：【{session_id}】")
                 return True
             else:
                 request_url = self.api_base + "/session/delete"
                 request_data = json.dumps({
                     "sessionId": session_id
                 })
                 request_response = resp.text
 
                 all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
                 file_path = self.save_bad_request_data('获取删除会话失败', all_data)
-                self.logger.error(f"获取删除会话失败，相关数据已写入【{file_path}】")
+                self.logger.error(f"[Qwen] 获取删除会话失败，相关数据已写入【{file_path}】")
                 return False
         except:
-            self.logger.error("delete_session unknown error", exc_info=True)
+            self.logger.error("[Qwen] delete_session unknown error", exc_info=True)
             return False
 
     def rename_session(self, session_id: str, summary: str) -> bool:
         """
         根据session_id重命名会话
         :param session_id:
         :param summary:
         :return:
         """
 
         try:
-            self.logger.info("根据session_id重命名会话")
+            self.logger.info("[Qwen] 根据session_id重命名会话")
 
             resp = requests.post(
                 url=self.api_base + "/session/update",
                 cookies=self.cookies_dict,
                 headers=self.headers,
                 data=json.dumps({
                     "sessionId": session_id,
                     "summary": summary
                 }),
                 timeout=10
             ).json()
 
             if 'success' in resp and resp['success']:
-                self.logger.info(f"重命名会话成功！session_id：【{session_id}】，summary：【{summary}】")
+                self.logger.info(f"[Qwen] 重命名会话成功！session_id：【{session_id}】，summary：【{summary}】")
                 return True
             else:
                 request_url = self.api_base + "/session/update"
                 request_data = json.dumps({
                     "sessionId": session_id,
                     "summary": summary
                 })
                 request_response = resp.text
 
                 all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
                 file_path = self.save_bad_request_data('重命名会话失败', all_data)
-                self.logger.error(f"重命名会话失败，相关数据已写入【{file_path}】")
+                self.logger.error(f"[Qwen] 重命名会话失败，相关数据已写入【{file_path}】")
                 return False
         except:
-            self.logger.error("function [rename_session] got an unknown error.", exc_info=True)
+            self.logger.error("[Qwen] function [rename_session] got an unknown error.", exc_info=True)
             return False
```

## zibuyu_llm_web/step_chat.py

```diff
@@ -314,23 +314,28 @@
         return buffer
 
     @staticmethod
     def parse_data(byte_data: bytes) -> list[dict]:
         """ 解析字节数据 """
 
         content_list = []
-        offset = 1
-        while offset < len(byte_data):
-            chunk_size = struct.unpack_from(">I", byte_data, offset)[0]
-
-            json_bytes = byte_data[offset - 1: offset - 1 + 5 + chunk_size]
-            decoded_json = json.loads(json_bytes[5:].decode('utf-8'))
-            content_list.append(decoded_json)
-            offset += chunk_size + 5
-        return content_list
+        try:
+            offset = 1
+            while offset < len(byte_data):
+                chunk_size = struct.unpack_from(">I", byte_data, offset)[0]
+
+                json_bytes = byte_data[offset - 1: offset - 1 + 5 + chunk_size]
+                decoded_json = json.loads(json_bytes[5:].decode('utf-8'))
+                content_list.append(decoded_json)
+                offset += chunk_size + 5
+
+        except:
+            LLMBase.logger.error(f'[跃问] 解析字节数据发生未知错误', exc_info=True)
+        finally:
+            return content_list
 
     def ask(
             self,
             question: str,
             chat_id: str,
             callback_func=None,
     ) -> Optional[AiAnswer]:
@@ -409,10 +414,9 @@
                             callback_func(END_SIGNAL)
                         except:
                             self.logger.error(f'[跃问] 回调函数执行失败', exc_info=True)
                 else:
                     continue
             except:
                 self.logger.error(f'[跃问] 解析数据失败，数据：{content}', exc_info=True)
-                print(content)
 
         return self.single_answer_obj
```

## zibuyu_llm_web/wanxiang.py

```diff
@@ -51,15 +51,15 @@
             self.logger = logger_obj
 
         # 2. 错误请求记录的保存目录
         self.error_dir = error_dir
 
         # 3. 处理cookies
         if cookies_str and cookies_dict:
-            self.logger.warning("cookies_str和cookies_dict同时传入；使用cookies_dict，cookies_str将失效")
+            self.logger.warning("[WanXiang] cookies_str和cookies_dict同时传入；使用cookies_dict，cookies_str将失效")
         self.cookies_str = cookies_str
         self.cookies_dict = cookies_dict
 
         super().__init__()
 
         self.headers = {
             "accept": "application/json, text/plain, */*",
@@ -125,23 +125,23 @@
             data=json.dumps(request_data),
             timeout=10
         )
 
         resp_json = resp.json()
 
         if 'success' in resp_json and resp_json['success']:
-            self.logger.info(f"提交绘图任务成功！")
+            self.logger.info(f"[WanXiang] 提交绘图任务成功！")
         else:
             request_url = self.api_base + "/imageGen"
             request_data = json.dumps(request_data)
             request_response = resp.text
 
             all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
             file_path = self.save_bad_request_data('提交绘图任务-出现错误', all_data)
-            self.logger.error(f"提交绘图任务出现错误，相关数据已写入【{file_path}】")
+            self.logger.error(f"[WanXiang] 提交绘图任务出现错误，相关数据已写入【{file_path}】")
 
             raise RequestsError("functon [generate_image] got an unexpected response.")
 
         task_id = resp_json['data']
         return task_id
 
     def _get_latest_id(self):
@@ -162,16 +162,16 @@
         if 'success' not in resp.json() or not resp.json()['success']:
             request_url = self.api_base + "/imageGen"
             request_data = json.dumps(request_data)
             request_response = resp.text
 
             all_data = f"{request_url}\n\n{request_data}\n\n{request_response}"
             file_path = self.save_bad_request_data('获取最新任务id-出现错误', all_data)
-            self.logger.error(f"获取最新任务id出现错误，相关数据已写入【{file_path}】")
-            raise RequestsError("functon [generate_image] got an unexpected response.")
+            self.logger.error(f"[WanXiang] 获取最新任务id出现错误，相关数据已写入【{file_path}】")
+            raise RequestsError("[WanXiang] functon [generate_image] got an unexpected response.")
 
         latest_id = resp.json()['data'][0]['id']
         return latest_id
 
     def generate_image(
             self,
             prompt: str,
```

## zibuyu_llm_web/xunfei.py

```diff
@@ -324,18 +324,18 @@
             'accountName': self.account_name,
             '_': self.get_timestamp(),
         }
 
         response = self.session.get(host, headers=headers, params=params, verify=False)
 
         if response.status_code != 200:
-            self.logger.error('【if-captcha】请求失败')
-            self.logger.info(f"响应数据为：【{response.text}】")
-            raise Exception('【if_captcha】请求失败')
-        self.logger.info('【if-captcha】请求成功')
+            self.logger.error('[XunFei] 【if-captcha】请求失败')
+            self.logger.info(f"[XunFei] 响应数据为：【{response.text}】")
+            raise Exception('[XunFei] 【if_captcha】请求失败')
+        self.logger.info('[XunFei] 【if-captcha】请求成功')
 
     def get_gt_and_challenge(self):
         """
         获取gt和challenge
         :return:
         """
 
@@ -355,22 +355,22 @@
 
         data = response.json()
 
         gt = data.get('data', {}).get('gt')
         challenge = data.get('data', {}).get('challenge')
 
         if not gt or not challenge:
-            self.logger.error('获取gt和challenge失败')
-            self.logger.info(f"响应数据为：【{response.text}】")
-            raise Exception('获取gt和challenge失败')
+            self.logger.error('[XunFei] 获取gt和challenge失败')
+            self.logger.info(f"[XunFei] 响应数据为：【{response.text}】")
+            raise Exception('[XunFei] 获取gt和challenge失败')
 
         self.challenge = challenge
         self.gt = gt
 
-        self.logger.info('【get_gt_and_challenge】请求成功，已获取到gt和challenge')
+        self.logger.info('[XunFei] 【get_gt_and_challenge】请求成功，已获取到gt和challenge')
         self.logger.info(f'\n【get_gt_and_challenge】gt: {gt};\n challenge: {challenge}')
         return gt, challenge
 
     def get_type(self):
 
         host = 'https://api.geetest.com/gettype.php'
 
@@ -386,37 +386,37 @@
         response = self.session.get(
             host,
             params=params,
             headers=headers
         )
 
         if response.status_code != 200:
-            self.logger.error('获取type失败')
-            self.logger.info(f"响应数据为：【{response.text}】")
-            raise Exception('获取type失败')
+            self.logger.error('[XunFei] 获取type失败')
+            self.logger.info(f"[XunFei] 响应数据为：【{response.text}】")
+            raise Exception('[XunFei] 获取type失败')
 
-        self.logger.info('【get_type】请求成功，已获取到type')
+        self.logger.info('[XunFei] 【get_type】请求成功，已获取到type')
 
     def other_static_js_1(self):
 
         host = 'https://static.geetest.com/static/js/fullpage.9.1.9-glhvqm.js'
 
         headers = self.headers.copy()
         headers['Referer'] = 'https://passport.xfyun.cn/'
 
         second_response = self.session.get(
             host,
             headers=headers
         )
 
         if second_response.status_code != 200:
-            self.logger.error('获取type失败')
-            self.logger.info(f"响应数据为：【{second_response.text}】")
-            raise Exception('获取type失败')
-        self.logger.info('额外请求：【other_static_js_1】请求成功，已获取到fullpage.js文件')
+            self.logger.error('[XunFei] 获取type失败')
+            self.logger.info(f"[XunFei] 响应数据为：【{second_response.text}】")
+            raise Exception('[XunFei] 获取type失败')
+        self.logger.info('[XunFei] 额外请求：【other_static_js_1】请求成功，已获取到fullpage.js文件')
 
     def get_c_and_s(self):
         # host = 'https://api.geetest.com/get.php'
 
         callback = f'geetest_{self.get_timestamp()}'
 
         # params = {
@@ -446,20 +446,20 @@
         if status != 'success':
             raise Exception('获取c和s失败')
 
         c = data.get('data', {}).get('c')
         s = data.get('data', {}).get('s')
 
         if not c or not s:
-            self.logger.error('获取c和s失败')
-            self.logger.info(f"响应数据为：【{response.text}】")
-            raise Exception('获取c和s失败')
+            self.logger.error('[XunFei] 获取c和s失败')
+            self.logger.info(f"[XunFei] 响应数据为：【{response.text}】")
+            raise Exception('[XunFei] 获取c和s失败')
 
-        self.logger.info('【get_c_and_s】请求成功，已获取到c和s')
-        self.logger.info(f'【get_c_and_s】\nc: {c};\n s: {s}')
+        self.logger.info('[XunFei] 【get_c_and_s】请求成功，已获取到c和s')
+        self.logger.info(f'[XunFei] 【get_c_and_s】\nc: {c};\n s: {s}')
 
         self.c = c
         self.s = s
 
         return c, s
 
     def check_ajax(self):
@@ -471,33 +471,33 @@
         callback = f'geetest_{self.get_timestamp()}'
 
         host = f'https://api.geetest.com/ajax.php?gt={self.gt}&challenge={self.challenge}&lang=zh&pt=0&client_type=web&callback={callback}&w='
 
         response = self.session.get(host)
 
         if response.status_code != 200:
-            self.logger.error('ajax请求失败')
-            self.logger.info(f"响应数据为：【{response.text}】")
-            raise Exception('ajax请求失败')
+            self.logger.error('[XunFei] ajax请求失败')
+            self.logger.info(f"[XunFei] 响应数据为：【{response.text}】")
+            raise Exception('[XunFei] ajax请求失败')
 
         data = self.get_json_data(response.text)
-        self.logger.info('【check_ajax】请求成功')
+        self.logger.info('[XunFei] 【check_ajax】请求成功')
 
     def other_statis_js_2(self):
 
         headers = self.headers.copy()
         headers['Referer'] = 'https://passport.xfyun.cn/'
         headers['Origin'] = 'https://passport.xfyun.cn'
 
         response = self.session.get('https://static.geetest.com/static/js/slide.7.9.2.js', headers=headers)
         if response.status_code != 200:
-            self.logger.error('获取js失败')
-            self.logger.info(f"响应数据为：【{response.text}】")
-            raise Exception('获取js失败')
-        self.logger.info('额外请求：【other_statis_js_2】请求成功，已获取到slide.js文件')
+            self.logger.error('[XunFei] 获取js失败')
+            self.logger.info(f"[XunFei] 响应数据为：【{response.text}】")
+            raise Exception('[XunFei] 获取js失败')
+        self.logger.info('[XunFei] 额外请求：【other_statis_js_2】请求成功，已获取到slide.js文件')
 
     def get_img(self, api_server, url):
 
         """
         网络请求获取图片二进制数据
         :return:
         """
@@ -520,15 +520,15 @@
         }
 
         # host = f"https://{api_server}{url}".replace('jpg', '.webp')
 
         # response = self.session.get(host, headers=headers)
         response = self.session.get(f"https://{api_server}{url}", headers=headers)
 
-        self.logger.info(f'【get_img】请求成功，已获取到图片。【f"https://{api_server}{url}"】')
+        self.logger.info(f'[XunFei] 【get_img】请求成功，已获取到图片。【f"https://{api_server}{url}"】')
         return response.content
 
     def get_img_and_params(self):
 
         headers = {
             'Accept': '*/*',
             'Accept-Encoding': 'gzip, deflate, br, zstd',
@@ -572,31 +572,31 @@
         # response = self.session.get(
         #     host,
         #     headers=headers
         # )
 
         response = requests.get(host, verify=False)
 
-        self.logger.info(f'get_img_and_params方法请求状态码：{response.status_code}')
+        self.logger.info(f'[XunFei] get_img_and_params方法请求状态码：{response.status_code}')
 
         try:
 
             json_data = json.loads(response.text)
             status = json_data.get('status')
             error = json_data.get('error')
             user_error = json_data.get('user_error')
             # print('status:', status)
             # print('error:', error)
             # print('user_error:', user_error)
-            self.logger.info('【get_img_and_params】请求失败')
-            self.logger.info(f"响应数据为：【{response.text}】")
+            self.logger.info('[XunFei] 【get_img_and_params】请求失败')
+            self.logger.info(f"[XunFei] 响应数据为：【{response.text}】")
         except:
 
             resp_data = self.get_json_data(response.text)
-            self.logger.info('【get_img_and_params】请求成功')
+            self.logger.info('[XunFei] 【get_img_and_params】请求成功')
 
             # 更新参数
             self.gt = resp_data['gt']
             self.challenge = resp_data['challenge']
             self.c = resp_data['c']
             self.s = resp_data['s']
 
@@ -610,28 +610,28 @@
 
         if user_error:
             raise Exception(user_error)
 
     def generate_w(self, target_bytes, background_bytes):
 
         res = self.get_slice_res(target_bytes, background_bytes)
-        self.logger.info(f'【generate_w】识别结果：{res}')
+        self.logger.info(f'[XunFei] 【generate_w】识别结果：{res}')
 
         # 读取slide.js执行get_w()方法
         with open(self.generate_w_js_file_path, 'r', encoding='utf-8') as f:
             js = f.read()
 
         ctx = execjs.compile(js)
 
         gtrace = GTrace()
 
         # -10，图片不是从头部开始的
         distance, track = gtrace.get_mouse_pos_path(res['target'][0] - 10)
-        self.logger.info(f'【generate_w】距离:{distance}')
-        self.logger.info(f'【generate_w】轨迹:{track}')
+        self.logger.info(f'[XunFei] 【generate_w】距离:{distance}')
+        self.logger.info(f'[XunFei] 【generate_w】轨迹:{track}')
         # print(f"距离:{distance}")
         # print(f"距离track:{track}")
 
         params = {
             # , gt, challenge, pass_distance, c, s, trance
             'gt': self.gt,
             'challenge': self.challenge,
@@ -680,31 +680,31 @@
 
         response = self.session.get(
             f'https://api.geetest.com/ajax.php',
             headers=headers,
             params=params,
         )
         json_data = self.get_json_data(response.text)
-        self.logger.info(f'【slice_main】请求状态码：{response.status_code}')
-        self.logger.info(f'【slice_main】请求响应数据：{json_data}')
+        self.logger.info(f'[XunFei] 【slice_main】请求状态码：{response.status_code}')
+        self.logger.info(f'[XunFei] 【slice_main】请求响应数据：{json_data}')
 
         self.validate = json_data.get('validate')
         self.score = json_data.get('score')
 
         return json_data
 
     def get_geetest_seccode(self):
 
         encoded_a = base64.b64encode(self.validate.encode('utf-8'))
         return encoded_a.decode('utf-8')  # 输出编码后的字符串
 
     def login(self):
 
         if not self.validate:
-            self.logger.error('没有validate值，无法登录')
+            self.logger.error('[XunFei] 没有validate值，无法登录')
             return
 
         host = 'https://sso.xfyun.cn/SSOService/login/check-account'
         geetest_seccode = self.get_geetest_seccode()
 
         data = {
             'geetest_challenge': self.challenge,
@@ -724,43 +724,43 @@
 
         response = self.session.post(
             host,
             headers=headers,
             data=data,
         )
 
-        self.logger.info(f'【login】请求响应数据：{response.text}')
+        self.logger.info(f'[XunFei] 【login】请求响应数据：{response.text}')
         try:
 
             if '用户名或密码错误' in response.text:
-                self.logger.error(f'【login】用户名或密码错误')
+                self.logger.error(f'[XunFei] 【login】用户名或密码错误')
                 return False
 
             json_data = json.loads(response.text)
-            self.logger.info(f'【login】请求响应数据：{json_data}')
+            self.logger.info(f'[XunFei] 【login】请求响应数据：{json_data}')
 
             self.sso_session_id = json_data.get('data', {}).get('ssoSessionId')
             self.account_id = json_data.get('data', {}).get('account_id')
 
-            self.logger.info(f'【login】ssoSessionId:{self.sso_session_id}')
-            self.logger.info(f'【login】account_id:{self.account_id}')
+            self.logger.info(f'[XunFei] 【login】ssoSessionId:{self.sso_session_id}')
+            self.logger.info(f'[XunFei] 【login】account_id:{self.account_id}')
 
             return True
         except:
-            self.logger.error(f'【login】请求响应数据：{response.text}')
+            self.logger.error(f'[XunFei] 【login】请求响应数据：{response.text}')
             return False
 
     def get_cookie(self):
 
         if not self.sso_session_id:
-            self.logger.error(f'【get_cookie】没有ssoSessionId，无法获取cookie')
+            self.logger.error(f'[XunFei] 【get_cookie】没有ssoSessionId，无法获取cookie')
             return
 
         if not self.account_id:
-            self.logger.error(f'【get_cookie】没有account_id，无法获取cookie')
+            self.logger.error(f'[XunFei] 【get_cookie】没有account_id，无法获取cookie')
             return
 
         host = f'https://sso.xfyun.cn/SSOService/login/setcookies?ssoSessionId={self.sso_session_id}&account_id={self.account_id}&url=aHR0cHM6Ly93d3cueGZ5dW4uY24v'
 
         headers = self.headers.copy()
         headers['Referer'] = 'https://passport.xfyun.cn/'
         headers['Host'] = 'sso.xfyun.cn'
@@ -768,15 +768,15 @@
         headers['Upgrade-Insecure-Requests'] = '1'
 
         response = self.session.get(
             host,
             headers=headers,
         )
 
-        self.logger.info(f'【get_cookie】请求响应数据：{response.text}')
+        self.logger.info(f'[XunFei] 【get_cookie】请求响应数据：{response.text}')
 
         for k, v in self.session.cookies.items():
             print(f'{k}: {v}')
 
     def run(self):
 
         if not self.generate_w_js_file_path:
@@ -997,27 +997,27 @@
         }
 
         if response.status_code == 200:
             if jsonfy:
                 result['response'] = self.parse_data(response, function_name=function_name)
 
         elif response.status_code == 401:
-            self.logger.error(f'The response status_code is 401, need to login again.')
+            self.logger.error(f'[XunFei] The response status_code is 401, need to login again.')
 
-            self.logger.info('即将尝试重新登录...')
+            self.logger.info('[XunFei] 即将尝试重新登录...')
             login_result = self.login()
             if login_result:
-                self.logger.info('重新登录成功，即将重新请求...')
+                self.logger.info('[XunFei] 重新登录成功，即将重新请求...')
                 result['is_success'] = False
 
-            self.logger.error('重新登录失败，即将退出程序...')
+            self.logger.error('[XunFei] 重新登录失败，即将退出程序...')
             result['continue'] = False
 
         else:
-            self.logger.error(f'【{self.model_name}】 get failed, status_code: 【{response.status_code}】')
+            self.logger.error(f'[XunFei] 【{self.model_name}】 get failed, status_code: 【{response.status_code}】')
             result['continue'] = False
 
         return result
 
     def get(
             self,
             url: str,
@@ -1046,31 +1046,31 @@
                 elif check_result['continue']:
                     continue
                 else:
                     return
 
             except NeedLoginError:
 
-                self.logger.info('即将尝试重新登录...')
+                self.logger.info('[XunFei] 即将尝试重新登录...')
                 result = self.login()
 
                 # 如果成功重新登录，则重新请求
                 if result:
-                    self.logger.info('重新登录成功，即将重新请求...')
+                    self.logger.info('[XunFei] 重新登录成功，即将重新请求...')
                     continue
 
                 # 如果登录失败，则跳出循环，直接返回
-                self.logger.error('重新登录失败，即将退出程序...')
+                self.logger.error('[XunFei] 重新登录失败，即将退出程序...')
                 break
             except UnexpectResponseError:
                 # TODO 这里暂时留空，后续补充
                 pass
 
             except:
-                self.logger.error(f'【{self.model_name}】 get request got an unexpected error.', exc_info=True)
+                self.logger.error(f'[XunFei] 【{self.model_name}】 get request got an unexpected error.', exc_info=True)
 
     def post(
             self,
             url: str,
             headers: dict = None,
             params: Optional[dict] = None,
             _json: Optional[dict] = None,
@@ -1104,30 +1104,30 @@
                 elif check_result['continue']:
                     continue
                 else:
                     return
 
             except NeedLoginError:
 
-                self.logger.info('即将尝试重新登录...')
+                self.logger.info('[XunFei] 即将尝试重新登录...')
                 result = self.login()
 
                 # 如果成功重新登录，则重新请求
                 if result:
-                    self.logger.info('重新登录成功，即将重新请求...')
+                    self.logger.info('[XunFei] 重新登录成功，即将重新请求...')
                     continue
 
                 # 如果登录失败，则跳出循环，直接返回
-                self.logger.error('重新登录失败，即将退出程序...')
+                self.logger.error('[XunFei] 重新登录失败，即将退出程序...')
                 break
             except UnexpectResponseError:
                 # TODO 这里暂时留空，后续补充
-                self.logger.error('出现了预期外的回应数据...')
+                self.logger.error('[XunFei] 出现了预期外的回应数据...')
             except:
-                self.logger.error(f'【{self.model_name}】 post request got an unexpected error.', exc_info=True)
+                self.logger.error(f'[XunFei] 【{self.model_name}】 post request got an unexpected error.', exc_info=True)
 
     def login(self) -> bool:
         """登录新方法，添加极验滑块的逆向"""
 
         try:
             handler = WebLogin(
                 account_name=self.account,
@@ -1137,23 +1137,23 @@
 
             if session_id:
                 self.request_session.cookies.update({'ssoSessionId': session_id})
                 self.request_session.headers.update({'Cookie': f'ssoSessionId={session_id}'})
                 self._sso_session_id = session_id
                 return True
         except:
-            self.logger.error(f'【{self.model_name}】 login failed', exc_info=True)
+            self.logger.error(f'[XunFei] 【{self.model_name}】 login failed', exc_info=True)
 
         return False
 
     def __login(self) -> bool:
         """登录旧方法，那时讯飞不验证极验滑块"""
 
         if not self.account or not self.password:
-            self.logger.error(f'【{self.model_name}】 account or password is empty')
+            self.logger.error(f'[XunFei] 【{self.model_name}】 account or password is empty')
             return False
 
         url = 'https://sso.xfyun.cn/SSOService/login/check-account'
 
         data = {
             'accountName': self.account,
             'accountPwd': self.password,
@@ -1163,27 +1163,27 @@
             response = self.post(url=url, data=data)
             resp_json = response.json()
 
             code = resp_json.get('code')
 
             if code != 0:
                 self.logger.error(
-                    f'【{self.model_name}】 login failed, code: 【{code}】, message: 【{resp_json.get("desc")}】')
+                    f'[XunFei] 【{self.model_name}】 login failed, code: 【{code}】, message: 【{resp_json.get("desc")}】')
                 return False
 
-            self.logger.info(f'【{self.model_name}】 login success')
+            self.logger.info(f'[XunFei] 【{self.model_name}】 login success')
 
             self._sso_session_id = data['ssoSessionId']
             self._account_id = data['account_id']
             self.request_session.cookies.update({'ssoSessionId': data['ssoSessionId']})
             self.request_session.cookies.update({'account_id': data['account_id']})
 
             return True
         except:
-            self.logger.error(f'【{self.model_name}】 login request got an unexpected error.', exc_info=True)
+            self.logger.error(f'[XunFei] 【{self.model_name}】 login request got an unexpected error.', exc_info=True)
             return False
 
     def get_chat_list(self) -> dict:
         """获取会话列表"""
 
         url = self.base_url + '/iflygpt/u/chat-list/v1/chat-list'
 
@@ -1281,38 +1281,38 @@
         新会话没有消息时，返回空字符串；
         """
 
         try:
             history_list = self.get_chat_history(chat_id)
             return history_list[-1]["historyList"][-1]["sid"]
         except:
-            self.logger.error(f'【{self.model_name}】 get_chat_sid failed, chat_id: 【{chat_id}】')
+            self.logger.error(f'[XunFei] 【{self.model_name}】 get_chat_sid failed, chat_id: 【{chat_id}】')
 
     def parse_data(self, response: Optional[requests.Response], function_name: str = None) -> dict:
 
         if not response:
-            self.logger.error(f'【{self.model_name}】 search_bot failed.')
+            self.logger.error(f'[XunFei] 【{self.model_name}】 search_bot failed.')
             return {}
 
         resp_json = response.json()
         code = resp_json.get('code')
         if code != 0:
             self.logger.error(
-                f'【{self.model_name}】 {function_name} failed, code: 【{code}】, message: 【{resp_json.get("desc")}】')
+                f'[XunFei] 【{self.model_name}】 {function_name} failed, code: 【{code}】, message: 【{resp_json.get("desc")}】')
 
             # 判断是否需要重新登录：80000错误表示token过期，需要重新登录
             if code == 80000:
-                msg = (f'【{self.model_name}】 {function_name} failed! Need re-login!\n\n'
+                msg = (f'[XunFei] 【{self.model_name}】 {function_name} failed! Need re-login!\n\n'
                        f'code: 【{code}】, message: 【{resp_json.get("desc")}】')
                 self.logger.error(msg)
 
                 raise NeedLoginError(msg)
 
             # 非预期响应
-            msg = (f'【{self.model_name}】 {function_name} got an unexpected response.\n\n'
+            msg = (f'[XunFei] 【{self.model_name}】 {function_name} got an unexpected response.\n\n'
                    f'code: 【{code}】, message: 【{resp_json.get("desc")}】\n\n'
                    f'full data: 【{response.text}】\n\n')
             self.logger.error(msg)
             raise UnexpectResponseError(msg)
 
         return resp_json
 
@@ -1362,15 +1362,15 @@
             'GtToken': gt_token or self.gt_token,
             'clientType': client_type
         }
 
         response = self.post(url=url, headers=headers, data=data, stream=True)
 
         if not response:
-            self.logger.error(f'【{self.model_name}】 ask failed, status_code: 【{response.status_code}】')
+            self.logger.error(f'[XunFei] 【{self.model_name}】 ask failed, status_code: 【{response.status_code}】')
             return AiAnswer()
 
         self.single_answer = ''
         for line in response.iter_lines():
 
             if not line:
                 continue
@@ -1389,30 +1389,30 @@
                     # answer = '【任务执行中】'
 
                 self.single_answer_padding = answer
 
                 # 执行回调函数，如果有的话
                 if callable(callback_func):
                     try:
-                        self.logger.debug(f"执行回调函数：内容【{answer}】")
+                        self.logger.debug(f"[XunFei] 执行回调函数：内容【{answer}】")
                         callback_func(answer)
                     except Exception as e:
-                        self.logger.error(f"回调函数执行出错: {e}", exc_info=True)
+                        self.logger.error(f"[XunFei] 回调函数执行出错: {e}", exc_info=True)
 
                 self.single_answer += answer
                 sys.stdout.flush()
             else:
-                self.logger.debug(f"AI交互结束")
+                self.logger.debug(f"[XunFei] AI交互结束")
 
                 # 执行回调函数，如果有的话
                 if callable(callback_func):
                     try:
                         callback_func('<<<end>>>')
                     except Exception as e:
-                        self.logger.error(f"回调函数执行出错: {e}", exc_info=True)
+                        self.logger.error(f"[XunFei] 回调函数执行出错: {e}", exc_info=True)
 
         self.single_answer_obj = AiAnswer(
             content=self.single_answer,
             is_success=True,
             conversation_id=chat_id,
         )
```

## Comparing `zibuyu_llm-2.1.20.dist-info/METADATA` & `zibuyu_llm-2.1.22.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: zibuyu-llm
-Version: 2.1.20
+Version: 2.1.22
 Summary: 子不语个人工具包-LLM
 Author: 子不语
 License: MIT
 Keywords: zibuyu
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Classifier: Intended Audience :: Developers
```

## Comparing `zibuyu_llm-2.1.20.dist-info/RECORD` & `zibuyu_llm-2.1.22.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 zibuyu_llm_api/__init__.py,sha256=Ox3V8_X8l52LqJ_ATAWv0xpxBZxq5o1xn16TcEvSUl4,305
 zibuyu_llm_api/minmax_api.py,sha256=86tA4Fey-WsUoKziwT7WM8X-6UVGYEftleJ2xnDLz5Q,30976
 zibuyu_llm_web/__init__.py,sha256=UypIajLr0sQR9_JowoqN9ZgrRMA4GjuaPt7m8G7eP38,965
-zibuyu_llm_web/baichuan.py,sha256=lFq8jX7VwTBqB9EP31-H1Zj-WIiDWD4JScVMiq9yxUA,7376
+zibuyu_llm_web/baichuan.py,sha256=Nea0ikO20HxUdu8GItH0JAwJPDCjUw5mLTCILFsW-lU,7453
 zibuyu_llm_web/base.py,sha256=UKcYa2l84I92qXfN3ClSjf-ypzhNXlnOr6F9465Zny8,8509
-zibuyu_llm_web/deepseek.py,sha256=iIPPhYATkZjgNazjiKU7z_89EOev6uuNocnC1HYIgZg,15556
-zibuyu_llm_web/emohaa.py,sha256=EhhI08tlDYPmhytBe6lvuPE4miEzBRxemp85Kekx-0w,2783
+zibuyu_llm_web/deepseek.py,sha256=iU-w1MwUFRHWJuEBPH1SXNEwRgrevjSmInlw4B_35MA,15842
+zibuyu_llm_web/emohaa.py,sha256=haiAoSOHwlEeKHmhVIe88lmFiBG-D05up3LSOZ5ioZI,2802
 zibuyu_llm_web/errors.py,sha256=EPjEXZJTWyhUz-LLnTra7Rg6Qu2EjpdYog2_QE-iEs8,807
-zibuyu_llm_web/kimi.py,sha256=cEJy_JOiEkirSAbPnufcploS_OKSw6BSFJIWEOmNHtk,11618
-zibuyu_llm_web/metaso.py,sha256=3lrjs9J4OfJae-awk9iJkrw88ZD0Ynul-UkUv6oZ6QY,11531
-zibuyu_llm_web/minmax.py,sha256=N-pBFXMM7MPyxtO65nwpzrPLH6ltqVNkkd4NajKp0hM,45441
-zibuyu_llm_web/qwen.py,sha256=ja3fyFtY6bQmjCWNtcOtgMIRt6RSgtuYmNxDCQBk5oU,37730
-zibuyu_llm_web/step_chat.py,sha256=miDqwEP-6f-wzaFEKVQfd-vfYDwtWbcA5t2QVK9UkeU,14134
+zibuyu_llm_web/kimi.py,sha256=oraj-0Koloq3uoCRxKs5ubdTbhyHmR-t3tfL3rhjND8,11810
+zibuyu_llm_web/metaso.py,sha256=6XNvMP-vcrSgdx9jLdO04B7lEsZjkLvGUycmdcGSNxg,11752
+zibuyu_llm_web/minmax.py,sha256=HiOiMOzPYA3xk9P81jFVLGfTeDAw98vLAEAnFB2uGVQ,46017
+zibuyu_llm_web/qwen.py,sha256=P3vzgx6eIcorS-n52Gl_Qi84HliTdS5NhGDA30AfKwU,38067
+zibuyu_llm_web/step_chat.py,sha256=QRBBaPocFffDir3yWAh6Pu58bo7qO7TUejgAvoeNPLQ,14284
 zibuyu_llm_web/types.py,sha256=igf4qapdL6VkgWK4Y22FfgDf1cqlA80qVwhtspR7dcU,5393
-zibuyu_llm_web/wanxiang.py,sha256=SRGH5iCrHg9zzr9GRhyjF8UulPrwwwYAEkgeEg6aazU,8097
+zibuyu_llm_web/wanxiang.py,sha256=BJ9ZGuHuxtGOBxgvnJlj0IASHRdrMdIHi5Op8VsxL8A,8152
 zibuyu_llm_web/xinchen.py,sha256=gY0YGYLSaChNSjemSnKPgHGd58jx3HllGKYpaJoJse0,14705
-zibuyu_llm_web/xunfei.py,sha256=qDB4mxLincaYG35sJfKFW9G8fFACM5IC2Lb6Xua8wfE,62458
-zibuyu_llm-2.1.20.dist-info/METADATA,sha256=akti_wO7mqXpoN56-MyPlC2RBHh3LoElz-nBJ_LjtW0,857
-zibuyu_llm-2.1.20.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-zibuyu_llm-2.1.20.dist-info/top_level.txt,sha256=QF6FI2Tcc78mYBpfy15YWDU-j16KK_2WqGF-3kj8Jew,30
-zibuyu_llm-2.1.20.dist-info/RECORD,,
+zibuyu_llm_web/xunfei.py,sha256=57Q8fAr924Ln8TrXkV_tD84P53eu4FMCOHZFmshqWnI,63160
+zibuyu_llm-2.1.22.dist-info/METADATA,sha256=QiW9ZflU7shP0I79OXfLBnh5qQTScpZB9odnJl3A4ck,857
+zibuyu_llm-2.1.22.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
+zibuyu_llm-2.1.22.dist-info/top_level.txt,sha256=QF6FI2Tcc78mYBpfy15YWDU-j16KK_2WqGF-3kj8Jew,30
+zibuyu_llm-2.1.22.dist-info/RECORD,,
```

